- en: Mining Function Specifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 挖掘函数规范
- en: 原文：[http://www.fuzzingbook.org/html/DynamicInvariants.html](http://www.fuzzingbook.org/html/DynamicInvariants.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/DynamicInvariants.html](http://www.fuzzingbook.org/html/DynamicInvariants.html)
- en: When testing a program, one not only needs to cover its several behaviors; one
    also needs to *check* whether the result is as expected. In this chapter, we introduce
    a technique that allows us to *mine* function specifications from a set of given
    executions, resulting in abstract and formal *descriptions* of what the function
    expects and what it delivers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试一个程序时，不仅需要覆盖其多种行为；还需要*检查*结果是否符合预期。在本章中，我们介绍了一种技术，使我们能够从一组给定的执行中*挖掘*函数规范，从而得到函数期望和提供的形式化*描述*。
- en: 'These so-called *dynamic invariants* produce pre- and post-conditions over
    function arguments and variables from a set of executions. They are useful in
    a variety of contexts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些所谓的*动态不变性*从一组执行中生成函数参数和变量的前置和后置条件。它们在多种环境中都很有用：
- en: Dynamic invariants provide important information for [symbolic fuzzing](SymbolicFuzzer.html),
    such as types and ranges of function arguments.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态不变性为[符号模糊测试](SymbolicFuzzer.html)提供了重要信息，例如函数参数的类型和范围。
- en: Dynamic invariants provide pre- and postconditions for formal program proofs
    and verification.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态不变性为形式化程序证明和验证提供了前置和后置条件。
- en: Dynamic invariants provide numerous assertions that can check whether function
    behavior has changed
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态不变性提供了许多断言，可以检查函数行为是否已改变
- en: Checks provided by dynamic invariants can be very useful as *oracles* for checking
    the effects of generated tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态不变性提供的检查可以作为*预言机*，用于检查生成的测试的效果
- en: Traditionally, dynamic invariants are dependent on the executions they are derived
    from. However, when paired with comprehensive test generators, they quickly become
    very precise, as we show in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，动态不变性依赖于它们从中派生的执行。然而，当与全面的测试生成器配对时，它们很快就会变得非常精确，正如本章所示。
- en: '**Prerequisites**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should be familiar with tracing program executions, as in the [chapter on
    coverage](Coverage.html).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该熟悉跟踪程序执行，如[关于覆盖的章节](Coverage.html)中所述。
- en: Later in this section, we access the internal *abstract syntax tree* representations
    of Python programs and transform them, as in the [chapter on information flow](InformationFlow.html).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本节的后面部分，我们访问Python程序的内部*抽象语法树*表示，并对其进行转换，如[关于信息流的章节](InformationFlow.html)中所述。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Synopsis
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章提供的代码[Importing.html]，请编写
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and then make use of the following features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter provides two classes that automatically extract specifications
    from a function and a set of inputs:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了两个类，可以自动从函数和一组输入中提取规范：
- en: '`TypeAnnotator` for *types*, and'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeAnnotator`用于*类型*，'
- en: '`InvariantAnnotator` for *pre-* and *postconditions*.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvariantAnnotator`用于*前置*和*后置条件*。'
- en: 'Both work by *observing* a function and its invocations within a `with` clause.
    Here is an example for the type annotator:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都是通过*观察*函数及其在`with`子句中的调用来工作的。以下是一个类型注释器的示例：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `typed_functions()` method will return a representation of `sum2()` annotated
    with types observed during execution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`typed_functions()`方法将返回一个表示`sum2()`的带有执行期间观察到的类型的注释。'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The invariant annotator works similarly:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不变注释器的工作方式类似：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `functions_with_invariants()` method will return a representation of `sum2()`
    annotated with inferred pre- and postconditions that all hold for the observed
    values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`functions_with_invariants()`方法将返回一个表示`sum2()`的注释，其中包含推断的前置和后置条件，这些条件对所有观察到的值都成立。'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Such type specifications and invariants can be helpful as *oracles* (to detect
    deviations from a given set of runs) as well as for all kinds of *symbolic code
    analyses*. The chapter gives details on how to customize the properties checked
    for.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型规范和不变性可以作为*预言机*（用于检测偏离给定运行集的偏差）以及所有类型的*符号代码分析*很有帮助。本章详细介绍了如何自定义要检查的属性。
- en: Specifications and Assertions
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范和断言
- en: When implementing a function or program, one usually works against a *specification*
    – a set of documented requirements to be satisfied by the code. Such specifications
    can come in natural language. A formal specification, however, allows the computer
    to check whether the specification is satisfied.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当实现一个函数或程序时，通常针对*规范*（即代码需要满足的一系列文档化要求）进行工作。这些规范可以是自然语言。然而，形式化规范允许计算机检查规范是否得到满足。
- en: 'In the [introduction to testing](Intro_Testing.html), we have seen how *preconditions*
    and *postconditions* can describe what a function does. Consider the following
    (simple) square root function:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [测试简介](Intro_Testing.html) 中，我们看到了 *前置条件* 和 *后置条件* 如何描述函数的行为。考虑以下（简单的）平方根函数：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The assertion `assert p` checks the condition `p`; if it does not hold, execution
    is aborted. Here, the actual body is not yet written; we use the assertions as
    a specification of what `any_sqrt()` *expects*, and what it *delivers*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 断言 `assert p` 检查条件 `p`；如果条件不成立，则执行被终止。在这里，实际的主体尚未编写；我们使用断言作为对 `any_sqrt()` *期望*
    和 *提供* 的规范。
- en: The topmost assertion is the *precondition*, stating the requirements on the
    function arguments. The assertion at the end is the *postcondition*, stating the
    properties of the function result (including its relationship with the original
    arguments). Using these pre- and postconditions as a specification, we can now
    go and implement a square root function that satisfies them. Once implemented,
    we can have the assertions check at runtime whether `any_sqrt()` works as expected;
    a [symbolic](SymbolicFuzzer.html) or [concolic](ConcolicFuzzer.html) test generator
    will even specifically try to find inputs where the assertions do *not* hold.
    (An assertion can be seen as a conditional branch towards aborting the execution,
    and any technique that tries to cover all code branches will also try to invalidate
    as many assertions as possible.)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最顶部的断言是 *前置条件*，说明了函数参数的要求。结尾的断言是 *后置条件*，说明了函数结果（包括其与原始参数的关系）的性质。使用这些前置和后置条件作为规范，我们现在可以编写一个满足这些条件的平方根函数。一旦实现，我们就可以让断言在运行时检查
    `any_sqrt()` 是否按预期工作；一个 [符号测试生成器](SymbolicFuzzer.html) 或 [冲突测试生成器](ConcolicFuzzer.html)
    甚至会尝试找到断言 *不成立* 的特定输入。（断言可以看作是一个条件分支，用于终止执行，任何试图覆盖所有代码分支的技术也会尝试尽可能多地使断言无效。）
- en: 'However, not every piece of code is developed with explicit specifications
    in the first place; let alone does most code comes with formal pre- and post-conditions.
    (Just take a look at the chapters in this book.) This is a pity: As Ken Thompson
    famously said, "Without specifications, there are no bugs – only surprises". It
    is also a problem for testing, since, of course, testing needs some specification
    to test against. This raises the interesting question: Can we somehow *retrofit*
    existing code with "specifications" that properly describe their behavior, allowing
    developers to simply *check* them rather than having to write them from scratch?
    This is what we do in this chapter.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非所有代码都是首先带有明确规范的；更不用说大多数代码带有正式的前置和后置条件。（只需看看这本书的章节。）这是令人遗憾的：正如肯·汤普森著名地说，“没有规范，就没有错误——只有惊喜”。这对测试也是一个问题，因为当然，测试需要一些规范来测试。这提出了一个有趣的问题：我们能否以某种方式
    *改造* 现有代码，使其带有“规范”，这些规范可以正确地描述其行为，使开发者只需简单地 *检查* 而不必从头编写？这就是我们在本章所做的事情。
- en: Why Generic Error Checking is Not Enough
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么泛型错误检查不够
- en: 'Before we go into *mining* specifications, let us first discuss why it could
    be useful to *have* them. As a motivating example, consider the full implementation
    of a square root function from the [introduction to testing](Intro_Testing.html):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始 *挖掘* 规范之前，让我们首先讨论为什么拥有它们可能是有用的。作为一个激励的例子，考虑 [测试简介](Intro_Testing.html)
    中的平方根函数的完整实现：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`my_sqrt()` does not come with any functionality that would check types or
    values. Hence, it is easy for callers to make mistakes when calling `my_sqrt()`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_sqrt()` 没有任何检查类型或值的函数。因此，调用者调用 `my_sqrt()` 时很容易出错：'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At least, the Python system catches these errors at runtime. The following
    call, however, simply lets the function enter an infinite loop:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，Python 系统会在运行时捕获这些错误。然而，以下调用却简单地让函数进入无限循环：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our goal is to avoid such errors by *annotating* functions with information
    that prevents errors like the above ones. The idea is to provide a *specification*
    of expected properties – a specification that can then be checked at runtime or
    statically.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过 *注解* 函数来避免上述错误，这些注解提供了防止错误的信息。想法是提供一个 *规范*，该规范可以随后在运行时或静态时进行检查。
- en: \todo{Introduce the concept of *contract*.}
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: \todo{介绍 *合同* 的概念。}
- en: Specifying and Checking Data Types
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定和检查数据类型
- en: For our Python code, one of the most important "specifications" we need is *types*.
    Python being a "dynamically" typed language means that all data types are determined
    at run time; the code itself does not explicitly state whether a variable is an
    integer, a string, an array, a dictionary – or whatever.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Python 代码，我们最需要的“规范”之一是**类型**。Python 是一种“动态”类型语言，这意味着所有数据类型都是在运行时确定的；代码本身并没有明确声明变量是整数、字符串、数组、字典——或任何其他类型。
- en: As *writer* of Python code, omitting explicit type declarations may save time
    (and allows for some fun hacks). It is not sure whether a lack of types helps
    in *reading* and *understanding* code for humans. For a *computer* trying to analyze
    code, the lack of explicit types is detrimental. If, say, a constraint solver,
    sees `if x:` and cannot know whether `x` is supposed to be a number or a string,
    this introduces an *ambiguity*. Such ambiguities may multiply over the entire
    analysis in a combinatorial explosion – or in the analysis yielding an overly
    inaccurate result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 Python 代码的**作者**，省略显式的类型声明可能会节省时间（并且允许一些有趣的技巧）。是否缺少类型有助于人类**阅读**和**理解**代码还不确定。对于一个试图分析代码的**计算机**来说，缺少显式类型是有害的。比如说，如果约束求解器看到
    `if x:` 而无法知道 `x` 是否应该是一个数字或一个字符串，这会引入**歧义**。这样的歧义可能会在整个分析中成倍增加——或者是在产生过于不准确结果的分析中。
- en: 'Python 3.6 and later allows data types as *annotations* to function arguments
    (actually, to all variables) and return values. We can, for instance, state that
    `my_sqrt()` is a function that accepts a floating-point value and returns one:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.6 及以后的版本允许将数据类型作为**注解**用于函数参数（实际上，用于所有变量）和返回值。例如，我们可以声明 `my_sqrt()`
    是一个接受浮点值并返回一个值的函数：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By default, such annotations are ignored by the Python interpreter. Therefore,
    one can still call `my_sqrt_typed()` with a string as an argument and get the
    exact same result as above. However, one can make use of special *typechecking*
    modules that would check types – *dynamically* at runtime or *statically* by analyzing
    the code without having to execute it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python 解释器会忽略这样的注解。因此，你仍然可以用字符串作为参数调用 `my_sqrt_typed()` 并得到与上面完全相同的结果。然而，你可以利用特殊的**类型检查**模块来检查类型——**动态地**在运行时检查，或者**静态地**通过分析代码而不必执行它。
- en: 'Excursion: Runtime Type Checking'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 离题：运行时类型检查
- en: (Commented out as `enforce` is not supported by Python 3.9)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: （注释掉，因为 `enforce` 不受 Python 3.9 支持）
- en: 'The Python `enforce` package provides a function decorator that automatically
    inserts type-checking code that is executed at runtime. Here is how to use it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `enforce` 包提供了一个函数装饰器，它会在运行时自动插入类型检查代码。以下是它的用法：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, invoking `my_sqrt_with_checked_type_annotations()` raises an exception
    when invoked with a type different from the one declared:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用与声明的类型不同的类型调用 `my_sqrt_with_checked_type_annotations()` 时，会引发异常：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that this error is not caught by the "untyped" variant, where passing a
    boolean value happily returns $\sqrt{1}$ as result.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个错误没有被“无类型”变体捕获，其中传递布尔值会愉快地返回 $\sqrt{1}$ 作为结果。
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Python (and other languages), the boolean values `True` and `False` can be
    implicitly converted to the integers 1 and 0; however, it is hard to think of
    a call to `sqrt()` where this would not be an error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python（和其他语言）中，布尔值 `True` 和 `False` 可以隐式转换为整数 1 和 0；然而，很难想象一个调用 `sqrt()` 不会出错的情况。
- en: Static Type Checking
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态类型检查
- en: Type annotations can also be checked *statically* – that is, without even running
    the code. Let us create a simple Python file consisting of the above `my_sqrt_typed()`
    definition and a bad invocation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类型注解也可以**静态地**进行检查——也就是说，甚至不需要运行代码。让我们创建一个简单的 Python 文件，其中包含上述 `my_sqrt_typed()`
    定义和一个错误的调用。
- en: '[PRE22]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These are the contents of our newly created Python file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们新创建的 Python 文件的内容：
- en: '[PRE26]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[Mypy](http://mypy-lang.org) is a type checker for Python programs. As it checks
    types statically, types induce no overhead at runtime; plus, a static check can
    be faster than a lengthy series of tests with runtime type checking enabled. Let
    us see what `mypy` produces on the above file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mypy](http://mypy-lang.org) 是一个用于 Python 程序的类型检查器。因为它进行静态类型检查，所以类型不会在运行时产生开销；此外，静态检查可能比启用运行时类型检查的长时间测试序列更快。让我们看看
    `mypy` 在上述文件上会产生什么结果：'
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We see that `mypy` complains about untyped function definitions such as `my_sqrt()`;
    most important, however, it finds that the call to `my_sqrt_with_type_annotations()`
    in the last line has the wrong type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `mypy` 对无类型的函数定义（如 `my_sqrt()`）表示不满；然而，最重要的是，它发现最后一行中调用 `my_sqrt_with_type_annotations()`
    的类型是错误的。
- en: With `mypy`, we can achieve the same type safety with Python as in statically
    typed languages – provided that we as programmers also produce the necessary type
    annotations. Is there a simple way to obtain these?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mypy`，我们可以像在静态类型语言中一样在Python中实现相同的安全类型，前提是我们作为程序员也产生了必要的类型注解。有没有简单的方法可以获得这些注解？
- en: Mining Type Specifications
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矿化类型规范
- en: 'Our first task will be to mine type annotations (as part of the code) from
    *values* we observe at run time. These type annotations would be *mined* from
    actual function executions, *learning* from (normal) runs what the expected argument
    and return types should be. By observing a series of calls such as these, we could
    infer that both `x` and the return value are of type `float`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务将是从运行时观察到的*值*中挖掘类型注解（作为代码的一部分）。这些类型注解将从实际函数执行中挖掘出来，通过（正常）运行学习预期的参数和返回类型应该是什么。通过观察一系列这样的调用，我们可以推断出`x`和返回值都是`float`类型：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'How can we mine types from executions? The answer is simple:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从执行中挖掘类型？答案是简单的：
- en: We *observe* a function during execution
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在执行过程中*观察*一个函数
- en: We track the *types* of its arguments
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们跟踪其参数的类型
- en: We include these types as *annotations* into the code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将这些类型作为*注解*包含到代码中。
- en: To do so, we can make use of Python's tracing facility we already observed in
    the [chapter on coverage](Coverage.html). With every call to a function, we retrieve
    the arguments, their values, and their types.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以利用我们已经在[覆盖率章节](Coverage.html)中观察到的Python的跟踪功能。每当调用一个函数时，我们都会检索其参数、它们的值和它们的类型。
- en: Tracking Calls
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪调用
- en: 'To observe argument types at runtime, we define a *tracer function* that tracks
    the execution of `my_sqrt()`, checking its arguments and return values. The `Tracker`
    class is set to trace functions in a `with` block as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行时观察参数类型，我们定义了一个*跟踪函数*，它跟踪`my_sqrt()`的执行，检查其参数和返回值。`Tracker`类被设置为在`with`块中跟踪函数，如下所示：
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As in the [chapter on coverage](Coverage.html), we use the `sys.settrace()`
    function to trace individual functions during execution. We turn on tracking when
    the `with` block starts; at this point, the `__enter__()` method is called. When
    execution of the `with` block ends, `__exit()__` is called.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[覆盖率章节](Coverage.html)中一样，我们使用`sys.settrace()`函数在执行期间跟踪单个函数。我们在`with`块开始时打开跟踪；此时调用`__enter__()`方法。当`with`块的执行结束时，调用`__exit__()`。
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `traceit()` method does nothing yet; this is done in specialized subclasses.
    The `CallTracker` class implements a `traceit()` function that checks for function
    calls and returns:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`traceit()`方法目前什么也不做；这是在专门的子类中完成的。`CallTracker`类实现了一个`traceit()`函数，用于检查函数调用和返回：'
- en: '[PRE40]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`trace_call()` is called when a function is called; it retrieves the function
    name and current arguments, and saves them on a stack.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，会调用`trace_call()`；它检索函数名称和当前参数，并将它们保存在栈上。
- en: '[PRE41]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When the function returns, `trace_return()` is called. We now also have the
    return value. We log the whole call with arguments and return value (if desired)
    and save it in our list of calls.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数返回时，会调用`trace_return()`。现在我们也有了返回值。我们可以记录整个调用及其参数和返回值（如果需要的话），并将其保存在我们的调用列表中。
- en: '[PRE43]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`simple_call_string()` is a helper for logging that prints out calls in a user-friendly
    manner.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_call_string()`是一个用于日志记录的辅助函数，以用户友好的方式打印调用。'
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`add_call()` saves the calls in a list; each function name has its own list.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_call()`将调用保存在列表中；每个函数名称都有自己的列表。'
- en: '[PRE45]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using `calls()`, we can retrieve the list of calls, either for a given function,
    or for all functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`calls()`，我们可以检索调用列表，无论是针对特定函数还是所有函数。
- en: '[PRE46]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let us now put this to use. We turn on logging to track the individual calls
    and their return values:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其付诸实践。我们打开日志记录以跟踪单个调用及其返回值：
- en: '[PRE47]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After execution, we can retrieve the individual calls:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们可以检索单个调用：
- en: '[PRE49]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Each call is pair (`argument_list`, `return_value`), where `argument_list` is
    a list of pairs (`parameter_name`, `value`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调用都是一个对（`argument_list`, `return_value`），其中`argument_list`是一个包含对（`parameter_name`,
    `value`）的列表。
- en: '[PRE51]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If the function does not return a value, `return_value` is `None`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数不返回值，则`return_value`为`None`。
- en: '[PRE53]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Getting Types
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取类型
- en: 'Despite what you may have read or heard, Python actually *is* a typed language.
    It is just that it is *dynamically typed* – types are used and checked only at
    runtime (rather than declared in the code, where they can be *statically checked*
    at compile time). We can thus retrieve types of all values within Python:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可能已经阅读或听到过，Python实际上*是*一种类型语言。只是它是*动态类型化的*——类型仅在运行时使用和检查（而不是在代码中声明，它们可以在编译时*静态检查*）。因此，我们可以检索Python中所有值的类型：
- en: '[PRE60]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can retrieve the type of the first argument to `my_sqrt()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检索`my_sqrt()`的第一个参数的类型：
- en: '[PRE66]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'as well as the type of the return value:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以及返回值的类型：
- en: '[PRE68]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Hence, we see that (so far), `my_sqrt()` is a function taking (among others)
    integers and floats and returning floats. We could declare `my_sqrt()` as:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们看到（到目前为止），`my_sqrt()`是一个接受（包括）整数和浮点数并返回浮点数的函数。我们可以将`my_sqrt()`声明为：
- en: '[PRE70]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is a representation we could place in a static type checker, allowing to
    check whether calls to `my_sqrt()` actually pass a number. A dynamic type checker
    could run such checks at runtime. And of course, any [symbolic interpretation](SymbolicFuzzer.html)
    will greatly profit from the additional annotations.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种可以放入静态类型检查器中的表示，允许检查对`my_sqrt()`的调用是否实际上传递了一个数字。动态类型检查器可以在运行时执行此类检查。当然，任何[符号解释](SymbolicFuzzer.html)都将从额外的注释中受益良多。
- en: 'By default, Python does not do anything with such annotations. However, tools
    can access annotations from functions and other objects:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Python不会对这样的注释做任何事情。然而，工具可以访问函数和其他对象的注释：
- en: '[PRE71]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is how run-time checkers access the annotations to check against.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行时检查器如何访问注释以进行检查的方式。
- en: Accessing Function Structure
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问函数结构
- en: Our plan is to annotate functions automatically, based on the types we have
    seen. To do so, we need a few modules that allow us to convert a function into
    a tree representation (called *abstract syntax trees*, or ASTs) and back; we already
    have seen these in the chapters on [concolic](ConcolicFuzzer.html) and [symbolic](SymbolicFuzzer.html)
    testing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计划是根据我们看到的类型自动注解函数。为此，我们需要一些模块，允许我们将函数转换为树表示（称为*抽象语法树*，或AST）并将其转换回来；我们已经在[concolic](ConcolicFuzzer.html)和[symbolic](SymbolicFuzzer.html)测试的章节中看到了这些。
- en: '[PRE73]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We can get the source of a Python function using `inspect.getsource()`. (Note
    that this does not work for functions defined in other notebooks.)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`inspect.getsource()`获取Python函数的源代码。（注意，这不适用于在其他笔记本中定义的函数。）
- en: '[PRE74]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To view these in a visually pleasing form, our function `print_content(s, suffix)`
    formats and highlights the string `s` as if it were a file with ending `suffix`.
    We can thus view (and highlight) the source as if it were a Python file:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以视觉上令人愉悦的形式查看这些内容，我们的函数`print_content(s, suffix)`格式化和突出显示字符串`s`，就像它是一个以`suffix`结尾的文件一样。因此，我们可以将源代码视为（并突出显示）一个Python文件：
- en: '[PRE76]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Parsing this gives us an abstract syntax tree (AST) – a representation of the
    program in tree form.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 解析此内容为我们提供了一个抽象语法树（AST）——以树形表示的程序。
- en: '[PRE79]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: What does this AST look like? The helper functions `ast.dump()` (textual output)
    and `showast.show_ast()` (graphical output with [showast](https://github.com/hchasestevens/show_ast))
    allow us to inspect the structure of the tree. We see that the function starts
    as a `FunctionDef` with name and arguments, followed by a body, which is a list
    of statements of type `Expr` (the docstring), type `Assign` (assignments), `While`
    (while loop with its own body), and finally `Return`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个AST看起来是什么样子？辅助函数`ast.dump()`（文本输出）和`showast.show_ast()`（带有[showast](https://github.com/hchasestevens/show_ast)的图形输出）允许我们检查树的结构。我们看到函数以具有名称和参数的`FunctionDef`开始，然后是一个体，它是一个类型为`Expr`（文档字符串）、类型`Assign`（赋值）、`While`（具有自己体的while循环）和最后的`Return`的语句列表。
- en: '[PRE80]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Too much text for you? This graphical representation may make things simpler.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 文字太多？这个图形表示可能使事情更简单。
- en: '[PRE82]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1684pt" height="548pt"
    viewBox="0.00 0.00 1684.00 548.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 544)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="282.62" y="-517.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="82" y="-444.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"my_sqrt"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="152.88"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="261.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge5" class="edge"><title>0--5</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="start" x="346.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge10" class="edge"><title>0--10</title></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="start" x="909.38"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">While</text></g> <g id="edge21" class="edge"><title>0--21</title></g>
    <g id="node59" class="node"><title>58</title> <text text-anchor="start" x="1316.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge58" class="edge"><title>0--58</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="63.62"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="start" x="182.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge6"
    class="edge"><title>5--6</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="285" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Constant</text></g> <g id="edge9" class="edge"><title>5--9</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="113"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge7" class="edge"><title>6--7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="201" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge8" class="edge"><title>6--8</title></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="start" x="354.5"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge11" class="edge"><title>10--11</title></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="start" x="458.38"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">BinOp</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="285"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"guess"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="369" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="426.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>14--15</title></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="515"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Div</text></g>
    <g id="edge18" class="edge"><title>14--18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="start" x="568" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge19"
    class="edge"><title>14--19</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"x"</text></g> <g id="edge16" class="edge"><title>15--16</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="443"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge17" class="edge"><title>15--17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="515" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">2</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="start" x="777.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge22" class="edge"><title>21--22</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="956.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge30" class="edge"><title>21--30</title></g>
    <g id="node38" class="node"><title>37</title> <text text-anchor="start" x="1290.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge37" class="edge"><title>21--37</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="start" x="670.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge23" class="edge"><title>22--23</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="769"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">NotEq</text></g>
    <g id="edge26" class="edge"><title>22--26</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="start" x="826.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge27"
    class="edge"><title>22--27</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="601" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge24" class="edge"><title>23--24</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="687"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge25" class="edge"><title>23--25</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="769" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge28" class="edge"><title>27--28</title></g>
    <g id="node30" class="node"><title>29</title> <text text-anchor="middle" x="851"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge29" class="edge"><title>27--29</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="start" x="964.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge31"
    class="edge"><title>30--31</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1092.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge34"
    class="edge"><title>30--34</title></g> <g id="node33" class="node"><title>32</title>
    <text text-anchor="middle" x="937" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge32" class="edge"><title>31--32</title></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="1025"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge33" class="edge"><title>31--33</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="middle" x="1109" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge35" class="edge"><title>34--35</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="1191"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge36" class="edge"><title>34--36</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="start" x="1298.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge38"
    class="edge"><title>37--38</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="start" x="1411.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge41"
    class="edge"><title>37--41</title></g> <g id="node40" class="node"><title>39</title>
    <text text-anchor="middle" x="1273" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge39" class="edge"><title>38--39</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1357"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge40" class="edge"><title>38--40</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1411.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge42"
    class="edge"><title>41--42</title></g> <g id="node56" class="node"><title>55</title>
    <text text-anchor="middle" x="1506" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge55" class="edge"><title>41--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="start" x="1559"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge56" class="edge"><title>41--56</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1343.5"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node47" class="node"><title>46</title> <text text-anchor="middle" x="1432"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Add</text></g>
    <g id="edge46" class="edge"><title>42--46</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1485.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge47"
    class="edge"><title>42--47</title></g> <g id="node45" class="node"><title>44</title>
    <text text-anchor="middle" x="1275" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge44" class="edge"><title>43--44</title></g>
    <g id="node46" class="node"><title>45</title> <text text-anchor="middle" x="1361"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge45" class="edge"><title>43--45</title></g> <g id="node49" class="node"><title>48</title>
    <text text-anchor="start" x="1417.5" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge48"
    class="edge"><title>47--48</title></g> <g id="node52" class="node"><title>51</title>
    <text text-anchor="middle" x="1506" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge51" class="edge"><title>47--51</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="start" x="1561.5"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge52" class="edge"><title>47--52</title></g>
    <g id="node50" class="node"><title>49</title> <text text-anchor="middle" x="1376"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge49" class="edge"><title>48--49</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1448" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge50" class="edge"><title>48--50</title></g>
    <g id="node54" class="node"><title>53</title> <text text-anchor="middle" x="1563"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge53" class="edge"><title>52--53</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="middle" x="1649" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge54" class="edge"><title>52--54</title></g>
    <g id="node58" class="node"><title>57</title> <text text-anchor="middle" x="1592"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">2</text></g>
    <g id="edge57" class="edge"><title>56--57</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="start" x="1503.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge59"
    class="edge"><title>58--59</title></g> <g id="node61" class="node"><title>60</title>
    <text text-anchor="middle" x="1520" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge60" class="edge"><title>59--60</title></g>
    <g id="node62" class="node"><title>61</title> <text text-anchor="middle" x="1606"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge61" class="edge"><title>59--61</title></g></g></svg>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1684pt" height="548pt"
    viewBox="0.00 0.00 1684.00 548.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 544)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="282.62" y="-517.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="82" y="-444.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"my_sqrt"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="152.88"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="261.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge5" class="edge"><title>0--5</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="start" x="346.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge10" class="edge"><title>0--10</title></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="start" x="909.38"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">While</text></g> <g id="edge21" class="edge"><title>0--21</title></g>
    <g id="node59" class="node"><title>58</title> <text text-anchor="start" x="1316.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge58" class="edge"><title>0--58</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="63.62"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="start" x="182.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge6"
    class="edge"><title>5--6</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="285" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Constant</text></g> <g id="edge9" class="edge"><title>5--9</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="113"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge7" class="edge"><title>6--7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="201" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge8" class="edge"><title>6--8</title></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="start" x="354.5"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge11" class="edge"><title>10--11</title></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="start" x="458.38"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">BinOp</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="285"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"guess"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="369" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="426.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>14--15</title></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="515"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Div</text></g>
    <g id="edge18" class="edge"><title>14--18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="start" x="568" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge19"
    class="edge"><title>14--19</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"x"</text></g> <g id="edge16" class="edge"><title>15--16</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="443"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge17" class="edge"><title>15--17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="515" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">2</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="start" x="777.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge22" class="edge"><title>21--22</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="956.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge30" class="edge"><title>21--30</title></g>
    <g id="node38" class="node"><title>37</title> <text text-anchor="start" x="1290.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge37" class="edge"><title>21--37</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="start" x="670.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge23" class="edge"><title>22--23</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="769"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">NotEq</text></g>
    <g id="edge26" class="edge"><title>22--26</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="start" x="826.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge27"
    class="edge"><title>22--27</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="601" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge24" class="edge"><title>23--24</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="687"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge25" class="edge"><title>23--25</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="769" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge28" class="edge"><title>27--28</title></g>
    <g id="node30" class="node"><title>29</title> <text text-anchor="middle" x="851"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge29" class="edge"><title>27--29</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="start" x="964.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge31"
    class="edge"><title>30--31</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1092.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge34"
    class="edge"><title>30--34</title></g> <g id="node33" class="node"><title>32</title>
    <text text-anchor="middle" x="937" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge32" class="edge"><title>31--32</title></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="1025"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge33" class="edge"><title>31--33</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="middle" x="1109" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge35" class="edge"><title>34--35</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="1191"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge36" class="edge"><title>34--36</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="start" x="1298.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge38"
    class="edge"><title>37--38</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="start" x="1411.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge41"
    class="edge"><title>37--41</title></g> <g id="node40" class="node"><title>39</title>
    <text text-anchor="middle" x="1273" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge39" class="edge"><title>38--39</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1357"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge40" class="edge"><title>38--40</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1411.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge42"
    class="edge"><title>41--42</title></g> <g id="node56" class="node"><title>55</title>
    <text text-anchor="middle" x="1506" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge55" class="edge"><title>41--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="start" x="1559"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge56" class="edge"><title>41--56</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1343.5"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node47" class="node"><title>46</title> <text text-anchor="middle" x="1432"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Add</text></g>
    <g id="edge46" class="edge"><title>42--46</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1485.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge47"
    class="edge"><title>42--47</title></g> <g id="node45" class="node"><title>44</title>
    <text text-anchor="middle" x="1275" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge44" class="edge"><title>43--44</title></g>
    <g id="node46" class="node"><title>45</title> <text text-anchor="middle" x="1361"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge45" class="edge"><title>43--45</title></g> <g id="node49" class="node"><title>48</title>
    <text text-anchor="start" x="1417.5" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge48"
    class="edge"><title>47--48</title></g> <g id="node52" class="node"><title>51</title>
    <text text-anchor="middle" x="1506" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge51" class="edge"><title>47--51</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="start" x="1561.5"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge52" class="edge"><title>47--52</title></g>
    <g id="node50" class="node"><title>49</title> <text text-anchor="middle" x="1376"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge49" class="edge"><title>48--49</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1448" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge50" class="edge"><title>48--50</title></g>
    <g id="node54" class="node"><title>53</title> <text text-anchor="middle" x="1563"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge53" class="edge"><title>52--53</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="middle" x="1649" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge54" class="edge"><title>52--54</title></g>
    <g id="node58" class="node"><title>57</title> <text text-anchor="middle" x="1592"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">2</text></g>
    <g id="edge57" class="edge"><title>56--57</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="start" x="1503.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge59"
    class="edge"><title>58--59</title></g> <g id="node61" class="node"><title>60</title>
    <text text-anchor="middle" x="1520" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge60" class="edge"><title>59--60</title></g>
    <g id="node62" class="node"><title>61</title> <text text-anchor="middle" x="1606"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge61" class="edge"><title>59--61</title></g></g></svg>
- en: 'The function `ast.unparse()` converts such a tree back into the more familiar
    textual Python code representation. Comments are gone, and there may be more parentheses
    than before, but the result has the same semantics:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`ast.unparse()`将这样的树转换回更熟悉的文本Python代码表示。注释已删除，并且可能比之前有更多的括号，但结果具有相同的语义：
- en: '[PRE84]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Annotating Functions with Given Types
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用给定类型注解函数
- en: Let us now go and transform these trees to add type annotations. We start with
    a helper function `parse_type(name)` which parses a type name into an AST.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在转换这些树以添加类型注释。我们从一个辅助函数`parse_type(name)`开始，它将类型名称解析为AST。
- en: '[PRE86]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We now define a helper function that actually adds type annotations to a function
    AST. The `TypeTransformer` class builds on the Python standard library `ast.NodeTransformer`
    infrastructure. It would be called as
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在定义一个辅助函数，该函数实际上向函数 AST 添加类型注释。`TypeTransformer` 类建立在 Python 标准库 `ast.NodeTransformer`
    基础之上。它将被调用为
- en: '[PRE91]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'to annotate the arguments of `my_sqrt()`: `x` with `int`, and the return type
    with `float`. The returned AST can then be unparsed, compiled or analyzed.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要注释 `my_sqrt()` 的参数：`x` 为 `int`，返回类型为 `float`。然后可以反解析、编译或分析返回的 AST。
- en: '[PRE92]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The core of `TypeTransformer` is the method `visit_FunctionDef()`, which is
    called for every function definition in the AST. Its argument `node` is the subtree
    of the function definition to be transformed. Our implementation accesses the
    individual arguments and invokes `annotate_args()` on them; it also sets the return
    type in the `returns` attribute of the node.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`TypeTransformer` 的核心方法是 `visit_FunctionDef()`，它在 AST 中的每个函数定义上都会被调用。它的参数 `node`
    是要转换的函数定义的子树。我们的实现访问单个参数并在它们上调用 `annotate_args()`；它还在节点的 `returns` 属性中设置返回类型。'
- en: '[PRE93]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Each argument gets its own annotation, taken from the types originally passed
    to the class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都获得自己的注释，这些注释来自最初传递给类的类型：
- en: '[PRE94]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Does this work? Let us annotate the AST from `my_sqrt()` with types for the
    arguments and return types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行吗？让我们用类型注释 `my_sqrt()` 的参数和返回类型来注释 AST：
- en: '[PRE95]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'When we unparse the new AST, we see that the annotations actually are present:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们反解析新的 AST 时，我们看到注释实际上确实存在：
- en: '[PRE96]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Similarly, we can annotate the `hello()` function from above:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以注释上面提到的 `hello()` 函数：
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Annotating Functions with Mined Types
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用挖掘的类型注释函数
- en: 'Let us now annotate functions with types mined at runtime. We start with a
    simple function `type_string()` that determines the appropriate type of a given
    value (as a string):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用在运行时挖掘的类型注释函数。我们从简单的函数 `type_string()` 开始，该函数确定给定值（作为字符串）的适当类型：
- en: '[PRE103]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: For composite structures, `type_string()` does not examine element types; hence,
    the type of `[3]` is simply `list` instead of, say, `list[int]`. For now, `list`
    will do fine.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复合结构，`type_string()` 不检查元素类型；因此，`[3]` 的类型只是 `list`，而不是例如 `list[int]`。目前，`list`
    就足够了。
- en: '[PRE108]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`type_string()` will be used to infer the types of argument values found at
    runtime, as returned by `CallTracker.calls()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`type_string()` 将用于推断在运行时通过 `CallTracker.calls()` 返回的参数值的类型：'
- en: '[PRE110]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The function `annotate_types()` takes such a list of calls and annotates each
    function listed:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate_types()` 函数接受这样的调用列表，并对列出的每个函数进行注释：'
- en: '[PRE113]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For each function, we get the source and its AST and then get to the actual
    annotation in `annotate_function_ast_with_types()`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个函数，我们获取其源代码及其 AST，然后进入 `annotate_function_ast_with_types()` 中的实际注释：
- en: '[PRE114]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The function `annotate_function_ast_with_types()` invokes the `TypeTransformer`
    with the calls seen, and for each call, iterate over the arguments, determine
    their types, and annotate the AST with these. The universal type `Any` is used
    when we encounter type conflicts, which we will discuss below.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`annotate_function_ast_with_types()` 函数使用看到的调用调用 `TypeTransformer`，并对每个调用迭代参数，确定它们的类型，并用这些类型注释
    AST。当我们遇到类型冲突时，使用通用类型 `Any`，我们将在下面讨论。'
- en: '[PRE115]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here is `my_sqrt()` annotated with the types recorded usign the tracker, above.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用跟踪器记录的类型注释的 `my_sqrt()`：
- en: '[PRE117]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: All-in-one Annotation
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一站式注释
- en: Let us bring all of this together in a single class `TypeAnnotator` that first
    tracks calls of functions and then allows accessing the AST (and the source code
    form) of the tracked functions annotated with types. The method `typed_functions()`
    returns the annotated functions as a string; `typed_functions_ast()` returns their
    AST.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在单个类 `TypeAnnotator` 中将这些内容整合起来，该类首先跟踪函数调用，然后允许访问带有类型注释的跟踪函数的 AST（以及源代码形式）。`typed_functions()`
    方法返回注释函数的字符串；`typed_functions_ast()` 返回它们的 AST。
- en: '[PRE119]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Here is how to use `TypeAnnotator`. We first track a series of calls:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用 `TypeAnnotator` 的。我们首先跟踪一系列调用：
- en: '[PRE121]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'After tracking, we can immediately retrieve an annotated version of the functions
    tracked:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪后，我们可以立即检索跟踪函数的注释版本：
- en: '[PRE122]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: This also works for multiple and diverse functions. One could go and implement
    an automatic type annotator for Python files based on the types seen during execution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于多个和多样化的函数。有人可以基于执行期间看到的类型实现一个自动类型注释器，用于 Python 文件。
- en: '[PRE124]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: A content as above could now be sent to a type checker, which would detect any
    type inconsistency between callers and callees. Likewise, type annotations such
    as the ones above greatly benefit symbolic code analysis (as in the chapter on
    [symbolic fuzzing](SymbolicFuzzer.html)), as they effectively constrain the set
    of values that arguments and variables can take.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将上述内容发送给类型检查器，它将检测调用者和被调用者之间是否存在任何类型不一致。同样，如上所述的类型注解对于符号代码分析（如 [符号模糊测试](SymbolicFuzzer.html)
    章节中所述）非常有用，因为它们有效地限制了参数和变量可以取的值的集合。
- en: Multiple Types
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多种类型
- en: 'Let us now resolve the role of the magic `Any` type in `annotate_function_ast_with_types()`.
    If we see multiple types for the same argument, we set its type to `Any`. For
    `my_sqrt()`, this makes sense, as its arguments can be integers as well as floats:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来解析一下在 `annotate_function_ast_with_types()` 中魔法 `Any` 类型的角色。如果我们看到同一个参数有多个类型，我们将它的类型设置为
    `Any`。对于 `my_sqrt()` 来说，这是有意义的，因为它的参数可以是整数也可以是浮点数：
- en: '[PRE128]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The following function `sum3()` can be called with floating-point numbers as
    arguments, resulting in the parameters getting a `float` type:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数 `sum3()` 可以用浮点数作为参数调用，这将导致参数获得 `float` 类型：
- en: '[PRE131]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'If we call `sum3()` with integers, though, the arguments get an `int` type:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用整数调用 `sum3()`，那么参数将获得 `int` 类型：
- en: '[PRE136]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'And we can also call `sum3()` with strings, giving the arguments a `str` type:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用字符串调用 `sum3()`，这将给参数赋予 `str` 类型：
- en: '[PRE140]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'If we have multiple calls, but with different types, `TypeAnnotator()` will
    assign an `Any` type to both arguments and return values:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有多个调用，但参数类型不同，`TypeAnnotator()` 将会为这两个参数和返回值分配一个 `Any` 类型：
- en: '[PRE144]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: A type `Any` makes it explicit that an object can, indeed, have any type; it
    will not be type-checked at runtime or statically. To some extent, this defeats
    the power of type checking; but it also preserves some of the type flexibility
    that many Python programmers enjoy. Besides `Any`, the `typing` module supports
    several additional ways to define ambiguous types; we will keep this in mind for
    a later exercise.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `Any` 明确表示一个对象确实可以具有任何类型；它既不会在运行时也不会在静态时进行类型检查。在某种程度上，这削弱了类型检查的力量；但它也保留了一些许多
    Python 程序员所享受的类型灵活性。除了 `Any` 之外，`typing` 模块还支持定义模糊类型的几种额外方式；我们将记住这些内容以备后续练习。
- en: Specifying and Checking Invariants
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定和检查不变量
- en: Besides basic data types. we can check several further properties from arguments.
    We can, for instance, whether an argument can be negative, zero, or positive;
    or that one argument should be smaller than the second; or that the result should
    be the sum of two arguments – properties that cannot be expressed in a (Python)
    type.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本数据类型之外，我们还可以从参数检查几个其他属性。例如，我们可以检查一个参数是否可以是负数、零或正数；或者一个参数应该比第二个参数小；或者结果应该是两个参数的和——这些属性在（Python）类型中无法表达。
- en: Such properties are called *invariants*, as they hold across all invocations
    of a function. Specifically, invariants come as *pre*- and *postconditions* – conditions
    that always hold at the beginning and at the end of a function. (There are also
    *data* and *object* invariants that express always-holding properties over the
    state of data or objects, but we do not consider these in this book.)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '这样的属性被称为 *不变量*，因为它们在函数的所有调用中都保持不变。具体来说，不变量以 *前置* 和 *后置条件* 的形式出现——这些条件在函数的开始和结束时始终成立。（还有
    *数据* 和 *对象* 不变量，它们表达数据或对象状态上始终成立的属性，但在这本书中我们不考虑这些。） '
- en: Annotating Functions with Pre- and Postconditions
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用前置和后置条件注释函数
- en: 'The classical means to specify pre- and postconditions is via *assertions*,
    which we have introduced in the [chapter on testing](Intro_Testing.html). A precondition
    checks whether the arguments to a function satisfy the expected properties; a
    postcondition does the same for the result. We can express and check both using
    assertions as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 指定前置和后置条件的经典方法是通过 *断言*，这在我们在 [测试章节](Intro_Testing.html) 中已经介绍过了。前置条件检查函数的参数是否满足预期的属性；后置条件对结果做同样的检查。我们可以使用断言如下表达和检查：
- en: '[PRE148]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'A nicer way, however, is to syntactically separate invariants from the function
    at hand. Using appropriate decorators, we could specify pre- and postconditions
    as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一种更优雅的方法是在语法上将不变量与当前函数分开。使用适当的装饰器，我们可以如下指定前置和后置条件：
- en: '[PRE149]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: The decorators `@precondition` and `@postcondition` would run the given functions
    (specified as anonymous `lambda` functions) before and after the decorated function,
    respectively. If the functions return `False`, the condition is violated. `@precondition`
    gets the function arguments as arguments; `@postcondition` additionally gets the
    return value as first argument.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器 `@precondition` 和 `@postcondition` 分别在装饰函数之前和之后运行给定的函数（指定为匿名 `lambda` 函数）。如果函数返回
    `False`，则条件被违反。`@precondition` 获取函数参数作为参数；`@postcondition` 还额外获取返回值作为第一个参数。
- en: 'It turns out that implementing such decorators is not hard at all. Our implementation
    builds on a [code snippet from StackOverflow](https://stackoverflow.com/questions/12151182/python-precondition-postcondition-for-member-function-how):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的装饰器并不困难。我们的实现基于一个来自 StackOverflow 的 [代码片段](https://stackoverflow.com/questions/12151182/python-precondition-postcondition-for-member-function-how)：
- en: '[PRE150]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'With these, we can now start decorating `my_sqrt()`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们现在可以开始装饰 `my_sqrt()`：
- en: '[PRE152]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'This catches arguments violating the precondition:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这会捕获违反前置条件的参数：
- en: '[PRE153]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Likewise, we can provide a postcondition:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以提供一个后置条件：
- en: '[PRE155]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'If we have a buggy implementation of $\sqrt{x}$, this gets caught quickly:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个有错误的 $\sqrt{x}$ 实现，这将很快被发现：
- en: '[PRE159]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: While checking pre- and postconditions is a great way to catch errors, specifying
    them can be cumbersome. Let us try to see whether we can (again) *mine* some of
    them.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然检查前置条件和后置条件是捕获错误的好方法，但指定它们可能会很繁琐。让我们看看我们是否可以（再次）*挖掘*其中的一些。
- en: Mining Invariants
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 矿山不变量
- en: To *mine* invariants, we can use the same tracking functionality as before;
    instead of saving values for individual variables, though, we now check whether
    the values satisfy specific *properties* or not. For instance, if all values of
    `x` seen satisfy the condition `x > 0`, then we make `x > 0` an invariant of the
    function. If we see positive, zero, and negative values of `x`, though, then there
    is no property of `x` left to talk about.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要 *挖掘* 不变量，我们可以使用之前相同的跟踪功能；不过，我们不是保存单个变量的值，而是现在检查值是否满足特定的 *属性*。例如，如果我们看到的所有
    `x` 的值都满足条件 `x > 0`，那么我们将 `x > 0` 作为函数的不变量。如果我们看到 `x` 的正值、零值和负值，那么关于 `x` 就没有属性可以讨论了。
- en: 'The general idea is thus:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般思路是：
- en: Check all variable values observed against a set of predefined properties; and
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将观察到的所有变量值与一组预定义的属性进行比较；并且
- en: Keep only those properties that hold for all runs observed.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只保留对所有观察到的运行都成立的属性。
- en: Defining Properties
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义属性
- en: 'What precisely do we mean by properties? Here is a small collection of value
    properties that would frequently be used in invariants. All these properties would
    be evaluated with the *metavariables* `X`, `Y`, and `Z` (actually, any upper-case
    identifier) being replaced with the names of function parameters:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的属性究竟是什么意思？这里有一小部分经常用于不变量的值属性。所有这些属性都将使用 *元变量* `X`、`Y` 和 `Z`（实际上，任何大写标识符）替换为函数参数的名称：
- en: '[PRE162]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: When `my_sqrt(x)` is called as, say `my_sqrt(5.0)`, we see that `x = 5.0` holds.
    The above properties would then all be checked for `x`. Only the properties `X
    > 0`, `X >= 0`, and `X != 0` hold for the call seen; and hence `x > 0`, `x >=
    0`, and `x != 0` would make potential preconditions for `my_sqrt(x)`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `my_sqrt(x)` 被调用，比如 `my_sqrt(5.0)` 时，我们看到 `x = 5.0` 成立。然后，上述属性将全部针对 `x` 进行检查。只有
    `X > 0`、`X >= 0` 和 `X != 0` 这三个属性适用于观察到的调用；因此 `x > 0`、`x >= 0` 和 `x != 0` 将成为
    `my_sqrt(x)` 的潜在前置条件。
- en: 'We can check for many more properties such as relations between two arguments:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查许多其他属性，例如两个参数之间的关系：
- en: '[PRE163]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Types also can be checked using properties. For any function parameter `X`,
    only one of these will hold:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 类型也可以通过属性进行检查。对于任何函数参数 `X`，以下其中之一将成立：
- en: '[PRE164]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'We can check for arithmetic properties:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查算术属性：
- en: '[PRE165]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Here''s relations over three values, a Python special:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三个值之间的关系，一个 Python 特殊情况：
- en: '[PRE166]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Finally, we can also check for list or string properties. Again, this is just
    a tiny selection.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以检查列表或字符串属性。这只是一个很小的选择。
- en: '[PRE167]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Extracting Meta-Variables
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取元变量
- en: Let us first introduce a few *helper functions* before we can get to the actual
    mining. `metavars()` extracts the set of meta-variables (`X`, `Y`, `Z`, etc.)
    from a property. To this end, we parse the property as a Python expression and
    then visit the identifiers.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行实际挖掘之前，让我们先介绍一些 *辅助函数*。`metavars()` 从属性中提取元变量集（`X`、`Y`、`Z` 等）。为此，我们将属性解析为
    Python 表达式，然后访问标识符。
- en: '[PRE168]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Instantiating Properties
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例化属性
- en: To produce a property as invariant, we need to be able to *instantiate* it with
    variable names. The instantiation of `X > 0` with `X` being instantiated to `a`,
    for instance, gets us `a > 0`. To this end, the function `instantiate_prop()`
    takes a property and a collection of variable names and instantiates the meta-variables
    left-to-right with the corresponding variables names in the collection.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要将属性作为不变量产生，我们需要能够用变量名 *实例化* 它。例如，将 `X > 0` 实例化为 `X` 为 `a` 的情况，得到 `a > 0`。为此，函数
    `instantiate_prop()` 接受一个属性和一组变量名，并将元变量从左到右与集合中的相应变量名实例化。
- en: '[PRE172]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Evaluating Properties
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 评估属性
- en: 'To actually *evaluate* properties, we do not need to instantiate them. Instead,
    we simply convert them into a boolean function, using `lambda`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际 *评估* 属性，我们不需要实例化它们。相反，我们只需将它们转换为布尔函数，使用 `lambda`：
- en: '[PRE176]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Here is a simple example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子：
- en: '[PRE177]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Checking Invariants
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查不变量
- en: To extract invariants from an execution, we need to check them on all possible
    instantiations of arguments. If the function to be checked has two arguments `a`
    and `b`, we instantiate the property `X < Y` both as `a < b` and `b < a` and check
    each of them.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要从执行中提取不变量，我们需要检查所有可能的参数实例。如果要检查的函数有两个参数 `a` 和 `b`，我们既将属性 `X < Y` 实例化为 `a <
    b`，也实例化为 `b < a`，并检查每一个。
- en: 'To get all combinations, we use the Python `permutations()` function:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有组合，我们使用 Python 的 `permutations()` 函数：
- en: '[PRE183]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: The function `true_property_instantiations()` takes a property and a list of
    tuples (`var_name`, `value`). It then produces all instantiations of the property
    with the given values and returns those that evaluate to True.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `true_property_instantiations()` 接受一个属性和一个元组列表 (`var_name`, `value`)。然后，它产生所有给定值的属性实例，并返回那些评估为
    True 的实例。
- en: '[PRE186]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Here is an example. If `x == -1` and `y == 1`, the property `X < Y` holds for
    `x < y`, but not for `y < x`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。如果 `x == -1` 和 `y == 1`，属性 `X < Y` 对 `x < y` 成立，但对 `y < x` 不成立：
- en: '[PRE187]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'The instantiation retrieves the short form:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化检索到简短形式：
- en: '[PRE190]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Likewise, with values for `x` and `y` as above, the property `X < 0` only holds
    for `x`, but not for `y`:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于 `x` 和 `y` 的值如上所述，属性 `X < 0` 仅对 `x` 成立，但对 `y` 不成立：
- en: '[PRE192]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: Extracting Invariants
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取不变量
- en: Let us now run the above invariant extraction on function arguments and return
    values as observed during a function execution. To this end, we extend the `CallTracker`
    class into an `InvariantTracker` class, which automatically computes invariants
    for all functions and all calls observed during tracking.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将上述不变量提取应用于函数执行期间观察到的函数参数和返回值。为此，我们将 `CallTracker` 类扩展为 `InvariantTracker`
    类，该类自动计算所有函数和跟踪期间观察到的所有调用的不变量。
- en: By default, an `InvariantTracker` uses the properties as defined above; however,
    one can specify alternate sets of properties.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`InvariantTracker` 使用上面定义的属性；然而，可以指定不同的属性集。
- en: '[PRE196]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The key method of the `InvariantTracker` is the `invariants()` method. This
    iterates over the calls observed and checks which properties hold. Only the intersection
    of properties – that is, the set of properties that hold for all calls – is preserved,
    and eventually returned. The special variable `return_value` is set to hold the
    return value.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`InvariantTracker` 的关键方法是 `invariants()` 方法。该方法遍历观察到的调用并检查哪些属性成立。仅保留属性的交集——即对所有调用都成立的属性集合——并最终返回。特殊变量
    `return_value` 被设置为保留返回值。'
- en: '[PRE197]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Here's an example of how to use `invariants()`. We run the tracker on a small
    set of calls.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `invariants()` 的一个示例。我们在一组小的调用上运行跟踪器。
- en: '[PRE199]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The `invariants()` method produces a set of properties that hold for the observed
    runs, together with their instantiations over function arguments.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`invariants()` 方法生成一组属性，这些属性对于观察到的运行成立，以及它们在函数参数上的实例化。'
- en: '[PRE201]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'As before, the actual instantiations are easier to read:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，实际的实例化更容易阅读：
- en: '[PRE203]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: We see that the both `x` and the return value have a `float` type. We also see
    that both are always greater than zero. These are properties that may make useful
    pre- and postconditions, notably for symbolic analysis.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`x` 和返回值都具有 `float` 类型。我们还可以看到，它们总是大于零。这些可能是有用的前置和后置条件，特别是对于符号分析。
- en: 'However, there''s also an invariant which does *not* universally hold, namely
    `return_value <= x`, as the following example shows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，也存在一个不普遍成立的不变量，即 `return_value <= x`，如下例所示：
- en: '[PRE206]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Clearly, 0.1 > 0.01 holds. This is a case of us not learning from sufficiently
    diverse inputs. As soon as we have a call including `x = 0.1`, though, the invariant
    `return_value <= x` is eliminated:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，0.1 > 0.01 成立。这是一个我们没有从足够多样化的输入中学习的例子。但是，一旦我们有一个包含 `x = 0.1` 的调用，不变量 `return_value
    <= x` 就被消除了：
- en: '[PRE208]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'We will discuss later how to ensure sufficient diversity in inputs. (Hint:
    This involves test generation.)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后讨论如何确保输入的多样性足够。（提示：这涉及到测试生成。）
- en: Let us try out our invariant tracker on `sum3()`. We see that all types are
    well-defined; the properties that all arguments are non-zero, however, is specific
    to the calls observed.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用我们的不变量跟踪器对 `sum3()` 进行测试。我们看到所有类型都定义良好；然而，所有参数都是非零的属性是针对观察到的调用特定的。
- en: '[PRE210]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: If we invoke `sum3()` with strings instead, we get different invariants. Notably,
    we obtain the postcondition that the return value starts with the value of `a`
    – a universal postcondition if strings are used.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用字符串而不是数字调用 `sum3()`，我们会得到不同的不变量。值得注意的是，我们获得了返回值以 `a` 的值为起始值的后条件——如果使用字符串，这是一个普遍的后条件。
- en: '[PRE212]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: If we invoke `sum3()` with both strings and numbers (and zeros, too), there
    are no properties left that would hold across all calls. That's the price of flexibility.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用字符串和数字（以及零）调用 `sum3()`，就没有留下任何在所有调用中都成立的属性。这就是灵活性的代价。
- en: '[PRE214]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Converting Mined Invariants to Annotations
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将挖掘的不变量转换为注释
- en: As with types, above, we would like to have some functionality where we can
    add the mined invariants as annotations to existing functions. To this end, we
    introduce the `InvariantAnnotator` class, extending `InvariantTracker`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 与类型一样，我们希望有一些功能，我们可以将挖掘的不变量作为注释添加到现有的函数中。为此，我们引入了 `InvariantAnnotator` 类，它扩展了
    `InvariantTracker`。
- en: We start with a helper method. `params()` returns a comma-separated list of
    parameter names as observed during calls.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个辅助方法开始。`params()` 返回在调用过程中观察到的参数名称的逗号分隔列表。
- en: '[PRE216]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Now for the actual annotation. `preconditions()` returns the preconditions
    from the mined invariants (i.e., those properties that do not depend on the return
    value) as a string with annotations:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实际的注释。`preconditions()` 返回从挖掘的不变量中获取的前条件（即，那些不依赖于返回值的属性），作为一个带有注释的字符串：
- en: '[PRE222]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '`postconditions()` does the same for postconditions:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`postconditions()` 对后条件做同样的处理：'
- en: '[PRE226]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'With these, we can take a function and add both pre- and postconditions as
    annotations:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些，我们可以将一个函数作为注释添加前条件和后条件：
- en: '[PRE230]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'Here comes `function_with_invariants()` in all its glory:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `function_with_invariants()` 在其所有荣耀中的样子：
- en: '[PRE231]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Quite a lot of invariants, is it? Further below (and in the exercises), we will
    discuss on how to focus on the most relevant properties.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 很多的不变量，是吗？在下面（以及在练习中），我们将讨论如何关注最相关的属性。
- en: Some Examples
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些例子
- en: 'Here''s another example. `list_length()` recursively computes the length of
    a Python function. Let us see whether we can mine its invariants:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子。`list_length()` 递归地计算一个 Python 函数的长度。让我们看看我们是否可以挖掘其不变量：
- en: '[PRE234]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Almost all these properties (except for the very first) are relevant. Of course,
    the reason the invariants are so neat is that the return value is equal to `len(L)`
    is that `X == len(Y)` is part of the list of properties to be checked.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有这些属性（除了第一个）都是相关的。当然，不变量之所以如此整洁，是因为返回值等于 `len(L)`，以及 `X == len(Y)` 是要检查的属性列表的一部分。
- en: 'The next example is a very simple function:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子是一个非常简单的函数：
- en: '[PRE237]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: The invariants all capture the relationship between `a`, `b`, and the return
    value as `return_value == a + b` in all its variations.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不变量都捕捉了 `a`、`b` 和返回值之间的关系，即 `return_value == a + b` 在所有变化中。
- en: '[PRE239]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: If we have a function without return value, the return value is `None`, and
    we can only mine preconditions. (Well, we get a "postcondition" that the return
    value is non-zero, which holds for `None`).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个没有返回值的函数，返回值是 `None`，我们只能挖掘前条件。（好吧，我们得到一个“后条件”，即返回值是非零的，这对于 `None` 是成立的。）
- en: '[PRE241]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Checking Specifications
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查规范
- en: A function with invariants, as above, can be fed into the Python interpreter,
    such that all pre- and postconditions are checked. We create a function `my_sqrt_annotated()`
    which includes all the invariants mined above.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，具有不变量的函数可以输入到 Python 解释器中，以便检查所有前条件和后条件。我们创建了一个函数 `my_sqrt_annotated()`，它包括上面挖掘的所有不变量。
- en: '[PRE246]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'The "annotated" version checks against invalid arguments – or more precisely,
    against arguments with properties that have not been observed yet:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: “注释”版本检查无效的参数——或者更精确地说，检查尚未观察到的属性的参数：
- en: '[PRE251]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'This is in contrast to the original version, which just hangs on negative values:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这与原始版本形成对比，原始版本只是对负值挂起：
- en: '[PRE253]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: If we make changes to the function definition such that the properties of the
    return value change, such *regressions* are caught as violations of the postconditions.
    Let us illustrate this by simply inverting the result, and return $-2$ as square
    root of 4.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对函数定义进行修改，使得返回值的属性发生变化，那么这种*回归*会被视为违反了后置条件。让我们通过简单地反转结果，将$-2$作为4的平方根来举例说明。
- en: '[PRE255]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'Technically speaking, $-2$ *is* a square root of 4, since $(-2)^2 = 4$ holds.
    Yet, such a change may be unexpected by callers of `my_sqrt()`, and hence, this
    would be caught with the first call:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上来说，$-2$确实是4的平方根，因为$(-2)^2 = 4$成立。然而，这种更改可能对`my_sqrt()`的调用者来说是出乎意料的，因此，这将在第一次调用时被发现：
- en: '[PRE259]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: We see how pre- and postconditions, as well as types, can serve as *oracles*
    during testing. In particular, once we have mined them for a set of functions,
    we can check them again and again with test generators – especially after code
    changes. The more checks we have, and the more specific they are, the more likely
    it is we can detect unwanted effects of changes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到前置和后置条件，以及类型，如何在测试期间充当*占卜者*。特别是，一旦我们为一系列函数挖掘了它们，我们就可以用测试生成器反复检查它们——尤其是在代码更改之后。检查越多，越具体，我们检测到变化带来的不期望效果的可能性就越大。
- en: Mining Specifications from Generated Tests
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从生成的测试中挖掘规范
- en: 'Mined specifications can only be as good as the executions they were mined
    from. If we only see a single call to, say, `sum2()` as defined above, we will
    be faced with several mined pre- and postconditions that *overspecialize* towards
    the values seen:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 从挖掘出的执行中，挖掘出的规范只能达到那样的水平。如果我们只看到像上面定义的`sum2()`这样的单个调用，我们将面临几个挖掘出的前置和后置条件，这些条件*过度专业化*于观察到的值：
- en: '[PRE261]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The mined precondition `a == b`, for instance, only holds for the single call
    observed; the same holds for the mined postcondition `return_value == a * b`.
    Yet, `sum2()` can obviously be successfully called with other values that do not
    satisfy these conditions.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，挖掘出的前置条件`a == b`仅适用于观察到的单个调用；同样的，挖掘出的后置条件`return_value == a * b`也是如此。然而，`sum2()`显然可以用其他不满足这些条件的值成功调用。
- en: 'To get out of this trap, we have to *learn from more and more diverse runs*.
    If we have a few more calls of `sum2()`, we see how the set of invariants quickly
    gets smaller:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 为了摆脱这个陷阱，我们必须从越来越多样化的运行中学习。如果我们有更多`sum2()`的调用，我们会看到不变量的集合如何迅速缩小：
- en: '[PRE263]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: But where to we get such diverse runs from? This is the job of generating software
    tests. A simple grammar for calls of `sum2()` will easily resolve the problem.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们从哪里得到这样多样化的运行呢？这是生成软件测试的工作。一个简单的`sum2()`调用语法将很容易解决这个问题。
- en: '[PRE265]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: But then, writing tests (or a test driver) just to derive a set of pre- and
    postconditions may possibly be too much effort – in particular, since tests can
    easily be derived from given pre- and postconditions in the first place. Hence,
    it would be wiser to first specify invariants and then let test generators or
    program provers do the job.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 但然后，仅仅为了推导出一组前置和后置条件而编写测试（或测试驱动程序）可能太过费力——特别是，因为测试可以很容易地从给定的前置和后置条件中推导出来。因此，首先指定不变量，然后让测试生成器或程序证明者来完成这项工作会更明智。
- en: Also, an API grammar, such as above, will have to be set up such that it actually
    respects preconditions – in our case, we invoke `sqrt()` with positive numbers
    only, already assuming its precondition. In some way, one thus needs a specification
    (a model, a grammar) to mine another specification – a chicken-and-egg problem.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，API语法，如上所述，必须设置得能够真正尊重前置条件——在我们的例子中，我们只使用正数调用`sqrt()`，已经假设了它的前置条件。在某种程度上，因此需要一种规范（一个模型，一个语法）来挖掘另一种规范——这是一个鸡生蛋的问题。
- en: 'However, there is one way out of this problem: If one can automatically generate
    tests at the system level, then one has an *infinite source of executions* to
    learn invariants from. In each of these executions, all functions would be called
    with values that satisfy the (implicit) precondition, allowing us to mine invariants
    for these functions. This holds, because at the system level, invalid inputs must
    be rejected by the system in the first place. The meaningful precondition at the
    system level, ensuring that only valid inputs get through, thus gets broken down
    into a multitude of meaningful preconditions (and subsequent postconditions) at
    the function level.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以解决这个问题：如果能够在系统级别自动生成测试，那么就有一个*无限的执行来源*来学习恒等式。在这些执行中的每一个，所有函数都会使用满足（隐式）先决条件的值被调用，这使我们能够为这些函数挖掘恒等式。这是因为在系统级别，无效的输入首先必须被系统拒绝。系统级别的有意义的先决条件，确保只有有效的输入通过，因此被分解为许多有意义的先决条件（以及随后的后置条件）在函数级别。
- en: The big requirement for this, though, is that one needs good test generators
    at the system level. In [the next part](05_Domain-Specific_Fuzzing.ipynb), we
    will discuss how to automatically generate tests for a variety of domains, from
    configuration to graphical user interfaces.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于这一点来说，一个重要的要求是，需要在系统级别有好的测试生成器。在[下一部分](05_Domain-Specific_Fuzzing.ipynb)中，我们将讨论如何自动为各种领域生成测试，从配置到图形用户界面。
- en: Lessons Learned
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Type annotations and explicit invariants allow for *checking* arguments and
    results for expected data types and other properties.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型注解和显式恒等式允许检查参数和结果以期望的数据类型和其他属性。
- en: One can automatically *mine* data types and invariants by observing arguments
    and results at runtime.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过观察运行时的参数和结果自动挖掘数据类型和恒等式。
- en: The quality of mined invariants depends on the diversity of values observed
    during executions; this variety can be increased by generating tests.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矿掘出的恒等式的质量取决于执行过程中观察到的值的多样性；这种多样性可以通过生成测试来增加。
- en: Next Steps
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: This chapter concludes the [part on semantic fuzzing techniques](04_Semantical_Fuzzing.html).
    In the next part, we will explore [domain-specific fuzzing techniques](05_Domain-Specific_Fuzzing.ipynb)
    from configurations and APIs to graphical user interfaces.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 本章总结了[关于语义模糊测试技术的部分](04_Semantical_Fuzzing.html)。在下一部分，我们将探讨从配置和API到图形用户界面的[特定领域模糊测试技术](05_Domain-Specific_Fuzzing.ipynb)。
- en: Background
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The [DAIKON dynamic invariant detector](https://plse.cs.washington.edu/daikon/)
    can be considered the mother of function specification miners. Continuously maintained
    and extended for more than 20 years, it mines likely invariants in the style of
    this chapter for a variety of languages, including C, C++, C#, Eiffel, F#, Java,
    Perl, and Visual Basic. On top of the functionality discussed above, it holds
    a rich catalog of patterns for likely invariants, supports data invariants, can
    eliminate invariants that are implied by others, and determines statistical confidence
    to disregard unlikely invariants. The corresponding paper [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    is one of the seminal and most-cited papers of Software Engineering. A multitude
    of works have been published based on DAIKON and detecting invariants; see this
    [curated list](http://plse.cs.washington.edu/daikon/pubs/) for details.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[DAIKON 动态不变检测器](https://plse.cs.washington.edu/daikon/)可以被认为是函数规范挖掘器的鼻祖。经过20多年的持续维护和扩展，它以本章所述的风格为包括C、C++、C#、Eiffel、F#、Java、Perl和Visual
    Basic在内的多种语言挖掘可能的恒等式。除了上述功能外，它还拥有大量可能的恒等式模式库，支持数据恒等式，可以消除由其他恒等式暗示的恒等式，并确定统计置信度以忽略不太可能的恒等式。相应的论文[[Ernst
    等人，2001](https://doi.org/10.1109/32.908957)]是软件工程领域的开创性且被引用次数最多的论文之一。基于DAIKON和检测恒等式，已经发表了大量作品；请参阅此[精选列表](http://plse.cs.washington.edu/daikon/pubs/)以获取详细信息。'
- en: The interaction between test generators and invariant detection is already discussed
    in [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)] (incidentally also
    using grammars). The Eclat tool [[Pacheco *et al*, 2005](https://doi.org/10.1007/11531142_22)]
    is a model example of tight interaction between a unit-level test generator and
    DAIKON-style invariant mining, where the mined invariants are used to produce
    oracles and to systematically guide the test generator towards fault-revealing
    inputs.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 测试生成器与不变性检测之间的交互已在 [[Ernst 等人，2001](https://doi.org/10.1109/32.908957)] 中讨论（顺便提一下，也使用了语法）。Eclat
    工具 [[Pacheco 等人，2005](https://doi.org/10.1007/11531142_22)] 是单元级测试生成器与 DAIKON
    风格的不变性挖掘之间紧密交互的一个模型示例，其中挖掘的不变性被用来生成或acles 并系统地引导测试生成器向故障揭示输入。
- en: Mining specifications is not restricted to pre- and postconditions. The paper
    "Mining Specifications" [[Ammons *et al*, 2002](https://doi.org/10.1145/503272.503275)]
    is another classic in the field, learning state protocols from executions. Grammar
    mining, as described in [our chapter with the same name](GrammarMiner.html) can
    also be seen as a specification mining approach, this time learning specifications
    of input formats.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘规范不仅限于前置条件和后置条件。论文《挖掘规范》[[Ammons 等人，2002](https://doi.org/10.1145/503272.503275)]是该领域的另一篇经典之作，它从执行中学习状态协议。正如我们在[同名章节](GrammarMiner.html)中描述的语法挖掘也可以被视为一种规范挖掘方法，这次是学习输入格式的规范。
- en: 'As it comes to adding type annotations to existing code, the blog post ["The
    state of type hints in Python"](https://www.bernat.tech/the-state-of-type-hints-in-python/)
    gives a great overview on how Python type hints can be used and checked. To add
    type annotations, there are two important tools available that also implement
    our above approach:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到向现有代码添加类型注解时，博客文章["Python 中类型提示的状态"](https://www.bernat.tech/the-state-of-type-hints-in-python/)提供了关于如何使用和检查
    Python 类型提示的极佳概述。要添加类型注解，有两个重要的工具可用，它们也实现了我们上述的方法：
- en: '[MonkeyType](https://instagram-engineering.com/let-your-code-type-hint-itself-introducing-open-source-monkeytype-a855c7284881)
    implements the above approach of tracing executions and annotating Python 3 arguments,
    returns, and variables with type hints.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[MonkeyType](https://instagram-engineering.com/let-your-code-type-hint-itself-introducing-open-source-monkeytype-a855c7284881)
    实现了上述跟踪执行并使用类型提示注解 Python 3 参数、返回值和变量的方法。'
- en: '[PyAnnotate](https://github.com/dropbox/pyannotate) does a similar job, focusing
    on code in Python 2\. It does not produce Python 3-style annotations, but instead
    produces annotations as comments that can be processed by static type checkers.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[PyAnnotate](https://github.com/dropbox/pyannotate) 执行类似的工作，专注于 Python 2 中的代码。它不会生成
    Python 3 风格的注解，而是生成可以作为注释处理的注解，这些注释可以被静态类型检查器处理。'
- en: These tools have been created by engineers at Facebook and Dropbox, respectively,
    assisting them in checking millions of lines of code for type issues.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具是由 Facebook 和 Dropbox 的工程师创建的，分别帮助他们检查数百万行代码中的类型问题。
- en: Exercises
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Our code for mining types and invariants is in no way complete. There are dozens
    of ways to extend our implementations, some of which we discuss in exercises.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们挖掘类型和不变量的代码远非完整。有许多方法可以扩展我们的实现，其中一些我们在练习中进行了讨论。
- en: 'Exercise 1: Union Types'
  id: totrans-492
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1：联合类型
- en: 'The Python `typing` module allows expressing that an argument can have multiple
    types. For `my_sqrt(x)`, this allows expressing that `x` can be an `int` or a
    `float`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `typing` 模块允许表达一个参数可以有多种类型。对于 `my_sqrt(x)`，这允许表达 `x` 可以是 `int` 或 `float`：
- en: '[PRE273]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Extend the `TypeAnnotator` such that it supports union types for arguments and
    return values. Use `Optional[X]` as a shorthand for `Union[X, None]`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `TypeAnnotator` 以支持参数和返回值的联合类型。使用 `Optional[X]` 作为 `Union[X, None]` 的简写。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)来完成练习并查看解决方案。'
- en: 'Exercise 2: Types for Local Variables'
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：局部变量的类型
- en: 'In Python, one cannot only annotate arguments with types, but actually also
    local and global variables – for instance, `approx` and `guess` in our `my_sqrt()`
    implementation:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，不仅可以使用类型注解参数，还可以注解局部和全局变量——例如，在我们的 `my_sqrt()` 实现中的 `approx` 和 `guess`：
- en: '[PRE275]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: Extend the `TypeAnnotator` such that it also annotates local variables with
    types. Search the function AST for assignments, determine the type of the assigned
    value, and make it an annotation on the left-hand side.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `TypeAnnotator` 以便它还注释局部变量的类型。在函数 AST 中搜索赋值语句，确定赋值的类型，并将其作为左侧的注释。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 3: Verbose Invariant Checkers'
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：冗长的不变性检查器
- en: Our implementation of invariant checkers does not make it clear for the user
    which pre-/postcondition failed.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的不变性检查器实现没有清楚地告诉用户哪个前置/后置条件失败。
- en: '[PRE276]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'The following implementation adds an optional `doc` keyword argument which
    is printed if the invariant is violated:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实现添加了一个可选的 `doc` 关键字参数，如果违反了不变性，则会打印出来：
- en: '[PRE279]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: Extend `InvariantAnnotator` such that it includes the conditions in the generated
    pre- and postconditions.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 `InvariantAnnotator` 以便它包括生成的预/后置条件中的条件。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 4: Save Initial Values'
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：保存初始值
- en: 'If the value of an argument changes during function execution, this can easily
    confuse our implementation: The values are tracked at the beginning of the function,
    but checked only when it returns. Extend the `InvariantAnnotator` and the infrastructure
    it uses such that'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数执行过程中参数的值发生变化，这很容易使我们的实现困惑：值在函数开始时被跟踪，但只在返回时进行检查。扩展 `InvariantAnnotator`
    及其使用的基础设施，以便
- en: it saves argument values both at the beginning and at the end of a function
    invocation;
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在函数调用的开始和结束时都保存了参数值；
- en: postconditions can be expressed over both *initial* values of arguments as well
    as the *final* values of arguments;
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后置条件可以表达为参数的 *初始* 值以及参数的 *最终* 值；
- en: the mined postconditions refer to both these values as well.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挖掘出的后置条件也引用了这两个值。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 5: Implications'
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 5：隐含关系
- en: 'Several mined invariant are actually *implied* by others: If `x > 0` holds,
    then this implies `x >= 0` and `x != 0`. Extend the `InvariantAnnotator` such
    that implications between properties are explicitly encoded, and such that implied
    properties are no longer listed as invariants. See [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    for ideas.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 几个挖掘出的不变性实际上是由其他不变性隐含的：如果 `x > 0` 成立，那么这隐含了 `x >= 0` 和 `x != 0`。扩展 `InvariantAnnotator`
    以便显式地编码属性之间的隐含关系，并且隐含的属性不再作为不变性列出。参见 [[Ernst 等人，2001](https://doi.org/10.1109/32.908957)]
    获取想法。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 6: Local Variables'
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 6：局部变量
- en: Postconditions may also refer to the values of local variables. Consider extending
    `InvariantAnnotator` and its infrastructure such that the values of local variables
    at the end of the execution are also recorded and made part of the invariant inference
    mechanism.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 后置条件也可能引用局部变量的值。考虑扩展 `InvariantAnnotator` 及其基础设施，以便记录执行结束时的局部变量值，并将它们作为不变性推理机制的一部分。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 7: Exploring Invariant Alternatives'
  id: totrans-530
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 7：探索不变性替代方案
- en: After mining a first set of invariants, have a [concolic fuzzer](ConcolicFuzzer.html)
    generate tests that systematically attempt to invalidate pre- and postconditions.
    How far can you generalize?
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在挖掘出一组不变性之后，让一个 [concolic fuzzer](ConcolicFuzzer.html) 生成测试，这些测试系统地尝试使预/后置条件无效。你能推广到什么程度？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 8: Grammar-Generated Properties'
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 8：语法生成的属性
- en: The larger the set of properties to be checked, the more potential invariants
    can be discovered. Create a *grammar* that systematically produces a large set
    of properties. See [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    for possible patterns.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查的属性集越大，可以发现的潜在不变量就越多。创建一个能够系统地生成大量属性的 *语法*。参见 [[Ernst 等人，2001](https://doi.org/10.1109/32.908957)]
    中可能的模式。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 9: Embedding Invariants as Assertions'
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 9：将不变量嵌入为断言
- en: 'Rather than producing invariants as annotations for pre- and postconditions,
    insert them as `assert` statements into the function code, as in:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将不变量作为前置条件和后置条件的注释，将它们作为 `assert` 语句插入到函数代码中，如下所示：
- en: '[PRE286]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Such a formulation may make it easier for test generators and symbolic analysis
    to access and interpret pre- and postconditions.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的表述可能使测试生成器和符号分析更容易访问和解释前置条件和后置条件。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/DynamicInvariants.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons 许可证](../Images/2f3faa36146c6fb38bbab67add09aa5f.png) 本项目的内容根据
    [Creative Commons 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
    许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，根据 [MIT 许可证](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)
    许可。 [最后更改：2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/DynamicInvariants.ipynb)
    • [引用](#citation) • [印记](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Mining Function Specifications](https://www.fuzzingbook.org/html/DynamicInvariants.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/DynamicInvariants.html](https://www.fuzzingbook.org/html/DynamicInvariants.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler:
    "[挖掘函数规范](https://www.fuzzingbook.org/html/DynamicInvariants.html)"。在 Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler 的 "[模糊测试书](https://www.fuzzingbook.org/)"
    中，[https://www.fuzzingbook.org/html/DynamicInvariants.html](https://www.fuzzingbook.org/html/DynamicInvariants.html)。检索日期：2024-11-09
    17:07:29+01:00。'
- en: '[PRE287]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
