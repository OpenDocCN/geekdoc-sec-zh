- en: 'Fuzzing: Breaking Things with Random Inputs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试：使用随机输入破坏事物
- en: 原文：[http://www.fuzzingbook.org/html/Fuzzer.html](http://www.fuzzingbook.org/html/Fuzzer.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/Fuzzer.html](http://www.fuzzingbook.org/html/Fuzzer.html)
- en: In this chapter, we'll start with one of the simplest test generation techniques.
    The key idea of random text generation, also known as *fuzzing*, is to feed a
    *string of random characters* into a program in the hope to uncover failures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从最简单的测试生成技术开始。随机文本生成的关键思想，也称为 *模糊测试*，是将 *随机字符序列* 输入到程序中，希望揭示故障。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should know fundamentals of software testing; for instance, from the chapter
    ["Introduction to Software Testing"](Intro_Testing.html).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解软件测试的基础知识；例如，从章节 ["软件测试简介"](Intro_Testing.html)。
- en: You should have a decent understanding of Python; for instance, from the [Python
    tutorial](https://docs.python.org/3/tutorial/).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该对 Python 有一定的了解；例如，从 [Python 教程](https://docs.python.org/3/tutorial/)。
- en: We can make these prerequisites explicit. First, we'll import a standard package
    required for working in notebooks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以明确这些先决条件。首先，我们将导入一个在笔记本中工作的标准包。
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we explicitly import (and thus require) the earlier chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们显式导入（因此需要）前面的章节。
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Synopsis
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要 [使用本章提供的代码](Importing.html)，请编写
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and then make use of the following features.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter provides two important classes, introduced in [A Fuzzing Architecture](#A-Fuzzing-Architecture):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了两个重要的类，在 [模糊测试架构](#A-Fuzzing-Architecture) 中介绍：
- en: '`Fuzzer` as a base class for fuzzers; and'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fuzzer` 作为模糊器的基类；并且'
- en: '`Runner` as a base class for programs under test.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runner` 作为测试程序的基础类。'
- en: Fuzzers
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊器
- en: '`Fuzzer` is a base class for fuzzers, with `RandomFuzzer` as a simple instantiation.
    The `fuzz()` method of `Fuzzer` objects returns a string with a generated input.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fuzzer` 是模糊器的基类，`RandomFuzzer` 是一个简单的实例化。`Fuzzer` 对象的 `fuzz()` 方法返回一个包含生成输入的字符串。'
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `RandomFuzzer()` constructor allows a number of keyword arguments:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomFuzzer()` 构造函数允许一系列关键字参数：'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<svg width="254pt" height="191pt" viewBox="0.00 0.00 254.12 190.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 186.5)"><g
    id="node1" class="node"><title>RandomFuzzer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class RandomFuzzer:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="254pt" height="191pt" viewBox="0.00 0.00 254.12 190.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 186.5)"><g
    id="node1" class="node"><title>RandomFuzzer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class RandomFuzzer:'
- en: 'Produce random inputs."><text text-anchor="start" x="8" y="-43.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">RandomFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="RandomFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, min_length: int = 10, max_length: int
    = 100, char_start: int = 32, char_range: int = 32) -> None:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '生成随机输入。"><text text-anchor="start" x="8" y="-43.7" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">RandomFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="RandomFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, min_length: int = 10, max_length: int
    = 100, char_start: int = 32, char_range: int = 32) -> None:'
- en: Produce strings of `min_length` to `max_length` characters
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 `min_length` 到 `max_length` 个字符的字符串
- en: 'in the range [`char_start`, `char_start` + `char_range`)"><text text-anchor="start"
    x="24.5" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '在范围 `[char_start`, `char_start` + `char_range`)"><text text-anchor="start"
    x="24.5" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
- en: 'Return fuzz input"><text text-anchor="start" x="24.5" y="-8.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>Fuzzer</title>
    <g id="a_node2"><a xlink:href="#" xlink:title="class Fuzzer:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入"><text text-anchor="start" x="24.5" y="-8.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>Fuzzer</title>
    <g id="a_node2"><a xlink:href="#" xlink:title="class Fuzzer:'
- en: 'Base class for fuzzers."><text text-anchor="start" x="33.88" y="-165.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node2_3"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node2_4"><a
    xlink:href="#" xlink:title="__init__(self) -> None:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '模糊器的基类。</text></a></g> <g id="a_node2_3"><a xlink:href="#" xlink:title="Fuzzer"><g
    id="a_node2_4"><a xlink:href="#" xlink:title="__init__(self) -> None:'
- en: 'Constructor"><text text-anchor="start" x="24.5" y="-143.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_5"><a xlink:href="#"
    xlink:title="fuzz(self) -> str:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数</text></a></g> <g id="a_node2_5"><a xlink:href="#" xlink:title="fuzz(self)
    -> str:'
- en: 'Return fuzz input"><text text-anchor="start" x="24.5" y="-130.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_6"><a xlink:href="#" xlink:title="run(self,
    runner: Runner = <Runner object>) -> Tuple[subprocess.CompletedProcess, str]:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入</text></a></g> <g id="a_node2_6"><a xlink:href="#" xlink:title="run(self,
    runner: Runner = <Runner object>) -> Tuple[subprocess.CompletedProcess, str]:'
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="24.5" y="-118" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">run()</text></a></g>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="runs(self, runner: Runner = <PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '使用模糊输入运行 `runner`，`run()` 函数</text></a></g> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="runs(self, runner: Runner = <PrintRunner object>, trials: int = 10)
    -> List[Tuple[subprocess.CompletedProcess, str]]:'
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="24.5"
    y="-105.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>RandomFuzzer->Fuzzer</title></g> <g id="node3"
    class="node"><title>Legend</title> <text text-anchor="start" x="126.88" y="-46.25"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="126.88" y="-36.25" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="132.88" y="-36.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="126.88" y="-26.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="132.88" y="-26.25" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="126.88" y="-16.25" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="132.88" y="-16.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="126.88" y="-7.2" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模糊输入运行 `runner`，`trials` 次数</text></a></g></a></g></a></g></g> <g id="edge1"
    class="edge"><title>RandomFuzzer->Fuzzer</title></g> <g id="node3" class="node"><title>图例</title>
    <text text-anchor="start" x="126.88" y="-46.25" font-family="Patua One, Helvetica,
    sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">图例</text> <text
    text-anchor="start" x="126.88" y="-36.25" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="132.88" y="-36.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="126.88" y="-26.25" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="132.88" y="-26.25"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="126.88" y="-16.25" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="132.88" y="-16.25"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="126.88"
    y="-7.2" font-family="Helvetica,sans-Serif" font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: Runners
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行器
- en: 'A `Fuzzer` can be paired with a `Runner`, which takes the fuzzed strings as
    input. Its result is a class-specific *status* and an *outcome* (`PASS`, `FAIL`,
    or `UNRESOLVED`). A `PrintRunner` will simply print out the given input and return
    a `PASS` outcome:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Fuzzer` 可以与一个 `Runner` 配对，该 `Runner` 将模糊字符串作为输入。其结果是特定类的 *状态* 和 *结果* (`PASS`,
    `FAIL`, 或 `UNRESOLVED`)。一个 `PrintRunner` 将简单地打印出给定的输入并返回一个 `PASS` 结果：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `ProgramRunner` will feed the generated input into an external program. Its
    result is a pair of the program status (a `CompletedProcess` instance) and an
    *outcome* (`PASS`, `FAIL`, or `UNRESOLVED`):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `ProgramRunner` 将生成的输入传递给外部程序。其结果是程序状态（`CompletedProcess` 实例）和 *结果* (`PASS`,
    `FAIL`, 或 `UNRESOLVED`) 的一个对：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<svg width="371pt" height="224pt" viewBox="0.00 0.00 371.12 224.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 220)"><g
    id="node1" class="node"><title>ProgramRunner</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ProgramRunner:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="371pt" height="224pt" viewBox="0.00 0.00 371.12 224.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 220)"><g
    id="node1" class="node"><title>程序运行器</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ProgramRunner:'
- en: 'Test a program with inputs."><text text-anchor="start" x="8" y="-56.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProgramRunner</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="ProgramRunner"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, program: Union[str, List[str]]) ->
    None:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '使用输入测试程序。"><text text-anchor="start" x="8" y="-56.45" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">程序运行器</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="程序运行器"><g id="a_node1_1"><a xlink:href="#"
    xlink:title="__init__(self, program: Union[str, List[str]]) -> None:'
- en: Initialize.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化。
- en: '`program` is a program spec as passed to `subprocess.run()`"><text text-anchor="start"
    x="18.5" y="-34.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="run(self, inp: str = '''') ->
    Tuple[subprocess.CompletedProcess, str]:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`program` 是传递给 `subprocess.run()` 的程序规范"><text text-anchor="start" x="18.5"
    y="-34.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="run(self, inp: str = '''') ->
    Tuple[subprocess.CompletedProcess, str]:'
- en: Run the program with `inp` as input.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inp` 作为输入运行程序。
- en: 'Return test outcome based on result of `subprocess.run()`."><text text-anchor="start"
    x="18.5" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">run()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="run_process(self, inp: str =
    '''') -> subprocess.CompletedProcess:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '根据 `subprocess.run()` 的结果返回测试结果。"><text text-anchor="start" x="18.5" y="-21.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g> <g id="a_node1_3"><a
    xlink:href="#" xlink:title="run_process(self, inp: str = '''') -> subprocess.CompletedProcess:'
- en: Run the program with `inp` as input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `inp` 作为输入运行程序。
- en: 'Return result of `subprocess.run()`."><text text-anchor="start" x="18.5" y="-7.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">run_process()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Runner</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Runner:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '返回 `subprocess.run()` 的结果。"><text text-anchor="start" x="18.5" y="-7.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">run_process()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>运行器</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Runner:'
- en: 'Base class for testing inputs."><text text-anchor="start" x="95.62" y="-199.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">Runner</text> <g id="a_node2_4"><a xlink:href="#" xlink:title="Runner"><g
    id="a_node2_5"><a xlink:href="#" xlink:title="FAIL = ''FAIL''"><text text-anchor="start"
    x="88.5" y="-176" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">FAIL</text></a></g> <g id="a_node2_6"><a xlink:href="#"
    xlink:title="PASS = ''PASS''"><text text-anchor="start" x="88.5" y="-163.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">PASS</text></a></g>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="UNRESOLVED = ''UNRESOLVED''"><text
    text-anchor="start" x="88.5" y="-150.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node2_8"><a xlink:href="#" xlink:title="Runner"><g id="a_node2_9"><a
    xlink:href="#" xlink:title="__init__(self) -> None:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '测试输入的基类。"><text text-anchor="start" x="95.62" y="-199.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">运行者</text>
    <g id="a_node2_4"><a xlink:href="#" xlink:title="运行者"><g id="a_node2_5"><a xlink:href="#"
    xlink:title="FAIL = ''FAIL''"><text text-anchor="start" x="88.5" y="-176" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">FAIL</text></a></g>
    <g id="a_node2_6"><a xlink:href="#" xlink:title="PASS = ''PASS''"><text text-anchor="start"
    x="88.5" y="-163.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">PASS</text></a></g> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="UNRESOLVED = ''UNRESOLVED''"><text text-anchor="start" x="88.5" y="-150.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node2_8"><a xlink:href="#" xlink:title="运行者"><g id="a_node2_9"><a xlink:href="#"
    xlink:title="__init__(self) -> None:'
- en: 'Initialize"><text text-anchor="start" x="88.5" y="-130.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_10"><a xlink:href="#"
    xlink:title="run(self, inp: str) -> Any:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '初始化"><text text-anchor="start" x="88.5" y="-130.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_10"><a xlink:href="#"
    xlink:title="run(self, inp: str) -> Any:'
- en: 'Run the runner with the given input"><text text-anchor="start" x="88.5" y="-118"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>ProgramRunner->Runner</title></g> <g id="node3"
    class="node"><title>PrintRunner</title> <g id="a_node3"><a xlink:href="#" xlink:title="class
    PrintRunner:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '使用给定输入运行运行者"><text text-anchor="start" x="88.5" y="-118" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="edge1" class="edge"><title>程序运行者->运行者</title></g>
    <g id="node3" class="node"><title>打印运行者</title> <g id="a_node3"><a xlink:href="#"
    xlink:title="class 打印运行者:'
- en: 'Simple runner, printing the input."><text text-anchor="start" x="141.25" y="-43.7"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">PrintRunner</text> <g id="a_node3_11"><a xlink:href="#" xlink:title="PrintRunner"><g
    id="a_node3_12"><a xlink:href="#" xlink:title="run(self, inp) -> Any:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '简单的运行者，打印输入。"><text text-anchor="start" x="141.25" y="-43.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">打印运行者</text>
    <g id="a_node3_11"><a xlink:href="#" xlink:title="打印运行者"><g id="a_node3_12"><a
    xlink:href="#" xlink:title="run(self, inp) -> Any:'
- en: Print the given input"><text text-anchor="start" x="164.5" y="-21.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>PrintRunner->Runner</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="243.88"
    y="-52.62" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="243.88" y="-42.62" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="249.88" y="-42.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="243.88" y="-32.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="249.88" y="-32.62" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="243.88" y="-22.62" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="249.88" y="-22.62" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="243.88" y="-13.57" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 打印给定输入"><text text-anchor="start" x="164.5" y="-21.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>PrintRunner->Runner</title></g>
    <g id="node4" class="node"><title>图例</title> <text text-anchor="start" x="243.88"
    y="-52.62" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">图例</text> <text text-anchor="start" x="243.88" y="-42.62" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="249.88" y="-42.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="243.88" y="-32.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="249.88" y="-32.62" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="243.88" y="-22.62" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="249.88" y="-22.62" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="243.88" y="-13.57" font-family="Helvetica,sans-Serif"
    font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: A Testing Assignment
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试作业
- en: Fuzzing was born in a "dark and stormy night in the Fall of 1988" [[Takanen
    *et al*, 2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)].
    Sitting in his apartment in Wisconsin, Madison, professor Barton Miller was connected
    to his university computer via a 1200 baud telephone line. The thunderstorm caused
    noise on the line, and this noise in turn caused the UNIX commands on either end
    to get bad inputs – and crash. The frequent crashes surprised him – surely, programs
    should be more robust than that? As a scientist, he wanted to investigate the
    extent of the problem and its causes. So he crafted a *programming exercise* for
    his students at the University of Wisconsin-Madison – an exercise that would have
    his students create the first fuzzers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试诞生于“1988年秋一个黑暗且暴风雨的夜晚”[[Takanen 等人，2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)]。当时，巴顿·米勒教授坐在威斯康星州麦迪逊的公寓里，通过一条1200波特电话线连接到他的大学电脑。雷暴导致线路产生噪音，而这种噪音反过来又导致两端UNIX命令接收到了错误的输入——从而导致崩溃。频繁的崩溃让他感到惊讶——难道程序应该比这更健壮吗？作为一名科学家，他想要调查问题的范围及其原因。因此，他为威斯康星大学麦迪逊分校的学生们设计了一个*编程练习*——一个让学生们创建第一个模糊测试器的练习。
- en: 'This is how the [assignment](http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf)
    read:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是[作业](http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf)的内容：
- en: The goal of this project is to evaluate the robustness of various UNIX utility
    programs, given an unpredictable input stream. [...] First, you will build a *fuzz
    generator*. This is a program that will output a random character stream. Second,
    you will take the fuzz generator and use it to attack as many UNIX utilities as
    possible, with the goal of trying to break them.
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 本项目的目标是评估各种UNIX实用程序的鲁棒性，给定一个不可预测的输入流。[...] 首先，你将构建一个*模糊生成器*。这是一个会输出随机字符流的程序。其次，你将使用模糊生成器攻击尽可能多的UNIX实用程序，目标是尝试使它们崩溃。
- en: 'This assignment captures the essence of fuzzing: *Create random inputs, and
    see if they break things.* Just let it run long enough, and you''ll see.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这项作业捕捉了模糊测试的精髓：*创建随机输入，看看它们是否会导致系统崩溃。* 只需运行足够长的时间，你就会看到结果。
- en: A Simple Fuzzer
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的模糊器
- en: Let us try to fulfill this assignment and build a fuzz generator. The idea is
    to produce random characters, adding them to a buffer string variable (`out`),
    and finally returning the string.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试完成这个任务并构建一个模糊生成器。想法是产生随机字符，将它们添加到缓冲字符串变量（`out`）中，最后返回字符串。
- en: 'This implementation uses the following Python features and functions:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现使用了以下 Python 特性和函数：
- en: '`random.randrange(start, end)` – return a random number $[$ `start`, `end`
    $)$'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random.randrange(start, end)` – 返回一个随机数 $[$ `start`, `end` $)$'
- en: '`range(start, end)` – create an iterator (which can be used as a list) with
    integers in the range $[$ `start`, `end` $)$.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range(start, end)` – 创建一个整数范围 $[$ `start`, `end` $)$ 的迭代器（可以用作列表）。'
- en: '`for elem in list: body` – execute `body` in a loop with `elem` taking each
    value from `list`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for elem in list: body` – 在循环中执行 `body`，其中 `elem` 从 `list` 中取每个值。'
- en: '`for i in range(start, end): body` – execute `body` in a loop with `i` from
    `start` to `end` $-$ 1.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for i in range(start, end): body` – 在循环中执行 `body`，其中 `i` 从 `start` 到 `end`
    $-$ 1。'
- en: '`chr(n)` – return a character with ASCII code `n`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chr(n)` – 返回 ASCII 码为 `n` 的字符'
- en: To use random numbers, we have to import the respective module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用随机数，我们必须导入相应的模块。
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here comes the actual `fuzzer()` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是实际的 `fuzzer()` 函数。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With its default arguments, the `fuzzer()` function returns a string of random
    characters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认参数，`fuzzer()` 函数返回一个随机字符的字符串：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Bart Miller coined the term "fuzz" as the name for such random, unstructured
    data. Now imagine that this "fuzz" string was the input to a program expecting
    a specific input format – say, a comma-separated list of values, or an e-mail
    address. Would the program be able to process such an input without any problems?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 巴特·米勒（Bart Miller）将“模糊”一词用作此类随机、无结构数据的名称。现在想象一下，这个“模糊”字符串是期望特定输入格式的程序的输入——比如说，逗号分隔的值列表，或者一个电子邮件地址。程序能否无任何问题地处理这种输入？
- en: If the above fuzzing input already is intriguing, consider that fuzzing can
    easily be set up to produce other kinds of input. For instance, we can also have
    `fuzzer()` produce a series of lowercase letters. We use `ord(c)` to return the
    ASCII code of the character `c`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述模糊输入已经很有趣，那么考虑一下，模糊可以轻松地设置来产生其他类型的输入。例如，我们也可以让 `fuzzer()` 产生一系列小写字母。我们使用
    `ord(c)` 来返回字符 `c` 的 ASCII 码。
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Assume a program expects an identifier as its input. Would it expect such a
    long identifier?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个程序期望接收一个标识符作为其输入。它会期望这么长的标识符吗？
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Quiz
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问答
- en: Which of these produces strings with arbitrary long decimal numbers?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个会产生任意长度的十进制数字字符串？
- en: 'Indeed! It is the last one that does the trick:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 的确！最后一个才是关键：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Fuzzing External Programs
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊外部程序
- en: Let us see what happens if we actually invoke an external program with fuzzed
    inputs. To this end, let us proceed in two steps. First, we create an *input file*
    with fuzzed test data; then we feed this input file into a program of choice.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们实际使用模糊输入调用外部程序会发生什么。为此，让我们分两步进行。首先，我们创建一个带有模糊测试数据的 *输入文件*；然后我们将这个输入文件喂给一个选择好的程序。
- en: Creating Input Files
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建输入文件
- en: Let us obtain a temporary file name such that we do not clutter the file system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取一个临时文件名，这样我们就不至于使文件系统变得杂乱。
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now open this file for writing. The Python `open()` function opens a
    file into which we can then write arbitrary contents. It is commonly used in conjunction
    with the `with` statement, which ensures that the file is closed as soon as it
    is no longer needed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以打开这个文件进行写入。Python 的 `open()` 函数打开一个文件，然后我们可以向其中写入任意内容。它通常与 `with` 语句一起使用，这确保了文件在不再需要时立即关闭。
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can verify that the file was actually created by reading its contents:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过读取其内容来验证文件是否实际创建：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Invoking External Programs
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用外部程序
- en: Now that we have an input file, we can invoke a program on it. For the fun of
    it, let us test the `bc` calculator program, which takes an arithmetic expression
    and evaluates it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了输入文件，我们可以在其上调用一个程序。为了好玩，让我们测试 `bc` 计算器程序，它接受一个算术表达式并对其进行评估。
- en: 'To invoke `bc`, let us use the Python `subprocess` module. This is how this
    works:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `bc`，让我们使用 Python 的 `subprocess` 模块。这是如何工作的：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From the `result`, we can check the program output. In the case of `bc`, this
    is the result of evaluating the arithmetic expression:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `result` 中，我们可以检查程序输出。在 `bc` 的情况下，这是评估算术表达式的结果：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can also check the status. A value of 0 indicates that the program terminated
    correctly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查状态。值为 0 表示程序正确终止。
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Any error messages would be available in `results.stderr`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误信息都会在 `results.stderr` 中可用：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Instead of `bc`, you can actually put in any program you like. Be aware, though,
    that if your program is able to change or even damage your system, there is quite
    a risk that the fuzzed input contains data or commands that do precisely this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用 `bc` 之外的任何你喜欢的程序。不过，请注意，如果你的程序能够更改或甚至损坏你的系统，那么模糊输入中包含的数据或命令可能会恰好做到这一点。
- en: Quiz
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问答
- en: Just for the fun of it, imagine you would test a file removal program - say
    `rm -fr FILE`, where `FILE` is a string produced by `fuzzer()`. What is the chance
    of `fuzzer()` (with default arguments) producing a `FILE` argument that results
    in deleting all your files?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就为了好玩，想象一下你会测试一个文件删除程序——比如说 `rm -fr FILE`，其中 `FILE` 是由 `fuzzer()` 生成的字符串。`fuzzer()`（使用默认参数）产生一个导致删除所有文件的
    `FILE` 参数的概率是多少？
- en: The chance is actually higher than you may think. If you remove `/` (the root
    of all files), for instance, your entire file system will be gone. If you remove
    `.` (the current folder), all the files in the current directory will be gone.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上的概率可能比你想象的要高。例如，如果你删除了 `/`（所有文件的根），那么你的整个文件系统都将消失。如果你删除了 `.`（当前文件夹），当前目录中的所有文件都将消失。
- en: The probability of generating a string that is exactly 1 character long is 1/101,
    this is because the length of the string is determined by calling random.randrange(0,
    max_length + 1), where the default value of max_length is 100\. Per the description
    given of random.randrange, that should return a random number in [0, 99 + 1).
    So, we end up with the inclusive range [0, 100] where there are 101 values in
    the interval.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个正好 1 个字符长的字符串的概率是 1/101，这是因为字符串的长度是通过调用 random.randrange(0, max_length +
    1) 来确定的，其中 max_length 的默认值是 100。根据 random.randrange 的描述，它应该返回一个在 [0, 99 + 1) 区间内的随机数。因此，我们最终得到一个包含
    101 个值的区间 [0, 100]。
- en: 'For `/` or `.` to be produced, you need a string length of 1 (chance: 1 out
    of 101) and one of these two characters (chance: 2 out of 32).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 `/` 或 `.`，你需要一个长度为 1 的字符串（概率：101 分之一）和这两个字符之一（概率：32 分之二）。
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The above code block precludes the possibility of removing `~` (your home directory),
    this is because the probability of generating the character '~' is not 1/32; it
    is 0/32\. The characters are created by calling chr(random.randrange(char_start,
    char_start + char_range)), where the default value of char_start is 32 and the
    default value of char_range is 32\. The documentation for chr reads, "[r]eturn
    the string representing a character whose Unicode code point is the integer i."
    The Unicode code point for '~' is 126 and therefore, not in the interval [32,
    64).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块排除了删除 `~`（你的主目录）的可能性，这是因为生成字符 '~' 的概率不是 1/32；它是 0/32。字符是通过调用 chr(random.randrange(char_start,
    char_start + char_range)) 生成的，其中 char_start 的默认值是 32，char_range 的默认值也是 32。chr
    的文档说明，“[r]eturn the string representing a character whose Unicode code point is
    the integer i。” '~' 的 Unicode 代码点是 126，因此不在区间 [32, 64) 内。
- en: If the code were to be changed so that char_range = 95 then the probability
    of obtaining the character '~' would be 1/94 , thus resulting in the probability
    of the event of deleting all files being equal to 0.000332
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码被修改为 char_range = 95，那么获得字符 '~' 的概率将是 1/94，因此删除所有文件的事件的概率等于 0.000332。
- en: And all your files in the home directory will be gone
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你主目录中的所有文件都将消失。
- en: '[PRE34]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, we can actually deal with any string as long as the *second* character
    is a space – after all, `rm -fr / WHATEVER` will first deal with `/`, and only
    then with whatever follows. The chances for the first character are 2 out of 32
    as the code block above only allows for the probability of obtaining a `/` or
    a `.` but not a `~`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只要第二个字符是空格，我们实际上可以处理任何字符串——毕竟，`rm -fr / WHATEVER` 将首先处理 `/`，然后才是随后的任何内容。第一个字符的概率是
    32 分之二，因为上面的代码块只允许获得 `/` 或 `.` 的概率，但不允许获得 `~`。
- en: For the space the probability is 1 out of 32.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于空格，概率是 32 分之一。
- en: We have to include the term for the probability of obtaining at least 2 characters
    which is required for the scenario of obtaining a space as the second character.
    This probability is 99/101 because it is calculated as (1 - probability of obtaining
    a single character or no character at all), so it is equal to 1-(2/101).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须包括获得至少 2 个字符的概率项，这是在获得空格作为第二个字符的场景中所需的。这个概率是 99/101，因为它被计算为（1 - 获得单个字符或没有任何字符的概率），因此等于
    1-(2/101)。
- en: 'Therefore, the probability calculation for the event of deleting all files
    in the case of having a space for the second character is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在第二个字符有空间的情况下，删除所有文件的概率计算如下：
- en: '[probability of obtaining ''/'' or ''. '' followed by a space] = [the probability
    of obtaining either the ''/'' character or the ''. '' character] *[the probability
    of obtaining space]* [Probability of getting at least 2 characters] = 0.001914'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[获取''/''或''. ''后跟空格的概率] = [获取''/''字符或''. ''字符的概率] * [获取空格的概率] * [获取至少2个字符的概率]
    = 0.001914'
- en: Diagram of probability of obtaining at least 2 characters.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 获取至少2个字符的概率图。
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Given that fuzz tests are typically run millions of times, you really don't
    want to take this risk. Run your fuzzers in a safe environment that you can reset
    at will, such as a Docker container.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模糊测试通常运行数百万次，你真的不希望承担这种风险。请在可以随时重置的安全环境中运行你的模糊器，例如Docker容器。
- en: Long-Running Fuzzing
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长时间模糊测试
- en: 'Let us now feed a large number of inputs into our tested program, to see whether
    it might crash on some. We store all results in the `runs` variable as pairs of
    input data and the actual result. (Note: running this may take a while.)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在向经过测试的程序输入大量输入，看看它是否会在某些输入上崩溃。我们将所有结果存储在`runs`变量中，作为输入数据和实际结果的配对。（注意：运行此操作可能需要一段时间。）
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can now query `runs` for some statistics. For instance, we can query how
    many runs actually passed -- that is, there were no error messages. We use a *list
    comprehension* here: The form *expression* `for` *element* `in` *list* `if` *condition*
    returns a list of evaluated *expressions* in which each *element* comes from *list*
    if the *condition* was true. (Actually, a list comprehension returns a *list generator*,
    but for our purposes, the generator behaves like a list.) Here, we have the *expression*
    be 1 for all elements where *condition* holds, and we use `sum()` to sum over
    all elements in the list.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查询`runs`以获取一些统计数据。例如，我们可以查询实际通过多少次运行——也就是说，没有错误消息。这里我们使用*列表推导*：形式为*expression*
    `for` *element* `in` *list* `if` *condition*的列表推导返回一个评估后的*expression*列表，其中每个*element*如果条件为真则来自*list*。实际上，列表推导返回一个*列表生成器*，但就我们的目的而言，生成器表现得像列表。这里，我们让*expression*对所有满足条件的元素为1，并使用`sum()`对列表中的所有元素进行求和。
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Most inputs apparently are invalid – not a big surprise, as it is unlikely that
    a random input contains a valid arithmetic expression.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数输入显然是无效的——这并不令人惊讶，因为随机输入包含有效算术表达式的可能性不大。
- en: 'Let us take a look at the first error message:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一条错误消息：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Are there any runs with messages other than `illegal character`, `parse error`,
    or `syntax error`? (Say, something like `crash` or `you found a fatal bug`?) Not
    very many:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有除了`非法字符`、`解析错误`或`语法错误`之外的消息的运行？（比如`崩溃`或`你发现了一个致命的错误`？）并不多：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Maybe a crash would be indicated by `bc` just crashing. Unfortunately, the
    return code is never nonzero:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 也许`bc`崩溃就能表明崩溃。不幸的是，返回代码永远不会是非零值：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How about we let the above `bc` test run for some more? While it is running,
    let us take a look on how the state of the art was in 1989.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让上面的`bc`测试再运行一段时间怎么样？当它运行时，让我们看看1989年的技术水平。
- en: Bugs Fuzzers Find
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊器发现的错误
- en: 'When Miller and his students ran their first fuzzers in 1989, they found an
    alarming result: About **a third of the UNIX utilities** they fuzzed had issues
    – they crashed, hung, or otherwise failed when confronted with fuzzing input [[Miller
    *et al*, 1990](https://doi.org/10.1145/96267.96279)]. This also included the `bc`
    program, above. (The `bc` above is a [modern reimplementation](https://git.gavinhoward.com/gavin/bc)
    whose author is a [staunch believer in fuzzing](https://git.gavinhoward.com/gavin/bc/src/branch/master/tests/fuzzing)!)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当米勒和他的学生在1989年运行他们的第一个模糊器时，他们发现了一个令人震惊的结果：他们模糊测试的约**三分之一**的UNIX实用程序存在问题——它们在遇到模糊测试输入时崩溃、挂起或以其他方式失败[[Miller
    *et al*, 1990](https://doi.org/10.1145/96267.96279)]。这还包括上面的`bc`程序。（上面的`bc`是一个[现代重实现](https://git.gavinhoward.com/gavin/bc)，其作者是一位[坚定的模糊测试信仰者](https://git.gavinhoward.com/gavin/bc/src/branch/master/tests/fuzzing)！）
- en: Considering that many of these UNIX utilities were used in scripts that would
    also process network input, this was an alarming result. Programmers quickly built
    and ran their own fuzzers, rushed to fix the reported errors, and learned not
    to trust external inputs anymore.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到许多这些UNIX实用程序被用于也会处理网络输入的脚本中，这是一个令人担忧的结果。程序员迅速构建并运行了自己的模糊器，急忙修复报告的错误，并学会了不再信任外部输入。
- en: What kind of problems did Miller's fuzzing experiment find? It turns out that
    the mistakes programmers made in 1990 are still the same mistakes being made today.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 米勒的模糊实验发现了什么样的问题？结果是，程序员在1990年犯的错误今天仍在犯。
- en: Buffer Overflows
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区溢出
- en: 'Many programs have built-in maximum lengths for inputs and input elements.
    In languages like C, it is easy to excess these lengths without the program (or
    the programmer) even noticing, triggering so-called **buffer overflows**. The
    following code, for instance, happily copies the `input` string into a `weekday`
    string even if `input` has more than eight characters:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序为输入和输入元素内置了最大长度。在C语言等语言中，很容易超出这些长度，而程序（或程序员）甚至没有注意到，从而触发所谓的**缓冲区溢出**。例如，以下代码会愉快地将`input`字符串复制到`weekday`字符串中，即使`input`有超过八个字符：
- en: '[PRE47]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Ironically, this already fails if `input` is `"Wednesday"` (9 characters); any
    excess characters (here, `'y'` and the following `'\0'` string terminator) are
    simply copied to whatever resides in memory after `weekday`, triggering arbitrary
    behavior; maybe some boolean character variable which would be set from `'n'`
    to `'y'`. With fuzzing, it is very easy to produce arbitrary long inputs and input
    elements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，如果`input`是`"Wednesday"`（9个字符），这已经失败了；任何多余的字符（在这里是`'y'`和随后的字符串终止符`'\0'`）都会简单地复制到`weekday`之后的内存中，从而触发任意行为；也许是一些布尔字符变量，它会被从`'n'`设置为`'y'`。使用模糊测试，很容易产生任意长度的输入和输入元素。
- en: 'We can easily simulate this buffer overflow behavior in a Python function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地在Python函数中模拟这种缓冲区溢出行为：
- en: '[PRE48]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: And yes, it quickly crashes.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，它很快就崩溃了。
- en: '[PRE49]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `with ExpectError()` line in the above code ensures that the error message
    is printed, yet execution continues; this is to differentiate this "expected"
    error from "unexpected" errors in other code examples.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`with ExpectError()`行确保打印错误信息，但执行继续；这是为了将这种“预期”错误与其他代码示例中的“意外”错误区分开来。
- en: Missing Error Checks
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缺少错误检查
- en: 'Many programming languages do not have exceptions, but instead have functions
    return special **error codes** in exceptional circumstances. The C function `getchar()`,
    for instance, normally returns a character from the standard input; if no input
    is available anymore, it returns the special value `EOF` (end of file). Now assume
    a programmer is scanning the input for the next character, reading in characters
    with `getchar()` until a space character is read:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多编程语言没有异常，而是在异常情况下通过函数返回特殊的**错误代码**。例如，C函数`getchar()`通常从标准输入返回一个字符；如果没有更多的输入，它返回特殊值`EOF`（文件结束）。现在假设程序员正在扫描输入以查找下一个字符，使用`getchar()`读取字符，直到读取到空格字符：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What happens if the input ends prematurely, as would perfectly be feasible with
    fuzzing? Well, `getchar()` returns `EOF`, and keeps on returning `EOF` when called
    again; so the code above simply enters an infinite loop.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入提前结束，这在模糊测试中是完全可行的，会发生什么？嗯，`getchar()`返回`EOF`，并且在再次调用时继续返回`EOF`；因此，上述代码简单地进入了一个无限循环。
- en: 'Again, we can simulate such missing error checks. Here''s a function that will
    effectively hang if no space is present in the input:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以模拟这种缺少错误检查。以下是一个函数，如果没有空格出现在输入中，它将有效地挂起：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the timeout mechanism from our [Introduction to Testing](Intro_Testing.html),
    we can interrupt this function after some time. And yes, it does hang after a
    few fuzzing inputs.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们[测试介绍](Intro_Testing.html)中的超时机制，我们可以在一段时间后中断此函数。是的，它会在几次模糊测试输入后挂起。
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `with ExpectTimeout()` line in the above code ensures that execution of
    the enclosed code is interrupted after two seconds, printing the error message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`with ExpectTimeout()`行确保在两秒后中断封装代码的执行，并打印错误信息。
- en: Rogue Numbers
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 恶意数字
- en: 'With fuzzing, it is easy to generate **uncommon values** in the input, causing
    all kinds of interesting behavior. Consider the following code, again in the C
    language, which first reads a buffer size from the input, and then allocates a
    buffer of the given size:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模糊测试，很容易在输入中生成**不常见的值**，导致各种有趣的行为。考虑以下代码，再次在C语言中，它首先从输入中读取缓冲区大小，然后分配给定大小的缓冲区：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: What happens if `size` is very large, exceeding program memory? What happens
    if `size` is less than the number of characters following? What happens if `size`
    is negative? By providing a random number here, fuzzing can create all kinds of
    damages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`size`非常大，超过了程序内存，会发生什么？如果`size`小于后续字符的数量，会发生什么？如果`size`是负数，会发生什么？通过在这里提供一个随机数，模糊测试可以造成各种损害。
- en: Again, we can easily simulate such rogue numbers in Python. The function `collapse_if_too_large()`
    fails if the passed value (a string) is too large after having been converted
    to an integer.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以很容易地在Python中模拟这种恶意数字。函数`collapse_if_too_large()`如果传递的值（一个字符串）在转换为整数后太大，就会失败。
- en: '[PRE58]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can have `fuzzer()` create a string of digits:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让`fuzzer()`创建一个数字字符串：
- en: '[PRE59]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we feed such numbers into `collapse_if_too_large()`, it will very soon fail.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这样的数字输入到`collapse_if_too_large()`中，它很快就会失败。
- en: '[PRE61]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If we really wanted to allocate that much memory on a system, having it quickly
    fail as above actually would be the better option. In reality, running out of
    memory may dramatically slow systems down, up to the point that they become totally
    unresponsive – and restarting is the only option.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想在系统上分配这么多内存，那么像上面那样快速失败实际上是一个更好的选择。在现实中，内存耗尽可能会极大地减慢系统的速度，甚至到它们完全无响应的程度——而重启是唯一的选择。
- en: One might argue that these are all problems of bad programming, or of bad programming
    languages. But then, there are thousands of people starting to program every day,
    and all of them make the same mistakes again and again, even today.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会认为这些都是编程不良或编程语言不良的问题。但是，每天都有成千上万的人开始编程，他们一次又一次地犯同样的错误，即使是在今天。
- en: Catching Errors
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕捉错误
- en: When Miller and his students built their first fuzzer, they could identify errors
    simply because the program would crash or hang – two conditions that are easy
    to identify. If the failures are more subtle, though, we need to come up with
    additional checks.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当Miller和他的学生们构建他们的第一个模糊测试器时，他们可以简单地通过程序崩溃或挂起来识别错误——这两种情况都很容易识别。但如果失败更加微妙，我们就需要想出额外的检查方法。
- en: Generic Checkers
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用检查器
- en: 'Buffer overflows, as [discussed above](#Buffer-Overflows), are a particular
    instance of a more general problem: In languages like C and C++, a program can
    access arbitrary parts of its memory – even those parts that are uninitialized,
    already freed or simply not part of the data structure you are trying to access.
    This is necessary if you want to write an operating system, and great if you want
    a maximum of performance or control, but pretty bad if you want to avoid mistakes.
    Fortunately, there are tools that help catching such issues at runtime, and they
    are great when combined with fuzzing.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如[上文所述](#Buffer-Overflows)，缓冲区溢出是更一般问题的一个特例：在C和C++等语言中，程序可以访问其内存的任意部分——甚至包括那些未初始化、已释放或根本不属于你试图访问的数据结构的部分。如果你想要编写操作系统，这可能是必要的；如果你想要最大化的性能或控制，这将是很好的；但如果你想要避免错误，这将是相当糟糕的。幸运的是，有一些工具可以帮助在运行时捕捉这类问题，而且当与模糊测试结合使用时，它们是非常棒的。
- en: Checking Memory Accesses
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查内存访问
- en: To catch problematic memory accesses during testing, one can run C programs
    in special *memory-checking* environments; at runtime, these check for each and
    every memory operation whether it accesses valid and initialized memory. A popular
    example is [LLVM Address Sanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)
    which detects a whole set of potentially dangerous memory safety violations. In
    the following example we will compile a rather simple C program with this tool
    and provoke an out-of-bounds read by reading past an allocated portion of memory.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在测试中捕捉到有问题的内存访问，可以在特殊的*内存检查*环境中运行C程序；在运行时，这些环境会检查每个内存操作是否访问了有效的已初始化内存。一个流行的例子是[LLVM
    Address Sanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)，它可以检测一系列潜在的内存安全违规。在下面的例子中，我们将使用这个工具编译一个相当简单的C程序，并通过读取已分配内存部分之外的数据来引发越界读取。
- en: '[PRE63]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We compile this C program with address sanitization enabled:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启用地址清理功能来编译这个C程序：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we run the program with an argument of `99`, it returns `buf[99]`, which
    is 42.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用`99`作为参数运行程序，它将返回`buf[99]`，其值为42。
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Accessing `buf[110]`, however, results in an out-of-bounds error in AddressSanitizer.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，访问`buf[110]`在AddressSanitizer中会导致越界错误。
- en: '[PRE70]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you want to find errors in a C program, turning on such checks for fuzzing
    is fairly easy. It will slow down execution by a certain factor depending on the
    tool (for AddressSanitizer it is typically 2$\times$) and also consume more memory,
    but CPU cycles are dead cheap compared to the human effort it takes to find these
    bugs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在C程序中找到错误，开启模糊测试的这些检查相对容易。这将根据工具的不同而减慢执行速度（对于AddressSanitizer来说，通常是2倍）并消耗更多的内存，但与找到这些错误所需的人力相比，CPU周期是非常便宜的。
- en: Out-of-bounds accesses to memory are a great security risk, as they may let
    attackers access or even modify information that is not meant for them. As a famous
    example, the [HeartBleed bug](https://en.wikipedia.org/wiki/Heartbleed) was a
    security bug in the OpenSSL library, implementing cryptographic protocols that
    provide communications security over a computer network. (If you read this text
    in a browser, it is likely encrypted using these protocols.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 越界访问内存是一个巨大的安全风险，因为它们可能让攻击者访问或甚至修改本不应该被他们访问的信息。以一个著名的例子，[HeartBleed漏洞](https://en.wikipedia.org/wiki/Heartbleed)是OpenSSL库中的一个安全漏洞，该库实现了提供计算机网络上通信安全的加密协议。（如果你在浏览器中阅读这篇文章，它很可能是使用这些协议加密的。）
- en: The HeartBleed bug was exploited by sending a specially crafted command to the
    SSL *heartbeat* service. A heartbeat service is used to check if the server on
    the other end is still alive. A client would send the service a string like
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: HeartBleed漏洞是通过向SSL *心跳*服务发送一个特别定制的命令而被利用的。心跳服务用于检查另一端的服务器是否仍然存活。客户端会向服务发送一个类似
- en: '[PRE72]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: to which the server would reply with `BIRD`, and the client would know the server
    is alive.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器会回复`BIRD`，客户端就会知道服务器是活着的。
- en: 'Unfortunately, this service could be exploited by asking the server to reply
    with *more* than the requested set of letters. This is very well explained in
    this [XKCD comic](https://xkcd.com/1354/):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个服务可以通过要求服务器回复比请求的字母集更多的内容来被利用。这一点在这[XKCD漫画](https://xkcd.com/1354/)中解释得很好：
- en: '![XKCD Comic](../Images/6b6685cb7a4fd6e38881d177a59f4484.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![XKCD漫画](../Images/6b6685cb7a4fd6e38881d177a59f4484.png)'
- en: '![XKCD Comic](../Images/4be606ce2f1ba917b9f5b31d3c40a689.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![XKCD漫画](../Images/4be606ce2f1ba917b9f5b31d3c40a689.png)'
- en: '![XKCD Comic](../Images/62570bd228b59b31a896243c80a46f78.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![XKCD漫画](../Images/62570bd228b59b31a896243c80a46f78.png)'
- en: In the OpenSSL implementation, these memory contents could involve cryptographic
    certificates, private keys, and more – and worse, no one would notice that this
    memory just had been accessed. When the HeartBleed bug was discovered, it had
    been around for many years, and none would know whether and which secrets had
    already leaked; the quickly set up [HeartBleed announcement page](http://heartbleed.com/)
    said it all.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenSSL实现中，这些内存内容可能包括加密证书、私钥等等——更糟糕的是，没有人会注意到这些内存刚刚被访问过。当HeartBleed漏洞被发现时，它已经存在了多年，没有人会知道是否以及哪些秘密已经泄露；快速建立的[HeartBleed公告页面](http://heartbleed.com/)说了这一切。
- en: But how was HeartBleed discovered? Very simple. Researchers both at the Codenomicon
    company as well as with Google compiled the OpenSSL library with a memory sanitizer,
    and then happily flooded it with fuzzed commands. The memory sanitizer would then
    notice whether an out-of-bounds memory access had occurred – and actually, it
    would very quickly discover this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但HeartBleed是如何被发现的呢？非常简单。Codenomicon公司和谷歌的研究人员都使用内存清理器编译了OpenSSL库，然后愉快地向它发送了模糊命令。内存清理器会注意到是否发生了越界内存访问——实际上，它会非常快地发现这一点。
- en: A memory checker is just one of many checkers one can run to detect runtime
    errors during fuzzing. In the [chapter on mining function specifications](DynamicInvariants.html),
    we will learn more about how to define generic checkers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 内存检查器只是可以在模糊测试期间运行的许多检查器之一。在[关于挖掘函数规范的章节](DynamicInvariants.html)中，我们将学习更多关于如何定义通用检查器的方法。
- en: 'We''re done with `program`, so we clean up:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`program`，所以我们需要清理：
- en: '[PRE73]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Information Leaks
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 信息泄露
- en: 'Information leaks may not only occur through illegal memory accesses; they
    can also occur within "valid" memory – if this "valid" memory contains sensitive
    information that should not leak out. Let us illustrate this issue in a Python
    program. To start with, let us create some program memory filled with actual data
    and random data:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 信息泄露不仅可能通过非法内存访问发生；它们也可能在“有效”内存中发生——如果这个“有效”内存包含敏感信息，这些信息不应该泄露出去。让我们用一个Python程序来阐述这个问题。首先，让我们创建一些填充了实际数据和随机数据的程序内存：
- en: '[PRE74]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We add more "memory" characters to `secrets`, filled with `"deadbeef"` as marker
    for uninitialized memory:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`secrets`中添加更多的“记忆”字符，用`"deadbeef"`作为未初始化内存的标记：
- en: '[PRE75]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We define a service (similar to the heartbeat service discussed above) that
    would take a reply to be sent back, as well as a length. It would store the reply
    to be sent in memory, and then send it back with the given length.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个服务（类似于上面讨论的心跳服务），它会接收一个要发送回的回复以及一个长度。它会将待发送的回复存储在内存中，然后以给定的长度发送它回。
- en: '[PRE76]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This perfectly works for standard strings:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于标准字符串工作得很好：
- en: '[PRE77]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'However, if the length is greater than the length of the reply string, additional
    contents of memory spill out. Note that all of this still occurs within regular
    array bounds, so an address sanitizer would not be triggered:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果长度大于回复字符串的长度，内存的额外内容就会溢出。请注意，所有这些仍然发生在常规数组边界内，因此地址清理器不会被触发：
- en: '[PRE81]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'How can one detect such issues? The idea is to identify information that should
    not leak out, such as the given secrets, but also uninitialized memory. We can
    simulate such a check in a small Python example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如何检测这类问题？思路是识别那些不应该泄露的信息，例如给定的秘密，以及未初始化的内存。我们可以在一个小的Python示例中模拟这样的检查：
- en: '[PRE83]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: With such a check, we find that secrets and/or uninitialized memory indeed leak
    out. In the [chapter on information flow](InformationFlow.html), we will discuss
    how to do this automatically, "tainting" sensitive information and values derived
    from them, and ensuring that "tainted" values do not leak out.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的检查，我们发现秘密和/或未初始化的内存确实泄露了。在[信息流章节](InformationFlow.html)中，我们将讨论如何自动执行此操作，“污染”敏感信息和从它们派生出的值，并确保“污染”的值不会泄露。
- en: As a rule of thumb, you should always *enable as many automatic checkers as
    possible* during fuzzing. CPU cycles are cheap, and errors are expensive. If you
    only execute the program without an option to actually detect errors, you will
    be missing several opportunities.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，你应该在模糊测试期间尽可能*启用尽可能多的自动检查器*。CPU周期很便宜，而错误很昂贵。如果你只执行程序而没有实际检测错误的选项，你将错过几个机会。
- en: Program-Specific Checkers
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 程序特定检查器
- en: Besides generic checkers that apply to *all* programs on a given platform or
    in a given language, you can also devise *specific* checkers that apply to your
    program, or a subsystem. In the [chapter on testing](Intro_Testing.html), we already
    have hinted at techniques of [runtime verification](Intro_Testing.html#Runtime-Verification)
    that check function results at runtime for correctness.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了适用于给定平台或给定语言的*所有*程序的通用检查器之外，你还可以设计*特定*的检查器，适用于你的程序或子系统。在[测试章节](Intro_Testing.html)中，我们已暗示了[运行时验证](Intro_Testing.html#Runtime-Verification)的技术，这些技术会在运行时检查函数结果是否正确。
- en: One key idea for detecting errors early is the concept of *assertion* – a predicate
    that checks the input (precondition) and the result (postcondition) of important
    functions. The more assertions you have in your program, the higher your chances
    to detect errors during execution that would go undetected by generic checkers
    – notably during fuzzing. If you worry about the impact of assertions on performance,
    keep in mind that assertions can be turned off in production code (although it
    can be helpful to leave the most critical checks active).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 检测错误的一个关键思想是*断言*的概念——一个检查重要函数的输入（先决条件）和结果（后置条件）的谓词。你程序中的断言越多，你在执行过程中检测到错误的几率就越高，这些错误在通用的检查器中可能无法检测到——尤其是在模糊测试期间。如果你担心断言对性能的影响，请记住，在生产代码中可以关闭断言（尽管保持最关键的检查激活可能是有帮助的）。
- en: One of the most important uses of assertions for finding errors is *checking
    the integrity of complex data structures.* Let us illustrate the concept using
    a simple example. Suppose we have a mapping of airport codes to airports, as in
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 断言在查找错误中的一个最重要的用途是*检查复杂数据结构的完整性*。让我们用一个简单的例子来说明这个概念。假设我们有一个机场代码到机场的映射，如下所示
- en: '[PRE86]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This list of airport codes may be pretty critical: if we have a spelling mistake
    in any of the airport codes, this may impact whatever application we have. We
    therefore introduce a function that checks the list for consistency. The consistency
    condition is called a *representation invariant*, and functions (or methods) that
    check it are therefore typically named `repOK()` for "the representation is ok".'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机场代码列表可能非常重要：如果我们任何一个机场代码中存在拼写错误，这可能会影响我们拥有的任何应用程序。因此，我们引入了一个检查列表一致性的函数。一致性条件被称为*表示不变性*，因此检查它的函数（或方法）通常命名为`repOK()`，表示“表示是正确的”。
- en: First, let's have a checker for individual airport codes. The checker fails
    if the code is inconsistent.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们有一个用于单个机场代码的检查器。如果代码不一致，检查器就会失败。
- en: '[PRE91]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can now use `code_repOK()` to check all elements in the list:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`code_repOK()`来检查列表中的所有元素：
- en: '[PRE93]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we add an invalid element to the list, our check would fail:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向列表中添加一个无效元素，我们的检查就会失败：
- en: '[PRE95]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Of course, rather than manipulating the list directly, we''d have a special
    function for adding elements; this could then also check whether the code is valid:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不会直接操作列表，而会有一个特殊的函数来添加元素；这可以检查代码是否有效：
- en: '[PRE98]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This check also allows us to find out errors in argument lists:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查还允许我们找出参数列表中的错误：
- en: '[PRE100]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: For maximum checking, though, the `add_new_airport()` function would also ensure
    the correct representation of the list of airport codes – *before* and *after*
    changing it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了进行最大限度的检查，`add_new_airport()` 函数还会确保在更改之前和之后机场代码列表的正确表示。
- en: '[PRE102]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This catches the inconsistency introduced earlier:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这捕捉了之前引入的不一致性：
- en: '[PRE103]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The more `repOK()` assertions exist in your code, the more errors you will catch
    – even those specific to only your domain and problem. On top, such assertions
    document the *assumptions you made* during programming and thus help other programmers
    to understand your code and prevent errors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码中存在的 `repOK()` 断言越多，你将捕获的错误就越多——甚至那些仅针对你自己的领域和问题的错误。此外，这样的断言记录了你在编程过程中做出的
    *假设*，因此有助于其他程序员理解你的代码并防止错误。
- en: 'As a final example, let us consider a rather complex data structure – a [red-black
    tree](https://en.wikipedia.org/wiki/Red-black_tree), a self-balancing binary search
    tree. Implementing a red-black tree is not too hard, but getting it correct can
    be a task of several hours even for experienced programmers. A `repOK()` method,
    however, documents all the assumptions and checks them as well:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的例子，让我们考虑一个相当复杂的数据结构——一个 [红黑树](https://en.wikipedia.org/wiki/Red-black_tree)，一个自平衡的二叉搜索树。实现红黑树并不太难，但即使是经验丰富的程序员，正确实现它也可能需要几个小时。然而，`repOK()`
    方法记录了所有的假设，并对其进行检查：
- en: '[PRE105]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, `repOK()` is a method that runs on an object of the `RedBlackTree` class.
    It runs five different checks, all of which have their own assertions. Whenever
    an element is added or deleted, all these consistency checks are run automatically.
    If you have an error in any of these, the checkers will find them – if you run
    the tree through sufficiently many fuzzed inputs, of course.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`repOK()` 是在 `RedBlackTree` 类的对象上运行的方法。它运行五个不同的检查，所有这些检查都有自己的断言。每当添加或删除元素时，都会自动运行所有这些一致性检查。如果你在这些检查中存在错误，检查器会发现它们——当然，如果你通过足够多的模糊输入运行树的话。
- en: Static Code Checkers
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态代码检查器
- en: 'Many of the benefits from `repOK()` assertions can also be obtained by using
    *static type checkers* on your code. In Python, for instance, the [MyPy](http://mypy-lang.org)
    static checker can find type errors as soon as types of arguments are properly
    declared:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 许多从 `repOK()` 断言中获得的益处也可以通过在你的代码上使用 *静态类型检查器* 来获得。例如，在 Python 中，[MyPy](http://mypy-lang.org)
    静态检查器可以在正确声明参数类型后立即找到类型错误：
- en: '[PRE106]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If we now add a key with a non-string type, as in
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在添加一个非字符串类型的键，就像
- en: '[PRE107]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'this would be caught by MyPy immediately:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这会被 MyPy 立即捕获：
- en: '[PRE108]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Statically checking more advanced properties such as the airport code consisting
    of exactly three uppercase characters or a tree being acyclic, however, quickly
    reach the limits of static checking. Your `repOK()` assertions will still be needed
    – best in conjunction with a good test generator.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，静态检查更高级的特性，如由恰好三个大写字母组成的机场代码或一个无环树，很快就会达到静态检查的极限。你的 `repOK()` 断言仍然需要——最好与一个好的测试生成器结合使用。
- en: A Fuzzing Architecture
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试架构
- en: Since we'd like to reuse some parts of this chapter in the following ones, let
    us define things in a way that are easier to reuse, and in particular easier to
    *extend*. To this end, we introduce a number of *classes* that encapsulate the
    functionality above in a reusable way.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在下文中重用本章的一些部分，让我们以更容易重用的方式定义事物，特别是更容易 *扩展* 的方式。为此，我们引入了一系列 *类*，以可重用的方式封装了上述功能。
- en: Runner Classes
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行器类
- en: The first thing we introduce is the notion of a `Runner` – that is, an object
    whose job it is to execute some object with a given input. A runner typically
    is some program or function under test, but we can also have simpler runners.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先引入的是 `Runner` 的概念——即一个执行具有给定输入的某个对象的对象。一个运行者通常是一些程序或正在测试的函数，但我们也可以有更简单的运行者。
- en: 'Let us start with a base class for runners. A runner essentially provides a
    method `run(input)` that is used to pass `input` (a string) to the runner. `run()`
    returns a pair (`result`, `outcome`). Here, `result` is a runner-specific value
    that gives details on the run; `outcome` is a value that classifies the result
    in three categories:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行器的基础类开始。运行器本质上提供了一个 `run(input)` 方法，用于将 `input`（一个字符串）传递给运行器。`run()` 返回一个对（`result`，`outcome`）。在这里，`result`
    是运行器特定的值，它提供了关于运行的详细信息；`outcome` 是一个值，将结果分类为三个类别：
- en: '`Runner.PASS` – the test *passed*. The run produced correct results.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runner.PASS` – 测试 *通过*。运行产生了正确的结果。'
- en: '`Runner.FAIL` – the test *failed*. The run produced incorrect results.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runner.FAIL` – 测试 *失败*。运行产生了错误的结果。'
- en: '`Runner.UNRESOLVED` – the test neither passed nor failed. This happens if the
    run could not take place – for instance, because the input was invalid.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runner.UNRESOLVED` – 测试既未通过也未失败。如果运行无法进行——例如，因为输入无效，这种情况就会发生。'
- en: '[PRE109]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As a base class, `Runner` merely provides an interface for more complex runners
    that build on it. More specifically, we introduce *subclasses* that *inherit*
    the methods from their superclass in order to add additional methods or to override
    inherited methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基类，`Runner` 仅提供对更复杂运行器的接口，这些运行器基于它构建。更具体地说，我们引入 *子类*，它们 *继承* 自其超类以添加额外的方法或覆盖继承的方法。
- en: 'Here is one example of such a subclass: `PrintRunner` simply prints out everything
    that is given to it, overriding the inherited `run()` method. This is the default
    runner in many situations.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个这样的子类的例子：`PrintRunner` 简单地打印出它所接受的一切，覆盖了继承的 `run()` 方法。这在许多情况下是默认的运行器。
- en: '[PRE111]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The result is just the string we passed as input:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 结果只是我们传递的输入字符串：
- en: '[PRE114]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Still, at this point, we have no way to classify program behavior:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，我们还没有方法来分类程序行为：
- en: '[PRE116]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `ProgramRunner` class sends the input to the standard input of a program
    instead. The program is specified when creating a `ProgramRunner` object.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgramRunner` 类将输入发送到程序的标准输入。程序在创建 `ProgramRunner` 对象时指定。'
- en: '[PRE118]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Here's a variant for binary (i.e., non-textual) input and output.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个针对二进制（即非文本）输入和输出的变体。
- en: '[PRE119]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Let us demonstrate a `ProgramRunner` using the `cat` program – a program that
    copies its input to its output. We see that a standard invocation of `cat` simply
    does the job, with the output of `cat` being the same as its input:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个 `ProgramRunner` 来演示 `cat` 程序——一个将输入复制到输出的程序。我们看到标准的 `cat` 调用只是简单地完成工作，`cat`
    的输出与它的输入相同：
- en: '[PRE120]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Fuzzer Classes
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊器类
- en: Let us now define a *fuzzer* that actually feed data into a consumer. The base
    class for fuzzers provides one central method `fuzz()` that creates some input.
    The `run()` function then sends the fuzz() input to a runner, returning the outcome;
    `runs()` does this for a given number (`trials`) of times.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个 *模糊器*，它实际上将数据喂给消费者。模糊器的基类提供了一个中心方法 `fuzz()`，用于创建一些输入。然后 `run()` 函数将
    `fuzz()` 输入发送到运行器，返回结果；`runs()` 为给定的次数（`trials`）执行此操作。
- en: '[PRE122]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: By default, `Fuzzer` objects do not do much, as their `fuzz()` function is merely
    an abstract placeholder. The subclass `RandomFuzzer`, however, implements the
    functionality of the `fuzzer()` function, above, adding a parameter `min_length`
    to specify a minimum length.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Fuzzer` 对象并不做很多事情，因为它们的 `fuzz()` 函数只是一个抽象占位符。然而，子类 `RandomFuzzer` 实现了上述
    `fuzzer()` 函数的功能，并添加了一个参数 `min_length` 来指定最小长度。
- en: '[PRE123]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With `RandomFuzzer`, we can now create a fuzzer whose configuration needs to
    be specified only once when creating the fuzzer.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RandomFuzzer`，我们现在可以创建一个模糊器，其配置只需在创建模糊器时指定一次。
- en: '[PRE124]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We can now send such generated inputs to our previously defined `cat` runner,
    verifying that `cat` actually does copy its (fuzzed) input to its output.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这些生成的输入发送到之前定义的 `cat` 运行器，验证 `cat` 是否确实将其（模糊的）输入复制到输出。
- en: '[PRE126]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Combining a `Fuzzer` with a `Runner`, however, is so common that we can use
    the `run()` method supplied by the `Fuzzer` class for this purpose:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将 `Fuzzer` 与 `Runner` 结合使用是如此普遍，以至于我们可以使用 `Fuzzer` 类提供的 `run()` 方法来完成此目的：
- en: '[PRE127]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: With `runs()`, we can repeat a fuzzing run a number of times, obtaining a list
    of results.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `runs()`，我们可以多次重复模糊测试运行，获得一系列结果。
- en: '[PRE129]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: With this, we have all in place to create fuzzers – starting with the simple
    random fuzzers introduced in this chapter, but even far more advanced ones. Stay
    tuned!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好创建模糊器——从本章介绍的简单随机模糊器开始，甚至更高级的模糊器。敬请期待！
- en: Lessons Learned
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Randomly generating inputs ("fuzzing") is a simple, cost-effective way to quickly
    test arbitrary programs for their robustness.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机生成输入（“模糊测试”）是一种简单、成本效益高的方法，可以快速测试任意程序的鲁棒性。
- en: Bugs fuzzers find are mainly due to errors and deficiencies in *input processing*.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模糊测试器发现的错误主要归因于输入处理中的错误和不足。
- en: To catch errors, have as many *consistency checkers* as possible.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了捕捉错误，尽可能多地使用*一致性检查器*。
- en: 'We''re done, so don''t forget to clean up:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了，所以别忘了清理：
- en: '[PRE131]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Next Steps
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: From here, you can explore how to
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以探索如何
- en: '[use *mutations* on existing inputs to get more valid inputs](MutationFuzzer.html)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过在现有输入上使用*变异*来获取更多有效输入](MutationFuzzer.html)'
- en: '[use *grammars* to specify the input format and thus get many more valid inputs](Grammars.html)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用*语法*来指定输入格式，从而获取更多有效输入](Grammars.html)'
- en: '[reduce *failing inputs* for efficient debugging](Reducer.html)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[减少*失败输入*以进行高效的调试](Reducer.html)'
- en: Enjoy the read!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 享受阅读吧！
- en: Background
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: 'Books on generating software tests in general are scarce (which is why we wrote
    this book). There are a few notable books on *fuzzing,* though, also based on
    the basic fuzzing techniques introduced in this chapter:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 关于生成软件测试的一般书籍很少（这也是我们写这本书的原因）。不过，也有一些关于模糊测试的显著书籍，它们也是基于本章介绍的基本模糊测试技术：
- en: The book "Fuzzing – Brute Force Vulnerability Discovery" covers a wide range
    of fuzzing domains, including files, Web pages, environment variables, and network
    protocols. The authors bring in lots of experience from fuzzing at Microsoft,
    and include a number of ready-made tools for Windows and UNIX programs. The tools
    have aged somewhat, but the principles remain.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍《模糊测试 - 强制力漏洞发现》涵盖了广泛的模糊测试领域，包括文件、网页、环境变量和网络协议。作者们带来了在微软进行模糊测试的大量经验，并包括了一些为Windows和UNIX程序准备的现成工具。这些工具可能有些过时，但原则依然适用。
- en: The book "Fuzzing for Software Security Testing and Quality Assurance" [[Takanen
    *et al*, 2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)],
    now in its second edition 2018, covers a wide range of fuzzing tools and detection
    techniques; its authors bring in plenty of experience from security testing and
    vulnerability discovery. This is arguably one of the most comprehensive and up-to-date
    books on the field.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍《Fuzzing for Software Security Testing and Quality Assurance》[[Takanen 等人，2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)]，现在已进入2018年的第二版，涵盖了广泛的模糊测试工具和检测技术；其作者们带来了丰富的安全测试和漏洞发现经验。这可能是该领域最全面和最新的书籍之一。
- en: Specifically for this chapter, the seminal work on fuzzing, introducing both
    the term and the approach, is "An Empirical Study of the Reliability of UNIX Utilities"
    [[Miller *et al*, 1990](https://doi.org/10.1145/96267.96279)]. As the foundation
    for the field, this is a must-read for anyone interested in fuzzing and robustness
    testing, with observations as valid today as they were 30 years ago.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 特别针对本章，关于模糊测试的开创性工作，介绍了该术语和方法，是“An Empirical Study of the Reliability of UNIX
    Utilities”[[Miller 等人，1990](https://doi.org/10.1145/96267.96279)]。作为该领域的基础，这是任何对模糊测试和鲁棒性测试感兴趣的人必读的，其观察结果至今依然有效，就像30年前一样。
- en: Exercises
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: One of the errors found by Miller et al. [[Miller *et al*, 1990](https://doi.org/10.1145/96267.96279)]
    involves the *troff* typesetting system. *Troff* takes as input a text consisting
    of lines; a line beginning with a dot (`.`) includes typesetting commands, as
    in
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 米勒等人[[Miller 等人，1990](https://doi.org/10.1145/96267.96279)]发现的错误之一涉及*troff*排版系统。*Troff*以文本作为输入，文本由行组成；以点（`.`）开头的行包含排版命令，如下所示：
- en: '[PRE132]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: which would produce (using `nroff -ms`) the text
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生（使用`nroff -ms`）以下文本
- en: '[PRE133]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: At the time of Miller et al., *troff* would fail if its input included
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在米勒等人当时，如果其输入包含*troff*会失败
- en: The input sequence `\D` (backslash + D) followed by a non-printable character
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入序列`\D`（反斜杠+D）后面跟着一个不可打印字符
- en: A character in the ASCII range 128–255 (i.e., the 8th bit is set) followed by
    a newline character
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASCII范围内的一个字符128-255（即第8位被设置），后面跟着一个换行符
- en: A single dot (`.`) followed by a newline character.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个点（`.`）后面跟着一个换行符。
- en: 'Exercise 1: Simulate Troff'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：模拟Troff
- en: For each of the above, write a Python function `f(s)` that fails if `s` fulfills
    the failure criterion.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述每一项，编写一个Python函数`f(s)`，如果`s`满足失败标准，则该函数失败。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Exercise 2: Run Simulated Troff'
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：运行模拟的Troff
- en: Create a class `TroffRunner` as subclass of `Runner` that checks for the above
    predicates. Run it with `Fuzzer`. Be sure to have the `Fuzzer` object produce
    the entire range of characters. Count how frequently the individual predicates
    fail.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`TroffRunner`的类，它是`Runner`的子类，用于检查上述谓词。使用`Fuzzer`运行它。确保`Fuzzer`对象产生整个字符范围。计算各个谓词失败的频率。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Exercise 3: Run Real Troff'
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：运行真实的Troff
- en: Using `BinaryProgramRunner`, apply the fuzzer you configured on the real `troff`
    program. Check if you can produce any run whose output code is non-zero, indicating
    a failure or a crash.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BinaryProgramRunner`，将配置好的fuzzer应用到真实的`troff`程序上。检查是否可以产生输出代码非零的运行，这表明有失败或崩溃。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Fuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
    License](https://creativecommons.org/licenses/by-nc-sa/4.0/)许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，均受[MIT
    License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)许可。最后修改时间：2024-11-09
    17:07:29+01:00。[引用](#citation) [版权信息](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing: Breaking Things with Random Inputs](https://www.fuzzingbook.org/html/Fuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Fuzzer.html](https://www.fuzzingbook.org/html/Fuzzer.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '安德烈亚斯·泽勒（Andreas Zeller）、拉胡尔·戈皮纳特（Rahul Gopinath）、马塞尔·博hme（Marcel Böhme）、戈登·弗朗西斯（Gordon
    Fraser）和克里斯蒂安·霍勒（Christian Holler）："[Fuzzing: Breaking Things with Random Inputs](https://www.fuzzingbook.org/html/Fuzzer.html)"。收录于安德烈亚斯·泽勒、拉胡尔·戈皮纳特、马塞尔·博hme、戈登·弗朗西斯和克里斯蒂安·霍勒的《The
    Fuzzing Book》中，[https://www.fuzzingbook.org/html/Fuzzer.html](https://www.fuzzingbook.org/html/Fuzzer.html)。检索时间：2024-11-09
    17:07:29+01:00。'
- en: '[PRE134]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
