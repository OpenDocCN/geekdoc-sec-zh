- en: Mutation Analysis
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变异分析
- en: 原文：[http://www.fuzzingbook.org/html/MutationAnalysis.html](http://www.fuzzingbook.org/html/MutationAnalysis.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/MutationAnalysis.html](http://www.fuzzingbook.org/html/MutationAnalysis.html)
- en: 'In the [chapter on coverage](Coverage.html), we showed how one can identify
    which parts of the program are executed by a program, and hence get a sense of
    the effectiveness of a set of test cases in covering the program structure. However,
    coverage alone may not be the best measure for the effectiveness of a test, as
    one can have great coverage without ever checking a result for correctness. In
    this chapter, we introduce another means for assessing the effectiveness of a
    test suite: After injecting *mutations* – *artificial faults* – into the code,
    we check whether a test suite can detect these artificial faults. The idea is
    that if it fails to detect such mutations, it will also miss real bugs.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[关于覆盖的章节](Coverage.html)中，我们展示了如何确定程序中哪些部分被程序执行，从而获得一组测试用例在覆盖程序结构方面的有效性感。然而，覆盖率本身可能不是衡量测试有效性的最佳指标，因为即使从未检查结果是否正确，也可能有很高的覆盖率。在本章中，我们介绍了一种评估测试套件有效性的另一种方法：在代码中注入*变异*（*人工故障*）后，我们检查测试套件是否可以检测这些人工故障。其思想是，如果它未能检测到这种变异，它也会错过真实错误。
- en: '**Prerequisites**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You need some understanding of how a program is executed.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要了解程序是如何执行的。
- en: You should have read [the chapter on coverage](Coverage.html).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该已经阅读了[关于覆盖的章节](Coverage.html)。
- en: Synopsis
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要[使用本章提供的代码](Importing.html)，请编写
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: and then make use of the following features.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter introduces two methods of running *mutation analysis* on subject
    programs. The first class `MuFunctionAnalyzer` targets individual functions. Given
    a function `gcd` and two test cases evaluate, one can run mutation analysis on
    the test cases as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种在主题程序上运行*变异分析*的方法。第一种类`MuFunctionAnalyzer`针对单个函数。给定一个函数`gcd`和两个测试用例评估，可以对测试用例进行如下变异分析：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The second class `MuProgramAnalyzer` targets standalone programs with test
    suites. Given a program `gcd` whose source code is provided in `gcd_src` and the
    test suite is provided by `TestGCD`, one can evaluate the mutation score of `TestGCD`
    as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类`MuProgramAnalyzer`针对具有测试套件的独立程序。给定一个程序`gcd`，其源代码在`gcd_src`中提供，测试套件由`TestGCD`提供，可以如下评估`TestGCD`的变异分数：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The mutation score thus obtained is a better indicator of the quality of a given
    test suite than pure coverage.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此获得的变异分数是衡量给定测试套件质量比纯覆盖率更好的指标。
- en: Why Structural Coverage is Not Enough
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么结构覆盖率不足以
- en: 'One of the problems with [structural coverage](Coverage.html) measures is that
    it fails to check whether the program executions generated by the test suite were
    actually *correct*. That is, an execution that produces a wrong output that is
    unnoticed by the test suite is counted exactly the same as an execution that produces
    the right output for coverage. Indeed, if one deletes the assertions in a typical
    test case, the coverage would not change for the new test suite, but the new test
    suite is much less useful than the original one. As an example, consider this
    "test":'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结构覆盖率[测量](Coverage.html)的一个问题是它未能检查测试套件生成的程序执行是否实际上是*正确的*。也就是说，一个产生错误输出但测试套件未注意到的执行与产生正确输出的执行在覆盖率中被计为完全相同。事实上，如果删除典型测试用例中的断言，新测试套件的覆盖率不会改变，但新测试套件比原始测试套件要少得多。作为一个例子，考虑这个“测试”：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The final assertion here will always pass, no matter what `execute_the_program_as_a_whole()`
    will do. Okay, if `execute_the_program_as_a_whole()` raises an exception, the
    test will fail, but we can also get around that:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最终断言将始终通过，无论`execute_the_program_as_a_whole()`做什么。好吧，如果`execute_the_program_as_a_whole()`引发异常，测试将失败，但我们也可以绕过这一点：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The problem with these "tests", however, is that `execute_the_program_as_a_whole()`
    may achieve 100% code coverage (or 100% of any other structural coverage metric).
    Yet, this number of 100% does not reflect the ability of the test to discover
    bugs, which actually is 0%.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些“测试”的问题在于`execute_the_program_as_a_whole()`可能达到100%的代码覆盖率（或100%的任何其他结构覆盖率指标）。然而，这个100%的数字并不能反映测试发现错误的能力，实际上这个能力是0%。
- en: This is indeed, not an optimal state of affairs. How can we verify that our
    tests are actually useful? One alternative (hinted in the chapter on coverage)
    is to inject bugs into the program, and evaluate the effectiveness of test suites
    in catching these injected bugs. However, that introduces another problem. How
    do we produce these bugs in the first place? Any manual effort is likely to be
    biased by the preconceptions of the developer as to where the bugs are likely
    to occur, and what effect it would have. Further, writing good bugs is likely
    to take a significant amount of time, for a very indirect benefit. Hence, such
    a solution is not sufficient.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实不是一种理想的状态。我们如何验证我们的测试实际上是有用的呢？一个替代方案（在第关于覆盖率的章节中暗示）是将错误注入程序中，并评估测试套件捕捉这些注入错误的有效性。然而，这又引入了另一个问题。我们最初如何产生这些错误呢？任何手动工作都可能受到开发者对错误可能发生位置及其影响的先入为主的偏见。此外，编写好的错误可能需要花费大量时间，而收益却非常间接。因此，这种解决方案是不够的。
- en: Seeding Artificial Faults with Mutation Analysis
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变异分析植入人工故障
- en: Mutation Analysis offers an alternative solution to assess the effectiveness
    of a test suite. The idea of mutation analysis is to seed *artificial faults*,
    known as *mutations*, into the program code, and to check whether the test suite
    finds them. Such a mutation could, for instance, replace a `+` by a `-` somewhere
    within `execute_the_program_as_a_whole()`. Of course, the above ineffective tests
    would not detect this, as they do not check any of the results. An effective test
    would, however; and the assumption is that the more effective a test is in finding
    *artificial* faults, the more effective it would be in finding *real* faults.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 变异分析提供了一种评估测试套件有效性的替代方案。变异分析的想法是在程序代码中植入*人工故障*，称为*变异*，并检查测试套件是否能发现它们。例如，这种变异可能是在`execute_the_program_as_a_whole()`函数中的某个地方将`+`替换为`-`。当然，上述无效的测试不会检测到这一点，因为它们没有检查任何结果。一个有效的测试将会这样做；并且假设测试在发现*人工*故障方面越有效，它在发现*真实*故障方面就越有效。
- en: The insight from Mutation Analysis is to consider the probability of insertion
    of a bug from the perspective of a programmer. If one assumes that the attention
    received by each program element in the program is sufficiently similar, one can
    further assume that each token in the program has a similar probability of being
    incorrectly transcribed. Of course, the programmer will correct any mistakes that
    gets detected by the compilers (or other static analysis tools). So the set of
    valid tokens different from the original that make it past the compilation stage
    is considered to be its possible set of *mutations* that represent the *probable
    faults* in the program. A test suite is then judged by its capability to detect
    (and hence prevent) such mutations. The proportion of such mutants detected over
    all *valid* mutants produced is taken as the mutation score. In this chapter,
    we see how one can implement Mutation Analysis in Python programs. The mutation
    score obtained represents the ability of any program analysis tools to prevent
    faults, and can be used to judge static test suites, test generators such as fuzzers,
    and also static and symbolic execution frameworks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 变异分析带来的洞察是从程序员的视角考虑引入错误的概率。如果假设程序中每个程序元素所获得的关注程度足够相似，那么可以进一步假设程序中的每个标记都有相似的概率被错误地转录。当然，程序员会纠正编译器（或其他静态分析工具）检测到的任何错误。因此，那些不同于原始版本并通过编译阶段的合法标记集合被认为是其可能的*变异*集合，这些变异代表了程序中的*可能故障*。然后，测试套件的判断标准是它检测（从而防止）此类变异的能力。检测到的此类变异与所有*有效*变异产生的比例被用作变异分数。在本章中，我们将看到如何在Python程序中实现变异分析。获得的变异分数代表了任何程序分析工具防止错误的能力，并且可以用来评估静态测试套件、测试生成器（如模糊器）、以及静态和符号执行框架。
- en: It might be intuitive to consider a slightly different perspective. A test suite
    is a program that can be considered to accept as its input, the program to be
    tested. What is the best way to evaluate such a program (the test suite)? We can
    essentially *fuzz* the test suite by applying small mutations to the input program,
    and verifying that the test suite in question does not produce unexpected behaviors.
    The test suite is supposed to only allow the original through; and hence any mutant
    that is not detected as faulty represents a bug in the test suite.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会直观地考虑一个稍微不同的视角。测试套件是一个程序，可以将其视为接受要测试的程序作为输入。评估这样一个程序（测试套件）的最佳方法是什么？我们可以通过对输入程序应用小的突变来模糊测试套件，并验证所讨论的测试套件不会产生意外的行为。测试套件应该只允许原始程序通过；因此，任何未被检测为错误的突变都代表测试套件中的错误。
- en: Structural Coverage Adequacy by Example
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过示例展示的结构覆盖率充分性
- en: Let us introduce a more detailed example to illustrate both the problems with
    coverage as well as how mutation analysis works. The `triangle()` program below
    classifies a triangle with edge lengths $a$, $b$, and $c$ into the proper triangle
    category. We want to verify that the program works correctly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个更详细的例子来说明覆盖率的问题以及突变分析是如何工作的。下面的`triangle()`程序根据边长$a$、$b$和$c$将三角形分类到正确的三角形类别。我们希望验证程序是否正确工作。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here are a few test cases to ensure that the program works.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些测试用例来确保程序能正常工作。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running them actually causes all tests to pass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它们实际上会导致所有测试通过。
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, the statement that "all tests pass" has value only if we know that
    our tests are effective. What is the effectiveness of our test suite? As we saw
    in the [chapter on coverage](Coverage.html), one can use structural coverage techniques
    such as statement coverage to obtain a measure of effectiveness of the test case.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，“所有测试通过”的陈述只有在我们知道我们的测试是有效的时才有价值。我们的测试套件的有效性是什么？正如我们在[覆盖率章节](Coverage.html)中看到的，可以使用结构覆盖率技术，如语句覆盖率，来获得测试用例有效性的度量。
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We add a function `show_coverage()` to visualize the coverage obtained.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`show_coverage()`函数来可视化获得的覆盖率。
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Our `strong_oracle()` seems to have adequately covered all possible conditions.
    That is, our set of test cases is reasonably good according to structural coverage.
    However, does the coverage obtained tell the whole story? Consider this test suite
    instead:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`strong_oracle()`似乎已经充分覆盖了所有可能的情况。也就是说，根据结构覆盖率，我们的测试用例集是相当好的。然而，获得的覆盖率是否就是全部故事？考虑这个测试套件：
- en: '[PRE15]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All that we are checking here is that a triangle with unequal sides is not equilateral.
    What is the coverage obtained?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里检查的只是具有不等边的三角形不是等边三角形。我们获得了什么样的覆盖率？
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Indeed, there does not seem to be *any* difference in coverage. The `weak_oracle()`
    obtains exactly the same coverage as that of `strong_oracle()`. However, a moment's
    reflection should convince one that the `weak_oracle()` is not as effective as
    `strong_oracle()`. However, *coverage* is unable to distinguish between the two
    test suites. What are we missing in coverage? The problem here is that coverage
    is unable to evaluate the *quality* of our assertions. Indeed, coverage does not
    care about assertions at all. However, as we saw above, assertions are an extremely
    important part of test suite effectiveness. Hence, what we need is a way to evaluate
    the quality of assertions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，似乎在覆盖率上没有*任何*差异。`weak_oracle()`获得的覆盖率与`strong_oracle()`完全相同。然而，稍加思考应该会让人相信`weak_oracle()`并不像`strong_oracle()`那样有效。然而，*覆盖率*无法区分这两个测试套件。我们在覆盖率上遗漏了什么？这里的问题是覆盖率无法评估我们断言的质量。事实上，覆盖率根本不在乎断言。然而，正如我们上面所看到的，断言是测试套件有效性的极其重要的一部分。因此，我们需要一种方法来评估断言的质量。
- en: Injecting Artificial Faults
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入人工故障
- en: Notice that in the [chapter on coverage](Coverage.html), coverage was presented
    as a *proxy* for the likelihood of a test suite to uncover bugs. What if we actually
    try to evaluate the likelihood of a test suite to uncover bugs? All we need is
    to inject bugs into the program, one at a time, and count the number of such bugs
    that our test suite detects. The frequency of detection will provide us with the
    actual likelihood of the test suite to uncover bugs. This technique is called
    *fault injection*. Here is an example for *fault injection*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [覆盖率章节](Coverage.html) 中，覆盖率被提出作为测试套件发现错误的可能性的 *代理*。如果我们实际上尝试评估测试套件发现错误的可能性怎么办？我们只需要将错误注入到程序中，一次一个，并计算我们的测试套件检测到的这种错误数量。检测频率将为我们提供测试套件发现错误的实际可能性。这种技术被称为
    *故障注入*。以下是一个 *故障注入* 的例子。
- en: '[PRE19]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let us see if our test suites are good enough to catch this fault. We first
    check whether `weak_oracle()` can detect this change.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的测试套件是否足够好，能够捕捉到这个错误。我们首先检查 `weak_oracle()` 是否能够检测到这个变化。
- en: '[PRE20]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `weak_oracle()` is unable to detect any changes. What about our `strong_oracle()`?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_oracle()` 无法检测到任何变化。那么我们的 `strong_oracle()` 呢？'
- en: '[PRE22]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `strong_oracle()` is able to detect this fault, which is evidence that `strong_oracle()`
    is probably a better test suite.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `strong_oracle()` 能够检测到这个错误，这是 `strong_oracle()` 可能是一个更好的测试套件的证据。
- en: '*Fault injection* can provide a good measure of effectiveness of a test suite,
    provided we have a list of possible faults. The problem is that collecting such
    a set of *unbiased* faults is rather expensive. It is difficult to create good
    faults that are reasonably hard to detect, and it is a manual process. Given that
    it is a manual process, the generated faults will be biased by the preconceptions
    of the developer who creates it. Even when such curated faults are available,
    they are unlikely to be exhaustive, and likely to miss important classes of bugs,
    and parts of the program. Hence, *fault injection* is an insufficient replacement
    for coverage. Can we do better?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*故障注入* 可以提供一个测试套件有效性的良好度量，前提是我们有一个可能的错误列表。问题是收集这样一组 *无偏* 错误相当昂贵。创建合理难以检测的良好错误很困难，而且是一个手动过程。鉴于这是一个手动过程，生成的错误将受到创建它的开发者的先入为主的偏见。即使这样的精心挑选的错误可用，它们也不太可能是详尽的，可能会错过重要的错误类别和程序的某些部分。因此，*故障注入*
    不能替代覆盖率。我们能做得更好吗？'
- en: Mutation Analysis provides an alternative to a curated set of faults. The key
    insight is that, if one assumes that the programmer understands the program in
    question, the majority of errors made are very likely small transcription errors
    (a few tokens). A compiler will likely catch most of these errors. Hence, the
    majority of residual faults in a program is likely to be due to small (single
    token) variations at certain points in the structure of the program from the correct
    program (This particular assumption is called the *Competent Programmer Hypothesis*
    or the *Finite Neighborhood Hypothesis*).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 变异分析为精心挑选的错误集提供了一种替代方案。关键洞察是，如果假设程序员理解了相关的程序，那么犯的大多数错误很可能都是小的转录错误（几个标记）。编译器可能会捕获这些错误中的大多数。因此，程序中剩余的大多数错误很可能是由程序结构中某些点的小（单个标记）变化引起的（这个特定的假设被称为
    *合格程序员假设* 或 *有限邻域假设*）。
- en: What about the larger faults composed of multiple smaller faults? The key insight
    here is that, for a majority of such complex faults, test cases that detect a
    single smaller fault in isolation is very likely to detect the larger complex
    fault that contains it. (This assumption is called the *Coupling Effect*.)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么由多个较小错误组成的较大错误呢？关键洞察在于，对于大多数这样的复杂错误，单独检测一个较小错误的测试用例很可能检测到包含它的较大复杂错误。（这个假设被称为
    *耦合效应*。）
- en: How can we use these assumptions in practice? The idea is to simply generate
    *all* possible *valid* variants of the program that differs from the original
    by a small change (such as a single token change) (Such variants are called *mutants*).
    Next, the given test suite is applied to each variant thus generated. Any mutant
    detected by the test suite is said to have been *killed* by the test suite. The
    effectiveness of a test suite is given by the proportion of mutants killed to
    the valid mutants generated.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些假设用于实践呢？想法是简单地生成所有可能的、与原始程序不同但只经过微小变化（如单个标记变化）的 *有效* 程序变体（这些变体被称为 *突变体*）。接下来，将给定的测试套件应用于生成的每个变体。任何被测试套件检测到的突变体都被说成是被测试套件
    *杀死* 的。测试套件的有效性由被杀死的突变体与生成的有效突变体的比例给出。
- en: We next implement a simple mutation analysis framework and use it to evaluate
    our test suites.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来实现一个简单的变异分析框架，并使用它来评估我们的测试套件。
- en: Mutating Python Code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异 Python 代码
- en: To manipulate a Python program, we work on the *abstract syntax tree* (AST)
    representation – which is the internal representation compilers and interpreters
    work on after reading in the program text.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了操作 Python 程序，我们在*抽象语法树*（AST）表示形式上工作——这是编译器和解释器在读取程序文本后工作的内部表示形式。
- en: Briefly speaking, we convert the program into a tree, and then *change parts
    of this tree* – for instance, by changing `+` operators into `-` or vice versa,
    or actual statements into `pass` statements that do nothing. The resulting mutated
    tree can then be processed further; it can be passed on to the Python interpreter
    for execution, or we can *unparse* it back into a textual form.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将程序转换成树，然后*改变树的某些部分*——例如，将 `+` 运算符更改为 `-` 或相反，或将实际语句更改为不执行任何操作的 `pass`
    语句。然后，可以进一步处理生成的变异树；它可以传递给 Python 解释器执行，或者我们可以*将其反解析*回文本形式。
- en: We begin by importing the AST manipulation modules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入 AST 操作模块。
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can get the source of a Python function using `inspect.getsource()`. (Note
    that this does not work for functions defined in other notebooks.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `inspect.getsource()` 获取 Python 函数的源代码。（注意，这不适用于在其他笔记本中定义的函数。）
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To view these in a visually pleasing form, our function `print_content(s, suffix)`
    formats and highlights the string `s` as if it were a file with ending `suffix`.
    We can thus view (and highlight) the source as if it were a Python file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以视觉上令人愉悦的形式查看这些内容，我们的函数 `print_content(s, suffix)` 格式化和突出显示字符串 `s`，就像它是一个以
    `suffix` 结尾的文件。因此，我们可以像查看（并突出显示）Python 文件一样查看（并突出显示）源代码：
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Parsing this gives us an abstract syntax tree (AST) – a representation of the
    program in tree form.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 解析这些语句会给我们一个抽象语法树（AST）——这是程序以树形表示的形式。
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: What does this AST look like? The helper functions `ast.dump()` (textual output)
    and `showast.show_ast()` (graphical output with [showast](https://github.com/hchasestevens/show_ast))
    allow us to inspect the structure of the tree. We see that the function starts
    as a `FunctionDef` with name and arguments, followed by a body, which is a list
    of statements; in this case, the body contains only an `If`, which itself contains
    other nodes of type `If`, `Compare`, `Name`, `Str`, and `Return`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 AST 看起来是什么样子？辅助函数 `ast.dump()`（文本输出）和 `showast.show_ast()`（带有 [showast](https://github.com/hchasestevens/show_ast)
    的图形输出）允许我们检查树的结构。我们看到函数以具有名称和参数的 `FunctionDef` 开始，后面是一个体，即语句列表；在这种情况下，体只包含一个 `If`，它本身包含其他类型的节点，如
    `If`、`Compare`、`Name`、`Str` 和 `Return`。
- en: '[PRE31]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Too much text for you? This graphical representation may make things simpler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 文字太多？这个图形表示可能使事情更简单。
- en: '[PRE33]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1791pt" height="476pt"
    viewBox="0.00 0.00 1791.38 476.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 472)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="115.88" y="-445.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="49.25" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"triangle"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="124.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="start" x="495"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">If</text></g> <g id="edge9" class="edge"><title>0--9</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="40.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="112.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge5" class="edge"><title>2--5</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="start" x="184.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge7" class="edge"><title>2--7</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="53.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="125.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge6" class="edge"><title>5--6</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="197.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge8" class="edge"><title>7--8</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="start" x="348.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge10"
    class="edge"><title>9--10</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="start" x="656" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge18"
    class="edge"><title>9--18</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="start" x="1187" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge33"
    class="edge"><title>9--33</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="start" x="252.75" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge11"
    class="edge"><title>10--11</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="341.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="396.75"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>10--15</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="197.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="269.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="341.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge16" class="edge"><title>15--16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="413.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge17" class="edge"><title>15--17</title></g>
    <g id="node20" class="node"><title>19</title> <text text-anchor="start" x="564.38"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge19" class="edge"><title>18--19</title></g>
    <g id="node28" class="node"><title>27</title> <text text-anchor="start" x="674.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge27" class="edge"><title>18--27</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="799.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge30" class="edge"><title>18--30</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="start" x="468.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="557.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Eq</text></g>
    <g id="edge23" class="edge"><title>19--23</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="start" x="612.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge24"
    class="edge"><title>19--24</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="413.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge21" class="edge"><title>20--21</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="485.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge22" class="edge"><title>20--22</title></g> <g id="node26" class="node"><title>25</title>
    <text text-anchor="middle" x="557.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"c"</text></g> <g id="edge25" class="edge"><title>24--25</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="629.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge26" class="edge"><title>24--26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="start" x="693.25" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge28"
    class="edge"><title>27--28</title></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="736.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Equilateral"</text></g> <g id="edge29" class="edge"><title>28--29</title></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="start" x="815.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge31" class="edge"><title>30--31</title></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="869.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge32" class="edge"><title>31--32</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1102.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge34"
    class="edge"><title>33--34</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1209.5" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge42"
    class="edge"><title>33--42</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="start" x="1521" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge45"
    class="edge"><title>33--45</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="start" x="1022.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge35"
    class="edge"><title>34--35</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="middle" x="1111.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge38" class="edge"><title>34--38</title></g>
    <g id="node40" class="node"><title>39</title> <text text-anchor="start" x="1166.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge39" class="edge"><title>34--39</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="967.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge36" class="edge"><title>35--36</title></g> <g id="node38" class="node"><title>37</title>
    <text text-anchor="middle" x="1039.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge37" class="edge"><title>35--37</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1111.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge40" class="edge"><title>39--40</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="middle" x="1183.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge41" class="edge"><title>39--41</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1242.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node45" class="node"><title>44</title> <text text-anchor="middle" x="1281.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge44" class="edge"><title>43--44</title></g> <g id="node47" class="node"><title>46</title>
    <text text-anchor="start" x="1436.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge46"
    class="edge"><title>45--46</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="start" x="1569.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge54"
    class="edge"><title>45--54</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="start" x="1690.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge57"
    class="edge"><title>45--57</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1362.75" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge47"
    class="edge"><title>46--47</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1451.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge50" class="edge"><title>46--50</title></g>
    <g id="node52" class="node"><title>51</title> <text text-anchor="start" x="1506.75"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge51" class="edge"><title>46--51</title></g>
    <g id="node49" class="node"><title>48</title> <text text-anchor="middle" x="1307.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge48" class="edge"><title>47--48</title></g> <g id="node50" class="node"><title>49</title>
    <text text-anchor="middle" x="1379.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge49" class="edge"><title>47--49</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="middle" x="1451.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge52" class="edge"><title>51--52</title></g> <g id="node54" class="node"><title>53</title>
    <text text-anchor="middle" x="1523.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge53" class="edge"><title>51--53</title></g>
    <g id="node56" class="node"><title>55</title> <text text-anchor="start" x="1582.25"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge55" class="edge"><title>54--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="middle" x="1621.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge56" class="edge"><title>55--56</title></g> <g id="node59" class="node"><title>58</title>
    <text text-anchor="start" x="1697.25" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge58"
    class="edge"><title>57--58</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="middle" x="1738.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Scalene"</text></g> <g id="edge59" class="edge"><title>58--59</title></g></g></svg>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1791pt" height="476pt"
    viewBox="0.00 0.00 1791.38 476.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 472)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="115.88" y="-445.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="49.25" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"triangle"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="124.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="start" x="495"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">If</text></g> <g id="edge9" class="edge"><title>0--9</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="40.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="112.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge5" class="edge"><title>2--5</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="start" x="184.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge7" class="edge"><title>2--7</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="53.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="125.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge6" class="edge"><title>5--6</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="197.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge8" class="edge"><title>7--8</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="start" x="348.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge10"
    class="edge"><title>9--10</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="start" x="656" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge18"
    class="edge"><title>9--18</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="start" x="1187" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge33"
    class="edge"><title>9--33</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="start" x="252.75" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge11"
    class="edge"><title>10--11</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="341.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="396.75"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>10--15</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="197.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="269.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="341.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge16" class="edge"><title>15--16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="413.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge17" class="edge"><title>15--17</title></g>
    <g id="node20" class="node"><title>19</title> <text text-anchor="start" x="564.38"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge19" class="edge"><title>18--19</title></g>
    <g id="node28" class="node"><title>27</title> <text text-anchor="start" x="674.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge27" class="edge"><title>18--27</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="799.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge30" class="edge"><title>18--30</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="start" x="468.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="557.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Eq</text></g>
    <g id="edge23" class="edge"><title>19--23</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="start" x="612.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge24"
    class="edge"><title>19--24</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="413.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge21" class="edge"><title>20--21</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="485.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge22" class="edge"><title>20--22</title></g> <g id="node26" class="node"><title>25</title>
    <text text-anchor="middle" x="557.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"c"</text></g> <g id="edge25" class="edge"><title>24--25</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="629.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge26" class="edge"><title>24--26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="start" x="693.25" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge28"
    class="edge"><title>27--28</title></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="736.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Equilateral"</text></g> <g id="edge29" class="edge"><title>28--29</title></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="start" x="815.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge31" class="edge"><title>30--31</title></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="869.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge32" class="edge"><title>31--32</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1102.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge34"
    class="edge"><title>33--34</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1209.5" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge42"
    class="edge"><title>33--42</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="start" x="1521" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge45"
    class="edge"><title>33--45</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="start" x="1022.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge35"
    class="edge"><title>34--35</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="middle" x="1111.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge38" class="edge"><title>34--38</title></g>
    <g id="node40" class="node"><title>39</title> <text text-anchor="start" x="1166.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge39" class="edge"><title>34--39</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="967.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge36" class="edge"><title>35--36</title></g> <g id="node38" class="node"><title>37</title>
    <text text-anchor="middle" x="1039.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge37" class="edge"><title>35--37</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1111.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge40" class="edge"><title>39--40</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="middle" x="1183.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge41" class="edge"><title>39--41</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1242.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node45" class="node"><title>44</title> <text text-anchor="middle" x="1281.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge44" class="edge"><title>43--44</title></g> <g id="node47" class="node"><title>46</title>
    <text text-anchor="start" x="1436.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge46"
    class="edge"><title>45--46</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="start" x="1569.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge54"
    class="edge"><title>45--54</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="start" x="1690.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge57"
    class="edge"><title>45--57</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1362.75" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge47"
    class="edge"><title>46--47</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1451.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge50" class="edge"><title>46--50</title></g>
    <g id="node52" class="node"><title>51</title> <text text-anchor="start" x="1506.75"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge51" class="edge"><title>46--51</title></g>
    <g id="node49" class="node"><title>48</title> <text text-anchor="middle" x="1307.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge48" class="edge"><title>47--48</title></g> <g id="node50" class="node"><title>49</title>
    <text text-anchor="middle" x="1379.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge49" class="edge"><title>47--49</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="middle" x="1451.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge52" class="edge"><title>51--52</title></g> <g id="node54" class="node"><title>53</title>
    <text text-anchor="middle" x="1523.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge53" class="edge"><title>51--53</title></g>
    <g id="node56" class="node"><title>55</title> <text text-anchor="start" x="1582.25"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge55" class="edge"><title>54--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="middle" x="1621.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge56" class="edge"><title>55--56</title></g> <g id="node59" class="node"><title>58</title>
    <text text-anchor="start" x="1697.25" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge58"
    class="edge"><title>57--58</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="middle" x="1738.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Scalene"</text></g> <g id="edge59" class="edge"><title>58--59</title></g></g></svg>
- en: The function `ast.unparse()` converts such a tree back into the more familiar
    textual Python code representation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `ast.unparse()` 将这样的树转换回更熟悉的文本 Python 代码表示形式。
- en: '[PRE35]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: A Simple Mutator for Functions
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的简单变异器
- en: Let us now go and mutate the `triangle()` program. A simple way to produce valid
    mutated version of this program is to replace some of its statements by `pass`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在去修改 `triangle()` 程序。产生这个程序有效变异版本的一个简单方法是将其中的一些语句替换为 `pass`。
- en: The `MuFunctionAnalyzer` is the main class responsible for mutation analysis
    of the test suite. It accepts the function to be tested. It normalizes the source
    code given by parsing and unparsing it once, using the functions discussed above.
    This is required to ensure that later `diff`s between the original and mutant
    are not derailed by differences in whitespace, comments, etc.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`MuFunctionAnalyzer` 是负责测试套件变异分析的主要类。它接受要测试的函数。它通过解析和反解析一次提供的源代码来规范化源代码。这是确保后续的原始代码和变异代码之间的
    `diff` 不受空白、注释等差异的影响所必需的。'
- en: '[PRE37]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `get_mutation_count()` fetches the number of possible mutations available.
    We will see later how this can be implemented.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_mutation_count()` 获取可用的变异数量。我们稍后会看到如何实现这一点。'
- en: '[PRE38]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Mutator` provides the base class for implementing individual mutations.
    It accepts a list of locations to mutate. It assumes that the method `mutable_visit()`
    is invoked on all nodes of interest as determined by the subclass. When the `Mutator`
    is invoked without a list of locations to mutate, it simply loops through all
    possible mutation points and retains a count in `self.count`. If it is invoked
    with a specific list of locations to mutate, the `mutable_visit()` method calls
    the `mutation_visit()` which performs the mutation on the node. Note that a single
    location can produce multiple mutations. (Hence the hashmap).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutator` 为实现单个突变提供了基类。它接受一个要突变的地点列表。它假设子类确定的所有感兴趣节点的 `mutable_visit()` 方法被调用。当
    `Mutator` 在没有要突变的地点列表的情况下被调用时，它简单地遍历所有可能的突变点，并在 `self.count` 中保留计数。如果它被调用并带有特定的突变地点列表，则
    `mutable_visit()` 方法调用 `mutation_visit()`，该方法在节点上执行突变。请注意，单个位置可以产生多个突变。（因此有哈希表）。'
- en: '[PRE39]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `StmtDeletionMutator` simply hooks into all the statement processing visitors.
    It performs mutation by replacing the given statement with `pass`. As you can
    see, it visits all kinds of statements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`StmtDeletionMutator` 简单地钩入所有语句处理访问者。它通过将给定的语句替换为 `pass` 来执行突变。正如你所见，它访问了所有类型的语句。'
- en: '[PRE40]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The actual mutation consists of replacing the node with a `pass` statement:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的突变包括用 `pass` 语句替换节点：
- en: '[PRE41]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For `triangle()`, this visitor produces five mutations – namely, replacing
    the five `return` statements with `pass`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `triangle()`，这个访问者产生了五个突变——即用 `pass` 替换五个 `return` 语句：
- en: '[PRE42]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We need a way to obtain the individual mutants. For this, we convert our `MuFunctionAnalyzer`
    to an *iterable*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来获取单个突变体。为此，我们将我们的 `MuFunctionAnalyzer` 转换为一个 *可迭代对象*。
- en: '[PRE44]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `PMIterator`, which is the *iterator* class for `MuFunctionAnalyzer` is
    defined as follows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`PMIterator` 是 `MuFunctionAnalyzer` 的 *迭代器* 类，定义如下。'
- en: '[PRE45]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `next()` method returns the corresponding `Mutant`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()` 方法返回相应的 `Mutant`：'
- en: '[PRE46]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `Mutant` class contains logic for generating mutants when given the locations
    to mutate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutant` 类包含在给定突变位置时生成突变体的逻辑。'
- en: '[PRE47]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is how it can be used:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用它的：
- en: '[PRE48]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: These names are a bit generic yet. Let's see whether we can get more insights
    into the mutations produced.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些名称有点通用。让我们看看我们是否能对产生的突变有更多的了解。
- en: The `generate_mutant()` simply calls the `mutator()` method, and passes the
    mutator a copy of the AST.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_mutant()` 简单地调用 `mutator()` 方法，并将 AST 的副本传递给突变器。'
- en: '[PRE50]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `src()` method returns the mutated source.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`src()` 方法返回突变后的源代码。'
- en: '[PRE51]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Here is how one can obtain the mutants, and visualize the difference from the
    original:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何获取突变体以及可视化与原始代码的差异：
- en: '[PRE52]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this `diff` output, lines prefixed with `+` are added, whereas lines prefixed
    with `-` are deleted. We see that each of the five mutants indeed replaces a return
    statement with a `pass` statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `diff` 输出中，以 `+` 前缀的行是添加的，而以 `-` 前缀的行是删除的。我们看到五个突变体确实用 `pass` 语句替换了每个返回语句。
- en: We add the `diff()` method to `Mutant` so that it can be called directly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `Mutant` 添加了 `diff()` 方法，以便可以直接调用它。
- en: '[PRE55]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Evaluating Mutations
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估突变
- en: We are now ready to implement the actual evaluation. We define our mutant as
    a *context manager* that verifies whether all assertions given succeed. The idea
    is that we can write code such as
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好实现实际的评估。我们定义我们的突变体作为一个 *上下文管理器*，以验证所有给出的断言是否成功。想法是我们可以编写如下代码
- en: '[PRE56]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: and while `mutant` is active (i.e., the code block under `with:`), the original
    function is replaced by the mutated function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mutant` 激活时（即 `with:` 下的代码块），原始函数被替换为突变函数。
- en: The `__enter__()` function is called when the `with` block is entered. It creates
    the mutant as a Python function and places it in the global namespace, such that
    the `assert` statement executes the mutated function rather than the original.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`__enter__()` 函数在进入 `with` 块时被调用。它创建突变体作为一个 Python 函数，并将其放置在全局命名空间中，这样 `assert`
    语句就执行突变函数而不是原始函数。'
- en: '[PRE57]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `__exit__()` function checks whether an exception has occurred (i.e., the
    assertion failed, or some other error was raised); if so, it marks the mutation
    as `detected`. Finally, it restores the original function definition.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__()` 函数检查是否发生了异常（即断言失败，或引发了其他错误）；如果是这样，它将突变标记为 `detected`。最后，它恢复原始函数定义。'
- en: '[PRE58]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `finish()` method simply invokes the method on the mutant, checks if the
    mutant was discovered, and returns the result.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`finish()` 方法简单地调用突变体上的方法，检查突变体是否被发现，并返回结果。'
- en: '[PRE59]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The mutation score – the ratio of mutants detected by the test suite - is computed
    by `score()`. A score of 1.0 means that all mutants were discovered; a score of
    0.1 means that only 10% of mutants were detected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 突变分数——测试套件检测到的突变体的比率——通过 `score()` 计算。1.0 的分数意味着所有突变体都被发现；0.1 的分数意味着只有 10% 的突变体被检测到。
- en: '[PRE61]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here is how we use our framework.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的框架的使用方法。
- en: '[PRE62]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Only one out of five mutations resulted in a failing assertion. Hence, the `weak_oracle()`
    test suite gets a mutation score of 20%.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 五个突变中只有一个导致了失败的断言。因此，`weak_oracle()` 测试套件的突变分数为 20%。
- en: '[PRE66]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Since we are modifying the global namespace, we do not have to refer to the
    function directly within the for loop of mutant.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在修改全局命名空间，我们不需要在突变体的 for 循环中直接引用该函数。
- en: '[PRE68]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: That is, we were able to achieve `100%` mutation score with the `strong_oracle()`
    test suite.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们能够通过 `strong_oracle()` 测试套件实现 `100%` 的突变分数。
- en: Here is another example. `gcd()` computes the greatest common divisor of two
    numbers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子。`gcd()` 计算两个数的最大公约数。
- en: '[PRE72]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here's a test for it. How effective is it?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对它的一个测试。它有多有效？
- en: '[PRE73]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We see that our `TestGCD` test suite is able to obtain a mutation score of 42%.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的 `TestGCD` 测试套件能够获得 42% 的突变分数。
- en: Mutator for Modules and Test Suites
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块和测试套件的突变器
- en: Consider the `triangle()` program we discussed previously. As we discussed,
    a simple way to produce valid mutated version of this program is to replace some
    of its statements by `pass`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们之前讨论的 `triangle()` 程序。正如我们讨论的那样，产生这个程序有效突变版本的一个简单方法是将其中的一些语句替换为 `pass`。
- en: For demonstration purposes, we would like to proceed as though the program was
    in a different file. We can do that by producing a `Module` object in Python,
    and attaching the function to it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们希望像程序在另一个文件中一样进行操作。我们可以通过在 Python 中创建一个 `Module` 对象并将函数附加到它上来实现这一点。
- en: '[PRE77]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We attach the `triangle()` function to the `shape` module.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `triangle()` 函数附加到 `shape` 模块。
- en: '[PRE79]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We can now invoke triangle through the module `shape`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过 `shape` 模块调用三角形。
- en: '[PRE80]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We want to test the `triangle()` function. For that, we define a `StrongShapeTest`
    class as below.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试 `triangle()` 函数。为此，我们定义了一个如下的 `StrongShapeTest` 类。
- en: '[PRE82]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We define a helper function `suite()` that looks through a given class and identifies
    the test functions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个辅助函数 `suite()`，该函数遍历给定的类并识别测试函数。
- en: '[PRE84]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The tests in `TestTriangle` class can be invoked with different test runners.
    The simplest is to directly invoke the `run()` method of the `TestCase`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestTriangle` 类的测试可以通过不同的测试运行器调用。最简单的方法是直接调用 `TestCase` 的 `run()` 方法。'
- en: '[PRE85]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `TextTestRunner` class provides ability to control the verbosity of execution.
    It also allows one to return on the *first* failure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextTestRunner` 类提供了控制执行详细程度的能力。它还允许在 *第一次* 失败时返回。'
- en: '[PRE87]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Running the program under coverage is accomplished as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在覆盖率下运行程序如下：
- en: '[PRE90]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The coverage obtained is given by:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的覆盖率如下：
- en: '[PRE91]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How much coverage does it obtain?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它获得了多少覆盖率？
- en: '[PRE94]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `MuProgramAnalyzer` is the main class responsible for mutation analysis
    of the test suite. It accepts the name of the module to be tested, and its source
    code. It normalizes the source code given by parsing and unparsing it once. This
    is required to ensure that later `diff`s between the original and mutant are not
    derailed by differences in whitespace, comments, etc.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`MuProgramAnalyzer` 是负责测试套件突变分析的主要类。它接受要测试的模块名称及其源代码。它通过解析和重新解析一次给定的源代码来规范化源代码。这是确保后续的原始和突变体之间的
    `diff` 不受空白、注释等差异的影响所必需的。'
- en: '[PRE97]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We now extend the `Mutator` class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在扩展 `Mutator` 类。
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `AdvStmtDeletionMutator` simply hooks into all the statement processing
    visitors. It performs mutation by replacing the given statement with `pass`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvStmtDeletionMutator` 简单地钩入所有语句处理访问者。它通过用 `pass` 替换给定的语句来进行突变。'
- en: '[PRE99]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Aagin, we can obtain the number of mutations produced for `triangle()` as follows.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以获得 `triangle()` 产生的突变数量如下。
- en: '[PRE100]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We need a way to obtain the individual mutants. For this, we convert our `MuProgramAnalyzer`
    to an *iterable*.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来获取单个突变体。为此，我们将我们的 `MuProgramAnalyzer` 转换为 *可迭代*。
- en: '[PRE102]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The `AdvPMIterator`, which is the *iterator* class for `MuProgramAnalyzer` is
    defined as follows.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdvPMIterator` 是 `MuProgramAnalyzer` 的 *迭代器* 类，定义如下。'
- en: '[PRE103]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `next()` method returns the corresponding `Mutant`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()` 方法返回相应的 `Mutant`。'
- en: '[PRE104]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The `Mutant` class contains logic for generating mutants when given the locations
    to mutate.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutant` 类包含在给定突变位置时生成突变体的逻辑。'
- en: '[PRE105]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here is how it can be used:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的用法：
- en: '[PRE106]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The `generate_mutant()` simply calls the `mutator()` method, and passes the
    mutator a copy of the AST.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`generate_mutant()`函数简单地调用`mutator()`方法，并将AST的副本传递给突变器。'
- en: '[PRE109]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The `src()` method returns the mutated source.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`src()`方法返回突变后的源代码。'
- en: '[PRE110]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Again, we visualize mutants as difference from the original:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将突变体表示为与原始版本的差异：
- en: '[PRE111]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We add the `diff()` method to `Mutant` so that it can be called directly.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Mutant`类添加了`diff()`方法，以便可以直接调用。
- en: '[PRE112]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We are now ready to implement the actual evaluation. For doing that, we require
    the ability to accept the module where the test suite is defined, and invoke the
    test method on it. The method `getitem` accepts the test module, fixes the import
    entries on the test module to correctly point to the mutant module, and passes
    it to the test runner `MutantTestRunner`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备实施实际的评估。为此，我们需要能够接受定义测试套件的模块，并在其上调用测试方法。`getitem`方法接受测试模块，将测试模块上的导入条目固定为正确指向突变体模块，并将其传递给测试运行器`MutantTestRunner`。
- en: '[PRE115]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The `MutantTestRunner` simply calls all `test_` methods on the test module,
    checks if the mutant was discovered, and returns the result.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`MutantTestRunner`简单地调用测试模块上的所有`test_`方法，检查突变体是否被发现，并返回结果。'
- en: '[PRE116]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The mutation score is computed by `score()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 突变分数是通过`score()`函数计算的。
- en: '[PRE118]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Here is how we use our framework.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用我们的框架。
- en: '[PRE119]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `WeakShape` test suite resulted in only `20%` mutation score.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakShape`测试套件只产生了`20%`的突变分数。'
- en: '[PRE123]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: On the other hand, we were able to achieve `100%` mutation score with `StrongShapeTest`
    test suite.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们能够使用`StrongShapeTest`测试套件实现`100%`的突变分数。
- en: Here is another example, `gcd()`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，`gcd()`。
- en: '[PRE126]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We see that our `TestGCD` test suite is able to obtain `42%` mutation score.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的`TestGCD`测试套件能够获得`42%`的突变分数。
- en: The Problem of Equivalent Mutants
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等价突变体的问题
- en: One of the problems with mutation analysis is that not all mutants generated
    need to be faulty. For example, consider the `new_gcd()` program below.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 突变分析的一个问题在于，并非所有生成的突变体都需要是错误的。例如，考虑下面的`new_gcd()`程序。
- en: '[PRE131]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This program can be mutated to produce the following mutant.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序可以被突变以产生以下突变体。
- en: '[PRE132]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: While other mutants are faulty compared to the original, `mutant 1` is indistinguishable
    from the original in terms of its semantics because it removes an inconsequential
    assignment. This means that `mutant 1` does not represent a fault. These kinds
    of mutants that do not represent a fault are called *Equivalent mutants*. The
    problem with equivalent mutants is that it becomes very difficult to judge the
    mutation score in the presence of equivalent mutants. For example, with a mutation
    score of 70%, anywhere from 0 to 30% of the mutants may be equivalent. Hence,
    without knowing the actual number of equivalent mutants, it is impossible to judge
    how much the tests can be improved. We discuss two methods to deal with equivalent
    mutants.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始版本相比，其他突变体可能是错误的，但`mutant 1`在语义上与原始版本不可区分，因为它删除了一个无关紧要的赋值。这意味着`mutant 1`不代表错误。这类不代表错误的突变体被称为*等价突变体*。等价突变体的问题在于，在存在等价突变体的情况下，判断突变分数变得非常困难。例如，在70%的突变分数下，从0到30%的突变体可能是等价的。因此，不知道实际等价突变体的数量，就无法判断测试可以改进多少。我们讨论了两种处理等价突变体的方法。
- en: Statistical Estimation of Number of Equivalent Mutants
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 等价突变体数量的统计估计
- en: 'If the number of mutants that are alive is small enough, one may rely on simply
    inspecting them manually. However, if the number of mutants are sufficiently large
    (say > 1000), one may choose a smaller number of mutants from the alive mutants
    randomly and manually evaluate them to see whether they represent faults. The
    sample size determination is governed by the following formula for a binomial
    distribution (approximated by a normal distribution):'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存活的突变体数量足够少，人们可能可以简单地手动检查它们。然而，如果突变体的数量足够大（比如说 > 1000），人们可以从存活的突变体中随机选择较少的数量并手动评估它们，以查看它们是否代表错误。样本大小的确定由以下二项分布公式（通过正态分布近似）控制：
- en: $$ n \ge \hat{p}(1-\hat{p})\bigg(\frac{Z_{\frac{\alpha}{2}}}{\Delta}\bigg)^2
    $$
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: $$ n \ge \hat{p}(1-\hat{p})\bigg(\frac{Z_{\frac{\alpha}{2}}}{\Delta}\bigg)^2
    $$
- en: 'where $n$ is the number of samples, $p$ is the parameter for the probability
    distribution, $\alpha$ is the accuracy desired, $\Delta$ the precision. For an
    accuracy of $95\%$, $Z_{0.95}=1.96$. we have the following values (the maximum
    value of $\hat{p}(1-\hat{p}) = 0.25$) and $Z$ is the critical value for normal
    distribution:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 $n$ 是样本数量，$p$ 是概率分布的参数，$\alpha$ 是所需的精度，$\Delta$ 是精度。对于 95% 的精度，$Z_{0.95}=1.96$。我们有以下值（$\hat{p}(1-\hat{p})$
    的最大值为 0.25）和 $Z$ 是正态分布的临界值：
- en: $$ n \ge 0.25\bigg(\frac{1.96}{\Delta}\bigg)^2 $$
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: $$ n \ge 0.25\bigg(\frac{1.96}{\Delta}\bigg)^2 $$
- en: For $\Delta = 0.01$, (that is for a maximum error of 1%), we need to evaluate
    $9604$ mutants for equivalence. If one relaxes the constraint to $\Delta = 0.1$
    (that is an error of $10\%$), then one needs to evaluate only $96$ mutants for
    equivalence.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 $\Delta = 0.01$（即最大误差为 1%），我们需要评估 $9604$ 个突变体以确定等效性。如果将约束放宽到 $\Delta = 0.1$（即误差为
    10%），那么只需要评估 $96$ 个突变体以确定等效性。
- en: Statistical Estimation of the Number of Immortals by Chao's Estimator
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Chao 估计器对不死突变体数量的统计估计
- en: 'While the idea of sampling only a limited number of mutants is appealing, it
    is still limited in that manual analysis is necessary. If computing power is cheap,
    another way to estimate the number of true mutants (and hence the number of equivalent
    mutants) is by means of Chao''s estimator. As we will see in the chapter on [when
    to stop fuzzing](WhenToStopFuzzing.html), the formula is given by:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然仅采样有限数量的突变体的想法很有吸引力，但它仍然有限，因为需要手动分析。如果计算能力便宜，另一种通过 Chao 估计器估计真实突变体数量（因此是等效突变体数量）的方法是通过
    Chao 估计器。正如我们将在关于 [何时停止模糊测试](WhenToStopFuzzing.html) 的章节中看到的那样，公式如下：
- en: $$ \hat S_\text{Chao1} = \begin{cases} S(n) + \frac{f_1^2}{2f_2} & \text{if
    $f_2>0$}\\ S(n) + \frac{f_1(f_1-1)}{2} & \text{otherwise} \end{cases} $$
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \hat S_\text{Chao1} = \begin{cases} S(n) + \frac{f_1^2}{2f_2} & \text{if
    } f_2>0\\ S(n) + \frac{f_1(f_1-1)}{2} & \text{otherwise} \end{cases} $$
- en: The basic idea is to compute the result of the complete test matrix $T \times
    M$ of each test against each mutant. The variable $f_1$ represents the number
    of mutants that were killed exactly once, and the variable $f_2$ represents the
    number of variables that were killed exactly twice. $S(n)$ is the total number
    of mutants killed. Here, $\hat{S}_{Chao1}$ provides the estimate of the true number
    of mutants. If $M$ is the total mutants generated, then $M - \hat{S}_{Chao1}$
    represents the number of **immortal** mutants. Note that these **immortal** mutants
    are somewhat different from the traditional equivalent mutants in that the **mortality**
    depends on the oracle used to distinguish variant behavior. That is, if one uses
    a fuzzer that relies on errors thrown to detect killing, it will not detect mutants
    that produce different output but does not throw an error. Hence, the *Chao1*
    estimate will essentially be the asymptote value of mutants the fuzzer can detect
    if it is given an infinite amount of time. The **immortal** mutant estimate will
    approach true **equivalent** mutant estimate when the oracle used is sufficiently
    strong. For more details see the chapter on [when to stop fuzzing](WhenToStopFuzzing.html).
    A comprehensive guide to species discovery in testing is the paper by Boehme [[Böhme
    *et al*, 2018](https://doi.org/10.1145/3210309)].
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是计算每个测试对每个突变体的完整测试矩阵 $T \times M$ 的结果。变量 $f_1$ 表示恰好被杀死一次的突变体数量，而变量 $f_2$
    表示恰好被杀死两次的变量数量。$S(n)$ 是被杀死的突变体总数。在这里，$\hat{S}_{Chao1}$ 提供了真实突变体数量的估计。如果 $M$ 是生成的总突变体数量，那么
    $M - \hat{S}_{Chao1}$ 表示 **不死** 突变体的数量。请注意，这些 **不死** 突变体与传统等效突变体有些不同，因为 **死亡率**
    取决于用于区分变异行为的预言者。也就是说，如果使用依赖于抛出错误来检测杀死的模糊器，它将无法检测出产生不同输出但不抛出错误的突变体。因此，*Chao1* 估计将基本上是模糊器在给定无限时间的情况下可以检测到的突变体的渐近值。当使用的预言者足够强大时，**不死**
    突变体估计将接近真实的 **等效** 突变体估计。更多细节请参阅关于 [何时停止模糊测试](WhenToStopFuzzing.html) 的章节。测试中物种发现的全面指南是
    Boehme 等人于 2018 年发表的论文 [[Böhme 等人，2018](https://doi.org/10.1145/3210309)]。
- en: Lessons Learned
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: We have learned why structural coverage is insufficient to evaluate the quality
    of test suites.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解到为什么结构覆盖率不足以评估测试套件的质量。
- en: We have learned how to use Mutation Analysis for evaluating test suite quality.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解到如何使用突变分析来评估测试套件的质量。
- en: We have learned the limitations of Mutation Analysis -- Equivalent and Redundant
    mutants, and how to estimate them.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经了解到突变分析的局限性——等效和冗余突变体，以及如何估计它们。
- en: Next Steps
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: While naive fuzzing generates poor quality oracles, techniques such as [symbolic](SymbolicFuzzer.html)
    and [concolic](ConcolicFuzzer.html) can enhance the quality oracles used in fuzzing.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然简单的模糊测试生成质量较差的预言机，但诸如[符号](SymbolicFuzzer.html)和[条件](ConcolicFuzzer.html)等技术可以提高模糊测试中使用的预言机的质量。
- en: '[Dynamic invariants](DynamicInvariants.html) can also be of great help in improving
    the quality of oracles.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[动态不变量](DynamicInvariants.html)也可以在提高预言机质量方面大有帮助。'
- en: The chapter on [when to stop fuzzing](WhenToStopFuzzing.html) provides a detailed
    overview of the Chao estimator.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于[何时停止模糊测试](WhenToStopFuzzing.html)的章节提供了Chao估计器的详细概述。
- en: Background
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The idea of Mutation Analysis was first introduced by Lipton et al. [Lipton
    *et al*, 1971]. An excellent survey of mutation analysis research was published
    by Jia et al. [Jia *et al*, 2011]. The chapter on Mutation Analysis by Papadakis
    et al [Papadakis *et al*, 2019] is another excellent overview of the current trends
    in mutation analysis.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 突变分析的想法最初由Lipton等人提出[Lipton *et al*, 1971]。Jia等人发表了一篇关于突变分析研究的优秀调查[Jia *et al*,
    2011]。Papadakis等人关于突变分析的章节[Papadakis *et al*, 2019]也是对当前突变分析趋势的另一个优秀概述。
- en: Exercises
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: Arithmetic Expression Mutators'
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1：算术表达式突变器
- en: Our simple statement deletion mutation is only one of the ways in which a program
    could be mutated. Another category of mutants is *expression mutation* where arithmetic
    operators such as `{+,-,*,/}` etc. are replaced for one another. For example,
    given an expression such as
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单的语句删除突变只是程序可能突变的一种方式。另一类突变体是*表达式突变*，其中算术运算符（如`{+,-,*,/}`等）相互替换。例如，给定一个表达式如下
- en: '[PRE135]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: One can mutate it to
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将其突变成
- en: '[PRE136]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: and
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE137]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: and
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE138]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: First, we need to find out which node types we want to mutate. We get these
    via the ast functions and find that the node type is named BinOp
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找出我们想要突变的节点类型。我们通过ast函数获取这些信息，并发现节点类型被命名为BinOp
- en: '[PRE139]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: To mutate the tree, you thus need to change the `op` attribute (which has one
    of the values `Add`, `Sub`, `Mult`, and `Div`)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要突变树，因此你需要更改`op`属性（它具有`Add`、`Sub`、`Mult`和`Div`等值之一）
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)来练习并查看解决方案。'
- en: To mutate the tree, we need to change the `op` attribute (which has one of the
    values `Add`, `Sub`, `Mult`, and `Div`). Write a class `BinOpMutator` that does
    the necessary mutations, and then create a class `MuBinOpAnalyzer` as subclass
    of `MuFunctionAnalyzer` which makes use of `BinOpMutator`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要突变树，我们需要更改`op`属性（它具有`Add`、`Sub`、`Mult`和`Div`等值之一）。编写一个`BinOpMutator`类来完成必要的突变，然后创建一个`MuBinOpAnalyzer`类，它是`MuFunctionAnalyzer`的子类，并利用`BinOpMutator`。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)来练习并查看解决方案。'
- en: 'Exercise 2: Optimizing Mutation Analysis'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：优化突变分析
- en: Our technique for mutation analysis is somewhat inefficient in that we run the
    tests even on mutants that have mutations in code not covered by the test case.
    Test cases have no possibility of detecting errors on portions of code they do
    not cover. Hence, one of the simplest optimizations is to first recover the coverage
    information from the given test case, and only run the test case on mutants where
    the mutations lie in the code being covered by the test case. Can you modify the
    `MuFunctionAnalyzer` to incorporate recovering coverage as the first step?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行突变分析的技巧在效率上有些低，因为我们在测试那些在测试用例未覆盖的代码中的突变体时也会运行测试。测试用例没有检测它们未覆盖的代码部分错误的可能性。因此，最简单的优化之一是首先从给定的测试用例中恢复覆盖率信息，并且只对那些突变位于测试用例覆盖的代码中的突变体运行测试用例。你能修改`MuFunctionAnalyzer`以将恢复覆盖率作为第一步吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)来练习并查看解决方案。'
- en: 'Exercise 3: Byte Code Mutator'
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：字节码突变器
- en: We have seen how to mutate the AST given the source. One of the deficiencies
    with this approach is that the Python bytecode is targeted by other languages
    too. In such cases, the source may not be readily converted to a Python AST, and
    it is desirable to mutate the bytecode instead. Can you implement a bytecode mutator
    for Python function that mutates the bytecode instead of fetching the source and
    then mutating it?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何根据源代码进行突变。这种方法的一个缺点是Python字节码也被其他语言针对。在这种情况下，源代码可能无法直接转换为Python AST，而突变字节码是更可取的。你能实现一个针对Python函数的字节码突变器，该突变器直接突变字节码而不是先获取源代码然后进行突变吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)来处理练习并查看解决方案。'
- en: 'Exercise 4: Estimating Residual Defect Density'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：估计残留缺陷密度
- en: The defect density of a program is the number of defects in a program that that
    were detected before release divided by the program size. The residual defect
    density is the percentage of defects that escaped detection. While estimation
    of the real residual defect density is difficult, mutation analysis can provide
    an upper bound. The number of mutants that remain undetected is a plausible upper
    bound on the number of defects that remain within the program. However, this upper
    bound may be too wide. The reason is that some remaining faults can interact with
    each other, and if present together, can be detected by the available test suite.
    Hence, a tighter bound is the number of mutants that can exist *together* in a
    given program without being detected by the given test suite. This can be accomplished
    by starting with the complete set of mutations possible, and applying delta-debugging
    from [the chapter on reducing](Reducer.html) to determine the minimum number of
    mutations that need to be removed to make the mutant pass undetected by the test
    suite. Can you produce a new `RDDEstimator` by extending the `MuFunctionAnalyzer`
    that estimates the residual defect density upper bound using this technique?
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的缺陷密度是指程序在发布前检测到的缺陷数量除以程序大小。残留缺陷密度是逃逸检测的缺陷百分比。虽然估计实际的残留缺陷密度很困难，但突变分析可以提供一个上限。未检测到的突变数量是程序内剩余缺陷数量的一个合理的上限。然而，这个上限可能太宽。原因是某些剩余的错误可能相互影响，如果同时存在，可能被现有的测试套件检测到。因此，一个更紧的上限是在给定程序中可以存在而不会被给定测试套件检测到的突变数量。这可以通过从可能的完整突变集开始，并应用来自[减少章节](Reducer.html)的delta-debugging来确定需要移除的最小突变数量来实现，以使突变通过测试套件不被检测到。你能通过扩展`MuFunctionAnalyzer`来生成一个新的`RDDEstimator`，该`RDDEstimator`使用这种技术估计残留缺陷密度的上限吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)来处理练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:06+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/MutationAnalysis.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)的许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，受[MIT
    许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)的许可。
    [最后更改：2023-11-11 18:18:06+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/MutationAnalysis.ipynb)
    • [引用](#citation) • [印记](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Mutation Analysis](https://www.fuzzingbook.org/html/MutationAnalysis.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/MutationAnalysis.html](https://www.fuzzingbook.org/html/MutationAnalysis.html).
    Retrieved 2023-11-11 18:18:06+01:00.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈亚斯·策勒，拉胡尔·戈皮纳特，马塞尔·博hme，戈登·弗莱泽，以及克里斯蒂安·霍勒："[突变分析](https://www.fuzzingbook.org/html/MutationAnalysis.html)"。收录于安德烈亚斯·策勒，拉胡尔·戈皮纳特，马塞尔·博hme，戈登·弗莱泽，以及克里斯蒂安·霍勒所著的"[模糊测试书](https://www.fuzzingbook.org/)"中。[https://www.fuzzingbook.org/html/MutationAnalysis.html](https://www.fuzzingbook.org/html/MutationAnalysis.html)。检索日期：2023-11-11
    18:18:06+01:00.
- en: '[PRE141]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
