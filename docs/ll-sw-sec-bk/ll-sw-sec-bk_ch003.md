# 3 隐蔽通道和侧信道

侧信道和隐蔽通道是系统内两个实体之间的通信通道，其中实体不应能够以这种方式进行通信。

**隐蔽通道**是一种两个实体都意图进行通信的通道。**侧信道**是一种一个实体是使用该通道进行攻击的攻击的受害者的通道。

隐蔽通道和侧信道之间的区别在于两个实体是否都意图进行通信。在侧信道攻击中，不意图进行通信的实体被称为**受害者**。另一个实体有时被称为**间谍**。

由于我们在这本书中关注攻击，因此在本章的其余部分我们主要使用侧信道这个术语。

接下来的几节将描述各种侧信道。每个部分都专注于通过所谓的微架构方面（如执行时间、缓存状态或分支预测器状态）的泄露。

## 3.1 时间侧信道

如果加密算法的运行时间受处理的数据值的影响，则其实现可能会泄露关于其处理的数据的信息。利用这种攻击的攻击被称为时间攻击。

防御此类攻击的主要措施是仔细实现算法，确保执行时间与处理的数据无关。这可以通过确保以下两点来实现：

1.  控制流，即执行指令的轨迹，不会根据处理的数据而改变。这保证了每次算法运行时，都会执行完全相同的指令序列，而不依赖于处理的数据。

1.  实现算法所使用的指令来自那些执行时间已知不依赖于处理的数据值的指令子集。

    例如，在 Arm 架构中，Armv8.4-A [DIT 扩展](https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/DIT--Data-Independent-Timing)保证了 AArch64 指令子集的执行时间与数据无关。

    通过确保扩展已启用并且只使用子集中的指令，可以保证数据无关的执行时间。

目前，我们不知道有任何编译器实现能够积极帮助保证（a）和（b）。

使用编译器技术将函数转换为尊重属性(a)是一个活跃的研究领域。[@Wu2018]提供了一种将程序转换为尊重属性(a)的方法，尽管可能会引入不安全的内存访问。[@Soares2021]通过不引入不安全的内存访问改进了该结果，尽管可能需要更改转换函数的接口。还讨论了在[Constatine 编译器](https://github.com/pietroborrello/constantine)中实现的技巧 [#172](https://github.com/llsoftsec/llsoftsecbook/issues/172)。还讨论了 Jasmin 语言和编译器 [1](https://members.loria.fr/VLaporte/files/CCS2021_StructuredLeakage.pdf) [2](https://dl.acm.org/doi/10.1145/3548606.3560689) [#213](https://github.com/llsoftsec/llsoftsecbook/issues/213)

在[@Pornin2018]中找到了一个很好的参考资料，提供了关于如何实现(a)、(b)以及更多针对加密内核的安全强化属性的实用建议。

如[@Pornin2018]中所述，在实现加密算法时，还需要考虑缓存侧信道攻击，这些攻击在缓存侧信道攻击部分中进行了讨论。

## 3.2 缓存侧信道

[缓存](https://en.wikipedia.org/wiki/Cache_(computing))几乎用于每个计算系统中。它们是比主存储器快得多的小型存储器。它们会自动保留最频繁使用的数据，从而提高平均内存访问时间。

当进程共享缓存时，存在各种技术来建立隐蔽通信通道。这些技术允许进程通过内存访问进行通信，即使它们不共享任何内存位置。我们首先描述缓存的工作原理，然后再探讨这些技术。

### 3.2.1 典型的 CPU 缓存架构

CPU 缓存微架构的细节有很多种，但用于设置隐蔽信道的最重要的主要特征在大多数流行实现中往往相似。

缓存是小型且比主存储器快得多的存储器，旨在保留最频繁访问的主存储器地址的数据副本。随着程序执行，最频繁使用的地址集合会迅速变化。因此，CPU 缓存的地址也会随时间快速演变。缓存的每次读取或写入指令执行后，其内容都可能发生变化。

在每次读取和写入指令中，缓存微架构都会查找请求地址的数据是否恰好存在于缓存中。如果是，CPU 可以继续快速执行；如果不是，依赖的操作将不得不等待数据从较慢的主内存返回。典型的访问时间是 CPU 上最快的缓存为 3 到 5 个 CPU 周期，而主内存访问需要数百个周期。当数据在读取或写入时存在于缓存中，它被称为**缓存命中**。否则，它被称为**缓存未命中**。

大多数系统具有多个缓存级别，每个级别在缓存大小和访问时间之间有不同的权衡。一些典型的特征可能包括：

+   L1（第 1 级）缓存，大小为 32KB，访问时间为 4 周期。

+   L2 缓存，大小为 256KB，访问时间为 10 周期。

+   L3 缓存，大小为 16MB，访问时间为 40 周期。

+   主内存，大小为千兆字节，访问时间超过 100 周期。

![典型系统中缓存级别的示意图](img/file6.svg)

典型系统中缓存级别的示意图

如果数据尚未存在于缓存层中，通常在从较慢的缓存级别或主内存中检索后存储在那里。这通常是一个好的决定，因为程序很快就会访问相同的地址。这种高可能性被称为[局部性原理](https://en.wikipedia.org/wiki/Locality_of_reference)]。

数据以对齐内存块的形式存储并在缓存级别之间传输。这样的块被称为**缓存块**或**缓存行**。典型的缓存行大小为每行 32、64 或 128 字节。

当需要将之前不在缓存中的数据存储到缓存中时，必须通过移除或**驱逐**一些其他地址/数据来为它腾出空间。如何做出这个选择由[缓存替换策略](https://en.wikipedia.org/wiki/Cache_replacement_policies)]决定。流行的替换算法包括最近最少使用（LRU）、随机和伪-LRU。正如其名称所暗示的，LRU 驱逐最不常使用的缓存行；随机选择一个随机的缓存行；伪-LRU 近似选择最不常使用的行。

如果一个缓存行可以存储在缓存中所有可用的位置，则该缓存是**全关联**的。然而，大多数缓存都不是全关联的，因为实现成本太高。相反，大多数缓存是**集合关联**的。在一个 N 路集合关联缓存中，一个特定的行只能存储在 N 个缓存位置中的一个。例如，如果一个行可以潜在地存储在 2 个位置中的一个，那么该缓存被称为 2 路集合关联。如果它可以存储在 4 个位置中的一个，那么它被称为 4 路集合关联，依此类推。当一个地址只能存储在缓存中的一个位置时，它被称为**直接映射**，而不是 1 路集合关联。典型的组织方式是直接映射、2 路、4 路、8 路、16 路或 32 路集合关联。

一个特定的缓存行可以存储的缓存位置集合被称为**缓存集**。

#### 3.2.1.1 集合关联缓存中的索引

对于某些缓存隐蔽通道，了解内存地址如何映射到特定的缓存集是至关重要的。

![集合关联缓存索引的示意图。在这个例子中：L = 6 位，因此缓存行大小为 2⁶=64 字节。S = 5 位，所以有 2⁵=32 个缓存集。N 可以与用于索引缓存的地址位无关。如果我们假设 N=12 为一个 12 路集合关联缓存，则总缓存大小为 N*2^L*2^S=12*64*32=24KB。](img/file7.svg)

**集合关联缓存**的索引示例。在这个例子中：*L* = 6 位，因此缓存行大小为 2⁶ = 64 字节。*S* = 5 位，所以有 2⁵ = 32 个缓存集。*N*可以与用于索引缓存的地址位无关。如果我们假设*N* = 12 为一个 12 路集合关联缓存，则总缓存大小为*N* * 2^(*L*) * 2^(*S*) = 12 * 64 * 32 = 24KB。

内存地址中的特定位用于不同的缓存索引目的，如图@fig:cache-indexing 所示。最不重要的*L*位，其中 2^(*L*)是缓存行大小，用于计算地址在缓存行内的偏移量。下一个*S*位，其中 2^(*S*)是缓存集的数量，用于确定地址映射到哪个缓存集。剩余的最高位是“标签位”。它们与缓存中的一行一起存储，以便后续操作可以检测哪个特定的内存地址在缓存行中重复。

对于直接映射和全关联缓存，地址到缓存位置的映射也如上所述。在全关联缓存中，缓存集的数量为 1，因此*S*=0。

还要解释缓存一致性缓存一致性？ [#173](https://github.com/llsoftsec/llsoftsecbook/issues/173)

还要谈谈 TLBs 和预取？ [#174](https://github.com/llsoftsec/llsoftsecbook/issues/174)

### 3.2.2 缓存旁路通道的操作

缓存旁路通道通常通过间谍确定内存访问是缓存命中还是缓存未命中来工作。从这个信息中，间谍可能能够推断出只有受害者应该能够访问的数据位。

让我们通过描述几个著名的缓存侧信道来阐述这一点：

#### 3.2.2.1 Flush+Reload

在所谓的**Flush+Reload**攻击[@Yarom2014]中，间谍进程与受害者进程共享内存。攻击分为 3 个步骤：

1.  Flush 步骤：间谍从缓存中刷新一个特定的地址。

1.  间谍等待一段时间，给受害者时间可能访问该地址，从而将其带回缓存。

1.  Reload 步骤：间谍访问地址并测量访问时间。短的访问时间意味着地址在缓存中；长的访问时间意味着它不在缓存中。换句话说，短的访问时间意味着在步骤 2 中受害者访问了该地址；长的访问时间意味着它没有访问该地址。

是否应该有一个更详细的示例，包含代码，以更详细地展示 flush+reload 攻击的工作原理？ [#175](https://github.com/llsoftsec/llsoftsecbook/issues/175)

知道受害者是否访问了特定的地址可能会泄露敏感信息。例如，当访问特定的数组元素取决于秘密数据中是否设置了特定的位时。例如，[@Yarom2014]演示了可以使用 Flush+Reload 攻击来泄露 GnuPG 私钥。

#### 3.2.2.2 Prime+Probe

在**Prime+Probe**攻击中，受害者和间谍之间无需共享内存。攻击分为 3 个步骤：

1.  Prime 步骤：间谍通过访问映射到这些缓存集的数据，例如，填充一个或多个缓存集。

1.  间谍等待一段时间，让受害者可能访问那些相同的缓存集映射的数据。

1.  Probe 步骤：间谍访问与 Prime 步骤中相同的数据。测量加载数据所需的时间，可以推导出受害者从每个缓存集中驱逐了多少缓存行，并据此推导出受害者访问的地址信息。

[@Osvik2005]于 2005 年首次记录了这项技术，并展示了只需几毫秒即可提取 AES 密钥。

#### 3.2.2.3 缓存隐蔽通道的一般方案

一个细心的读者可能已经注意到，上述描述的攻击遵循一个类似的 3 步骤模式。[@Weber2021]描述了这种一般模式，并使用它自动发现更多遵循此 3 步骤模式的侧信道。他们将这种一般模式描述为：

1.  一个重置内部 CPU 状态（**重置序列**）的指令序列。

1.  一个触发状态变化的指令序列（**触发序列**）。

1.  一个泄露内部状态（**测量序列**）的指令序列。

其他遵循此一般 3 步骤方法的基于缓存的侧信道攻击包括：Flush+Flush[@Gruss2016a]、Flush+Prefetch[@Gruss2016]、Evict+Reload[@Percival2005]、Evict+Time[@Osvik2005]、Reload+Refresh[@Briongos2020]、Collide+Probe[@Lipp2020]等。

### 3.2.3 缓存侧信道攻击缓解

如[@Su2021]所述，为了使基于缓存的侧信道攻击成功，需要满足 3 个条件：

1.  缓存状态的变化与受害者程序中的敏感信息之间存在映射。

1.  间谍程序在运行在共享与受害者运行的 CPU 相同缓存级别的 CPU 上。

1.  间谍程序可以通过自己的缓存状态推断出由受害者引起的缓存状态变化。

针对缓存旁路攻击的缓解措施可以根据它们旨在防止上述哪 3 个条件发生来进行分类：

#### 3.2.3.1 通过解耦受害者程序中的缓存状态变化与敏感信息的缓解措施

当一个程序使用秘密信息来索引数组时，缓存状态变化可能与敏感信息相关联的典型例子是。攻击者可以通过观察哪个缓存行被检索来推导出秘密信息的一部分。

尤其是在加密内核中，使用秘密值索引数组通常是被避免的。一种替代的缓解措施是始终访问所有数组索引，而不管秘密值如何，例如，在 PuTTY 项目的[提交 46fbe375](https://git.tartarus.org/?p=simon/putty.git;a=commitdiff;h=46fbe375bf)中所做的那样，该项目包含以下注释：

> ```asm
> * Side-channel considerations: the exponent is secret, so
> * actually doing a single table lookup by using a chunk of
> * exponent bits as an array index would be an obvious leak of
> * secret information into the cache. So instead, in each
> * iteration, we read _all_ the table entries, and do a sequence
> * of mp_select operations to leave just the one we wanted in the
> * variable
> ```

#### 3.2.3.2 禁止间谍程序与受害者程序共享缓存的缓解措施

如果受害者和间谍没有共享一个公共通道——在这种情况下是一个缓存级别——那么就无法创建一个旁路通道。

实现这一点的办法是只允许一个程序同时运行，当发生上下文切换时，清除所有缓存内容。显然，这会对性能产生巨大影响，尤其是在具有多个核心和大型缓存的系统中。因此，已经提出了各种各样的缓解措施，旨在使攻击变得稍微困难一些，同时不会损失太多的系统效率。[Mushtaq2020]和[Su2021]总结了数十个提案和实现——太多以至于无法在这里全部描述。

一种流行的缓解措施是禁用[CPU 多线程](https://en.wikipedia.org/wiki/Multithreading_(computer_architecture))。例如，[Azure 建议运行不受信任代码的用户应考虑禁用 CPU 多线程](https://learn.microsoft.com/en-us/azure/virtual-machines/mitigate-se)。[Linux 内核的核心调度文档](https://www.kernel.org/doc/Documentation/admin-guide/hw-vuln/core-scheduling.rst)也指出，互不信任的代码不应在同一个核心上同时运行。它实现了一个调度器，该调度器[考虑哪些进程是相互信任的](https://lwn.net/Articles/861251/)，并且只允许那些进程在同一个核心上同时运行。

有些人可能会认为，在许多网络浏览器中实现的[网站隔离](https://developer.chrome.com/blog/site-isolation/)也是一种缓解措施，它也属于这一类别。网站隔离在其自己的部分中描述得更为详细。

#### 3.2.3.3 通过禁用间谍程序来推断受害者程序通过其自己的缓存状态变化缓存状态变化

在某些情况下，间谍程序可测量的最小时间增量可以减少到如此程度，以至于很难区分缓存命中和未命中。向计时器注入噪声和抖动也使得区分缓存命中和未命中更加困难。这是 JavaScript 引擎对抗 Spectre 攻击的缓解措施之一。更多信息请参阅这篇[v8 博客文章](https://v8.dev/blog/spectre)或这篇[Firefox 性能.now()方法文档](https://developer.mozilla.org/en-US/docs/Web/API/Performance/now)。

注意，这并不是完美的缓解措施——攻击者通常有出人意料的方法可以获得足够精细的时间计时器或使用统计方法来检测缓存命中或未命中的差异。一个极端的例子是 NetSpectre 攻击[@Schwarz2019]，它通过统计分析网络数据包响应的延迟来测量缓存命中和未命中的差异。此外，[@Schwarz2017]展示了如何在所有已移除显式精细计时器的浏览器中以各种间接方式构建高分辨率计时器。

另一种可能性是在受害者运行和间谍运行的时间之间清除缓存。这可能会带来相当大的性能开销，并且可能并不总是可行，例如，当受害者和间谍在同一时间在共享同一缓存级别的 2 个 CPU 上运行时。

## 3.3 基于分支预测器的旁路通道

### 3.3.1 分支预测器

大多数 CPU 实现一个或多个[指令流水线](https://en.wikipedia.org/wiki/Instruction_pipelining)。在指令流水线中，下一条指令在上一条指令完成执行之前就开始执行。当上一条指令是分支指令时，需要执行的下一条指令只有在分支指令完成时才知道。然而，在开始下一条指令之前等待分支指令完成会导致巨大的性能损失。1 因此，大多数 CPU 在分支指令完成之前预测分支后需要执行的指令。正确且快速地预测分支指令后的指令对于性能至关重要，以至于大多数 CPU 都有多个[分支预测器](https://en.wikipedia.org/wiki/Branch_predictor)，例如：

+   预测条件分支的结果：是否执行。预测通常基于历史数据，即基于最近过去此分支和其他分支的结果。

+   预测已执行分支的目标，即分支后下一条指令的地址。

+   专门预测函数返回指令后下一条指令的预测器。

### 3.3.2 通过分支预测器的旁路通道

在过去几年中已经描述了许多攻击。以下各节列出了几个例子，按它们针对的分支预测器组件进行分类。

#### 3.3.2.1 条件分支方向预测器旁路攻击

两个例子是 BranchScope [@Evtyushkin2018] 和 BlueThunder [@Huo2019]。这些攻击推断受害进程中的分支是否被取或未被取。它们通过确保间谍进程中的一个分支使用与受害进程中的目标分支相同的分支预测器条目来实现。通过测量间谍进程中的分支是否被正确预测，可以推断受害进程中的分支是否被取。

这可以被认为与 Prime+Probe 基于缓存的旁路攻击有些相似。

当分支的结果取决于秘密键中的一个位时，这可以使攻击者推导出秘密键的值。这些论文展示了从特定加密内核的实现中推导出秘密键。它也可以用来破坏 ASLR。

#### 3.3.2.2 分支目标预测器旁路攻击

两个例子是 SBPA [@Aciicmez2007] 和 BranchShadow [@Lee2017]。这些早期的攻击基于在间谍进程中创建一个分支，使其在分支目标缓冲器（BTB）中与受害进程中的目标分支发生别名。它们使用时间差异、最后分支记录、指令跟踪或性能计数器来测量间谍进程中的分支是否在 BTB 中引起特定的状态变化。

#### 3.3.2.3 返回地址预测器旁路攻击

一个例子是 Hyper-Channel [@Bulygin2008]。在这种情况下，间谍进程调用*N*次来填充返回栈预测器。然后它让受害进程执行。然后，间谍进程可以通过测量*N*次返回中误预测的数量来测量其返回栈条目中有多少被从返回栈缓冲器（RSB）中移除。如果受害进程中的调用次数依赖于秘密信息，这可能会泄露它。

上文提到的论文详细解释了他们如何设置攻击。所有这些攻击都使用一个通用的 3 步方法，类似于缓存旁路通道：

1.  一个由间谍进程运行的指令序列，用于重置分支预测器状态（*重置序列*）。

1.  一个由受害进程运行的指令序列，触发分支预测器状态变化（*触发序列*）。

1.  一个由间谍进程运行的指令序列，泄露分支预测器状态（*测量序列*）。

### 3.3.3 缓解措施

描述针对这些旁路攻击提出的缓解措施。[#203](https://github.com/llsoftsec/llsoftsecbook/issues/203)

## 3.4 资源竞争通道

## 3.5 利用其他预测器中别名化的通道

我们是否也应该在这里讨论更多“隐蔽”的通道，例如功率分析等？[#176](https://github.com/llsoftsec/llsoftsecbook/issues/176)

## 3.6 临时执行攻击

### 3.6.1 临时执行

#### 3.6.1.1 投机执行

CPU 执行指令序列。序列中的指令之间通常存在依赖关系。这意味着一个指令的结果会影响后续指令的执行。

除了最小的微控制器之外，所有 CPU 都会并行执行多个指令。有时甚至同时执行数百条指令，它们处于各种执行阶段。指令在可能数百条之前的指令尚未产生结果的情况下开始执行。当之前的一个指令（可能尚未完全执行）的输出可能会影响后续指令的执行时，CPU 如何实现这一点？换句话说，一个尚未完成的指令和 CPU 已经开始执行的后续指令之间可能存在**依赖关系**。

存在多种类型的依赖关系。一种类型是**控制依赖**，即后续指令是否应该执行完全取决于早期指令的结果。其他类型包括**真实数据依赖**、**反依赖**和**输出依赖**。关于这些依赖关系的更多详细信息可以在[维基百科页面](https://en.wikipedia.org/wiki/Data_dependency)上找到。

CPU 通过大量**预测**来克服由依赖关系强加的并行执行限制。例如，大多数 CPU 会预测条件分支是否被取用，这实际上是对控制依赖的预测。另一个例子是 CPU 预测一个加载操作是否访问与之前存储操作相同的内存地址。如果它们不访问相同的内存位置，加载操作可以与存储操作并行运行，因为它们之间没有数据依赖。如果它们访问重叠的内存位置，则存在依赖关系，存储操作应该在加载操作开始执行之前完成。

在解决所有依赖关系之前，根据预测开始执行后续指令称为**投机**。

让我们用一个例子来说明这一点。以下 C 代码

```asm
[](#cb2-1)long abs(long a) {
[](#cb2-2)  if (a >= 0)
[](#cb2-3)    return a;
[](#cb2-4)  else
[](#cb2-5)    return -a;
[](#cb2-6)}
```

可以翻译为以下 AArch64 汇编代码：

```asm
[](#cb3-1)        cmp     x0, #0
[](#cb3-2)        b.ge    Lbb2
[](#cb3-3)Lbb1:
[](#cb3-4)        neg     x0, x0
[](#cb3-5)Lbb2:
[](#cb3-6)        ret
```

`b.ge` 指令是一个条件分支指令。它计算下一条指令是否应该是紧随其后的指令，或者是标签 `Lbb2` 所指向的指令。如果它是紧随其后的指令，则说分支没有被采取。相反，如果它是标签 `Lbb2` 所指向的指令，则说分支被采取了。当条件 `.ge`（大于或等于）为真时，分支被采取。这个条件是由前一条指令，即 `cmp x0, #0` 指令定义或设置的，该指令比较寄存器 `x0` 中的值与 0。因此，`cmp` 指令和 `b.ge` 指令之间存在依赖关系。为了克服这种依赖关系，并能够并行执行 `cmp`、`b.ge` 以及可能更多的指令，CPU 预测分支指令的结果。换句话说，它预测分支是被采取还是不被采取。CPU 将选择 `neg` 或 `ret` 指令以开始执行下一条指令。这被称为 *speculation*，因为 CPU *推测性地执行* 任意指令 `neg` 或 `ret`。

展示一个不基于分支预测的 CPU 推测的第二个例子。[#177](https://github.com/llsoftsec/llsoftsecbook/issues/177)

当然，与所有预测一样，CPU 有时会预测错误。在这种情况下，需要撤销影响程序正确执行的所有系统状态的变化。在上面的例子中，如果分支应该被采取，但 CPU 预测它不会被采取，则 `neg` 指令会被错误执行并改变寄存器 `x0` 中的值。在发现分支被错误预测后，CPU 将不得不恢复寄存器 `x0` 中的正确、未被取反的值。

在所谓的**误猜测**下执行的任何指令被称为**瞬态指令**。2

上面的段落说“*影响程序正确执行的系统状态需要被撤销*”。有许多系统状态不影响程序的正确执行。瞬态指令对这些系统状态的更改通常不会被撤销。

例如，一个瞬态加载指令可以将一个之前不在缓存中的值加载到缓存中。通过将这个值带入缓存，它可能会将另一个值从缓存中驱逐出去。一个值是否存在于缓存中不影响程序的正确执行；它仅仅影响其执行速度。因此，瞬态执行对缓存内容的影响通常在检测到误猜测时不会被撤销。

有时，人们说需要撤销瞬态指令的**架构效应**，但不需要撤销**微架构效应**。

上述解释描述了架构效应作为在检测到误预测后需要撤销的系统状态变化。在现实中，大多数系统将实现技术，将所有状态变化保留在微架构缓冲区中，直到确定对执行该指令的所有预测都是正确的。到那时，微架构状态将被**提交**成为架构状态。这样，误预测自然不会影响架构状态。我们能否找到一个好的参考资料，更详细地解释微架构状态与架构状态？《计算机架构：定量方法》是否是最佳参考资料？

**产生错误的指令**是指在运行时产生异常的指令。许多指令可以产生异常，因此是**可能产生错误的**。例如，大多数加载和存储指令在访问的地址未映射时会产生异常。由于如此多的指令可以产生异常，处理器通常推测它们不会产生异常，以便实现更多的并行执行。

当一条指令产生错误时，执行通常会继续在另一个位置。在检测到错误之前，任何被推测执行的后续指令也被称为**瞬态指令**。

每一条可能产生错误的指令与下一条指令之间存在一种控制依赖关系，因为下一条要执行的指令取决于该指令是否产生异常。我们将这种依赖关系单独提出来，作为我们接下来要描述的瞬态执行攻击的分类依据，这些攻击根据是否在预测错误后或错误指令后使用瞬态指令来分类。

### 3.6.2 瞬态执行攻击

**瞬态执行攻击**是一类侧信道攻击，它利用瞬态执行的微架构副作用作为侧信道。

2018 年 Spectre [@Kocher2019] 和 Meltdown [@Lipp2018] 攻击的发布开启了一个时期，在这个时期内发现了大量瞬态攻击并被公布。其中大多数都有特定的名称，如 ZombieLoad、NetSpectre、LVI、Straight-line Speculation 等。新的变体仍在定期发布。

在这里详细讨论每一个攻击会使本书过于冗长，并且可能不会对更好地了解瞬态攻击的共同特征有很大帮助。因此，我们将尝试将它们归入几个类别，并描述每个类别的特征。

决定是否需要讨论瞬态执行攻击的替代分类，如果是的话，请添加内容。考虑引用[`github.com/MattPD/cpplinks/blob/master/comparch.micro.channels.md`](https://github.com/MattPD/cpplinks/blob/master/comparch.micro.channels.md)。

以下分类基于[@Bulck2020]提出的一个分类。存在其他分类方式。[@Bulck2020]根据是否：

1.  瞬态执行发生是因为预测错误或故障指令。

1.  攻击者是否积极引导瞬态执行的数据或控制流。

这给出了以下 4 个类别：

|  | 攻击者是否引导瞬态执行？ |
| --- | --- |
| 否（泄露） | 是（注入） |
| --- | --- |
| 预测错误 | 基于分支预测器的侧信道 | Spectre-style 攻击 |
| 故障 | Meltdown-style 攻击 | LVI-style 攻击 |

#### 3.6.2.1 基于分支预测器的侧信道攻击

我们已经在通过分支预测器的侧信道这一节中讨论了这一类别。

#### 3.6.2.2 Spectre-style 攻击

添加关于 Spectre-style 攻击的描述，例如 Spectre-PHT、Spectre-BTB、Spectre-RSB、Spectre-STL、SpectreV1、SpectreV2、SpectreV3、SpectreV4、NetSpectre。[#178](https://github.com/llsoftsec/llsoftsecbook/issues/178)

#### 3.6.2.3 Meltdown-style 攻击

添加关于 Meltdown-style 攻击的描述，例如 Meltdown、Foreshadow、LazyFP、Fallout、ZombieLoad、RIDL。[#178](https://github.com/llsoftsec/llsoftsecbook/issues/178)

#### 3.6.2.4 LVI-style 攻击

添加关于 LVI-style 攻击的描述。[#178](https://github.com/llsoftsec/llsoftsecbook/issues/178)

### 3.6.3 针对瞬态执行攻击的缓解措施

#### 3.6.3.1 网站隔离

在网站隔离部分添加关于 SpectreV1 缓解措施的章节 [#179](https://github.com/llsoftsec/llsoftsecbook/issues/179)

## 3.7 物理访问侧信道攻击

* * *
