# （三）：应用 Wireshark IO 图形工具分析数据流

基本**IO Graphs:**

IO graphs 是一个非常好用的工具。基本的 Wireshark IO graph 会显示抓包文件中的整体流量情况，通常是以每秒为单位（报文数或字节数）。默认 X 轴时间间隔是 1 秒，Y 轴是每一时间间隔的报文数。如果想要查看每秒 bit 数或 byte 数，点击“Unit”，在“Y Axis”下拉列表中选择想要查看的内容。这是一种基本的应用，对于查看流量中的波峰/波谷很有帮助。要进一步查看，点击图形中的任意点就会看到报文的细节。

为了讲解方便，点击[示例报文包](https://www.cloudshark.org/captures/d6f9e83699c8)，或用自己的 wireshark 点击 Statistics – IO Graphs。这个抓包是 HTTP 下载遇到报文丢失的情况。

注意：过滤条件为空，此图形显示所有流量。

这个默认条件下的显示在大多数 troubleshooting 中并不是非常有用。将 Y 轴改为 bits/tick 这样就可以看到每秒的流量。从这张图可以看到峰值速率是 300kbps 左右。如果你看到有些地方流量下降为零，那可能是一个出问题的点。这个问题在图上很好发现，但在看报文列表时可能不那么明显。

**过滤：**

每一个图形都可以应用一个过滤条件。这里创建两个不同的 graph，一个 HTTP 一个 ICMP。可以看到过滤条件中 Graph 1 使用“http”Graph 2 使用“icmp”。图中可以看到红色 ICMP 流量中有些间隙，进一步分析。

创建两个图形，一个显示 ICMP Echo（Type=8）一个显示 ICMP Reply（Type=0）。正常情况下对于每一个 echo 请求会有一个连续的 reply。这里的情况是：

可以看到红色脉冲线(icmp type==0 – ICMP Reply)中间有间隙，而整张图中 ICMP 请求保持连续。这意味着有些 reply 没有接收到。这是由于报文丢失导致的 reply drop。CLI 中看到的 ping 信息如下：

**常用排错过滤条件****:**

对于排查网络延时/应用问题有一些过滤条件是非常有用的：

**tcp.analysis.lost_segment**：表明已经在抓包中看到不连续的序列号。报文丢失会造成重复的 ACK，这会导致重传。

**tcp.analysis.duplicate_ack：**显示被确认过不止一次的报文。大凉的重复 ACK 是 TCP 端点之间高延时的迹象。

**tcp.analysis.retransmission：**显示抓包中的所有重传。如果重传次数不多的话还是正常的，过多重传可能有问题。这通常意味着应用性能缓慢和/或用户报文丢失。

**tcp.analysis.window_update：**将传输过程中的 TCP window 大小图形化。如果看到窗口大小下降为零，这意味着发送方已经退出了，并等待接收方确认所有已传送数据。这可能表明接收端已经不堪重负了。

**tcp.analysis.bytes_in_flight：**某一时间点网络上未确认字节数。未确认字节数不能超过你的 TCP 窗口大小（定义于最初 3 此 TCP 握手），为了最大化吞吐量你想要获得尽可能接近 TCP 窗口大小。如果看到连续低于 TCP 窗口大小，可能意味着报文丢失或路径上其他影响吞吐量的问题。

**tcp.analysis.ack_rtt：**衡量抓取的 TCP 报文与相应的 ACK。如果这一时间间隔比较长那可能表示某种类型的网络延时（报文丢失，拥塞，等等）。

在抓包中应用以上一些过滤条件：

注意：Graph 1 是 HTTP 总体流量，显示形式为 packets/tick，时间间隔 1 秒。Graph 2 是 TCP 丢失报文片段。Graph 3 是 TCP 重复 ACK。Graph 4 是 TCP 重传。

从这张图可以看到：相比于整体 HTTP 流量，有很多数量的重传以及重复 ACK。从这张图中，可以看到这些事件发生的时间点，以及在整体流量中所占的比例。

**函数****:**

IO Graphs 有六个可用函数：SUM, MIN, AVG, MAX, COUNT, LOAD。

**MIN( ), AVG( ), MAX( )**

首先看一下帧之间的最小，平均和最大时间，这对于查看帧/报文之间的延时非常有用。我们可以将这些函数结合“**frame.time_delta****”**过滤条件看清楚帧延时，并使得往返延时更为明显。如果抓包文件中包含不同主机之间的多个会话，而只想知道其中一个 pair，可将“**frame.time_delta**”结合源和目标主机条件如“ip.addr==x.x.x.x &&ip.addr==y.y.y.y”。如下图所示：

我们做了以下步骤：

*   将 Y 轴设置为“Advanced”，让 Caculation 域可见。不做这一步就看不到计算选项。
*   X 轴时间间隔 1 秒，所以每个柱状图代表 1 秒间隔的计算结果。
*   过滤出两个特定 IP 地址的 HTTP 会话，使用条件：“(ip.addr==192.168.1.4&& ip.addr==128.173.87.169) && http”。
*   使用 3 个不同的 graph，分别计算 Min(), Avg(), Max()。
*   对每一个计算结果应用条件“frame.time_delta”，将 style 设置成“FBar”，显示效果最佳。

从上图可见，在第 106 秒时数据流的 MAX frame.delta_time 达到 0.7 秒，这是一个严重延时并且导致了报文丢失。如果想要深入研究，只需要点击图中这一点，就会跳转至相应帧。对应于本例抓包文件中第 1003 个报文。如果你看见帧之间平均延时相对较低但突然某一点延时很长，可点击这一帧，看看这一时间点究竟发生了什么。

**Count( )       **

此函数计算时间间隔内事件发生的次数，在查看 TCP 分析标识符时很有用，例如重传。例图如下：

**Sum( )         **

该函数统计事件的累加值。有两种常见的用例是看在捕获 TCP 数据量，以及检查 TCP 序列号。让我们看看第一个 TCP 长度的例子。创建两个图，一个使用客户端 IP 192.168.1.4 为源，另一个使用客户端 IP 作为一个目的地址。每个图我们将 sum()功能结合 tcp.len 过滤条件。拆分成两个不同的图我们就可以看到在一个单一的方向移动的数据量。

从图表中我们可以看到，发送到客户端的数据量（IP.DST = = 192.168.1.4 过滤条件）比来自客户端的数据量要高。在图中红色表示。黑条显示从客户端到服务器的数据，相对数据量很小。这是有道理的，因为客户只是请求文件和收到之后发送确认数据，而服务器发送大文件。很重要的一点是，如果你交换了图的顺序，把客户端的 IP 作为图 1 的目标地址，并且客户端 IP 作为图 2 的源地址，采用了 FBAR 的时候可能看不到正确的数据显示。因为图编号越低表示在前台显示，可能会覆盖较高图号。

现在让我们看一下同一个数据包丢失和延迟的 TCP 序列号。

可以在图中看到若干峰值和下降，表示 TCP 传输有问题。与正常 TCP 报文比较：

这张图可以看到 TCP 序列号相当稳定地增加，表示传输平稳，没有过多重传或丢包。