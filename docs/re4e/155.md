# 第四部分-调试“Hello World”

> 原文：<https://0xinfection.github.io/reversing/pages/part-4-debugging-hello-world.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[`github.com/mytechnotalent/hacking\_c-\_arm64`](https://github.com/mytechnotalent/hacking\_c-\_arm64)

今天我们将利用 Radare2 的开发版本调试我们的第一个程序。

首先，让我们打开 Radare2 中的二进制文件。

```
radare2 ./0x01_asm_64_helloworld

```

让我们利用 Radare2 的自动分析功能。

```
aaa

```

接下来我们要做的逻辑上的事情是在调试模式下启动程序，这样它就可以将原始的机器代码从磁盘映射到一个正在运行的进程。

```
ood

```

现在我们有了一个正在运行的实例，我们可以寻找二进制文件的主入口点。

```
s main

```

让我们通过以下方式进行初步检查。

```
v

```

Radare2 的输出太大，无法在本课程中展示，但是当您在自己的环境中学习时，您将能够跟上。为了提高文档的可读性，我们将在整个课程中保持这一约定。

请记住，磁盘上的可执行文件和映射时驻留的文件是有区别的。当它在磁盘上时，它被称为未映射。我们将在本课结束时讨论这个问题。现在我们正在看一个映射版本，正如你所看到的，它是映射代码的一个偏移量，我们将在后面讨论。

你有没有注意到你的映射内存值和我的不同？那是因为 ALSR。

地址空间布局随机化(ASLR)是操作系统中使用的一种安全技术，于 2001 年首次实施。所有主要操作系统(iOS、Android、Windows、macOS 和 Linux)的当前版本都具有 ASLR 防护功能。

ASLR 主要用于防止缓冲区溢出攻击。在缓冲区溢出中，攻击者向函数提供它所能处理的尽可能多的垃圾数据，然后是恶意负载。

我们注意到在我的映射内存中，在地址 *0x55629cab48* 我们看到我们的字符串*“Hello World！”*。我们讨论的偏移不同，但结果相同。

让我们通过执行以下操作返回控制台窗口。

```
q

```

让我们验证一下我们最初的分析。

```
[0x55629ca9e4]> ps @0x55629cab48
Hello World!
[0x55629ca9e4]>

```

我们可以看到，在映射的内存地址 *0x55629cab48* 处，我们看到了字符串*“Hello World！”*。

让我们也看看十六进制视图，这样我们可以看到并更好地理解机器代码级别上发生了什么。

```
px @0x55629cab48

```

![](img/5be1c3aa09f68a81e24c5a3fb991e6cd.png)

我们看到我们的“你好，世界！”字符串，我们可以再次看到它从映射内存地址 0x55629cab48 开始存在。

我们看到我们的机器代码指令是 16 字节长或 64 位长，因为我们可以看到第一列从 *48* 开始，以 *00* 结束。

我们了解一些关键的事情是非常重要的。首先，单个十六进制数字是 4 位宽，或者是半字节或半字节。在我们的例子中， *4* 是半个字节，而 *8* 是另一半字节。它们一起构成一个字节，在我们的例子中是一个有效的 ascii 字符代码。

让我们访问在线 ascii 表。

[`www.asciitable.com`](http://www.asciitable.com)

其次，我们需要理解机器代码翻译成什么。让我们看看十六进制中的 *48* 是什么。我们看到它是一个大写的 H。这是一个完美的映射，正如你在上面图像的右边一栏看到的，我们看到一个 0，下面是字母 h。

显然 *65* 的十六进制是***‘e’***等等等等。既然你对你正在看的东西有了基本的了解，你可以自己推断剩下的部分。

现在，让我们在 main 上定义一个断点，并执行这个二进制文件来验证当我们从 main 继续时，它会将 *"Hello World"* 输出到 stdout。

```
[0x55629ca9e4]> db 0x55629ca9e4
[0x55629ca9e4]>

```

让我们继续验证我们的假设。首先，我们继续前进，在主干道上休息。

```
[0x55629ca9e4]> dc
hit breakpoint at: 0x55629ca9e4
[0x55629ca9e4]>

```

现在我们再次单步执行，由于没有其他断点，我们将结束执行并在 stdout 中验证我们的结果。

```
[0x55629ca9e4]> dc
Hello World!
(59575) Process exited with status=0x0
[0x7fb146cb8c]>

```

让我们离开雷达 2 号。

```
q
y
y

```

让我们再次运行 Radare2，这一次不运行二进制文件，只查看磁盘上未映射的二进制文件。

```
radare2 ./0x01_asm_64_helloworld

```

让我们自动分析。

```
aaa

```

让我们去找 main。

```
s main

```

景色

```
v

```

注意我们有*“你好，世界！”*这次是在 *0xb48* 的未映射内存地址。您会注意到，当您运行二进制文件时，可执行文件对这个值有一个偏移量，但是 LSB 是十六进制的 *48* 。

希望这一课能帮助你了解 64 位 ARM 汇编的基础知识，以及如何正确反转。

在下一课中，我们将破解该值。