# 第三十六部分- x64 C++ 3 黑客攻击[第三部分]

> 原文：<https://0xinfection.github.io/reversing/pages/part-36-x64-c++-3-hacking-part-3.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[`github . com/mytechnotalent/逆向工程-教程`](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

让我们回顾一下我们的代码:

![](img/bb1d4da17ccdc48a63369460048bd623.png)

编译:

![](img/d1e62abed6f9d9ac37b4eac5098e6b3a.png)

运行:

![](img/3ae7eceb00957dda56b9a14852f2073b.png)

当我们与被黑掉的二进制文件进行比较时，让我们记住上面的这一行。

让我们打开写模式的二进制文件，简单地分析二进制文件。

![](img/642b9d22e9a0a24081262894e99ecd74.png)

好吧，这里发生了很多事情。我们来分解一下。首先，我们通过键入' **r2 -w ./1** '以写入模式打开 Radare 2，然后使用' **aaa** 命令来分析二进制文件。然后我们使用' **s sym.main** '来寻找二进制程序的主例程，这是我们的入口点。然后我们执行一个' **pdf** 命令来反汇编二进制文件。

我们看到我们称之为序言的部分，我们将堆栈基址指针推送到堆栈上。然后，为了安全起见，我们将 **rsp** 移入 **rbp** ，然后在堆栈上保留 **0x10** 十六进制字节或 16 个十进制字节，为我们的字符串腾出空间。

如果这些都没有意义，请回到本系列教程的开头，复习基本的汇编和寄存器，因为在我们继续之前，理解这一点是至关重要的。

我们可以清楚地看到内存地址 **0x2005** 处的“ **Hello World\n** 的 qword，然后我们看到我们的 C++库调用输出流 **cout** 向终端显示我们的字符串。

让我们检查一下 **0x2005** 来验证我们的字符串是否在那个位置:

![](img/329188be006b220cbc0a1b90d837f256.png)

现在该黑了！

让我们将该值简化为如下形式:

![](img/81cb2dd859f189366d0441abc613afa1.png)

现在我们来看看现在内存里面是什么值@ **0x2005** ！

![](img/e45c0527cfa0eb12e00cbbddcd294b6e.png)

嘣！正如我们所看到的，我们已经破解了这个值，当我们退出 Radare 2 时，它会写它并修改我们的二进制文件。,

![](img/f2c0518fc72bffc0dfb495f8f8c630eb.png)

如你所见，我们已经破解了二进制文件！这是非常基本的，但是现在你已经对 C++二进制代码的逆向工程有了初步的了解。

下周我们将继续我们的 C 语言之旅，一步一步的逆向工程。