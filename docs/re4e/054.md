# 第十一部分- ARM 固件引导程序

> 原文：<https://0xinfection.github.io/reversing/pages/part-11-arm-firmware-boot-procedures.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[`github . com/mytechnotalent/逆向工程-教程`](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

让我们花点时间来讨论一下当我们第一次打开 Raspberry Pi 设备时会发生什么。

一旦 Pi 通电，图形处理器将首先运行，因为处理器处于复位状态，GPU 将开始执行代码。ROM 从 SD 卡中读取并读取 **bootcode.bin** ，加载到 C2 缓存的内存中，然后打开剩余的 RAM**start . elf**加载到其中。

**start.elf** 是图形处理器的操作系统，读取 **config.txt** ，你可以对其进行修改。然后 **kernel.img** 被加载到内存中的 **0x8000** 中，这是 Linux 内核。

一旦加载， **kernel.img** 打开 CPU，并在内存中的 **0x8000** 开始运行。

如果我们愿意，我们可以创建自己的 **kernel.img** ,我们可以将机器代码硬编码到一个文件中，替换原始映像，然后重新启动。请记住，ARM 字长为 32 位，从 0 位到 31 位。

如上所述，当 **kernel.img** 被加载时，第一个字节，即 8 位，被加载到地址 **0x8000** 中。

让我们打开一个十六进制编辑器并编写以下内容:

**FE FF FF 和**

将文件另存为 **kernel.img** 并重启。

“好吧什么都没发生，这太糟糕了！”

实际上确实发生了一些事情，你创建了你的第一个裸机固件！该开香槟庆祝了！

当 Pi 启动时，下面的代码在到达 **kernel.img** 时加载如下内容:

**FE FF FF 和**

**@地址 0x8000，加载 0xfe。**

**@地址 0x8001，加载 0xff。**

**@地址 0x8002，加载 0xff。**

**@地址 0x8003，加载 0xea。**

“那到底是怎么回事？”

这组命令只是执行一个无限循环。

查看数据手册:

[`www . raspberrypi . org/WP-content/uploads/2012/02/BCM 2835-ARM-peripherals . pdf`](https://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf)

上面的代码有 3 个部分:

1)有条件–设置为始终

2)操作码–分行

3)偏移–在当前位置内移动多远

**条件–第 31-28 位:0xe 或 1110**

**操作码–第 27-24 位:0xa 或 1010**

**偏移–第 23-0 -2 位**

我知道这可能让你难以接受，但请务必花时间阅读上面链接的数据手册。如果你真的有热情去理解以上内容，不要偷工减料。阅读数据手册！

我将努力一步一步地分解每件事情，但是我会要求你复习上面的数据表，这样你就可以更好地了解当你陷入某个特定的例程或一组机器代码时应该从哪里入手。这是我要求你阅读和研究上面的数据表的一次机会！

“我好无聊！这些废话到底有什么关系？”

很高兴你问了！当今地球上最危险的恶意软件是 root-kit 变种。如果你对以上没有基本的理解，随着你理解的进步，你甚至永远不会开始理解什么是根包。

任何人都可以简单地用他们自己的黑客版本替换掉 kernel.img 文件，你可以从启动开始完全控制整个过程。

下周我们将深入探讨冯·诺依曼架构。