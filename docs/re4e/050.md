# 第七部分–程序计数器

> 原文：<https://0xinfection.github.io/reversing/pages/part-7-program-counter.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[`github . com/mytechnotalent/逆向工程-教程`](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

在接下来的几周里，我们将深入了解这些登记簿，以确保您对它们的作用和功能有一个明确的了解。

我们从 PC 或程序计数器开始。程序计数器负责指导 CPU 下一步执行什么指令。PC 实际上保存了下一个要提取的指令的地址。

编码时，您可以将 PC 称为 PC 或 R15，因为寄存器 15 是程序计数器。你必须小心对待它，因为你可以设置错误，很容易崩溃的可执行文件。

你可以用代码直接控制电脑:

```
mov r15, 0x00000000

```

我不建议尝试，因为我们不是在 Thumb 模式下，这将导致一个错误，因为你将进入一个 OS 区域，而不是指定的程序区域。

关于我们的 ARM 处理器，我们遵循标准的调用约定，即在调用子例程之前，通过将参数值放入 regs R0–R3 来传递参数，子例程在返回之前，通过将值放入 R0 来返回值。

当我们考虑处理堆栈操作和链接寄存器(我们将在以后的教程中讨论)时，理解这一点很重要。

当你在破解或反转一个二进制程序时，当你想测试子程序的执行和了解程序如何流动，以便分解它并准确理解它在做什么时，控制 PC 是必不可少的。

下周我们将深入了解更多关于 CPSR 的信息！敬请期待！