# 第十四部分- Hello World

> 原文：<https://0xinfection.github.io/reversing/pages/part-14-hello-world.html>

如需所有课程的完整目录，请点击下方，因为除了课程涵盖的主题之外，它还会为您提供每个课程的简介。[`github . com/mytechnotalent/逆向工程-教程`](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)

今天，我们开始进入 C++的世界，更好地了解 C++如何与我们的 ARM 处理器交互。

本系列之前的课程重点关注 ARM 处理器的基础知识，并触及其架构，以及一切如何最终转化为汇编语言，然后最终将操作码转化为机器语言。

我们从第一个 C++程序开始，这是我们的“Hello World”程序。让我们深入下去，一步一步地分解每一行，看看这种语言是如何工作的。我们将把它命名为 **example1.cpp** 并保存到我们的设备中。

```
#include <iostream>

int main(void) {
    std::cout << “Hello World” std::endl;

    return 0;
}

```

![](img/963172309ec27da934dedd3aaca822de.png)

要编译它，我们只需键入:

```
g++ example1.cpp -o example1

```

我们只需输入:

```
./example1

```

![](img/61ebfb6fbc82f97e0ad8b1e6abd3345b.png)

成功！我们看到“Hello World”打印到标准输出或终端！

让我们一行一行地分解它:

**#include < iostream >** 被称为预处理器语句。这些预处理语句发生在编译其余代码之前。#include 关键字将找到一个名为 **iostream** 的文件，并将该文件的所有内容粘贴到我们刚刚创建的现有代码中。这些文件也称为头文件。

我们调用 **iostream** 是因为我们需要一个名为 **cout** 和 **endl** 的函数的声明。 **cout** 函数允许我们将文本打印到标准输出或终端，而 **endl** 函数在文本显示后创建一个新行。

整数类型的主要部分是主应用程序或二进制文件的入口点。您会注意到在 **()** 中有一个 **void** ，这表明它没有任何将被传递到函数中的参数。

**std** 表示一个名称空间，这是一种将代码组织成逻辑组的简单机制，目的是在处理多个库时防止名称冲突。

您将看到许多使用命名空间 std 声明的示例；但是我永远不会使用这种方法，因为它会在更复杂的应用程序中导致命名冲突。

**< <** 运算符被称为重载运算符。它们本质上是一个非常类似于 C 语言中的 **printf** 的函数。我们只是通过使用 **< <** 重载操作符将**“Hello World”**字符串移动到 **cout** 函数中。然后我们按下 **endl** ，这将创建一条到控制台的新线路。

最后一行是返回值 0。因为我们的主函数是 int 类型的，所以我们必须返回一些东西。在 C++ 11 中，主函数中不需要这样做，但是其他函数都需要这样做。我将坚持传统，简单地包括它。

下一步是我们编译文件。首先发生的是 iostream 头的全部内容进入源文件，正如我们所讨论的。编译过程是 C++代码被翻译成机器代码的地方。编译的下一个阶段发生在我们现有代码的剩余部分被解析完的时候。本质上，我们将 iostream 的所有内容放入一个新文件，然后将现有文件的所有内容添加到一个文件中。

编译将我们的文本文件 cpp 文件转换成一种叫做 obj 文件的中间格式。创建一个抽象语法树，它是常量数据、变量和指令的转换。

一旦创建了树，就生成了代码。这意味着我们现在有了 ARM CPU 将执行的机器代码。每个 cpp 文件(翻译单元)都有自己的 obj 文件与之关联。

链接需要我们的 obj 文件，我们的编译文件，以及 C++标准库，找到每个符号和函数的位置，并把它们链接成一个可执行文件。

如果你是编程新手，上面的概念可能会显得有点混乱，但是随着你用汇编语言编码、编译、调试和破解，一切都会变得非常清楚，你将学会掌握处理器。

下周我们将深入调试 Hello World。