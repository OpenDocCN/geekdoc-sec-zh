# 第十二部分-调试浮动

> 原文：<https://0xinfection.github.io/reversing/pages/part-12-debugging-float.html>

让我们回顾一下我们的例子。 **0x05_float.c** 如下。

```
#include <stdio.h>
#include "pico/stdlib.h"

int main() 
{
  stdio_init_all();

  while(1) 
  {
    float x = 40.5;

    printf("%f\n", x); 

    sleep_ms(1000);
  }

  return 0;
}

```

让我们启动我们的调试器。

```
radare2 -w arm -b 16 0x05_float.elf

```

让我们自动分析。

```
aaaa

```

让我们去找 main。

```
s main

```

让我们通过键入 **V** 和 **p** 两次进入可视化模式，以获得一个好的调试器视图。

![](img/db3b41af62f17ad75d4916e07e5b3a71.png)

我们在*【0x 0000033 c】中看到了格式说明符。*

```
:> psz @ [0x0000033c]
%f

```

浮动在*【0x 00000340】*。

```
:> pff @ [0x00000340]
0x00004000 = 9.32830524e-09

```

不要担心浮动不准确，因为这台机器是 x64。重要的是要看到值 *0x00004000* 。你接着问自己，嘿，那不是 *40.5* 吗！交易是什么？

好...

Pico 没有自己的数学协处理器，所以它使用软件处理浮点和双精度。因此 *0x00004000* 将是十进制数 *40.5* 的表示。

例如，如果该值为 *40.4* ，则该值为 *0x00003333* 。反之 *40.6* 将是 *0x00004ccc* 。

看看下面的表格，这将有助于说明这一点。

```
0x3ff00000 = 1.000000
0x3ff00001 = 1.000001
0x3ff00002 = 1.000002
...
0x3ff0000f = 1.000015
0x3ff00010 = 1.000016
0x3ff00011 = 1.000017
etc...

```

最终，这 4 个字节(32 位)中的值将决定浮点的值。

在下一课中，我们将破解 float 并演示这个逻辑。