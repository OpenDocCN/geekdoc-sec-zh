## 4.6 处理文件

根据 Android 安全设计理念，文件仅用于信息持久化和临时保存（缓存），原则上它应该是私有的。 在应用之间交换信息不应该直接通过文件，而应该通过应用间的连接系统（如内容供应器或服务）来交换。 通过使用此功能，可以实现应用间访问控制。 

由于无法在 SD 卡等外部存储设备上执行足够的访问控制，因此文件应限制仅在必要时通过功能方式使用，例如处理大型文件，或将信息传输到其他位置时（PC 等等）。 基本上，包含敏感信息的文件不应保存在外部存储设备中。 在需要将敏感信息保存在外部设备文件中的情况下，需要采取加密等对策，但这里没有提及。

### 4.6.1 示例代码

如上所述，文件原则上应该是私有的。 但是，由于某些原因，有时文件应该由其他应用直接读写。 按照安全角度分类和比较中文件类型如表 4.6-1 所示。 它们根据文件存储位置或其他应用的访问权限分为四类。 下面展示了每个文件类别的示例代码，并在其中添加了每个的解释。

表 4.6-1 按照安全角度的文件类别和比较

| 文件类别 | 其它应用的访问权限 | 储存位置 | 概述 |
| --- | --- | --- | --- |
| 私有文件 | NA | 应用目录中 | （1）只能在应用中读写，（2）可以处理敏感数据，（3）文件原则上应该是这个类型 |
| 只读公共文件 | 读 | 应用目录中 | （1）其它应用和用户可读，（2）可以处理公开给应用外部的信息 |
| 读写公共文件 | 读写 | 应用目录中 | （1）其它应用和用户可以读写，（2）从安全和应用设计角度来看，不应该使用 |
| 外部存储设备（读写文件） | 读写 | 外部存储设备，例如 SD 卡 | （1）没有访问控制，（2）其它应用和用户总是可以读写或删除文件，（3）应该以最小需求使用，（4）可以处理很大的文件 |

#### 4.6.1.1 使用私有文件

这种情况下使用的文件，只能在同一个应用中读取/写入，并且这是使用文件的一种非常安全的方式。 原则上，无论存储在文件中的信息是否是公开的，尽可能使用私有文件，当与其他应用交换必要的信息时，应该使用另一个 Android 系统（内容供应器，服务）来完成。

要点：

1) 文件必须在应用目录中创建。

2) 文件的访问权限必须设置为私有模式，以免其他应用使用。

3) 可以存储敏感信息。

4) 对于存储在文件中的信息，请仔细和安全地处理文件数据。

PrivateFileActivity.java

```java
package org.jssec.android.file.privatefile;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;
public class PrivateFileActivity extends Activity {
    private TextView mFileView;
    private static final String FILE_NAME = "private_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.file);
        mFileView = (TextView) findViewById(R.id.file_view);
    }
    
    /**
    * Create file process
    *
    * @param view
    */
    public void onCreateFileClick(View view) {
        FileOutputStream fos = null;
        try {
            // *** POINT 1 *** Files must be created in application directory.
            // *** POINT 2 *** The access privilege of file must be set private mode in order not to be used by other applications.
            fos = openFileOutput(FILE_NAME, MODE_PRIVATE);
            // *** POINT 3 *** Sensitive information can be stored.
            // *** POINT 4 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            fos.write(new String("Not sensotive information (File Activity)¥n").getBytes());
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PrivateFileActivity", "failed to read file");
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    android.util.Log.e("PrivateFileActivity", "failed to close file");
                }
            }
        }
        finish();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            fis = openFileInput(FILE_NAME);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PrivateFileActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("PrivateFileActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Delete file process
    *
    * @param view
    */
    public void onDeleteFileClick(View view) {
        File file = new File(this.getFilesDir() + "/" + FILE_NAME);
        file.delete();
        mFileView.setText(R.string.file_view);
    }
}
```

PrivateUserActivity.java

```java
package org.jssec.android.file.privatefile;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

public class PrivateUserActivity extends Activity {

    private TextView mFileView;
    private static final String FILE_NAME = "private_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.user);
        mFileView = (TextView) findViewById(R.id.file_view);
    }
    
    private void callFileActivity() {
        Intent intent = new Intent();
        intent.setClass(this, PrivateFileActivity.class);
        startActivity(intent);
    }
    
    /**
    * Call file Activity process
    *
    * @param view
    */
    public void onCallFileActivityClick(View view) {
        callFileActivity();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            fis = openFileInput(FILE_NAME);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            // *** POINT 4 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PrivateUserActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("PrivateUserActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Rewrite file process
    *
    * @param view
    */
    public void onWriteFileClick(View view) {
        FileOutputStream fos = null;
        try {
            // *** POINT 1 *** Files must be created in application directory.
            // *** POINT 2 *** The access privilege of file must be set private mode in order not to be used by other applications.
            fos = openFileOutput(FILE_NAME, MODE_APPEND);
            // *** POINT 3 *** Sensitive information can be stored.
            // *** POINT 4 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            fos.write(new String("Sensitive information (User Activity)¥n").getBytes());
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PrivateUserActivity", "failed to read file");
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    android.util.Log.e("PrivateUserActivity", "failed to close file");
                }
            }
        }
        callFileActivity();
    }
}
```

#### 4.6.1.2 使用公共只读文件

这是使用文件向未指定的大量应用公开内容的情况。 如果通过遵循以下几点来实现，那么它也是比较安全的文件使用方法。 请注意，在 API 级别 1 7及更高版本中，不推荐使用`MODE_WORLD_READABLE`变量来创建公共文件，并且在 API 级别 24 及更高版本中，会触发安全异常; 因此使用内容供应器的文件共享方法更可取。

要点：

1) 文件必须在应用目录中创建。


2) 文件的访问权限必须设置为其他应用只读。

3) 敏感信息不得存储。

4) 对于要存储在文件中的信息，请仔细和安全地处理文件数据。

PublicFileActivity.java

```java
package org.jssec.android.file.publicfile.readonly;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

public class PublicFileActivity extends Activity {

    private TextView mFileView;
    private static final String FILE_NAME = "public_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.file);
        mFileView = (TextView) findViewById(R.id.file_view);
    }

    /**
    * Create file process
    *
    * @param view
    */
    public void onCreateFileClick(View view) {
        FileOutputStream fos = null;
        try {
            // *** POINT 1 *** Files must be created in application directory.
            // *** POINT 2 *** The access privilege of file must be set to read only to other applications.
            // (MODE_WORLD_READABLE is deprecated API Level 17,
            // don't use this mode as much as possible and exchange data by using ContentProvider().)
            fos = openFileOutput(FILE_NAME, MODE_WORLD_READABLE);
            // *** POINT 3 *** Sensitive information must not be stored.
            // *** POINT 4 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            fos.write(new String("Not sensitive information (Public File Activity)¥n").getBytes());
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PublicFileActivity", "failed to read file");
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    android.util.Log.e("PublicFileActivity", "failed to close file");
                }
            }
        }
        finish();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            fis = openFileInput(FILE_NAME);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("PublicFileActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("PublicFileActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Delete file process
    *
    * @param view
    */
    public void onDeleteFileClick(View view) {
        File file = new File(this.getFilesDir() + "/" + FILE_NAME);
        file.delete();
        mFileView.setText(R.string.file_view);
    }
}
```

PublicUserActivity.java

```java
package org.jssec.android.file.publicuser.readonly;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import android.app.Activity;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

public class PublicUserActivity extends Activity {

    private TextView mFileView;
    private static final String TARGET_PACKAGE = "org.jssec.android.file.publicfile.readonly";
    private static final String TARGET_CLASS = "org.jssec.android.file.publicfile.readonly.PublicFileActivity";
    private static final String FILE_NAME = "public_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.user);
        mFileView = (TextView) findViewById(R.id.file_view);
    }
    
    private void callFileActivity() {
        Intent intent = new Intent();
        intent.setClassName(TARGET_PACKAGE, TARGET_CLASS);
        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            mFileView.setText("(File Activity does not exist)");
        }
    }
    
    /**
    * Call file Activity process
    *
    * @param view
    */
    public void onCallFileActivityClick(View view) {
        callFileActivity();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            File file = new File(getFilesPath(FILE_NAME));
            fis = new FileInputStream(file);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            // *** POINT 4 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            android.util.Log.e("PublicUserActivity", "no file");
        } catch (IOException e) {
            android.util.Log.e("PublicUserActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("PublicUserActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Rewrite file process
    *
    * @param view
    */
    public void onWriteFileClick(View view) {
        FileOutputStream fos = null;
        boolean exception = false;
        try {
            File file = new File(getFilesPath(FILE_NAME));
            // Fail to write in. FileNotFoundException occurs.
            fos = new FileOutputStream(file, true);
            fos.write(new String("Not sensitive information (Public User Activity)¥n").getBytes());
        } catch (IOException e) {
            mFileView.setText(e.getMessage());
            exception = true;
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    exception = true;
                }
            }
        }
        if (!exception)
            callFileActivity();
    }
    
    private String getFilesPath(String filename) {
        String path = "";
        try {
            Context ctx = createPackageContext(TARGET_PACKAGE,
            Context.CONTEXT_RESTRICTED);
            File file = new File(ctx.getFilesDir(), filename);
            path = file.getPath();
        } catch (NameNotFoundException e) {
            android.util.Log.e("PublicUserActivity", "no file");
        }
        return path;
    }
}
```

#### 4.6.1.3 创建公共读写文件

这是一种文件用法，它允许未指定的大量应用的读写访问。 

未指定的大量应用可以读写，意思不用多说了。 恶意软件也可以读取和写入，因此数据的可信度和安全性将永远不会得到保证。 另外，即使在没有恶意的情况下，也不能控制文件中的数据格式或写入的时间。 所以这种类型的文件在功能方面几乎不实用。 

如上所述，从安全性和应用设计的角度来看，不可能安全地使用读写文件，因此应该避免使用读写文件。

要点：

不要创建允许来自其他应用的读写操作的文件。

#### 4.6.1.4 使用外部存储器（公共读写）文件

将文件存储在 SD 卡等外部存储器中时，就是这种情况。当存储比较庞大的信息（放置从 Web 下载的文件）或者将信息带出到外部时（备份等）时，应该使用它。

对于未指定的大量应用，“外部存储器文件（公共读写）”与“公共读写文件“有相同特性。另外，对于声明使用`android.permission.WRITE_EXTERNAL_STORAGE`权限的应用，它和“公共读写文件”具有相同的特性。因此，应尽可能减少“外部存储器（公共读写）文件”的使用。

按照 Android 应用的惯例，备份文件很可能是在外部存储器中创建的。但是，如上所述，外部存储器中的文件存在被其他应用（包括恶意软件）篡改/删除的风险。因此，在输出备份的应用中，为了最小化应用规范或设计方面的风险，一些设计是必要的，例如显示“尽快将备份文件复制到 PC 等安全位置”。

要点：

1) 不得存储敏感信息。

2) 文件必须存储在每个应用的唯一目录中。

3) 对于要存储在文件中的信息，请仔细和安全地处理文件数据。

4) 请求应用的文件写入应该按照规范禁止。

AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.jssec.android.file.externalfile" >
    <!-- declare android.permission.WRITE_EXTERNAL_STORAGE permission to write to the external strage --
    >
    <!-- In Android 4.4 (API Level 19) and later, the application, which read/write only files in its sp
    ecific
    directories on external storage media, need not to require the permission and it should declare
    the maxSdkVersion -->
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
    android:maxSdkVersion="18"/>
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:allowBackup="false" >
        <activity
            android:name=".ExternalFileActivity"
            android:label="@string/app_name"
            android:exported="true" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

ExternalFileActivity.java

```java
package org.jssec.android.file.externalfile;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import android.app.Activity;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

public class ExternalFileActivity extends Activity {

    private TextView mFileView;
    private static final String TARGET_TYPE = "external";
    private static final String FILE_NAME = "external_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.file);
        mFileView = (TextView) findViewById(R.id.file_view);
    
    }
    /**
    * Create file process
    *
    * @param view
    */
    public void onCreateFileClick(View view) {
        FileOutputStream fos = null;
        try {
            // *** POINT 1 *** Sensitive information must not be stored.
            // *** POINT 2 *** Files must be stored in the unique directory per application.
            File file = new File(getExternalFilesDir(TARGET_TYPE), FILE_NAME);
            fos = new FileOutputStream(file, false);
            // *** POINT 3 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            fos.write(new String("Non-Sensitive Information(ExternalFileActivity)¥n")
            .getBytes());
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("ExternalFileActivity", "failed to read file");
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    android.util.Log.e("ExternalFileActivity", "failed to close file");
                }
            }
        }
        finish();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            File file = new File(getExternalFilesDir(TARGET_TYPE), FILE_NAME);
            fis = new FileInputStream(file);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            // *** POINT 3 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("ExternalFileActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("ExternalFileActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Delete file process
    *
    * @param view
    */
    public void onDeleteFileClick(View view) {
        File file = new File(getExternalFilesDir(TARGET_TYPE), FILE_NAME);
        file.delete();
        mFileView.setText(R.string.file_view);
    }
}
```

使用的示例代码：

ExternalFileUser.java

```java
package org.jssec.android.file.externaluser;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import android.app.Activity;
import android.app.AlertDialog;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.PackageManager.NameNotFoundException;
import android.os.Bundle;
import android.view.View;
import android.widget.TextView;

public class ExternalUserActivity extends Activity {

    private TextView mFileView;
    private static final String TARGET_PACKAGE = "org.jssec.android.file.externalfile";
    private static final String TARGET_CLASS = "org.jssec.android.file.externalfile.ExternalFileActivity";
    private static final String TARGET_TYPE = "external";
    private static final String FILE_NAME = "external_file.dat";
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.user);
        mFileView = (TextView) findViewById(R.id.file_view);
    }
    private void callFileActivity() {
        Intent intent = new Intent();
        intent.setClassName(TARGET_PACKAGE, TARGET_CLASS);
        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            mFileView.setText("(File Activity does not exist)");
        }
    }
    
    /**
    * Call file Activity process
    *
    * @param view
    */
    public void onCallFileActivityClick(View view) {
        callFileActivity();
    }
    
    /**
    * Read file process
    *
    * @param view
    */
    public void onReadFileClick(View view) {
        FileInputStream fis = null;
        try {
            File file = new File(getFilesPath(FILE_NAME));
            fis = new FileInputStream(file);
            byte[] data = new byte[(int) fis.getChannel().size()];
            fis.read(data);
            // *** POINT 3 *** Regarding the information to be stored in files, handle file data carefully and securely.
            // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
            String str = new String(data);
            mFileView.setText(str);
        } catch (FileNotFoundException e) {
            mFileView.setText(R.string.file_view);
        } catch (IOException e) {
            android.util.Log.e("ExternalUserActivity", "failed to read file");
        } finally {
            if (fis != null) {
                try {
                    fis.close();
                } catch (IOException e) {
                    android.util.Log.e("ExternalUserActivity", "failed to close file");
                }
            }
        }
    }
    
    /**
    * Rewrite file process
    *
    * @param view
    */
    public void onWriteFileClick(View view) {
        // *** POINT 4 *** Writing file by the requesting application should be prohibited as the specification.
        // Application should be designed supposing malicious application may overwrite or delete file.
        final AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(this);
        alertDialogBuilder.setTitle("POINT 4");
        alertDialogBuilder.setMessage("Do not write in calling appllication.");
        alertDialogBuilder.setPositiveButton("OK",
        new DialogInterface.OnClickListener() {
            @Override
            public void onClick(DialogInterface dialog, int which) {
                callFileActivity();
            }
        });
        alertDialogBuilder.create().show();
    }
    
    private String getFilesPath(String filename) {
        String path = "";
        try {
            Context ctx = createPackageContext(TARGET_PACKAGE,
            Context.CONTEXT_IGNORE_SECURITY);
            File file = new File(ctx.getExternalFilesDir(TARGET_TYPE), filename);
            path = file.getPath();
        } catch (NameNotFoundException e) {
            android.util.Log.e("ExternalUserActivity", "no file");
        }
        return path;
    }
}
```

AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.jssec.android.file.externaluser" >
    <!-- In Android 4.0.3 (API Level 14) and later, the permission for reading external storages
    has been defined and the application should decalre that it requires the permission.
    In fact in Android 4.4 (API Level 19) and later, that must be declared to read other directories
    than the package specific directories. -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:allowBackup="false" >
        <activity
            android:name=".ExternalUserActivity"
            android:label="@string/app_name"
            android:exported="true" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

### 4.6.2 规则书

遵循以下规则：

#### 4.6.2.1 文件原则上必须创建为私有（必需）

如“4.6 处理文件”和“4.6.1.3 使用公共读/写文件”所述，无论要存储的信息的内容如何，原则上都应该将文件设置为私有。 从 Android 安全角度来看，交换信息及其访问控制应该在 Android 系统中完成，如内容供应器和服务，并且如果存在不可能的因素，则应该考虑由文件访问权限作为替代方法。 

请参阅每个文件类型的示例代码和以下规则条目。

#### 4.6.2.2 禁止创建允许来自其他应用的读写访问的文件（必需）

如“4.6.1.3 使用公共读/写文件”中所述，当允许其他应用读取/写入文件时，存储在文件中的信息无法控制。 因此，从安全和功能/设计的角度来看，不应该用公共读/写文件共享信息。

#### 4.6.2.3 使用存储在外部存储器如 SD 卡）的文件，应该尽可能最小（必需）

如“4.6.1.4 使用外部存储器（公共读写）文件”中所述，出于安全和功能的考虑，将文件存储在外部存储器（如 SD 卡）中，会导致潜在的问题。 另一方面，与应用目录相比，SD 卡可以处理更大范围的文件，并且这是可以用于将数据带出到应用之外的唯一存储器。 所以，可能有很多情况下必须使用它，取决于应用的规范。 

将文件存储在外部存储器中时，考虑到未指定的大量应用和用户可以读/写/删除文件，所以有必要考虑以下各点以及示例代码中提及的要点，来设计应用。

+   原则上，敏感信息不应保存在外部存储器的文件中。
+   将敏感信息保存在外部存储器的文件中时，应将其加密。
+   将文件保存在外部存储器时，如果被其他应用或用户篡改，将会出现问题，应该用电子签名保存。
+   当读入外部存储器中的文件时，请在验证读取的数据安全性后使用数据。
+   应该这样设计应用，假设外部存储器中的文件始终可以被删除。

请参考“4.6.2.4 应用应该在考虑文件范围的情况下设计”。

#### 4.6.2.4 应用应该在考虑文件范围的情况下设计（必需）

保存在应用目录中的数据，被以下用户操作删除。 它与应用的范围是一致的，并且与应用的范围相比，它的独特之处在于它比应用的范围小。

+   卸载应用
+   删除每个应用的数据和缓存（设置=>应用=>选择目标应用）

保存在外部存储器中的文件，如 SD 卡，文件的范围比应用的范围长。 另外，还需要考虑以下情况。

+   文件由用户删除
+   取出/替换/取消挂载 SD 卡
+   文件由恶意软件删除

如上所述，由于文件范围取决于文件的保存位置而有所不同，不仅从保护敏感信息的角度，而且从实现应用的正确行为的角度，有必要选择文件保存位置。

### 4.6.3 高级话题

#### 4.6.3.1 通过文件描述符的文件共享

有一种方法可以通过文件描述符共享文件，而不是让其他应用访问公共文件。 此方法可用在内容供应器和服务中。 对方的应用可以通过文件描述符读取/写入文件，这些文件描述符通过在内容供应器或服务中，打开私人文件来获得。 

其他应用直接访问文件的共享方式，与文件描述符的共享方式的比较如下表 4.6-2。 优点是访问权限的变化，以及允许访问的应用范围。 特别是从安全角度来看，这是一个很大的优点，可以详细控制允许访问的应用。

表 4.6-2 应用内文件共享方式的比较

| 文件共享方式 | 验证或者访问权限设置 | 允许访问的应用范围 |
| --- | --- | --- |
| 允许其他应用直接访问的文件共享 | 读、写、读写 | 给予所有应用同等访问权限 |
| 通过文件描述符的文件共享 | 读、写、仅添加、读写、读+添加 | 可以控制是否将权限授予应用，它们尝试独立和暂时访问内容供应器和服务。 |

在上述两种文件共享方法中，这是很常见的，因为向其他应用提供文件写入权限时，文件内容的完整性很难得到保证。 当多个应用并行写入时，可能会破坏文件内容的数据结构，导致应用无法正常工作。 因此，在与其他应用共享文件时，只允许只读权限。 

以下是通过内容供应器的文件共享的实现示例，及其示例代码。

要点：

1) 源应用是内部应用，因此可以保存敏感信息。

2) 即使是由内部的内容供应器产生的结果，也要验证结果数据的安全性。

InhouseProvider.java

```java
package org.jssec.android.file.inhouseprovider;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import org.jssec.android.shared.SigPerm;
import org.jssec.android.shared.Utils;
import android.content.ContentProvider;
import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.net.Uri;
import android.os.ParcelFileDescriptor;

public class InhouseProvider extends ContentProvider {

    private static final String FILENAME = "sensitive.txt";
    // In-house signature permission
    private static final String MY_PERMISSION = "org.jssec.android.file.inhouseprovider.MY_PERMISSION";
    // In-house certificate hash value
    private static String sMyCertHash = null;

    private static String myCertHash(Context context) {
        if (sMyCertHash == null) {
            if (Utils.isDebuggable(context)) {
                // Certificate hash value of debug.keystore "androiddebugkey"
                sMyCertHash = "0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255";
            } else {
                // Certificate hash value of keystore "my company key"
                sMyCertHash = "D397D343 A5CBC10F 4EDDEB7C A10062DE 5690984F 1FB9E88B D7B3A7C2 42E142CA";
            }
        }
        return sMyCertHash;
    }
    
    @Override
    public boolean onCreate() {
        File dir = getContext().getFilesDir();
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(new File(dir, FILENAME));
            // *** POINT 1 *** The source application is In house application, so sensitive information can be saved.
            fos.write(new String("Sensitive information").getBytes());
        } catch (IOException e) {
            android.util.Log.e("InhouseProvider", "failed to read file");
        } finally {
            try {
                fos.close();
            } catch (IOException e) {
                android.util.Log.e("InhouseProvider", "failed to close file");
            }
        }
        return true;
    }
    
    @Override
    public ParcelFileDescriptor openFile(Uri uri, String mode)
        throws FileNotFoundException {
        // Verify that in-house-defined signature permission is defined by in-house application.
        if (!SigPerm.test(getContext(), MY_PERMISSION, myCertHash(getContext()))) {
            throw new SecurityException(
                "In-house-defined signature permission is not defined by in-house application.");
        }
        File dir = getContext().getFilesDir();
        File file = new File(dir, FILENAME);
        // Always return read-only, since this is sample
        int modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
        return ParcelFileDescriptor.open(file, modeBits);
    }
    
    @Override
    public String getType(Uri uri) {
        return "";
    }
    
    @Override
    public Cursor query(Uri uri, String[] projection, String selection,
        String[] selectionArgs, String sortOrder) {
        return null;
    }

    @Override
    public Uri insert(Uri uri, ContentValues values) {
        return null;
    }
    
    @Override
    public int update(Uri uri, ContentValues values, String selection,
        String[] selectionArgs) {
        return 0;
    }
    
    @Override
    public int delete(Uri uri, String selection, String[] selectionArgs) {
        return 0;
    }
}
```

InhouseUserActivity.java

```java
package org.jssec.android.file.inhouseprovideruser;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import org.jssec.android.shared.PkgCert;
import org.jssec.android.shared.SigPerm;
import org.jssec.android.shared.Utils;
import android.app.Activity;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.pm.ProviderInfo;
import android.net.Uri;
import android.os.Bundle;
import android.os.ParcelFileDescriptor;
import android.view.View;
import android.widget.TextView;

public class InhouseUserActivity extends Activity {

    // Content Provider information of destination (requested provider)
    private static final String AUTHORITY = "org.jssec.android.file.inhouseprovider";
    // In-house signature permission
    private static final String MY_PERMISSION = "org.jssec.android.file.inhouseprovider.MY_PERMISSION";
    // In-house certificate hash value
    private static String sMyCertHash = null;
    
    private static String myCertHash(Context context) {
        if (sMyCertHash == null) {
            if (Utils.isDebuggable(context)) {
                // Certificate hash value of debug.keystore "androiddebugkey"
                sMyCertHash = "0EFB7236 328348A9 89718BAD DF57F544 D5CCB4AE B9DB34BC 1E29DD26 F77C8255";
            } else {
                // Certificate hash value of keystore "my company key"
                sMyCertHash = "D397D343 A5CBC10F 4EDDEB7C A10062DE 5690984F 1FB9E88B D7B3A7C2 42E142CA";
            }
        }
        return sMyCertHash;
    }

    // Get package name of destination (requested) content provider.
    private static String providerPkgname(Context context, String authority) {
        String pkgname = null;
        PackageManager pm = context.getPackageManager();
        ProviderInfo pi = pm.resolveContentProvider(authority, 0);
        if (pi != null)
        pkgname = pi.packageName;
        return pkgname;
    }
    
    public void onReadFileClick(View view) {
        logLine("[ReadFile]");
        // Verify that in-house-defined signature permission is defined by in-house application.
        if (!SigPerm.test(this, MY_PERMISSION, myCertHash(this))) {
            logLine(" In-house-defined signature permission is not defined by in-house application.");
            return;
        }
        // Verify that the certificate of destination (requested) content provider application is in-house certificate.
        String pkgname = providerPkgname(this, AUTHORITY);
        if (!PkgCert.test(this, pkgname, myCertHash(this))) {
            logLine(" Destination (Requested) Content Provider is not in-house application.");
            return;
        }
        // Only the information which can be disclosed to in-house only content provider application, can be included in a request.
        ParcelFileDescriptor pfd = null;
        try {
            pfd = getContentResolver().openFileDescriptor(
            Uri.parse("content://" + AUTHORITY), "r");
        } catch (FileNotFoundException e) {
            android.util.Log.e("InhouseUserActivity", "no file");
        }
        if (pfd != null) {
            FileInputStream fis = new FileInputStream(pfd.getFileDescriptor());
            if (fis != null) {
                try {
                    byte[] buf = new byte[(int) fis.getChannel().size()];
                    fis.read(buf);
                    // *** POINT 2 *** Handle received result data carefully and securely,
                    // even though the data came from in-house applications.
                    // Omitted, since this is a sample. Please refer to "3.2 Handling Input Data Carefully and Securely."
                    logLine(new String(buf));
                } catch (IOException e) {
                    android.util.Log.e("InhouseUserActivity", "failed to read file");
                } finally {
                    try {
                        fis.close();
                    } catch (IOException e) {
                        android.util.Log.e("ExternalFileActivity", "failed to close file");
                    }
                }
            }
            try {
                pfd.close();
            } catch (IOException e) {
                android.util.Log.e("ExternalFileActivity", "failed to close file descriptor");
            }
        } else {
            logLine(" null file descriptor");
        }
    }
    
    private TextView mLogView;
    
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        mLogView = (TextView) findViewById(R.id.logview);
    }
    
    private void logLine(String line) {
        mLogView.append(line);
        mLogView.append("¥n");
    }
}
```

#### 4.6.3.2 为目录设置访问权限

以上所解释的安全考虑，重点在于文件。 还需要考虑作为文件容器的目录的安全性。 以下说明了目录的访问权限设置的安全性考虑。 

在 Android 中，有一些方法可以在应用目录中获取/创建子目录。 主要如表 4.6-3。

表 4.6-3 在应用目录中获取/创建子目录的方法

| | 规定其它应用的访问权限 | 删除文件 |
| --- | --- | --- |
| `Context#getFilesDir()` | 不可能（只有执行权限） | 设置=>应用=>选择目标应用=>清除数据 |
| `Context#getCacheDir()` | 不可能（只有执行权限） | 设置=>应用=>选择目标应用=>清除缓存（也可以清除数据） |
| `Context#getDir(String name,
int MODE)` | 可以对`MODE`设置如下：`MODE_PRIVATE` `MODE_WORLD_READABLE` `MODE_WORLD_WRITEABLE` | 设置=>应用=>选择目标应用=>清除数据 |


这里特别需要注意的是`Context#getDir()`的访问权限设置。 正如文件创建中所说明的，从安全设计的角度来看，目录基本上也应该设置为私有的。 当信息共享取决于访问权限设置时，可能会产生意想不到的副作用，所以应采取其他方法用于信息共享。

`MODE_WORLD_READABLE`

这是一个标志，为所有应用提供目录的只读权限。 所以所有应用都可以获取目录中的文件列表，和单个文件属性信息。 由于秘密文件可能不会被放置在这些目录中，所以通常不能使用该标志 [15]。

`MODE_WORLD_WRITEABLE`

该标志位其他应用提供目录的写入权限。 所有应用都可以创建/移动/重命名/删除目录中的文件。 这些操作与文件本身的访问权限设置（读/写/执行）没有关系，所以需要注意的是，仅仅使用目录的写入权限就能执行操作。 此标志允许其他应用随意删除或替换文件，因此一般不能使用。

> [15] `MODE_WORLD_READABLE`和`MODE_WORLD_WRITEABLE`在 API 17 和更高版本以及 API 24 和更高版本中弃用，使用它们将触发安全异常。

对于表 4.6-3 “用户删除”，请参考“4.6.2.4 应用应考虑文件范围而设计（必需）”。

#### 4.6.3.3 共享首选项和数据库文件的访问权限设置

共享首选项和数据库也由文件组成。 对于访问权限设置，对文件解释的内容也会在这里解释。 因此，共享首选项和数据库都应该创建为私有文件，与文件相同，内容共享应该由 Android 的应用间联动系统来实现。 

下面将展示共享首选项的使用示例。 通过`MODE_PRIVATE`，共享首选项被设置为私有文件。

```java
import android.content.SharedPreferences;
import android.content.SharedPreferences.Editor;

// Ommision of a passage

// Get Shared Preference . (If there's no Shared Preference, it's to be created.)
// Point:Basically, specify MODE_PRIVATE mode.
SharedPreferences preference = getSharedPreferences(
    PREFERENCE_FILE_NAME, MODE_PRIVATE);

// Example of writing preference which value is charcter string
Editor editor = preference.edit();
editor.putString("prep_key", "prep_value");// key:"prep_key", value:"prep_value"
editor.commit();
```

对于数据库，请参考“4.5 使用 SQLite”。

#### 4.6.3.4 Android 4.4（API 级别 19）及更高版本中，外部存储访问的规范更改

自 Android 4.4（API Level 19）以来，外部存储访问的规范已更改为以下内容。 

（1）如果应用需要读/写其外部存储器上的特定目录，则不需要使用`<uses-permission>`声明`WRITE_EXTERNAL_STORAGE`/`READ_EXTERNAL_STORAGE`权限。（已更改）

（2）如果应用需要读取除外部存储器上特定目录以外的目录中的文件，则需要使用`<uses-permission>`声明`READ_EXTERNAL_STORAGE`权限。 （已更改）

（3）如果应用需要写入主外部存储器上的特定目录以外的目录中的文件，则需要使用`<uses-permission>`声明`WRITE_EXTERNAL_STORAGE`权限。 

（4）应用无法写入次要外部存储器上的特定目录以外的目录中的文件。

在该规范中，根据 Android OS 的版本确定是否需要权限请求。 因此，如果应用支持包括 Android 4.3 和 4.4 在内的版本，则可能会导致应用需要用户不必要的许可。 因此，建议使用对应（1）的应用，如下所示使用`<uses-permission>`的`maxSdkVersion`属性。

AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="org.jssec.android.file.externaluser" >
    <!-- In Android 4.0.3 (API Level 14) and later, the permission for reading external storages
    has been defined and the application should decalre that it requires the permission.
    In fact in Android 4.4 (API Level 19) and later, that must be declared to read other directories
    than the package specific directories. -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name"
        android:allowBackup="false" >
        <activity
            android:name=".ExternalUserActivity"
            android:label="@string/app_name"
            android:exported="true" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```

#### 4.6.3.5 Android 7.0（API Level 24）中的规范已修改，以便访问外部存储介质上的特定目录

在运行 Android 7.0（API Level 24）或更高版本的设备上，引入了一种称为作用域目录访问 API的新 API。 作用域目录访问允许应用在未经许可的情况下，访问外部存储器上的特定目录。 在作用域目录访问中，将`Environment`类中定义的目录作为参数传递给`StorageVolume#createAccessIntent`方法，来创建一个意图。 通过`startActivityForResult`发送此意图，可以启动一个对话框，在终端屏幕上请求访问权限，并且 - 如果用户授予权限 - 每个存储卷上的指定目录都可以访问。

表 4.6-4 可以通过作用域目录访问来访问的目录

| `DIRECTORY_MUSIC` | 通用音乐文件的标准位置 |
| --- | --- |
| `DIRECTORY_PODCASTS` | 播客的标准目录 |
| `DIRECTORY_RINGTONES` | ringtone 的标准目录 |
| `DIRECTORY_ALARMS` | 闹铃的标准目录 |
| `DIRECTORY_NOTIFICATIONS` | 提醒的标准目录 |
| `DIRECTORY_PICTURES` | 图片的标准目录 |
| `DIRECTORY_MOVIES` | 电影的标准目录 |
| `DIRECTORY_DOWNLOADS` | 用户下载的文件的标准目录 |
| `DIRECTORY_DCIM` | 相机产生的图片/视频文件的标准目录 |
| `DIRECTORY_DOCUMENTS` | 用户创建的文档的标准目录 |

如果应用要访问的位置位于上述目录之一，并且该应用正在 Android 7.0 或更高版本的设备上运行，则建议使用作用域目录访问，原因如下。 对于必须继续支持 Android 7.0 以下的设备的应用，请参阅“4.6.3.4 Android 4.4（API级别19）及更高版本中的外部存储访问的规范更改”中，列出的`AndroidManifest`中的示例代码。 

+   授予访问外部存储的权限时，应用可以访问预期目标以外的目录。
+   使用存储器访问框架来要求用户选择可访问的目录，会导致繁琐的过程，用户必须在每次访问时配置一个选择器。 另外，当访问外部存储器的根目录时，整个存储器变成可访问的。


