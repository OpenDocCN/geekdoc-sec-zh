# 四、利用的变体

漏洞利用是一门艺术。就像任何艺术一样，有不止一种完成事情的方式。通常你并不想走别人已经走过的路来利用东西，而是利用你的目标环境、经验、发现和使用程序中现存的行为。这个额外的努力可以在很多东西中得到回报，首先就是你的利用的可靠性和健壮性。或者如果漏洞仅仅影响一个平台或系统，你可以利用特殊的系统特征，来寻找利用的捷径。有很多东西可以使用，这仅仅是常见技巧的一个基本概览。

## 4.1 短整形写入

我们不需要写入四次，而是可能使用两次写入操作来覆盖一个地址。这可以通过通常的`%n`操作以及带有较大`n`值的`%nu`字符串。但是对于这个特殊案例来说，我们可以利用特殊的写操作，它可以写入短整形类型：`%hn`参数。这里的`h`可以用于其他格式化参数，来将栈上提供的值转为短整形。短整形写入技巧比第一种技巧有一个优点，它不会地址旁边的数据，所以如果在你覆盖的地址后面有珍贵的数据，例如函数参数，它就会保留下来。

但是通常你应该避免它，虽然多数 C 标准库支持它，但是它也取决于格式化函数的行为，也就是，如果写入字符数的内部计数器可以突破缓冲区边界的话。这在就得 GNU C 库（libc5）中无效。同样，它在目标进程中会消耗更多内存。

```
printf ("%.29010u%hn%.32010u%hn", 
    1, (short int *) &foo[0], 
    1, (short int *) &foo[2]);
```

这对于基于 RISC 的系统尤其有用，它的`%n`指令拥有对齐限制。通过使用`h`修饰符，对齐在软件中被计算，或者是用特殊的机器指令，你通常可以在每两个字节边界上写入。

除此之外，它的工作原理就像四字节的技巧那样。一些人甚至说，可以只用一步就完成写入，通过使用特别大的填充，例如`%.3221219073u`。但是实践证明这在多数系统上都不管用。这个话题的深入分析最早出现在 portal 的站点上 [3]。一些其他的不错注解可以在 HERT 文章 [4] 的早期发布版中找到。

## 4.2 栈的弹出

如果格式化字符串太短而不能提供栈的弹出序列，它无法到达你的字符串，这怎么办？到你的格式化字符串的实际距离，以及格式化字符串的大小之间会有一个竞争，其中你需要至少弹出实际距离。所以我们就需要一个有效的方式来使用尽可能少的字节增加栈指针。

当前我们仅仅使用了`%u`序列，来展示原理，但是有更加高效的方式。`%u`序列有两个字节长，但是弹出了四个字节，比率为 1:2（我们贡献了 1 个字节，让它前进了两个字节）。

虽然使用`%f`参数，我们就能让其前进八个字节，这仅仅贡献了两个字节。但是这有个很大的缺陷，由于如果栈上的垃圾打印为浮点数，可能就有除零错误，会使成哥进程崩溃。为了避免它，我们可以使用特殊格式修饰符，它只会打印浮点数的整数部分：`%.f`会向上遍历堆栈的八个字节，仅仅在缓冲区中占用三个字节。

在 BSD 衍生系统以及 IRIX 中，可以使用`*`修饰符来满足我们的需要。它用于动态提供格式化参数生成输出的长度。虽然`%10d`打印十个字符，`%*d`动态获取输出长度：下一个栈上的格式化参数提供了他。因为上面提到的 LIBC 允许类型为`%*******d`的参数，我们可以从每个`*`拉取四个字节，这相当于 4:1 的比例。这就产生了另一个问题：多数情况下我们不能预测输出长度，因为它从栈上动态设置。

但是我们可以通过再所有型号的后面插入一个硬编码的值，来覆盖动态定义，`%********10d`会始终打印 10 个字节，无论从堆栈上取出了什么。这个技巧由 lorian 发现。

## 4.3 直接参数访问

除了改进栈弹出方式，有一个巨大简化方式，它被称为“直接参数访问”，一种直接从格式化字符串对栈寻址的方式。几乎所有现有的 C 标准库都支持这个特性，但是并不所有都能够将这个方式应用于格式化字符串利用上。

> 译者注：MSVC 不支持这个特性。

直接参数访问由`$`修饰符控制：

```
printf ("%6$d\n", 6, 5, 4, 3, 2, 1);
```

这会打印`1`，因为`6$`显式寻址了栈上的第六个参数。使用这种方式，整个栈弹出序列就可以扔掉了。

```
char foo[4];
printf ("%1$16u%2$n" 
        "%1$16u%3$n" 
        "%1$32u%4$n" 
        "%1$64u%5$n", 
        1, 
        (int *) &foo[0], (int *) &foo[1], 
        (int *) &foo[2], (int *) &foo[3]);
```

这会在`foo`中创建`\x10\x20\x40\x80`。这个直接访问在 BSD 机器衍生系统中仅仅限制于前八个参数，除了 IRIX。Solaris 的 C 标准库将其限制在前三十个参数，就像在 portal 的文章中那样。如果你选择了负的或者巨大的值，打算访问低于当前位置的栈参数，它不会产生预期结果而是崩溃。

虽然它极大简化了利用，你应该尽可能使用栈弹出技巧，因为它使你的利用可以一直。如果你想要利用的漏洞仅存于一个平台上，它允许这种方式，你当然可以利用它（例如 LSD 的 IRIX telnet 守护进程利用 [21]）。
