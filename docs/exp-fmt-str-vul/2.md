# 二、格式化函数

格式化函数是一类特殊的 ANSI C 函数，接受可变数量的参数，其中的一个就是所谓的格式化字符串。当函数求解格式化字符串时，它会访问向函数提供的额外参数。它是一个转换函数，用于将原始的 C 数据类型表示为人类可读的字符串形式。它们在几乎任何 C 程序中都会使用，来输出信息、打印错误信息或处理字符串。

这一章中，我们会涵盖格式化函数使用中的典型漏洞，正确用法，它们的一些参数，以及格式化字符串漏洞的一般概念。

## 2.1 格式化字符串

如果攻击者能够向 ANSI C 格式化函数提供字符串，无论部分还是全部，就出现了格式化字符串漏洞。由此，格式化函数的行为会改变，并且攻击者就可能控制目标应用。

在下面的例子中，字符串`user`由攻击者提供 -- 他可以控制整个 ASCIIZ 字符串，例如通过使用命令行参数。

错误用法：

```c
int func (char *user) { 
    printf (user); 
}
```

正确用法：

```c
int func (char *user) { 
    printf ("%s", user); 
}
```

## 2.2 格式化函数系列

ANSI C 规范中定义了大量格式化函数。有一些基本的格式化函数，复杂的函数基于它们，它们中的一些并不是标准的一部分，但是广泛可用。

实际成员为：

+   `fprintf` -- 打印到`FILE`流

+   `printf` -- 打印到`stdout`流

+   `sprintf` -- 打印到字符串

+   `snprintf` -- 打印到字符串，带有长度检查

+   `vfprintf` -- 从`va_arg`结构打印到`FILE`流

+   `vprintf` -- 从`va_arg`结构打印到`stdout`流

+   `vsprintf` -- 从`va_arg`结构打印到字符串

+   `vsnprintf` -- 从`va_arg`结构打印到字符串，带有长度检查

近亲：

+   `setproctitle` -- 设置`argv[]`

+   `syslog` -- 输出到`syslog`设施

+   其它类似`err*`, `verr*`, `warn*`, `vwarn*`的函数

## 2.3 格式化函数的用法

为了理解这个漏洞在 C 语言代码的哪里，我们必须检验格式化函数的目的。

功能

+   用于将简单的 C 数据类型转换为字符串表示

+   允许指定表示的格式

+   处理产生的字符串（输出到`stderr`、`stdout`、`syslog`...）

格式化函数工作原理

+   格式化字符串控制了函数的行为

+   它指定了需要打印的参数类型

+   直接（传值）或间接（传址）保存二者

调用函数

需要知道它向栈中压入了多少参数，因为它当格式化函数返回时需要清栈。

## 2.4 格式化字符串具体是什么？

格式化字符串是一个 ASCIIZ 字符串，包含文本和格式化参数。

例如：

```c
printf ("The magic number is: %d\n", 1911); 
```

要打印的文本是`The magic number is: `，后面是格式化参数`%d`，它在输出中会被参数`1911`代替。所以输出是这个样子：`he magic number is: 1911`。

一些格式化参数：

| 参数 | 输出 | 传递方式 |
| --- | --- | --- |
| `%d` | 十进制（`int`） | 传值 |
| `%u` | 无符号十进制（`unsigned int`） | 传值 |
| `%x` | 十六进制（`unsigned int`） | 传值 |
| `%s` | 字符串（`(const) char*`） | 传址 |
| `%n` | 目前为止写入的字节数（`int *`） | 传址 |

`\`字符用于转义特殊字符。它会被 C 编译器在编译使其替换，将转义序列替换为二进制中的适当字符。格式化函数并不会识别这些特殊的序列。实际上，它们并不对格式化字符串做任何事情，但是有时会产生混淆，就像它们被编译器求值一样。

例如：

```c
printf ("The magic number is: \x25d\n", 23);
```

上面的代码可以工作，因为`\x25`在编译时期替换为`%`，虽然`0x25`（37）是百分号字符的 ASCII 值。

## 2.5 栈和它在格式化字符串中的作用

格式化函数的行为由格式化字符串控制。函数接受栈上的一些参数，它们由格式化字符串请求。

```c
printf ("Number %d has no address, number %d has: %08x\n", i, a, &a);
```

从`printf`来看，栈的样子是：

```
   栈顶
+--------+
|  ...   |
|   &a   |
|   a    |
|   i    |
|   A    |
|  ...   |
+--------+
   栈底
```

其中：

| 符号 | 含义 |
| --- | --- |
| A | 格式化字符串的地址 |
| i | 变量`i`的值 |
| a | 变量`a`的值 |
| &a | 变量`a`的地址 |

格式化字符串现在解析了格式化字符串`A`，一次读取一个字符。如果它不是`%`，字符会复制到输出中。否则，`%`后面的字符规定了要求值的参数类型。字符串`%%`拥有特殊函数，用于打印转义字符`%`本身。其它每个参数都和数据相关，位于栈上。
