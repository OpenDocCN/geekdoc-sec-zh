# 第一章、Windows 下堆栈溢出入门

# 1.1 梦，已经展开

## 1.1 梦，已经展开

大学生活开始了，一切都是那么美好、宁静。精神矍铄的长须学者，行色匆匆的赶路人，明星熠熠的荷潭月影，甜蜜的对对恋人，似乎是大学校园里永恒的画面。

在某个教室里，正在上一门特殊的课——网络攻防。说它特殊，其实只是对外人而言，因为在他们看来，这门课显得有些神秘与高深。

让我们一起推开教室的门，感悟一下他们的学习和讨论氛围吧。嘘！小声点！

让我们的梦想在这里实现吧……

# 1.2 啤酒和杯子――缓冲区溢出原理

## 1.2 啤酒和杯子――缓冲区溢出原理

第一节课，各位同学都规规矩矩的坐在位置上，看着老师，大气也不敢出。

老师带着眼镜，一副精干的样子，看出了大家紧张的神情，于是说道：“大家这么紧张干嘛是怕这门课的技术还是怕这门课的老师――我啊我很好说话的，都是年轻人嘛；而技术，就比我更好啦――它是不会说话的。”

“呵呵！是呀！是呀！”大家听了老师的独白都笑了，气氛一下活跃了不少。

老师停了一下，问道：“同学们，这门课叫‘网络攻防’，那你们知道网络上的攻击手段哪些么”

大家听了，马上七嘴八舌的应到：“一些安全杂志上有介绍，好像有注入、缓冲区溢出、劫持、嗅探……”

“哈哈，对！”老师满意的说道，“大家说得很好！攻防是个全方位的问题，涉及到诸多技术，但我们课时有限，第一学期只能讲几个有限的部分。现在最流行的有攻击手段两种方式，一种是 SQL 注入，另一种就是缓冲区溢出攻击。我们选一个作为首先讨论的主题吧！”

“好啊，好啊！”

“不过讲什么呢好像都挺有意思的。”一位女生说道。

“不知道，投硬币吧！”一个胖乎乎的同学说。

老师眼镜一亮，说：“对，真是个好办法！”

老师摸出一个硬币，拈在手中说：“如果是正面就先讲缓冲区溢出，反面就先讲 SQL 注入。”语音刚落，硬币就在空中划出一道美妙的弧线，落在地上转了几圈后停了下来。

前排的几个同学壮着胆子围上去看，叫道：“是正面也！”

“好！那就先讲缓冲区溢出！注入留在以后讲！”老师说道。

“不过似乎很难也……”一个瘦瘦的但很精神的同学说。 “不用怕！大家只要有信心、有毅力，就一定能战胜，Follow me！”

“好，首先让我们来认识一下缓冲区以及缓冲区溢出吧！”老师说。

“先作下类比，如果某个人把一瓶啤酒全部倒入一个小杯子中，那装不下的啤酒就会四处冒出，流到桌子上，这个大家都清楚吧！”

“是啊！是啊！”男生们都遗憾的说到，“那好浪费啊！”

那个胖胖的同学说：“这么好的天，啤酒、小菜，再加上超爆 DVD 大片，好舒服啊！”

“就是啊，谁这么做的拖出来打一顿！”大家的情绪被带动起来了。

“安静！安静！”老师好不容易把持序维护下来，然后兴致索然的说，“我只是打个比方而已！你们什么都能联想到吃。那位同学，你叫什么名字呢”

那位胖胖的同学老实的答道：“我叫玉波。”玉波果然像名字一样，长的白白胖胖的，一张圆乎乎的脸，挺可爱的样子。

“不过我很理解你们，食堂的饭菜是太难吃了。”老师挺同情的说道，“大学食堂就是伤心太平洋啊！”

“哈哈哈哈……”同学们都乐了，教室里充满了愉快的笑声。

等大家平稳下来后，老师继续说道：“同样的道理，在计算机内部，输入数据通常被存放在一个临时空间内，这个临时存放空间就被称为缓冲区，缓冲区的长度事先已经被程序或者操作系统定义好了。缓冲区就很像那个啤酒杯，用来装东西，而且大小固定。”

“向缓冲区内填充数据，如果数据的长度很长（如同那瓶啤酒），超过了缓冲区（那个啤酒杯）本身的容量，那么结果就如同啤酒一样，四处溢出，数据也会溢出存储空间！装不下的啤酒会流到桌子上，而装不下的数据则会覆盖在合法数据上，这就是缓冲区和缓冲区溢出的道理。”

“当然在理想的情况下，程序检查每个数据的长度，并且不允许超过缓冲区的长度大小，就像在倒啤酒的时候，啤酒要冒出杯子时我们就停止。但有些程序会假设数据长度总是与所分配的存储空间相匹配，而不作检查，从而为缓冲区溢出埋下隐患。”

“OK，那我们如何利用缓冲区溢出呢在一般情况下，就像啤酒会到处流满桌面一样，溢出的数据会覆盖掉任何数据、指针或内容。除了破坏之外，对攻击者来说没有任何好处。但我们可引导溢出的数据，使计算机执行我们想要的命令。这就是很多漏洞公告上说的：‘黑客可以用精心构造的数据……’。道理就是这样。”

“如果初学，还不熟悉这个概念，可先把缓存区溢出利用理解为允许攻击者往某个程序变量中放一个比期望长度要长的值，由此以当前运行该程序的用户的特权执行任意命令。”

“而具体的利用和方法，就是如何精心构造。”老师最后说道。

# 1.3 神秘的 Windows 系统

## 1.3 神秘的 Windows 系统

“大家都听明白了吗”老师问大家。

“呜啦！”同学们高高兴兴的说，“明白什么是缓冲区溢出了！就是啤酒和杯子嘛！那我们就开始学习注入了吧，老师！”

“晕哦！这只是最基本的缓冲区溢出原理，要想掌握利用还早着呢！都坐下！” 老师又好气又好笑的说。

待大家又安静下来后，老师说：“学缓冲区溢出要有信心，但也不能浮躁，知道缓冲区的系统结构吗知道怎么执行我们想要的程序吗嗯”

大家摇摇头：“不知道。”

“好，既然不知道，那就安安静静的坐好，马上就是最关键的地方了。”

同学们问道：“什么关键的地方呢”

“就是 Windows 系统内部处理缓冲区的机制，我们明白了这个之后，就可利用缓冲区溢出漏洞来控制别人的主机。”

“哇，好哦！”教室里一阵欢呼。

“为了讲清楚 Windows 是如何处理缓冲区的，我们先看一段很简单的程序。考虑到大家的初学基础，我会尽量少提复杂的代码，多作感性的讲解。”

“是啊，一看复杂的代码就头大，这样好啊！”又一阵欢呼。

“对，我的目的就是让你们知道那些复杂代码是如何来的，而理解了下面这个很简单的程序，再看其他的那些程序时，会发现思路基本上都是一样的。”

“嗯！好！那快给我们看看那段程序吧！”大家都迫不及待了。

“大家的热情都很高嘛，好的！”

# 1.3.1 溢出例子――报错对话框

### 1.3.1 溢出例子――报错对话框

“这个很简单的程序是这样的。”老师在墙上做出投影。

```
/*很简单的程序：*/
#include<stdio.h>
#include<string.h>
char name[] = “ww0830”;pu 
int main()
{
    char output[8];
    strcpy(output, name);
    for(int i=0;i<8&&output[i];i++) 
    printf("\\0x%x",output[i]);
    return 0;
} 
```

“这个程序，还比较简单吧？”老师小心翼翼的问台下的同学。

台下一阵默然，同学们都在头晕中呢……

“好，我来解释一下！这是用 C 语言写的程序！”老师说。

台下一阵狂晕：“地球人都知道！”

“不要急，我一句一句的来。首先， #include<stdio.h> 和 #include<string.h> 是包含这两个头文件进来，因为后面使用的 strcpy 函数和 printf 函数是这两个头文件中定义的。”

“嗯，这个清楚了。”

“然后， char name[] = “ww0830”; 是把‘name’这个数组赋值，往里面放入‘ww0830’这几个字符。”

“哦，为什么要放入‘ww0830’而不放其他的呢？”大家疑惑不解。

“因为这是我的名字啦，哈哈！这个并不重要，什么都可以放，后面大家就会看到的。然后是 int main(){ …… } ，这个是重点啦，这就是我们常说的主函数！程序进来就是先找到这个地方，执行里面的语句。”

“接下来的 char output[8]; strcpy(output, name); 就是让系统给 output 变量分配 8 个 char 的空间，然后把‘name’里面装的字符拷贝给它。”

“ strcpy（des，source） 这个拷贝函数是把第二个参数 source 的值拷给第一个参数 des。它不检查拷贝的长度，它会一直拷贝，直到 source 到结尾。这就是它的弱点了！”

“下面的 for(int i=0;i<8&&output[i];i++) printf("\0x%x",output[i]); 只是让大家方便检查 output 里面的值而已，我把它以 16 进制的形式打出来。”

台下听得聚精会神，一片安静。

“好，让我们运行一下，看看结果吧！在 VC 中编译、链接、执行，如图 1－1。”

![](img/Q 版缓冲区溢出教程 10924.jpg)

“看，打出来的是 \0x77\0x77\0x30\0x38\0x33\0x30 ，77 就是‘w’的 16 进制表示，而 30、38、33、30 就是‘0830’的 16 进制表示。程序运行后一切正常，把‘ww0830’的 16 进制打出后，安全退出了。”

“嗯，呼……”台下长出了一口气，连几个女生也说道，“对，明白了，明白了。”

“呵呵，大家明白了就好。刚才大家不是问为什么要输入‘ww0830’吗，好！那我稍微改一下，改成其他的。”

“这次我把‘name[]’的值赋成‘abcdefgh’，大家再看看运行的结果有什么问题没有！如图 1－2。”

![](img/Q 版缓冲区溢出教程 11192.jpg)

台下的同学使劲的看啊看，什么都没看出来，最后玉波小心翼翼的问：“只是把‘abcdefgh’的十六进制 61、62、63 等打出来嘛，有什么问题吗？”

老师瞟了一眼，然后说道：“对！其实就是没有问题！”

台下狂倒……

“不是啊，不是啊”老师忙解释，“目的是让大家清楚的看下面真正的玄机。”

“这次我把‘name’再改长点，改成‘abcdefghijklmnopqrstuvwxyz’再运行，如图 1－3。”

![](img/Q 版缓冲区溢出教程 11395.jpg)

“哦哦哦……不得了了，出错了！”台下一阵恐慌。

“哈哈！不要急。”老师摆出一副天塌下来自己顶的模样。“大家来仔细看看这个出错的警告是什么。”

“是 0x706f6e6d 引用的 0x706f6e6d 内存，该内存不能为 read。”玉波喃喃的念道。

“你们不觉得‘6d6e6f70’这些很熟悉吗？我们的第二个程序中打出的……”老师提示道。

“哦！‘abcd’是‘61626364’，那么‘6d6e6f70’就应该是 mnop 了。”那位瘦瘦的同学一阵埋头苦算后说道！

“Good，这位同学能不能给大家介绍一下自己呢？”

那位瘦瘦的同学说道，“我叫古风。”

从古风灰灰的衣服、黑黑的脸上能看出他是从农村来的。他的眼神里带着中华民族勤奋刻苦的优良传统。

“大家都要向古风同学习啊！”老师说道，“我给一个对应转换表吧，以后大家直接查就可以了。”老师打出表 1 所示的表格：

![](img/Q 版缓冲区溢出教程 11772.jpg)

(黑手教程中的这个表格有问题，所以我自己做了一个贴了出来，并不是原先的那个表格)

# 1.3.2 堆栈和溢出

### 1.3.2 堆栈和溢出

“现在大家清楚了，刚才的程序是输入到 mnop 时出错了，那究竟是什么原因呢？在‘name[]’比较短时不会有问题，反而在比较长的时候出错。”

大家眉头紧缩：“不知道。”

老师说：“嗯，这个就涉及到 Windows 的运行机制了。”

“哇！岂不是很难啊！”

“No，只要理解了两个概念，再结合实际分析一下，就很简单了。我会用很简单的语言给大家解释。”

“第一个概念是 中断 。我举一个日常生活中的例子来说明，假如你正在给朋友写信，电话铃响了。这时，你放下手中的笔去接电话。通话完毕，再继续写信。这个例子就表现了中断及其处理过程：电话铃声使你暂时中止当前的工作，而去处理更为急需处理的事情（接电话），把急需处理的事情处理完毕之后，再回头来继续原来的事情。”

“第二个概念是 堆栈 。计算机为了能回头继续处理原来的事情，就需要把原来指令的指针 EIP 保存在堆栈中；当要回去原来的地方时，就把保存在堆栈中的 EIP 恢复即可。并且各个函数的局部变量的分配也是在堆栈中。”

台下似懂非懂。

“好，我们看看刚才那个程序就清楚了。”

小知识——PUSH 和 POP

堆栈是一数据结构，遵循“先进后出，后进先出”的规则，就像我们平时叠盘子一样，先放在下面的最后才能取出来，最后放上去的最先取出来。而在操作系统中，存和取的动作就是 PUSH 和 POP。PUSH 放一个数据到堆栈中去，POP 取一个堆栈中的数据出来。

# 1.3.3 溢出报错的原因分析

### 1.3.3 溢出报错的原因分析

“第一次我们输入的只是‘abcdefgh’。因为要进入 main 函数，所以系统把之前的 EIP 和 EBP 保存在堆栈中，便于以后恢复；然后为‘output[8]’在堆栈中分配 8 个 char，拷贝‘abcdefgh’到其中。要注意的是，Windows 下堆栈的分配是高址往低址分配的，其结构如图 1－4。”

![](img/Q 版缓冲区溢出教程 12601.jpg)

“这样在执行完 main 函数后，只要把保存在堆栈中的 EBP、EIP 恢复回去，就可继续原来的执行过程而没有任何问题。”

同学们点点头：“大概明白了，呵呵！”

“好，那第二次输入‘abcdefghijklmnopqrstuvwxyz’时，output 分配的还是 8 个字节，但却拷了 26 个字母进来，和前面比较，其结果如图 1－5 所示。”

![](img/Q 版缓冲区溢出教程 12768.jpg)

“大家注意了！由于拷贝的字母过长，不仅把分配给 output 的 8 个字节占据完了，而且还继续往下，把保存的 EBP 和 EIP 给占据了。”

“当执行完 main 函数后，系统要恢复 EBP、EIP，而 EIP 已经被我们覆盖成 ponm（即 6d6e6f70）了。但系统不知道，就会去执行‘6d6e6f70’位置的东东。而那个位置是不可读的，所以就会出错。”

“乌拉！就是啊！”台下一片欢腾。

“呵呵，现在大家想想，我们可通过覆盖 EIP 为任意值来让程序运行到一个错误的地方，那如果我们特意把 EIP 覆盖成我们想去的程序的地方，那会怎么样呢？”

“我想，应该会运行我们‘想要的程序’吧！”一位浓眉大眼的同学说道，他叫宇强。

“很好！”老师以赞许的目光看了一眼宇强，“就是这样的。我们来看看‘想要的程序’的编写吧！”

# 1.4 ShellCode 编写简介

## 1.4 ShellCode 编写简介

“一般来说，我们把‘想要的程序’称为 ShellCode。Shell 最先指人机交互界面，而这里的 ShellCode 不仅仅指交互了，还可以是实现任意功能的代码。”

“ShellCode 的编写很深奥，涉及很多方面，在以后的课程中我们会作详细讨论，这里就不多说了。只给个例子。”

“我们‘想要的程序’功能最好是能够开一个 DOS 窗口，那我们就可以做很多事情，比如下面这个程序。”

```
#include<windows.h>
int main()
{
    LoadLibrary(“msvcrt.dll”);
    system(“command.com”);
    return 0;
} 
```

“大家看！执行一个 command.com 就可获得一个 DOS 窗口，在 C 库函数里面，语句 system(“command.com”); 将完成我们需要的功能。”

小知识：

Windows 不像 Unix 那样使用系统调用来实现关键函数。Windows 通过动态链接库来提供系统函数，就是所谓的 Dll。

“system 函数由 msvcrt.dll（the Microsoft Visual C++ Runtime library）提供，所以要想执行 system，必须首先使用 LoadLibrary(“msvcrt.dll”); 装载动态链接库 msvcrt.dll，之后才能调用 system 函数。”

“OK，我们执行，看看效果吧！弹出一个 DOS 对话框！如图 1－6，可以执行 dir、copy 等命令。”

![](img/Q 版缓冲区溢出教程 13789.jpg)

“乌拉，太神奇了！”大家一片欢腾，都觉得不可思议。

“呵呵，现在我们把程序改为机器码，可能你们过去也看到过，别人的程序中有很多诸如 \x01\xff\x3f\xff 一类的东东，那些就是程序的机器码。也把我们的程序变成机器码吧！”

“可是怎么变呢？”几位女生有些疑惑。

“很简单！”老师说道，“在 VC 中按 F10 调试，然后在 Debug 工具栏中点击最后一个按钮‘Disassemble’，这样就出现了源程序的汇编代码；再在代码窗口上点击鼠标右键，在弹出菜单中选择‘Code Bytes’，这样就出现了机器码，如图 1－7！”

![](img/Q 版缓冲区溢出教程 14061.jpg)

“哦，那我们把它抄下来就可以了？”古风高兴的说道，埋头就要写。

“不！”老师阻止到，“其实还要作相关的一些工作之后才能直接抄取机器码，ShellCode 的编写将在后面的课程中讲到。”

“哦！”古风耸耸肩，遗憾的说道，“我不怕辛苦，不怕做累人的活。”

“呵呵，以后有机会的，大家先这么认为 ShellCode 是这样生成的吧，我直接给大家一个开 DOS 窗口的机器码。”老师在影屏上打出来。

```
char ShellCode[] = 
{
    0x8B,0xE5, 0x55,0x8B,0xEC,0x83,0xEC,0x0C,0xB8,
    0x63,0x6F,0x6D,0x6D,0x6D,0x6D,0x6F,0x63,0x89,
    0x45,0xF4,0xB8,0x61,0x6E,0x64,0x2E,0x89,0x45,
    0xF8,0xB8,0x63,0x6F,0x6D,0x22,0x89,0x45,0xFC,
    0x33,0xD2, 0x88,0x55,0xFF, 0x8D,0x45,0xF4, 
    0x50, 0xB8,0x24,0x98,0x01,0x78, 0xFF,0xD0 
}; 
```

老师说：“接下来，我们把这些背景知识连起来，写一个真正的利用程序！”

# 1.5 窥豹一斑――本地缓冲区溢出简单利用

## 1.5 窥豹一斑――本地缓冲区溢出简单利用

“首先，我们分析一下现在拥有的资源。”

“1.我们知道了‘有问题程序’返回点的精确位置，意思就是我们可把它覆盖成任意地址，让计算机执行那个地址的代码。”

“2.我们有了 ShellCode（一个可以提供 DOS 窗口的代码）。”

“3.那接下来，大家想想，我们应该做什么呢？”

“嗯……”同学们陷入了沉思。

宇强紧锁眉头，突然灵感一亮，说道：“莫非把‘有问题程序’的返回点地址覆盖成我们 ShellCode 的地址？”

“Very Good！这三步就是缓冲区溢出攻击的基本原理和精髓！”

# 1.5.1 ShellCode 的定位

### 1.5.1 ShellCode 的定位

老师说：“现在我们有了前两步，返回点定位和 ShellCode 的编写，现在只需完成第三步——把返回点覆盖成 ShellCode 的地址，就可成功利用缓冲区溢出了！”

“哈哈，太好了！”玉波的口水都要流出来啦……

“现在的问题就是：ShellCode 所在地址是多少呢？即我们把返回地址覆盖成多少？”

“呜……好像不好办啊……”

“嗯，在以前很多朋友提出了不少方法来定位 ShellCode，但都不精确。随着技术的发展，1999 年 dark spyrit AKA Barnaby Jack 提出了一个天才的想法：用系统核心 dll 里的指令来完成跳转！这一技巧开创了一个崭新的 Windows 缓冲区溢出思路！”

小知识：

过去（尤其是在 Unix 下），提出过的覆盖方法主要有两种：

1.NNNNNNNNNSSSSSSSSSSSRRRRRRRRRRRRRR 型。适合于大缓冲区，“N”代表空指令，也就是 0x90，在实际运行中，程序将什么也不做，而是一直延着这些 NOPS 运行下去，直到遇到不是 NOPS 的指令再执行之；“S”代表 ShellCode；“R”代表覆盖的返回地址，思路是把返回地址 R 覆盖为 nops 的大概位置，这样就会跳到 Nop 中，然后继续执行，直到我们的 ShellCode 中。但这种方法由于定位不准确，所以使用起来也不准确。

2.RRRRRRRRRRNNNNNNNNNNNSSSSSSSSSS 型。是用大量的“R”填满整个缓冲区，然后大量的 Nop，最后是 ShellCode。这里，“R”往后跳到 Nop 中，再顺着往下执行就会到 ShellCode 中。但在 Windows 下，“R”中必定会含有 0，这样，整个构造就会被截断，只能用于 Unix 中。

Windows 的系统核心 dll 包括 kernel32.dll、user32.dll、gdi32.dll。这些 dll 一直位于内存中，而且对应于固定的版本，Windows 加载的位置是固定的。

老师继续说：“我们来看看在 Windows 下如何利用系统核心 dll 里的指令来完成跳转吧。我们用系统核心 dll 中的 jmp esp 地址来覆盖返回地址，而把 ShellCode 紧跟在后面，这样就可跳转到我们的 ShellCode 中。其利用格式是 NNNNNNRSSSSSS，N＝Nop， S＝ShellCode， R＝jmp esp 的地址 ”

同学们急了：“等一下，为什么用 JMP ESP 的地址覆盖就可以跳到后面的 ShellCode 中呢？”

“这里是关键的地方，理解了这个就理解了整个缓冲区溢出攻击！下面是详细的讲解，大家注意跟上。你们看，覆盖后的缓冲区如图 1－8 所示：‘N’表示 NOP，存原 EIP 的地方覆盖成了 JMP ESP 的地址，接下去的‘S0’、‘S1’等表示 ShellCode 开始的 0 字节、1 字节等。”

![](img/Q 版缓冲区溢出教程 16070.jpg)

“嗯，这个没有问题。”

老师说：“函数执行完毕，要返回时堆栈指针 ESP 会指向保存原 EIP 的地方，而指令指针 EIP 指向 Ret 指令。如图 1-9。”

![](img/Q 版缓冲区溢出教程 16148.jpg)

“Ret？Ret 是什么？”有人问道。

“Ret 相当于 Pop EIP ，就是把栈顶指针 ESP 指向的值弹出来给 EIP。所以在正常情况下，Ret 执行后，就可把原来的 EIP 恢复，从而回到中断前的流程。”

“哦！”

“但是，保存的 EIP 已经被我们覆盖成 JMP ESP 指令的地址了。这样执行 Pop EIP 后，EIP 会被改为 JMP ESP 的地址，即指向 JMP ESP。而堆栈指针 ESP 往下移一位，指向 ShellCode 的第一个字节（即图 1-9 中的‘S0’）了。如图 1-10。”

![](img/Q 版缓冲区溢出教程 16389.jpg)

“计算机不知道我们做了手脚，继续往下执行 EIP 指向的指令——JMP ESP，而 ESP 指向的是‘S0’，这样就 JMP 到了‘S0’中，开始执行我们的 ShellCode 了！如下图 1-11。”

![](img/Q 版缓冲区溢出教程 16485.jpg)

小知识：

EIP 指令指针指向下一条要执行的命令，一般会自动加 1。ESP 堆栈顶指针指向堆栈的顶部。在 PUSH 时，ESP 往上走，减 1；在 POP 时，ESP 往下走，加 1。

“哦！有点感觉了，但还不是非常清楚。”

“我再用具体的数字重复一下这个过程吧！”老师耐心的讲解道，“‘FF E4’是 JMP ESP 的机器码，而在 Windows 2000 SP2 下，地址 0x77e0492b 里正好就是‘FF E4’。所以我们用 0x77e0492b（即 JMP ESP 指令的地址）来覆盖保存的 EIP，如图 1-12。”

![](img/Q 版缓冲区溢出教程 16745.jpg)

“当程序返回时，执行 Ret＝POP EIP ，EIP 就变成 0x77e0492b 了，而 ESP 往下走，指向 ShellCode 的第一个字节中，如图 1-13。”

![](img/Q 版缓冲区溢出教程 16828.jpg)

“系统不知道我们做了手脚，继续执行。执行 EIP 指向的指令，就是‘FF E4’，即 JMP ESP。而此时的 ESP 指向后面 ShellCode 的第一个字节，执行‘FF E4’（即 JMP ESP）就正好进入到我们的 ShellCode 中啦！”老师万般耐心的说道，生怕大家有一点不懂。

“下来大家再仔细想想，多看看上面的图和讲解。我们先实际感受一下。”

# 1.5.2 成功构造利用

### 1.5.2 成功构造利用

老师说：“这里 JMP ESP 的地址，会由于版本的不同而不一样。比如在 Win2000 的 User32.dll 中，JMP ESP 指令的地址分别为：sp0:0x77e2e32a、sp1:0x77e8898b、sp2:0x77e0492b、sp3:0x77e188a7、sp4:0x77e22c75。以前很多攻击利用程序需要带上对方版本的参数，就是这个原因。”

“哦！”

“但随着技术的发展，大家又发现了可以通用的地址。这样，攻击程序的统一化和简单化就有了很大提高。从这里可以看出，技术是不断发展进步的，如果自己有什么发现，一定要公布出来，促进大家讨论，反过来也促进自己提高，否则技术会很快过时的。”

大家都点点头。

“好了，我们把它们综合起来吧！还是对于那个程序，我们把它覆盖成这个样子。”如图 1-14。

![](img/Q 版缓冲区溢出教程 17376.jpg)

“把代码合起来，就如图 1-15 所示。”

![](img/Q 版缓冲区溢出教程 17401.jpg)

“接下来，我们在程序中把‘name’赋成这样的值。它看起来很奇怪，但会得到很奇妙的结果。我们执行，就会弹出想要的 DOS 对话框了！”

“大家看，写 main 函数的程序员，他只会去负责读‘name’并赋给 output 数组，根本不会感觉到‘name’数组中会隐藏这样精心构造的恶意代码；对于任何的‘name’，他都会把它读入并作为正常的东西处理，但会出现想不到的结果，呵呵！如图 1-16。”

![](img/Q 版缓冲区溢出教程 17598.jpg)

“这样，我们就完成了首个缓冲区溢出攻击的编写了。感觉怎么样？有收获没有？”

同学们答道：“有！不错不错！”

“有收获就好！下节课我们将进入 Windows 漏洞的缓冲区溢出利用编写了。OK，今天就到这里，放学！”

# 1.6 小结——摘自小强的日记

## 1.6 小结——摘自小强的日记

9 月 16 日 阴

军训完后，大学正式生活已开始一星期了，自己也从最初的新鲜逐渐走向了适应。

学校很大，还有几个分校区，和同学转了几天后才基本熟悉本部的情况。寝室在学校中心，周围是几个食堂。食堂和教学楼之间有一个篮球场，篮球场旁边有一排乒乓桌，永远都排满了人在打球。图书馆则比较远，要越过篮球场，路过一个足球场，并走过一个绿化很好的草坪，直到校门口的边上才到。

我平时住寝室，周末才回家。大一的课比较多，基本上排满了，每门课我都认真听，但内容基本都很无聊，有的老师全按书本上的知识讲，一点儿也不和社会知识接轨，有的老师经常出差。有些同学上课讲话、睡觉，老师也不说什么，只顾讲自己的。

但有一门‘网络攻防’的课还比较有意思，那个老师好像姓王。王老师不看讲义，思维活跃，随时都能调动我们思考。他居然用投硬币来决定讲缓冲区溢出编程，呵呵！真是有意思。

上次课，王老师讲了缓冲区溢出编程的基本原理和步骤，我觉得还是比较清楚，而且他还对一个有漏洞的程序通过精心构造数据、改变程序流程，弹出了一个 DOS 窗口。回家后在自己的机器上照着做了一遍，成功了！我的兴趣一下被提起来了，希望再看看实际中的利用。王老师说下次课将进入实际漏洞的编写，自己很兴奋，盼着下次课早点到来。

在那次课上，知道了一位同学叫玉波，白白胖胖的，跟食神一样；还有一位叫古风，很勤奋的人。还看到了一位穿着绿色薄毛衣的 PLMM，留着短发，很清秀的脸。她坐我前面不远的地方，我看了她几次，她一直在认真听课，真是一个美丽又勤奋的女孩。

给偶遇的女孩

五百年前的回眸，

换来今世的擦肩而过；

你在世界的这头，我在世界的那头，

遥遥相望。

一闭眼，全是你的模样。

想像着你，在操场上，在课桌前，在寝室里。

一样活泼，

一样漂亮。

蒹葭苍苍，白露为霜，

所谓伊人，在水一方。

下次课时，再和她相见吧！

# 1.7 首次实战――FoxMail 溢出漏洞编写

## 1.7 首次实战――FoxMail 溢出漏洞编写

“早晨起床，铃儿响啊，叮叮当当上学堂”。老师一边哼着歌，一边迈进教室。

“哇！”老师大叫一声。原来看见更多的同学坐得整整齐齐，老师吓了一跳，“我还以为走错了教室呢！”

大家都笑了。宇强看见 PLMM 这次穿了件淡黄的外套，坐在他左边的第四个位子。

“老师，上次讲了缓冲区溢出后，大家下来都对其产生了浓厚的兴趣，也希望能继续学习实际缓冲区溢出漏洞的编写。”古风认真的说道。

“哦，是这样啊，没问题，真正的黑客精神就是交流和共享！有更多的人参与，就会激发出更多的思想，大家也就会一起进步。”

“有一点我要再三强调，就是有什么技术发现，一定要公布出来，别人可以在此基础上有更好的发现，自己也可获得很大的收益；而如果只是自己用，技术本身会很快过时。大家记住了吗？”

“记住了！”教室里齐声答道。

“好，从现在起，我们就进入真正的 Windows 平台下缓冲区溢出漏洞的编写！”

“好哦！”一阵欢呼！

“我们从易至难进行，首次实战对象就是 FoxMail 的漏洞！”老师说道。

小知识：

FoxMail 是国内著名的 Internet 电子邮件客户端软件。可以到其主页 www.FoxMail.com.cn 获得最新的信息。

“哇！第一个就选这么难的啊？我们能行嘛？”一些同学说道。

“呵呵，其实有了上堂课的知识，要利用该漏洞实在是小菜一碟。”老师轻松的说道。

“哦！是不是哦……”大家都有些担心。

“绝对没问题！Follow me！首先让我们看看漏洞公告吧！”

# 1.7.1 漏洞公告的分析

### 1.7.1 漏洞公告的分析

“大家拿到任何一篇漏洞公告后，首先要注意是什么程序、它的什么版本有漏洞。从图 1-17 可以看出，有问题的的版本是 FoxMail5.0 beta1、FoxMail5.0 beta2 和 FoxMail5.0，那我们就安装上相应的版本，写出对它的溢出攻击程序。这里我用的是 Win2000 SP2+FoxMail5.0 beta1。”

![](img/Q 版缓冲区溢出教程 19357.jpg)

“漏洞公告还会给出大概的问题分析。图 1-17 就说到了，有问题的东东是 punylib.dll。安装了 FoxMail 后，我们可以在安装目录的 3rdParty 子目录下发现它，大家看！”如图 1-18。

![](img/Q 版缓冲区溢出教程 19464.jpg)

“除此之外，漏洞公告一般还会给出漏洞的解决办法或补丁下载，这里我们就不关心了，但在平时生活中，大家一定要重视，这可是安全的保证哦！”

“当然，漏洞公告是不会给我们说如何利用漏洞的。所以除了查看漏洞公告，我们还要查找其他人或安全组织的相关漏洞分析报告。比如 root 关于 FoxMail 漏洞的分析，如图 1-19。”

![](img/Q 版缓冲区溢出教程 19627.jpg)

“好了，从漏洞公告和分析中，我们可以知道，是 FoxMail 在处理 From:字段时允许的长度超过了缓冲区分配的长度，从而导致了缓冲区溢出。以上的大家都能理解吧？”老师问道。

“嗯。但如何写该缓冲区溢出漏洞的利用程序呢？”胖胖的玉波急不可耐了。

“好，就让我们依次解决上节课上说的三个条件，来实现对 FoxMail 漏洞的利用编写。首先复习一下要成功利用缓冲区溢出需要的三个条件：

1.有问题程序返回点的精确位置――我们可以把它覆盖成任意地址。

2.ShellCode――一个提供给我们想要的功能的代码。

3.JMP ESP 的地址――把返回点覆盖 JMP ESP 的地址，这样可跳入 ShellCode。”

“这三点大家一定要牢牢记在头脑里，这是标准缓冲区堆栈溢出利用的标准方法！”

同学们都使劲的点点头。

“来，就让我们一步步的解决需要的这三个条件吧！”

# 1.7.2 美妙定位溢出点

### 1.7.2 美妙定位溢出点

“第一个条件是最主要的：‘有问题程序’返回点的精确位置。从漏洞公告和漏洞分析中我们可以知道，邮件的‘From:’字段太长就会覆盖到返回地址，那我们就写一个初步的溢出程序框架 FoxMail1.c，来逐步定位返回点的位置。这个程序很简单，就是往邮箱发一封信，而且只有‘From:’字段。不要小看这个框架哦，虽然简陋，但我们会在此基础上打造出最终的梦幻版本。”

[FoxMail1.c 请参见光盘 ]

“在程序的 FoxMail1.c 中，我们对‘From:’字段进行填充。因为不能超过 0x200 的长度，所以我们先填充 0x150 个 A 试试。”

```
memset (buffer, 0x41, 0x150);
sprintf (temp, "From: %s\r\n", buffer);
send (sock, temp, strlen (temp), 0); 
```

“然后执行程序，发送成功！”如图 1-20。

![](img/Q 版缓冲区溢出教程 20432.jpg)

“然后我们用 FoxMail 接收邮件，大家看图 1-21。”

![](img/Q 版缓冲区溢出教程 20463.jpg)

“噢！接收的时候出错了！‘41414141’就是我们添加的 A 啊！”

“找到喽！”教室里一片欢腾。

“等一下！”老师把手一挥，“我把它们列出来，让大家仔细看看，和上节课的报错信息对比一下。”。

上节课的报错信息如图 1-22。

![](img/Q 版缓冲区溢出教程 20583.jpg)

FoxMail 的报错信息如图 1-23。

![](img/Q 版缓冲区溢出教程 20605.jpg)

“发现有什么不同了吗？”老师问道。

“一个有两个按钮，一个只有一个按钮……”

“倒~~~”老师当即晕倒。

费了好大劲站起来后，老师说：“对，这的确是个不同的地方，这是由于程序错误的处理机制不同而造成的。但这不是重要的地方，大家再仔细看看里面提示的信息有什么不同。”

小知识：不同出错处理的外在表现

1.弹出“只有一个确定按钮的红叉框”，意味着外层有“**try/**except”块决定处理异常，而内层有“**try/**finally”块。当按下确定后，是在“**try/**finally”中执行。

2.弹出“有调试、关闭按钮的非红叉框”，意味着设置了“Just-In-Time Debugging”，并获得机会执行，这已经是最后机会了。

3.弹出“只有一个关闭按钮的非红叉框”，意味着没有设置“Just-In-Time Debugging”，内层也没有决定处理异常的“**try/**except”块。

4.触发异常，但什么框也未弹出，意味着内层有“**try/**except”块决定处理异常。或者在异常处理过程中再次触发异常。

宇强仔细看后，说道：“那…是不是前一个提示的是内存不能 read（读）而出错；而后一个提示的是内存不能 write（写）而出错？”

“对！就是这里啦！”老师高兴的说。“是这样的，我们覆盖了 0x150 个 A，可能不仅覆盖过了 EIP 的地方，而且还覆盖了其他一些程序要用的参量，如果在程序返回前，要对那些参量改写，但参量的地址被改成‘41414141’，是根本不能写的，所以就造成了写（write）类型错误！”

“哦，原来是这样，那怎么办呢？” 宇强发现那位 PLMM 在自己发言时朝这边看了一眼，心中紧了一下，多么美丽的眼眸啊！

老师可不会注意这些，回答道：“我们把‘From:’字段覆盖短一点，要覆盖到返回地址，但不要覆盖到那些参量地址。这里我们采用二分法：即先前 0x150 太长，就改成 0x75，如果 0x75 太短，不能覆盖返回地址没有报错，那又改长一点，改成 0x115 的长度，以此类推。”

老师接着说：“当我们覆盖到 0x104 时，我们想要的结果出现了！如图 1-24。”

```
memset (buffer, 0x41, 0x104);
sprintf (temp, "From: %s\r\n", buffer);
send (sock, temp, strlen (temp), 0); 
```

![](img/Q 版缓冲区溢出教程 21638.jpg)

“哦！和原来那个是一样的错误，都是 Read 错误！”同学们叫了起来。

老师笑道：“哈哈，对！说明我们填充‘From:’字段时不能超过 0x104 的长度。解决了这个问题，我们继续，想办法定位返回点的位置。”

“大家想想，上节课的返回点我们是怎么确定的呢？”老师提示大家。

“嗯……是根据报错信息直接数出来的。”古风说道。

“对，这里我们也仿照那样，但这里的缓冲区太长了，我们把数的方法改进一下。”老师大笔一挥。

“我们改变 FoxMail1.c，把‘From:’字段的填充方法改一下。改变的程序为 FoxMail2.c。”

“我们把 FoxMail1.c 填充‘From:’字段的那段替换为如下。”

```
for(i=0; i<=0x104; i++)
    buffer[i] = 'A' + i % 10;
sprintf (temp, "From: %s\r\n", buffer);
send (sock, temp, strlen (temp), 0); 
```

“我们进入邮箱，把原来的信删除；再执行 FoxMail2.c，给邮箱发封新信。这次用 FoxMail 接收时出现的报错框成了‘Access violation at address 4A494847,Read of address 4A494847’， 如图 1-25 所示。”

![](img/Q 版缓冲区溢出教程 22210.jpg)

“OK，我们记录下这个数字，看来这次是 0x4A494847 覆盖了返回点。再在 FoxMail13.c 中把 buffer[i] = 'A' + i % 10 的取余数改为整除。”

```
for(i=0; i<=0x104; i++)
    buffer[i] = 'A' + i / 10;
sprintf (temp, "From: %s\r\n", buffer); 
```

“再次删除信件，执行 FoxMail3.c。用 FoxMail 接收，这次出现的错误框成了‘Access violation at address 5A5A5A5A,Read of address 5A5A5A5A’，如图 1-26。”

![](img/Q 版缓冲区溢出教程 22513.jpg)

“从上面的两个提示中，我们就可得到精确的返回地址位置了！”老师得意的说。

大家都丈二和尚摸不着头脑：“怎么得到呢？”

“不要急，我们一起来推算一下。分析一下上面两次我们做的事情。”

“第一次用 FoxMail2.c，是在‘From:’字段不停的加上 A~J 的循环（就是十六进制 0x41~0x4A 这十个数的循环）。”

“第二次用 FoxMail3.c，是以 10 为一段长度，每段分别为 0x41、0x42……来填充‘From:’。”

“注意了，第一次溢出时报错的最小值是 0x47，此时只有 0x41~0x4A 在不断循环，所以我们可大胆推出尾数是 0x47－0x41＝6。”

“在第二次溢出时报错的全部是 0x5A，而此时是从 0x41 开始，每 10 个数为一段。所以 0x5A－0x41＝0x19，就是十进制的 25，即在字符串的第 25 个段。”

“所以我们可大胆计算出程序的返回点位置是： （0x5A－0x41）×10＋（0x47－0x41）＝25×10＋6＝256 ”

“哇！这样啊！”大家一片欢呼！

“哈哈，我们验证一下猜测结果吧！再改一下程序，指定‘From:’字段第 256 开始的四个字节是‘BBBB’，而其他全部为‘A’。”

```
memset(buffer, 'A', 0x104);
buffer[256] = 'B';
buffer[257] = 'B';
buffer[258] = 'B';
buffer[259] = 'B'; 
```

“代码如上修改后，如果猜测正确，大家想想，会是什么样呢？”老师问道。

“嗯，应该是‘BBBB’覆盖到了返回地址吧！”

“我们一起试试吧！执行这个程序（FoxMail4.c），果然弹出的对话框成了‘Access violation at address 42424242,Read of address 42424242’，如图 1-27。”

![](img/Q 版缓冲区溢出教程 23313.jpg)

“42 就是‘B’的 ASCII 码表示！”

“哇！So Cool！”堂下响起了一片掌声！

“谢谢，谢谢大家的鼓励，我能取得现在这个成绩，是离不开大家的支持，谢谢你们，我爱你们！”

台下无语※※……￥

“呵呵，上面溢出点定位的方法非常巧妙和准确，以后大家在标准的堆栈溢出中，可经常使用这种方法来进行定位。”老师强调到。

“太好了，真是个好方法啊！这样别人给出漏洞证实程序，我们可以很快定位了！”教室里顿时议论纷纷。

“嗯，OK，回到我们这个程序的利用上来吧！”

# 1.7.3 ShellCode 的使用

### 1.7.3 ShellCode 的使用

“让我们再看看第二个条件――ShellCode。ShellCode 很重要，但这里我不详细介绍， ShellCode 的编写很有考究的，会涉及到各方面。应用不同，要求不同，编写也不同。如果同学们有兴趣，我会抽个时间讲‘ShellCode’的编写。”

“有有有，当然有兴趣啦！”听老师一说，大家都争先恐后的表示想听。

“呵呵，那好吧，我们在以后的课程中涉及。这次我就直接给出在中文 Win2000 SP2 下添加名为‘w’用户的 ShellCode。以后大家会写 ShellCode 时，直接替换掉就可以了。"

```
char ShellCode[] = 
    "\x8B\xE5\x55\x8B\xEC\x33\xFF\x57\x57\x57\x57\xC7\x45\xF1\x6E\x65"
    "\x74\x20\xC7\x45\xF5\x75\x73\x65\x72\xC7\x45\xF9\x20\x77\x20\x2E"
    "\x80\x45\xFC\x01\xC6\x45\xFD\x61\xC6\x45\xFE\x64\x33\xC0\x88\x45"
    "\xFF\x8D\x45\xF1\x50\xB8\x4A\x9B\x01\x78\xFF\xD0" ; 
```

# 1.7.4 通用的 JMP ESP 地址

### 1.7.4 通用的 JMP ESP 地址

“最后是第三个条件――JMP ESP 地址。这个上次给大家讲了，并给出了中文 Win2000 各版本相应的地址，大家直接使用即可。但各个版本不统一，使用起来相当麻烦。这里，我再给大家一个大餐――中文版 Win2000、XP、Win2003 的 JMP ESP 通用跳转地址（lion 给出的 0x7ffa4512）。经我测试，绝对可用，童叟无欺！是编写溢出利用程序的必备良药！让我们一起感谢 lion 的无私共享精神吧！这才是真正的 Hacker 精神，大家一定要发扬啊！”

大家听后拼命的点头：“好也！”

“好吧，这下我们的三个条件都有了，我们来完成统一吧！”

“初步分析后，我们知道‘From:’字段作如下构造就可跳入我们的 ShellCode。如果还有不清楚的同学，请再复习一下上节课的内容。如图 1-28。”

![](img/Q 版缓冲区溢出教程 24475.jpg)

“对！就这样喽！”

“但是，大家别忘啦！”老师突然一喝！“这样和最开始我们覆盖 0x150 个‘A’测试时是类似的，ShellCode 会把程序要写的参量覆盖了，那程序在返回之前，会产生那个 write 型错误！”

“哇，是啊，这可怎么办啊？”那位 PLMM 紧张的说，瞬间她成为了整个教室的焦点，大家都屏住了呼吸，一是想仔细听听这清脆的声音，二是等待着老师的回答。

“在这种情况下，一般有三种解决方法”，老师耐心的解释道。“第一种，注意覆盖参量为可写的地址，即保证参量是可写的，不让它出现 write 错误，但这种方法很麻烦，需要知道不能写的参量的所有位置；第二种，覆盖异常，这种方法会在后面讲到；第三种，就是这里我们使用的，把 ShellCode 放在前面！根本不覆盖参量。”

“哦？把 ShellCode 放在前面是什么意思？”宇强见 PLMM 不太懂，也忙着问老师。

“就是说，我们把 ShellCode 放在 RET 前的缓冲区中，而在 RET 后面放入很短的一个指令，指令的内容就是往前跳，跳到前面的 ShellCode 中。”

“形象的说，就是这样的格式，根本不去覆盖不能改变的参量，如图 1-29。”

![](img/Q 版缓冲区溢出教程 24969.jpg)

“在这样的格式下，返回时程序就会先执行 JMP –0x80 这个指令，往前跳到一堆空指令中，然后顺着空指令往下执行，最后进入到 ShellCode 中，就可执行我们的 ShellCode 了。”

“哦！这样啊！太有创意了！”大家感叹道。

“这是很基本的方法，更多精彩还在后面呢！”老师回答说，“好，这里不罗嗦了，让我们按照这个格式，给漏洞以最后一击，写出最终的利用程序――Exploit！”

[ 参看光盘中的程序 FoxMail5.c ]

“我们先把邮箱清空，编译 FoxMail5.c 并执行，再用 FoxMail 接收邮件。只要一接收，就会在本机上添加一个名为‘w’的管理员用户了，大家看图 1-30。”

![](img/Q 版缓冲区溢出教程 25272.jpg)

“也！太帅了！”

“大家也注意到了吧，通过我们的实际编写，发现只要用户用 FoxMail 一收邮件，就会马上触发。而不是像有些厂商传闻的那样只在用户回复该邮件时才被触发。所以国内外软件开发公司对待漏洞发现者的态度、漏洞本身的态度、对产品使用用户公布漏洞信息的态度……”老师逐渐沉默了。

“是啊，厂商还居然说是漏洞发现者的炒作，这简直太不负责任了！明明有问题，还不敢承认。”同学们一个个义愤填膺！

“算了，我们这里只讨论技术，其他方面就不多评论了。”老师又恢复了原来的生气，“这里再和大家一起总结下对 FoxMail 的利用过程吧！”

“第一步、精确定位返回点。我们用求余取整法可巧妙得到返回位置。”

“第二步、ShellCode 编写。我们直接用别人写好的 ShellCode。”

“第三步、JMP ESP 的地址。我们使用 Lion 共享的中文通用地址――0x7ffa4512。”

“最后把它们合起来，由于返回点后面不远处不能覆盖，所以我们把组合位置作稍稍改变，把 ShellCode 放前面，RET 后面放一个往前跳的指令，用这样的方式跳到我们的 ShellCode 中。”

“ShellCode 的功能是添加用户。好了，这样就完成了我们首个缓冲区漏洞的利用编写了，是真实的漏洞哦！感觉怎么样啊？”

“太有成就感了！”同学们嚷道。

“呵呵，那就好，兴趣就是这样培养起来的，有了兴趣就会更有动力钻研下去，钻研也是真正的黑客精神的一部分。大家休息一下，然后我们再继续。”

# 1.8 牛刀小试――Printer 溢出漏洞编写

## 1.8 牛刀小试――Printer 溢出漏洞编写

课间十分钟，大家和老师随便的聊了起来。

“哇！我们这里有几位女黑客啊！难得啊！”老师说。

全班同学都笑了起来。

“几位女黑客介绍一下自己啊！让大家认识一下。”老师边喝水边说。

“嗯，我叫小亮。”“我叫小红。”几位女生依次介绍自己。

宇强仔细的听着，到那位 PLMM 时更是聚精会神。

“我叫吴小倩。”PLMM 清晰的说道。

“多好听的声音啊！ 宇强暗暗想到，“而且，小倩…嗯？《倩女幽魂》中王祖贤扮演的就是小倩嘛！

宇强想起了《倩女幽魂》中的诗――“十里平湖霜满天，寸寸青丝愁华年。对月影单望相护，只羡鸳鸯不羡仙。”

“什么啊，《倩女幽魂》讲的是鬼魂啊，自己想到哪儿去了。”宇强暗暗骂了自己一句。

老师在台上继续说：“几位女同学要努力啊！以后成为像 wollf 一样的中国女黑客啊！”

大家都笑了起来，几位女同学也抿着嘴乐了。

“好，我们趁热打铁，利用刚才的步骤迅速完成对 IIS5.0 Printer 漏洞的利用编写吧！”

# 1.8.1 漏洞背景

### 1.8.1 漏洞背景

“IIS 的 Printer 漏洞只对 Win2000SP0、SP1 版本有效，可以说是个元老级的漏洞了，现在基本上都没有了，大家用它来练练手吧！”

小知识：IIS（Internet Infomation Server）：Internet 信息服务。它是一种 Web 服务，主要包括 WWW 服务器、FTP 服务器等。它使得在 Intranet（局域网）或 Internet（因特网）上发布信息很容易。

“微软 Win2K IIS5 的打印 ISAPI 扩展接口建立了.printer 扩展名到 msw3prt.dll 的映射关系，缺省情况下该映射存在。当远程用户提交对.printer 的 URL 请求时，IIS5 调用 msw3prt.dll 解释该请求。由于 msw3prt.dll 缺乏足够的缓冲区边界检查，远程用户可提交一个精心构造的针对.printer 的 URL 请求，这样，就会在 msw3prt.dll 中发生典型的缓冲区溢出，潜在允许执行任意代码。”老师简单的介绍了漏洞的背景和原因。

# 1.8.2 构造利用

### 1.8.2 构造利用

“我们看看如何利用它吧！还是三大步骤。”

“第一步、确定返回点的位置。这里我们查看相关的漏洞公告和分析公告，可以知道，对[`域填充到 268 个字节时就可以覆盖到 EIP。”`](http://域填充到 268 个字节时就可以覆盖到 EIP。”)

“第二步、ShellCode。我们还是使用现成的 ShellCode 吧！给 SP0 的机器添加一个用户。”

“第三步、JMP ESP 的地址。还用说吗？Lion 大虾的地址是通吃的。”

“好了，把它们组合起来，格式如图 1-31。”

![](img/Q 版缓冲区溢出教程 27013.jpg)

“然后轻松把他们合成程序 Printer.c，我们把写好的程序编译、执行！再看远程机器的效果吧！”

“Yeah！成功添加了一个用户！”“太好了！”又是一阵欢呼，宇强简直不敢相信，“太容易了吧！”

“呵呵，讲解这个漏洞一方面是让大家再熟悉一下溢出编写的基本思路，但更关键是，我要通过这个漏洞讲解缓冲区溢出利用的另一种形式――更常用的形式，大家千万别松气哦！”

# 1.10 拾阶而上——IDA/IDQ 溢出漏洞编写

## 1.10 拾阶而上——IDA/IDQ 溢出漏洞编写

“好了，诸位，经过刚才的讲解，大家清楚了 JMP ESP 和 JMP/CALL EBX 两种方式的利用和区别吧？”

“嗯，好想再来一次 JMP/CALL EBX 的实战啊！”大家都感叹道，连玉波都不觉得饿了。

“好！大家有兴趣就好！兴趣是最好的老师！既然大家很想，那我们再来一次实战，巩固一下知识吧！”

“好咧！”

“这次我们就对 IIS 的 IDA/IDQ 漏洞进行利用编写吧！”

# 1.10.1 漏洞公告

### 1.10.1 漏洞公告

“首先，我们来看看漏洞公告，如图 1-42。”

![](img/Q 版缓冲区溢出教程 35477.jpg)

小知识：IIS 的 IDA/IDQ 漏洞

作为安装 IIS 过程的一部分，系统还会安装几个 ISAPI 扩展.dll，其中，idq.dll 是 Index Server 的一个组件，对管理员脚本和 Internet 数据查询提供支持。但是，idq.dll 在一段处理 URL 输入的代码中存在一个未经检查的缓冲区，攻击者利用此漏洞能导致受影响的服务器产生缓冲区溢出，从而执行自己提供的代码。更为严重的是，idq.dll 是以 System 身份运行的，攻击者可以利用此漏洞取得系统管理员权限。

“该漏洞对 Win2000 SP0、SP1、SP2 有效。大家可以看到，采用 GET /NULL.ida?[bufer]=x HTTP /1.1 对 Buffeer（缓冲区）域进行填充，就可以覆盖到 EIP，再继续也可以覆盖到异常处理点。”

# 1.10.2 初步利用

### 1.10.2 初步利用

“我们温故而知新，还是按照三个步骤来进行。”

“第一、异常点位置。通过漏洞分析可以知道，异常处理点在 Buffer（缓冲区）第 240 字节处，所以我们在 236 字节放上 NOP NOP jmp 04 ，在 240 字节处放上 JMP EBX 的地址，在 244 字节放上我们的 ShellCode。”

“第二、ShellCode。这里我也不说了，还是添加用户。”

“第三、Jmp EBX 的地址——0x7FFA1571。”

好，我们的三步曲都有了，来构造吧！构造形式如图 1-43。”

![](img/Q 版缓冲区溢出教程 36089.jpg)

“哦，Yeah！，我们把构造好的程序运行吧！”大家都迫不及待了。“好！运行！”手忙脚乱的把程序编译并运行开来。

“咦？怎么没有反应？”等了半天后，同学们望着黑黑的屏幕都呆了。

“呵呵！”老师看到大家忙完后才说道，“这个 IIS 漏洞和前面讲的那些漏洞有些不一样——它要对 URL 进行一定的编码转换，这样转换后，我们的 JMP 04、JMP EBX 的地址和 ShellCode 都被改变啦！当然就不能执行我们想要的 ShellCode 了。”

“啊？”

“这就是该漏洞不同的地方，也给大家带来了些挑战性，但在实际中，这种事还是很常见的。比如 Cmail 会把大写改成小写等。”

“哦，那怎么解决呢？”大家问道，“这方面不解决，那很多漏洞都不能用了。”

“对！我们一定要解决。但解铃还需系铃人，首先要看看 IDA 是如何变换那些 URL 请求字符的！”

# 1.10.3 宽字符

### 1.10.3 宽字符

“对 IDA/IDQ 漏洞提交的 URL 被改变，是因为发送的内容由单字节转换成了宽字符。”

小知识：单字节、多字节和宽字节

在多年前，许多人一直将文本串作为一系列单字节字符来进行编码，并在结尾处放上一个零。但单字节只能有 256 种编码，根本不够表示世界各国的文字。这样，就出现了多字节编码。

在多字节编码中，字符有单字节和双字节。在双字节字符中，第一个字节或“前导字节”发出信号，表示它和下一个字节将被解释为一个字符。因为字节编码既有单字节又有双字节，这样就比较麻烦。

“宽字符”是双字节、多语言字符代码。每个字符都用固定的 16 位大小表示，因此使用宽字符可以简化国际字符集的编程。特别的，Unicode 就是一种宽字符编码的国际标志，它用一个 16 位的值来表示每个字符。

“所以，在最开始的时候，eEye 的办法是在 ShellCode 前面放上很多 NOP，这样就把 ShellCode 推向了 0x004x00xx 的地址，就可以用 xx4x 这样的串来覆盖 ret，这个串被扩展为 xx004x00 以后，正好跳转到 ShellCode 的位置。”

“哇，办法很巧妙哈！”大家说道。

“嗯，这种方法虽然理论上行得通，但实际上问题非常多，可以控制跳转却无法执行代码，而且不同的机器这个 0x004x00xx 都不一样，这样就很难做出通用性比较好的 Exploit。”

“哦，那怎么办呢？”

“随着技术的发展，有人发现可用巧妙的方法来避开被扩展成宽字符，这样我们就可轻松的改写很完善的 Exploit 了！”

“哦！黑客精神真是好啊！很多困难的问题大家一起解决、一起进步。”大家由衷的说道，“用的是什么方法呢？”

“方法就是：在我们要用的 JMP 04、JMP EBX 地址和 ShellCode 前面加一个‘%u’符号，IIS 是这样处理‘%u’的，它认为是宽字符，就不再作变换了。比如，JMP 04 的指令写成 %u04eb 。我们把 ShellCode 都加上‘%u’，就不会改变我们的东西了。”

“哦！这样啊！真是一语点破天机啊！”台下感叹道。

“呵呵，这就是黑客魅力的所在。好了，我们就用这个办法把这个 Exploit 完成吧！”

“好咧！”

大家一边回答，一边给 ShellCode 添上“%u”标志。

“呼！ 添加完成了。”同学们擦擦汗。

“好！我们运行试试吧！”老师一编译、执行，哈，一个用户就添加上了。

“哦！”教室里欢呼了起来，“成功罗！成功罗！”

“呵呵，菜鸟还是有菜鸟的乐趣吧！尤其是经过种种挫折后的成功，会很有成就感的！好，今天就到这里，下周这个时候我们再继续吧！”

# 课后解惑

## 课后解惑

Q：用 JMP ESP 地址覆盖时，意思是要跳到 ESP 去执行，那 ESP 具体的值是多少呢？

A：你还没有理解覆盖的意义。我们不需要知道 ESP 具体的值，只需要知道 JMP ESP 指令的地址就可以了。而 JMP ESP 指令的地址在同种系统甚至是不同种系统下，都有相同的值，即 0x7FFA4512。建议再看看本章节 ShellCode 的定位部分。

Q：怎么知道 JMP ESP 指令的地址呢？

A：JMP ESP 指令的机器码是 FF E4。只要你发现内存里面有一个地方是 FF E4，那么就可以用此地方的地址了。比如，你查看内存 0x7FFA4512 的地方，只要是中文版 Windows，一定放的是 FF E4 指令，所以说是通用地址。

Q：怎么知道 JMP ESP 指令的机器码是 FF E4 呢？

A：即可以用查询工具得到，也可以在 VC 中用“__asm{}”嵌入汇编 JMP ESP，再按 F10 进入调试，然后调出 JMP ESP 代码对应的机器码。

我们将在 ShellCode 编写一章，详细讲解得到机器码的过程；在堆溢出一章有查找 call [esi+0x4C] 指令机器码的讲解，过程类似，可以参看。

Q：只能用 ESP 来定位吗？

A： 当然不是啦！最好把当时寄存器的内容都看一遍，比如覆盖异常时，我们用 EBX。

Q： 覆盖异常处理点时，我用的就是 CALL EBX 指令地址，为什么会失败？

A： 在 Windows 2000 下，可以用 CALL EBX 指令地址覆盖；但在 XP 下，EBX 会变为 0，需要用 POP POP RET 的指令地址来覆盖。这也有个中文版ＮＴ/Win2000/Win2003 都通用的地址——0x7FFA1571。我们将在 ShellCode 变形一章的 MDTM 漏洞利用讲解时详细讲到。

Q： 为什么会存在通用地址呢？

A： 上面说的两个通用地址都是指中文版的通用地址。是因为在同一个语言版本中，存在着一个从来没有改动过的程序——svchost。它只是一个壳，用以启动其他程序，所以我们很幸运，能在它那里找到通用的地址。

Q： 有世界通用地址吗？

A： 抱歉，我不知道！但同种版本的各语言版本，比如 Windows 2000 SP3 的中文版和英文版，在 Msvcrt.dll 中找到的地址可以通用。

另外，同一种语言的各个系统版本（比如中文版 Windows2000、Windows XP），在 0x7FFA0000 中找到的地址可以通用，就像 0x7FFA4512 和 0x7FFA1571。

如果你找到了世界通用地址，请共享一下，谢谢！

Q：只能是用 JMP CALL RET 这样的指令地址来覆盖吗？

A：大多数情况下是这样。

Q：Windows 可以确切的定位了，但 Linux 下有确切的定位 ShellCode 的方法吗？

A：在 Linux 下，可以把 ShellCode 放在环境变量，然后就能确切计算出 ShellCode 在内存中的地址，也非常精确。

Q：在分析你给的那个例子程序时，发现 ESP 一来就减很大的值，为什么分配这么大的缓冲器还要溢出呢？

A：分配的空间是系统自己用的。但 output[8]还是只分配了 8 个字节的空间。

Q： 奇怪，在“name”数组比较短的时候，测试会报错；但我按照格式覆盖并加上 ShellCode 后，结果不但没弹出窗口，连错误也不报了，这是怎么回事啊？（这个问题我就遇到了~~~55555）

A： 是用的覆盖地址不对。而没有报错，是因为你覆盖的字符串太长了，把异常处理点也覆盖了，当然报错对话框也弹不出来了。

使用系统相关的地址，我们马上会在第二章 ShellCode 的编写中讲到。