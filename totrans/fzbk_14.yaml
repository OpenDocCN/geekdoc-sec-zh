- en: Fuzzing with Grammars
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用语法进行模糊测试
- en: 原文：[http://www.fuzzingbook.org/html/Grammars.html](http://www.fuzzingbook.org/html/Grammars.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/Grammars.html](http://www.fuzzingbook.org/html/Grammars.html)
- en: In the chapter on ["Mutation-Based Fuzzing"](MutationFuzzer.html), we have seen
    how to use extra hints – such as sample input files – to speed up test generation.
    In this chapter, we take this idea one step further, by providing a *specification*
    of the legal inputs to a program. Specifying inputs via a *grammar* allows for
    very systematic and efficient test generation, in particular for complex input
    formats. Grammars also serve as the base for configuration fuzzing, API fuzzing,
    GUI fuzzing, and many more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在["基于变异的模糊测试"](MutationFuzzer.html)章节中，我们已经看到了如何使用额外的提示——例如示例输入文件——来加速测试生成。在本章中，我们进一步发展了这个想法，通过提供程序合法输入的**规范**。通过语法指定输入允许非常系统且高效地生成测试，特别是对于复杂的输入格式。语法还作为配置模糊测试、API模糊测试、GUI模糊测试以及更多的基础。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should know how basic fuzzing works, e.g. from the [Chapter introducing
    fuzzing](Fuzzer.html).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该了解基本的模糊测试是如何工作的，例如从[介绍模糊测试的章节](Fuzzer.html)中了解。
- en: Knowledge on [mutation-based fuzzing](MutationFuzzer.html) and [coverage](Coverage.html)
    is *not* required yet, but still recommended.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于[基于变异的模糊测试](MutationFuzzer.html)和[覆盖率](Coverage.html)的知识目前**不需要**，但仍然推荐。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Synopsis
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要[使用本章提供的代码](Importing.html)，请编写
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: and then make use of the following features.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter introduces *grammars* as a simple means to specify input languages,
    and to use them for testing programs with syntactically valid inputs. A grammar
    is defined as a mapping of nonterminal symbols to lists of alternative expansions,
    as in the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了**语法**作为指定输入语言的一种简单方法，以及如何使用它们对具有语法有效输入的程序进行测试。语法被定义为非终结符号到一系列替代扩展的映射，如下例所示：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Nonterminal symbols are enclosed in angle brackets (say, `<digit>`). To generate
    an input string from a grammar, a *producer* starts with the start symbol (`<start>`)
    and randomly chooses a random expansion for this symbol. It continues the process
    until all nonterminal symbols are expanded. The function `simple_grammar_fuzzer()`
    does just that:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 非终结符号用尖括号括起来（例如，`<digit>`）。要从语法生成一个输入字符串，一个**生成器**从起始符号（`<start>`）开始，并随机选择这个符号的随机扩展。它继续这个过程，直到所有非终结符号都被扩展。`simple_grammar_fuzzer()`函数正是这样做的：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In practice, though, instead of `simple_grammar_fuzzer()`, you should use [the
    `GrammarFuzzer` class](GrammarFuzzer.html) or one of its [coverage-based](GrammarCoverageFuzzer.html),
    [probabilistic-based](ProbabilisticGrammarFuzzer.html), or [generator-based](GeneratorGrammarFuzzer.html)
    derivatives; these are more efficient, protect against infinite growth, and provide
    several additional features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，虽然你应该使用[GrammarFuzzer类](GrammarFuzzer.html)或其[基于覆盖率的](GrammarCoverageFuzzer.html)、[基于概率的](ProbabilisticGrammarFuzzer.html)或[基于生成器的](GeneratorGrammarFuzzer.html)衍生类之一，而不是`simple_grammar_fuzzer()`；这些更高效，可以防止无限增长，并提供几个额外的功能。
- en: This chapter also introduces a [grammar toolbox](#A-Grammar-Toolbox) with several
    helper functions that ease the writing of grammars, such as using shortcut notations
    for character classes and repetitions, or extending grammars
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还介绍了一个[语法工具箱](#A-Grammar-Toolbox)，其中包含几个辅助函数，这些函数可以简化语法的编写，例如使用字符类和重复的快捷符号，或扩展语法。
- en: Input Languages
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入语言
- en: 'All possible behaviors of a program can be triggered by its input. "Input"
    here can be a wide range of possible sources: We are talking about data that is
    read from files, from the environment, or over the network, data input by the
    user, or data acquired from interaction with other resources. The set of all these
    inputs determines how the program will behave – including its failures. When testing,
    it is thus very helpful to think about possible input sources, how to get them
    under control, and *how to systematically test them*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的所有可能行为都可以通过其输入触发。"输入"在这里可以是一系列可能的来源：我们谈论的是从文件、环境或网络中读取的数据，用户输入的数据，或从与其他资源的交互中获得的数据。所有这些输入的集合决定了程序将如何表现——包括其失败。在测试时，考虑可能的输入来源、如何控制它们以及**如何系统地测试它们**是非常有帮助的。
- en: 'For the sake of simplicity, we will assume for now that the program has only
    one source of inputs; this is the same assumption we have been using in the previous
    chapters, too. The set of valid inputs to a program is called a *language*. Languages
    range from the simple to the complex: the CSV language denotes the set of valid
    comma-separated inputs, whereas the Python language denotes the set of valid Python
    programs. We commonly separate data languages and programming languages, although
    any program can also be treated as input data (say, to a compiler). The [Wikipedia
    page on file formats](https://en.wikipedia.org/wiki/List_of_file_formats) lists
    more than 1,000 different file formats, each of which is its own language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们目前假设程序只有一个输入源；这也是我们在前几章中使用的相同假设。程序的有效输入集合被称为*语言*。语言的范围从简单到复杂：CSV语言表示有效的逗号分隔输入集合，而Python语言表示有效的Python程序集合。我们通常将数据语言和编程语言分开，尽管任何程序也可以被视为输入数据（例如，用于编译器）。[维基百科上的文件格式页面](https://en.wikipedia.org/wiki/List_of_file_formats)列出了超过1,000种不同的文件格式，每种格式都是其自己的语言。
- en: 'To formally describe languages, the field of *formal languages* has devised
    a number of *language specifications* that describe a language. *Regular expressions*
    represent the simplest class of these languages to denote sets of strings: The
    regular expression `[a-z]*`, for instance, denotes a (possibly empty) sequence
    of lowercase letters. *Automata theory* connects these languages to automata that
    accept these inputs; *finite state machines*, for instance, can be used to specify
    the language of regular expressions.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正式描述语言，*形式语言*领域已经设计了一系列*语言规范*，这些规范描述了一种语言。*正则表达式*代表了这些语言中最简单的一类，用于表示字符串集合：例如，正则表达式`[a-z]*`表示一个（可能为空）的小写字母序列。*自动机理论*将这些语言与接受这些输入的自动机联系起来；例如，*有限状态机*可以用来指定正则表达式的语言。
- en: Regular expressions are great for not-too-complex input formats, and the associated
    finite state machines have many properties that make them great for reasoning.
    To specify more complex inputs, though, they quickly encounter limitations. At
    the other end of the language spectrum, we have *universal grammars* that denote
    the language accepted by *Turing machines*. A Turing machine can compute anything
    that can be computed; and with Python being Turing-complete, this means that we
    can also use a Python program $p$ to specify or even enumerate legal inputs. But
    then, computer science theory also tells us that each such testing program has
    to be written specifically for the program to be tested, which is not the level
    of automation we want.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式非常适合不太复杂的输入格式，与之相关的有限状态机也具有许多使它们非常适合推理的性质。然而，为了指定更复杂的输入，它们很快就会遇到限制。在语言谱的另一端，我们有*通用语法*，它表示由*图灵机*接受的语言。图灵机可以计算任何可以计算的东西；由于Python是图灵完备的，这意味着我们也可以使用Python程序$p$来指定或甚至枚举合法的输入。但是，计算机科学理论也告诉我们，每个这样的测试程序都必须为要测试的程序专门编写，这不是我们想要的自动化水平。
- en: Grammars
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: The middle ground between regular expressions and Turing machines is covered
    by *grammars*. Grammars are among the most popular (and best understood) formalisms
    to formally specify input languages. Using a grammar, one can express a wide range
    of the properties of an input language. Grammars are particularly great for expressing
    the *syntactical structure* of an input, and are the formalism of choice to express
    nested or recursive inputs. The grammars we use are so-called *context-free grammars*,
    one of the easiest and most popular grammar formalisms.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式和图灵机之间的中间地带由*语法*覆盖。语法是正式指定输入语言中最受欢迎（且理解最好）的形式化方法之一。使用语法，可以表达输入语言的各种属性。语法特别适合表达输入的*句法结构*，并且是表达嵌套或递归输入的首选形式化方法。我们使用的语法是所谓的*上下文无关语法*，这是一种最容易且最受欢迎的语法形式化方法。
- en: Rules and Expansions
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则和扩展
- en: 'A grammar consists of a *start symbol* and a set of *expansion rules* (or simply
    *rules*) which indicate how the start symbol (and other symbols) can be expanded.
    As an example, consider the following grammar, denoting a sequence of two digits:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 语法由一个*起始符号*和一组*扩展规则*（或简单地称为*规则*）组成，这些规则表明起始符号（和其他符号）如何进行扩展。例如，考虑以下语法，表示两个数字的序列：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To read such a grammar, start with the start symbol (`<start>`). An expansion
    rule `<A> ::= <B>` means that the symbol on the left side (`<A>`) can be replaced
    by the string on the right side (`<B>`). In the above grammar, `<start>` would
    be replaced by `<digit><digit>`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 读取这样的语法时，从起始符号（`<start>`）开始。一个展开规则`<A> ::= <B>`意味着左侧的符号（`<A>`）可以被右侧的字符串（`<B>`）替换。在上面的语法中，`<start>`将被替换为`<digit><digit>`。
- en: In this string again, `<digit>` would be replaced by the string on the right
    side of the `<digit>` rule. The special operator `|` denotes *expansion alternatives*
    (or simply *alternatives*), meaning that any of the digits can be chosen for an
    expansion. Each `<digit>` thus would be expanded into one of the given digits,
    eventually yielding a string between `00` and `99`. There are no further expansions
    for `0` to `9`, so we are all set.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字符串中，`<digit>`将被替换为`<digit>`规则右侧的字符串。特殊运算符`|`表示*展开替代项*（或简称为*替代项*），意味着可以选择任何数字进行展开。因此，每个`<digit>`将被展开为给定的数字之一，最终得到一个介于`00`和`99`之间的字符串。对于`0`到`9`没有进一步的展开，所以我们已经准备好了。
- en: 'The interesting thing about grammars is that they can be *recursive*. That
    is, expansions can make use of symbols expanded earlier – which would then be
    expanded again. As an example, consider a grammar that describes integers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 关于语法的有趣之处在于它们可以是*递归的*。也就是说，展开可以使用之前展开的符号——然后这些符号将被再次展开。作为一个例子，考虑一个描述整数的语法：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a `<integer>` is either a single digit, or a digit followed by another
    integer. The number `1234` thus would be represented as a single digit `1`, followed
    by the integer `234`, which in turn is a digit `2`, followed by the integer `34`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个`<integer>`要么是一个单独的数字，要么是一个数字后面跟着另一个整数。因此，数字`1234`将被表示为一个单独的数字`1`，后面跟着整数`234`，这个整数又是一个数字`2`，后面跟着整数`34`。
- en: If we wanted to express that an integer can be preceded by a sign (`+` or `-`),
    we would write the grammar as
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要表达一个整数可以由一个符号（`+`或`-`） precede，我们就会把语法写成
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These rules formally define the language: Anything that can be derived from
    the start symbol is part of the language; anything that cannot is not.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则正式定义了语言：可以从起始符号推导出的任何内容都是语言的一部分；不能推导出的则不是。
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Quiz
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: Which of these strings cannot be produced from the above `<start>` symbol?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些字符串不能由上述`<start>`符号产生？
- en: Arithmetic Expressions
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术表达式
- en: Let us expand our grammar to cover full *arithmetic expressions* – a poster
    child example for a grammar. We see that an expression (`<expr>`) is either a
    sum, or a difference, or a term; a term is either a product or a division, or
    a factor; and a factor is either a number or a parenthesized expression. Almost
    all rules can have recursion, and thus allow arbitrary complex expressions such
    as `(1 + 2) * (3.4 / 5.6 - 789)`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们的语法以涵盖完整的*算术表达式*——这是一个语法的典型示例。我们看到一个表达式（`<expr>`）要么是一个和，要么是一个差，要么是一个项；一个项要么是一个乘法，要么是一个除法，要么是一个因子；一个因子要么是一个数字，要么是一个括号表达式。几乎所有的规则都可以有递归性，从而允许任意复杂的表达式，例如`(1
    + 2) * (3.4 / 5.6 - 789)`。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In such a grammar, if we start with `<start>` and then expand one symbol after
    another, randomly choosing alternatives, we can quickly produce one valid arithmetic
    expression after another. Such *grammar fuzzing* is highly effective as it comes
    to produce complex inputs, and this is what we will implement in this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的语法中，如果我们从`<start>`开始，然后逐个展开符号，随机选择替代项，我们可以快速产生一个有效的算术表达式，然后是另一个。这种*语法模糊化*在产生复杂输入时非常有效，这正是我们将在本章中实现的。
- en: Quiz
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: Which of these strings cannot be produced from the above `<start>` symbol?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 哪些字符串不能由上述`<start>`符号产生？
- en: Representing Grammars in Python
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中表示语法
- en: Our first step in building a grammar fuzzer is to find an appropriate format
    for grammars. To make the writing of grammars as simple as possible, we use a
    format that is based on strings and lists. Our grammars in Python take the format
    of a *mapping* between symbol names and expansions, where expansions are *lists*
    of alternatives. A one-rule grammar for digits thus takes the form
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 构建语法模糊器时的第一步是找到一个合适的语法格式。为了使语法的编写尽可能简单，我们使用基于字符串和列表的格式。我们的Python语法采用符号名称和展开之间的*映射*格式，其中展开是*列表*形式的替代项。因此，一个用于数字的单规则语法具有以下形式
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <details id="Excursion:-A-Grammar-Type"><summary>A `Grammar` Type</summary>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-A-Grammar-Type"><summary>一个`Grammar`类型</summary>
- en: Let us define a type for grammars, such that we can check grammar types statically.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个语法类型，以便我们可以静态地检查语法类型。
- en: 'A first attempt at a grammar type would be that each symbol (a string) is mapped
    to a list of expansions (strings):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 语法类型的第一次尝试可能是这样的：每个符号（字符串）映射到一个展开列表（字符串）：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, our `opts()` feature for adding optional attributes, which we will
    introduce later in this chapter, also allows expansions to be *pairs* that consist
    of strings and options, where options are mappings of strings to values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的 `opts()` 功能，用于添加可选属性，我们将在本章后面介绍，也允许展开成为由字符串和选项组成的配对，其中选项是将字符串映射到值的映射：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hence, an expansion is either a string – or a pair of a string and an option.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个展开要么是一个字符串——要么是一个字符串和选项的配对。
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With this, we can now define a `Grammar` as a mapping of strings to `Expansion`
    lists.</details>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们现在可以定义一个 `Grammar`，它将字符串映射到 `Expansion` 列表。</details>
- en: 'We can capture the grammar structure in a *`Grammar`* type, in which each symbol
    (a string) is mapped to a list of expansions (strings):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 *`Grammar`* 类型中捕获语法结构，其中每个符号（字符串）映射到一个展开列表（字符串）：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this `Grammar` type, the full grammar for arithmetic expressions looks
    like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 `Grammar` 类型，算术表达式的完整语法看起来是这样的：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the grammar, every symbol can be defined exactly once. We can access any
    rule by its symbol...
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法中，每个符号只能定义一次。我们可以通过其符号访问任何规则...
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '....and we can check whether a symbol is in the grammar:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '...并且我们可以检查一个符号是否在语法中：'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we assume that on the left-hand side of a rule (i.e., the key in the
    mapping) is always a single symbol. This is the property that gives our grammars
    the characterization of *context-free*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们假设规则左侧（即映射中的键）始终是单个符号。这是赋予我们的语法以 *上下文无关* 特性的属性。
- en: Some Definitions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些定义
- en: 'We assume that the canonical start symbol is `<start>`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设规范起始符号是 `<start>`：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The handy `nonterminals()` function extracts the list of nonterminal symbols
    (i.e., anything between `<` and `>`, except spaces) from an expansion.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的 `nonterminals()` 函数可以从一个展开中提取非终结符符号列表（即，`<` 和 `>` 之间的任何内容，除了空格）。
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Likewise, `is_nonterminal()` checks whether some symbol is a nonterminal:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`is_nonterminal()` 检查某个符号是否是非终结符：
- en: '[PRE27]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A Simple Grammar Fuzzer
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单语法模糊器
- en: Let us now put the above grammars to use. We will build a very simple grammar
    fuzzer that starts with a start symbol (`<start>`) and then keeps on expanding
    it. To avoid expansion to infinite inputs, we place a limit (`max_nonterminals`)
    on the number of nonterminals. Furthermore, to avoid being stuck in a situation
    where we cannot reduce the number of symbols any further, we also limit the total
    number of expansion steps.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在使用上述语法。我们将构建一个非常简单的语法模糊器，它从起始符号（`<start>`）开始，然后不断展开它。为了避免无限输入的展开，我们对非终结符的数量（`max_nonterminals`）设置了一个限制。此外，为了避免陷入无法进一步减少符号数量的情况，我们还限制了总的展开步骤数。
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let us see how this simple grammar fuzzer obtains an arithmetic expression
    from the start symbol:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个简单的语法模糊器是如何从起始符号获得算术表达式的：
- en: '[PRE32]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'By increasing the limit of nonterminals, we can quickly get much longer productions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通过增加非终结符的限制，我们可以快速得到更长的产生式：
- en: '[PRE35]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that while our fuzzer does the job in most cases, it has a number of drawbacks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然我们的模糊器在大多数情况下都能完成任务，但它有一些缺点。
- en: Quiz
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问答
- en: What drawbacks does `simple_grammar_fuzzer()` have?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`simple_grammar_fuzzer()` 有哪些缺点？'
- en: Indeed, `simple_grammar_fuzzer()` is rather inefficient due to the large number
    of search and replace operations, and it may even fail to produce a string. On
    the other hand, the implementation is straightforward and does the job in most
    cases. For this chapter, we'll stick to it; in the [next chapter](GrammarFuzzer.html),
    we'll show how to build a more efficient one.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`simple_grammar_fuzzer()` 由于搜索和替换操作的数量庞大，效率相当低，甚至可能无法生成字符串。另一方面，实现简单，在大多数情况下都能完成任务。对于本章，我们将坚持使用它；在[下一章](GrammarFuzzer.html)中，我们将展示如何构建一个更高效的版本。
- en: Visualizing Grammars as Railroad Diagrams
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将语法可视化成铁路图
- en: With grammars, we can easily specify the format for several of the examples
    we discussed earlier. The above arithmetic expressions, for instance, can be directly
    sent into `bc` (or any other program that takes arithmetic expressions). Before
    we introduce a few additional grammars, let us give a means to *visualize* them,
    giving an alternate view to aid their understanding.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法，我们可以轻松地指定我们之前讨论的几个示例的格式。例如，上述算术表达式可以直接发送到 `bc`（或任何接受算术表达式的程序）。在我们介绍一些额外的语法之前，让我们提供一种
    *可视化* 语法的方法，以提供另一种辅助理解的观点。
- en: '*Railroad diagrams*, also called *syntax diagrams*, are a graphical representation
    of context-free grammars. They are read left to right, following possible "rail"
    tracks; the sequence of symbols encountered on the track defines the language.
    To produce railroad diagrams, we implement a function `syntax_diagram()`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*铁路图*，也称为 *语法图*，是上下文无关语法的图形表示。它们从左到右读取，遵循可能的“铁路”轨道；轨道上遇到的符号序列定义了语言。为了生成铁路图，我们实现了一个名为
    `syntax_diagram()` 的函数。'
- en: <details id="Excursion:-Implementing-syntax_diagram()"><summary>Implementing
    `syntax_diagram()`</summary>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-syntax_diagram()"><summary>实现 `syntax_diagram()`</summary>
- en: We use [RailroadDiagrams](RailroadDiagrams.html), an external library for visualization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 [RailroadDiagrams](RailroadDiagrams.html)，一个用于可视化的外部库。
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We first define the method `syntax_diagram_symbol()` to visualize a given symbol.
    Terminal symbols are denoted as ovals, whereas nonterminal symbols (such as `<term>`)
    are denoted as rectangles.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个名为 `syntax_diagram_symbol()` 的方法来可视化给定的符号。终结符号用椭圆形表示，而非终结符号（如 `<term>`）用矩形表示。
- en: '[PRE39]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 154.0 62" width="154.0"><g
    transform="translate(.5 .5)"><g class="non-terminal"><text x="77.0" y="35">term</text></g></g></svg>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 154.0 62" width="154.0"><g
    transform="translate(.5 .5)"><g class="non-terminal"><text x="77.0" y="35">term</text></g></g></svg>
- en: We define `syntax_diagram_expr()` to visualize expansion alternatives.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `syntax_diagram_expr()` 来可视化扩展替代方案。
- en: '[PRE41]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 310.5 62" width="310.5"><g
    transform="translate(.5 .5)"><g><g class="non-terminal"><text x="85.5" y="35">factor</text></g>
    <g class="terminal"><text x="163.75" y="35">*</text></g> <g class="non-terminal"><text
    x="233.5" y="35">term</text></g></g></g></svg>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 310.5 62" width="310.5"><g
    transform="translate(.5 .5)"><g><g class="non-terminal"><text x="85.5" y="35">factor</text></g>
    <g class="terminal"><text x="163.75" y="35">*</text></g> <g class="non-terminal"><text
    x="233.5" y="35">term</text></g></g></g></svg>
- en: This is the first alternative of `<term>` – a `<factor>` followed by `*` and
    a `<term>`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `<term>` 的第一个替代方案——一个 `<factor>` 后跟 `*` 和一个 `<term>`。
- en: Next, we define `syntax_diagram_alt()` for displaying alternate expressions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `syntax_diagram_alt()` 来显示替代表达式。
- en: '[PRE43]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: We see that a `<digit>` can be any single digit from `0` to `9`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 `<digit>` 可以是 `0` 到 `9` 之间的任何单个数字。
- en: Finally, we define `syntax_diagram()` which given a grammar, displays the syntax
    diagram of its rules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了 `syntax_diagram()`，它接受一个语法，并显示其规则的语法图。
- en: '[PRE46]</details>'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE46]</details>'
- en: 'Let us use `syntax_diagram()` to produce a railroad diagram of our expression
    grammar:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `syntax_diagram()` 来生成我们的表达式语法的铁路图：
- en: '[PRE47]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 313.5 122" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">term</text></g>
    <g class="terminal"><text x="156.75" y="35">+</text></g> <g class="non-terminal"><text
    x="226.5" y="35">expr</text></g></g> <g><g class="non-terminal"><text x="87.0"
    y="65">term</text></g> <g class="terminal"><text x="156.75" y="65">-</text></g>
    <g class="non-terminal"><text x="226.5" y="65">expr</text></g></g> <g><g class="non-terminal"><text
    x="156.75" y="95">term</text></g></g></g></g></svg>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 313.5 122" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">term</text></g>
    <g class="terminal"><text x="156.75" y="35">+</text></g> <g class="non-terminal"><text
    x="226.5" y="35">expr</text></g></g> <g><g class="non-terminal"><text x="87.0"
    y="65">term</text></g> <g class="terminal"><text x="156.75" y="65">-</text></g>
    <g class="non-terminal"><text x="226.5" y="65">expr</text></g></g> <g><g class="non-terminal"><text
    x="156.75" y="95">term</text></g></g></g></g></svg>
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 330.5 122" width="330.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">factor</text></g>
    <g class="terminal"><text x="173.75" y="35">*</text></g> <g class="non-terminal"><text
    x="243.5" y="35">term</text></g></g> <g><g class="non-terminal"><text x="95.5"
    y="65">factor</text></g> <g class="terminal"><text x="173.75" y="65">/</text></g>
    <g class="non-terminal"><text x="243.5" y="65">term</text></g></g> <g><g class="non-terminal"><text
    x="165.25" y="95">factor</text></g></g></g></g></svg>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 330.5 122" width="330.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">factor</text></g>
    <g class="terminal"><text x="173.75" y="35">*</text></g> <g class="non-terminal"><text
    x="243.5" y="35">term</text></g></g> <g><g class="non-terminal"><text x="95.5"
    y="65">factor</text></g> <g class="terminal"><text x="173.75" y="65">/</text></g>
    <g class="non-terminal"><text x="243.5" y="65">term</text></g></g> <g><g class="non-terminal"><text
    x="165.25" y="95">factor</text></g></g></g></g></svg>
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <svg class="railroad-diagram" height="182" viewBox="0 0 347.5 182" width="347.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="128.25" y="65">-</text></g>
    <g class="non-terminal"><text x="198.0" y="65">factor</text></g></g> <g><g class="terminal"><text
    x="128.25" y="35">+</text></g> <g class="non-terminal"><text x="198.0" y="35">factor</text></g></g>
    <g><g class="terminal"><text x="112.5" y="95">(</text></g> <g class="non-terminal"><text
    x="173.75" y="95">expr</text></g> <g class="terminal"><text x="235.0" y="95">)</text></g></g>
    <g><g class="non-terminal"><text x="99.75" y="125">integer</text></g> <g class="terminal"><text
    x="173.75" y="125">.</text></g> <g class="non-terminal"><text x="247.75" y="125">integer</text></g></g>
    <g><g class="non-terminal"><text x="173.75" y="155">integer</text></g></g></g></g></svg>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="182" viewBox="0 0 347.5 182" width="347.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="128.25" y="65">-</text></g>
    <g class="non-terminal"><text x="198.0" y="65">factor</text></g></g> <g><g class="terminal"><text
    x="128.25" y="35">+</text></g> <g class="non-terminal"><text x="198.0" y="35">factor</text></g></g>
    <g><g class="terminal"><text x="112.5" y="95">(</text></g> <g class="non-terminal"><text
    x="173.75" y="95">expr</text></g> <g class="terminal"><text x="235.0" y="95">)</text></g></g>
    <g><g class="non-terminal"><text x="99.75" y="125">integer</text></g> <g class="terminal"><text
    x="173.75" y="125">.</text></g> <g class="non-terminal"><text x="247.75" y="125">integer</text></g></g>
    <g><g class="non-terminal"><text x="173.75" y="155">integer</text></g></g></g></g></svg>
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: This railroad representation will come in handy as it comes to visualizing the
    structure of grammars – especially for more complex grammars.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种铁路图表示法在可视化语法结构时非常有用，尤其是对于更复杂的语法。
- en: Some Grammars
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些语法
- en: Let us create (and visualize) some more grammars and use them for fuzzing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建（并可视化）一些更多的语法，并使用它们进行模糊测试。
- en: A CGI Grammar
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CGI 语法
- en: Here's a grammar for `cgi_decode()` introduced in the [chapter on coverage](Coverage.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 [覆盖章节](Coverage.html) 中引入的 `cgi_decode()` 的语法。
- en: '[PRE54]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 191.0 62" width="191.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">string</text></g></g></g></g></svg>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 191.0 62" width="191.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">string</text></g></g></g></g></svg>
- en: '[PRE57]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="141.0" y="35">letter</text></g></g>
    <g><g class="non-terminal"><text x="95.5" y="65">letter</text></g> <g class="non-terminal"><text
    x="186.5" y="65">string</text></g></g></g></g></svg>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="141.0" y="35">letter</text></g></g>
    <g><g class="non-terminal"><text x="95.5" y="65">letter</text></g> <g class="non-terminal"><text
    x="186.5" y="65">string</text></g></g></g></g></svg>
- en: '[PRE58]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 199.5 122" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">plus</text></g></g>
    <g><g class="non-terminal"><text x="99.75" y="65">percent</text></g></g> <g><g
    class="non-terminal"><text x="99.75" y="95">other</text></g></g></g></g></svg>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 199.5 122" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">plus</text></g></g>
    <g><g class="non-terminal"><text x="99.75" y="65">percent</text></g></g> <g><g
    class="non-terminal"><text x="99.75" y="95">other</text></g></g></g></g></svg>
- en: '[PRE59]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">+</text></g></g></g></g></svg>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">+</text></g></g></g></g></svg>
- en: '[PRE60]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 364.5 62" width="364.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">%</text></g>
    <g class="non-terminal"><text x="152.5" y="35">hexdigit</text></g> <g class="non-terminal"><text
    x="260.5" y="35">hexdigit</text></g></g></g></g></svg>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 364.5 62" width="364.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">%</text></g>
    <g class="non-terminal"><text x="152.5" y="35">hexdigit</text></g> <g class="non-terminal"><text
    x="260.5" y="35">hexdigit</text></g></g></g></g></svg>
- en: '[PRE61]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <svg class="railroad-diagram" height="138" viewBox="0 0 611.0 138" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g> <g><g class="terminal"><text
    x="84.25" y="103">2</text></g></g></g> <g><g><g class="terminal"><text x="172.75"
    y="43">3</text></g></g> <g><g class="terminal"><text x="172.75" y="73">4</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">5</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="43">6</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">7</text></g></g> <g><g class="terminal"><text x="261.25" y="103">8</text></g></g></g>
    <g><g><g class="terminal"><text x="349.75" y="43">9</text></g></g> <g><g class="terminal"><text
    x="349.75" y="73">a</text></g></g> <g><g class="terminal"><text x="349.75" y="103">b</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">c</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">d</text></g></g> <g><g class="terminal"><text x="438.25" y="103">e</text></g></g></g>
    <g><g><g class="terminal"><text x="526.75" y="73">f</text></g></g></g></g></g></svg>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="138" viewBox="0 0 611.0 138" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g> <g><g class="terminal"><text
    x="84.25" y="103">2</text></g></g></g> <g><g><g class="terminal"><text x="172.75"
    y="43">3</text></g></g> <g><g class="terminal"><text x="172.75" y="73">4</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">5</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="43">6</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">7</text></g></g> <g><g class="terminal"><text x="261.25" y="103">8</text></g></g></g>
    <g><g><g class="terminal"><text x="349.75" y="43">9</text></g></g> <g><g class="terminal"><text
    x="349.75" y="73">a</text></g></g> <g><g class="terminal"><text x="349.75" y="103">b</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">c</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">d</text></g></g> <g><g class="terminal"><text x="438.25" y="103">e</text></g></g></g>
    <g><g><g class="terminal"><text x="526.75" y="73">f</text></g></g></g></g></g></svg>
- en: '[PRE62]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 699.5 109" width="699.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">a</text></g></g> <g><g class="terminal"><text x="349.75" y="73">b</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">c</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">d</text></g></g></g> <g><g><g class="terminal"><text x="526.75"
    y="43">e</text></g></g> <g><g class="terminal"><text x="526.75" y="73">-</text></g></g></g>
    <g><g><g class="terminal"><text x="615.25" y="73">_</text></g></g></g></g></g></svg>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 699.5 109" width="699.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">a</text></g></g> <g><g class="terminal"><text x="349.75" y="73">b</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">c</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">d</text></g></g></g> <g><g><g class="terminal"><text x="526.75"
    y="43">e</text></g></g> <g><g class="terminal"><text x="526.75" y="73">-</text></g></g></g>
    <g><g><g class="terminal"><text x="615.25" y="73">_</text></g></g></g></g></g></svg>
- en: 'In contrast to [basic fuzzing](Fuzzer.html) or [mutation-based fuzzing](MutationFuzzer.html),
    the grammar quickly produces all sorts of combinations:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [基本模糊测试](Fuzzer.html) 或 [基于变异的模糊测试](MutationFuzzer.html) 相比，语法可以快速生成各种组合：
- en: '[PRE63]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: A URL Grammar
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: URL 语法
- en: 'The same properties we have seen for CGI input also hold for more complex inputs.
    Let us use a grammar to produce numerous valid URLs:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CGI 输入中看到的相同属性也适用于更复杂的输入。让我们使用语法生成大量的有效 URL：
- en: '[PRE65]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 165.5 62" width="165.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">url</text></g></g></g></g></svg>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 165.5 62" width="165.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">url</text></g></g></g></g></svg>
- en: '[PRE68]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 529.5 62" width="529.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">scheme</text></g>
    <g class="terminal"><text x="173.75" y="35">://</text></g> <g class="non-terminal"><text
    x="264.75" y="35">authority</text></g> <g class="non-terminal"><text x="360.0"
    y="35">path</text></g> <g class="non-terminal"><text x="438.25" y="35">query</text></g></g></g></g></svg>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 529.5 62" width="529.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">scheme</text></g>
    <g class="terminal"><text x="173.75" y="35">://</text></g> <g class="non-terminal"><text
    x="264.75" y="35">authority</text></g> <g class="non-terminal"><text x="360.0"
    y="35">path</text></g> <g class="non-terminal"><text x="438.25" y="35">query</text></g></g></g></g></svg>
- en: '[PRE69]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <svg class="railroad-diagram" height="152" viewBox="0 0 182.5 152" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="91.25" y="65">https</text></g></g>
    <g><g class="terminal"><text x="91.25" y="35">http</text></g></g> <g><g class="terminal"><text
    x="91.25" y="95">ftp</text></g></g> <g><g class="terminal"><text x="91.25" y="125">ftps</text></g></g></g></g></svg>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="152" viewBox="0 0 182.5 152" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="91.25" y="65">https</text></g></g>
    <g><g class="terminal"><text x="91.25" y="35">http</text></g></g> <g><g class="terminal"><text
    x="91.25" y="95">ftp</text></g></g> <g><g class="terminal"><text x="91.25" y="125">ftps</text></g></g></g></g></svg>
- en: '[PRE70]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <svg class="railroad-diagram" height="152" viewBox="0 0 453.0 152" width="453.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="165.25" y="65">host</text></g>
    <g class="terminal"><text x="226.5" y="65">:</text></g> <g class="non-terminal"><text
    x="287.75" y="65">port</text></g></g> <g><g class="non-terminal"><text x="226.5"
    y="35">host</text></g></g> <g><g class="non-terminal"><text x="165.25" y="95">userinfo</text></g>
    <g class="terminal"><text x="243.5" y="95">@</text></g> <g class="non-terminal"><text
    x="304.75" y="95">host</text></g></g> <g><g class="non-terminal"><text x="104.0"
    y="125">userinfo</text></g> <g class="terminal"><text x="182.25" y="125">@</text></g>
    <g class="non-terminal"><text x="243.5" y="125">host</text></g> <g class="terminal"><text
    x="304.75" y="125">:</text></g> <g class="non-terminal"><text x="366.0" y="125">port</text></g></g></g></g></svg>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="152" viewBox="0 0 453.0 152" width="453.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="165.25" y="65">host</text></g>
    <g class="terminal"><text x="226.5" y="65">:</text></g> <g class="non-terminal"><text
    x="287.75" y="65">port</text></g></g> <g><g class="non-terminal"><text x="226.5"
    y="35">host</text></g></g> <g><g class="non-terminal"><text x="165.25" y="95">userinfo</text></g>
    <g class="terminal"><text x="243.5" y="95">@</text></g> <g class="non-terminal"><text
    x="304.75" y="95">host</text></g></g> <g><g class="non-terminal"><text x="104.0"
    y="125">userinfo</text></g> <g class="terminal"><text x="182.25" y="125">@</text></g>
    <g class="non-terminal"><text x="243.5" y="125">host</text></g> <g class="terminal"><text
    x="304.75" y="125">:</text></g> <g class="non-terminal"><text x="366.0" y="125">port</text></g></g></g></g></svg>
- en: '[PRE71]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 267.5 122" width="267.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="133.75" y="35">cispa.saarland</text></g></g>
    <g><g class="terminal"><text x="133.75" y="65">www.google.com</text></g></g> <g><g
    class="terminal"><text x="133.75" y="95">fuzzingbook.com</text></g></g></g></g></svg>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 267.5 122" width="267.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="133.75" y="35">cispa.saarland</text></g></g>
    <g><g class="terminal"><text x="133.75" y="65">www.google.com</text></g></g> <g><g
    class="terminal"><text x="133.75" y="95">fuzzingbook.com</text></g></g></g></g></svg>
- en: '[PRE72]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 174.0 122" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="87.0" y="35">80</text></g></g>
    <g><g class="terminal"><text x="87.0" y="65">8080</text></g></g> <g><g class="non-terminal"><text
    x="87.0" y="95">nat</text></g></g></g></g></svg>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 174.0 122" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="87.0" y="35">80</text></g></g>
    <g><g class="terminal"><text x="87.0" y="65">8080</text></g></g> <g><g class="non-terminal"><text
    x="87.0" y="95">nat</text></g></g></g></g></svg>
- en: '[PRE73]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 265.0 92" width="265.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="132.5" y="35">digit</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">digit</text></g> <g class="non-terminal"><text
    x="173.75" y="65">digit</text></g></g></g></g></svg>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 265.0 92" width="265.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="132.5" y="35">digit</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">digit</text></g> <g class="non-terminal"><text
    x="173.75" y="65">digit</text></g></g></g></g></svg>
- en: '[PRE74]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: '[PRE75]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 250.5 62" width="250.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="125.25" y="35">user:password</text></g></g></g></g></svg>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 250.5 62" width="250.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="125.25" y="35">user:password</text></g></g></g></g></svg>
- en: '[PRE76]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 205.5 122" width="205.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="102.75" y="65">/</text></g></g>
    <g><g class="terminal"><text x="74.25" y="95">/</text></g> <g class="non-terminal"><text
    x="127.0" y="95">id</text></g></g></g></g></svg>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 205.5 122" width="205.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="102.75" y="65">/</text></g></g>
    <g><g class="terminal"><text x="74.25" y="95">/</text></g> <g class="non-terminal"><text
    x="127.0" y="95">id</text></g></g></g></g></svg>
- en: '[PRE77]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 313.5 122" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="156.75" y="35">abc</text></g></g>
    <g><g class="terminal"><text x="156.75" y="65">def</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">x</text></g> <g class="non-terminal"><text x="139.75" y="95">digit</text></g>
    <g class="non-terminal"><text x="222.25" y="95">digit</text></g></g></g></g></svg>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 313.5 122" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="156.75" y="35">abc</text></g></g>
    <g><g class="terminal"><text x="156.75" y="65">def</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">x</text></g> <g class="non-terminal"><text x="139.75" y="95">digit</text></g>
    <g class="non-terminal"><text x="222.25" y="95">digit</text></g></g></g></g></svg>
- en: '[PRE78]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 239.5 92" width="239.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="65">?</text></g>
    <g class="non-terminal"><text x="144.0" y="65">params</text></g></g></g></g></svg>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 239.5 92" width="239.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="65">?</text></g>
    <g class="non-terminal"><text x="144.0" y="65">params</text></g></g></g></g></svg>
- en: '[PRE79]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 322.0 92" width="322.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="161.0" y="35">param</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">param</text></g> <g class="terminal"><text
    x="156.75" y="65">&</text></g> <g class="non-terminal"><text x="226.5" y="65">params</text></g></g></g></g></svg>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 322.0 92" width="322.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="161.0" y="35">param</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">param</text></g> <g class="terminal"><text
    x="156.75" y="65">&</text></g> <g class="non-terminal"><text x="226.5" y="65">params</text></g></g></g></g></svg>
- en: '[PRE80]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 271.0 92" width="271.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">id</text></g>
    <g class="terminal"><text x="135.5" y="35">=</text></g> <g class="non-terminal"><text
    x="188.25" y="35">id</text></g></g> <g><g class="non-terminal"><text x="78.5"
    y="65">id</text></g> <g class="terminal"><text x="131.25" y="65">=</text></g>
    <g class="non-terminal"><text x="188.25" y="65">nat</text></g></g></g></g></svg>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 271.0 92" width="271.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">id</text></g>
    <g class="terminal"><text x="135.5" y="35">=</text></g> <g class="non-terminal"><text
    x="188.25" y="35">id</text></g></g> <g><g class="non-terminal"><text x="78.5"
    y="65">id</text></g> <g class="terminal"><text x="131.25" y="65">=</text></g>
    <g class="non-terminal"><text x="188.25" y="65">nat</text></g></g></g></g></svg>
- en: Again, within milliseconds, we can produce plenty of valid inputs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在毫秒之内，我们可以生成大量的有效输入。
- en: '[PRE81]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: A Natural Language Grammar
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自然语言语法
- en: 'Finally, grammars are not limited to *formal languages* such as computer inputs,
    but can also be used to produce *natural language*. This is the grammar we used
    to pick a title for this book:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，语法不仅限于 *形式语言*，如计算机输入，还可以用于生成 *自然语言*。这是我们用来选择这本书标题的语法：
- en: '[PRE83]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">title</text></g></g></g></g></svg>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">title</text></g></g></g></g></svg>
- en: '[PRE86]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 347.5 62" width="347.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">topic</text></g>
    <g class="terminal"><text x="161.0" y="35">:</text></g> <g class="non-terminal"><text
    x="243.5" y="35">subtopic</text></g></g></g></g></svg>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 347.5 62" width="347.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">topic</text></g>
    <g class="terminal"><text x="161.0" y="35">:</text></g> <g class="non-terminal"><text
    x="243.5" y="35">subtopic</text></g></g></g></g></svg>
- en: '[PRE87]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 358.5 122" width="358.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="179.25" y="35">Generating
    Software Tests</text></g></g> <g><g class="non-terminal"><text x="129.5" y="65">fuzzing-prefix</text></g>
    <g class="terminal"><text x="258.75" y="65">Fuzzing</text></g></g> <g><g class="terminal"><text
    x="179.25" y="95">The Fuzzing Book</text></g></g></g></g></svg>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 358.5 122" width="358.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="179.25" y="35">Generating
    Software Tests</text></g></g> <g><g class="non-terminal"><text x="129.5" y="65">fuzzing-prefix</text></g>
    <g class="terminal"><text x="258.75" y="65">Fuzzing</text></g></g> <g><g class="terminal"><text
    x="179.25" y="95">The Fuzzing Book</text></g></g></g></g></svg>
- en: '[PRE88]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 233.5 122" width="233.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="116.75" y="65">The
    Art of</text></g></g> <g><g class="terminal"><text x="116.75" y="95">The Joy of</text></g></g></g></g></svg>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 233.5 122" width="233.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="116.75" y="65">The
    Art of</text></g></g> <g><g class="terminal"><text x="116.75" y="95">The Joy of</text></g></g></g></g></svg>
- en: '[PRE89]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 418.0 122" width="418.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="209.0" y="35">subtopic-main</text></g></g>
    <g><g class="non-terminal"><text x="133.75" y="65">subtopic-prefix</text></g>
    <g class="non-terminal"><text x="292.75" y="65">subtopic-main</text></g></g> <g><g
    class="non-terminal"><text x="125.25" y="95">subtopic-main</text></g> <g class="non-terminal"><text
    x="284.25" y="95">subtopic-suffix</text></g></g></g></g></svg>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 418.0 122" width="418.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="209.0" y="35">subtopic-main</text></g></g>
    <g><g class="non-terminal"><text x="133.75" y="65">subtopic-prefix</text></g>
    <g class="non-terminal"><text x="292.75" y="65">subtopic-main</text></g></g> <g><g
    class="non-terminal"><text x="125.25" y="95">subtopic-main</text></g> <g class="non-terminal"><text
    x="284.25" y="95">subtopic-suffix</text></g></g></g></g></svg>
- en: '[PRE90]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 412.0 122" width="412.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="206.0" y="35">Breaking
    Software</text></g></g> <g><g class="terminal"><text x="206.0" y="65">Generating
    Software Tests</text></g></g> <g><g class="terminal"><text x="206.0" y="95">Principles,
    Techniques and Tools</text></g></g></g></g></svg>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 412.0 122" width="412.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="206.0" y="35">Breaking
    Software</text></g></g> <g><g class="terminal"><text x="206.0" y="65">Generating
    Software Tests</text></g></g> <g><g class="terminal"><text x="206.0" y="95">Principles,
    Techniques and Tools</text></g></g></g></g></svg>
- en: '[PRE91]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 352.5 92" width="352.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="176.25" y="65">Tools
    and Techniques for</text></g></g></g></g></svg>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 352.5 92" width="352.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="176.25" y="65">Tools
    and Techniques for</text></g></g></g></g></svg>
- en: '[PRE92]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 634.0 92" width="634.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="108.25" y="35">for</text></g>
    <g class="non-terminal"><text x="233.25" y="35">reader-property</text></g> <g
    class="terminal"><text x="358.25" y="35">and</text></g> <g class="non-terminal"><text
    x="483.25" y="35">reader-property</text></g></g> <g><g class="terminal"><text
    x="91.25" y="65">for</text></g> <g class="non-terminal"><text x="224.75" y="65">software-property</text></g>
    <g class="terminal"><text x="358.25" y="65">and</text></g> <g class="non-terminal"><text
    x="491.75" y="65">software-property</text></g></g></g></g></svg>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 634.0 92" width="634.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="108.25" y="35">for</text></g>
    <g class="non-terminal"><text x="233.25" y="35">reader-property</text></g> <g
    class="terminal"><text x="358.25" y="35">and</text></g> <g class="non-terminal"><text
    x="483.25" y="35">reader-property</text></g></g> <g><g class="terminal"><text
    x="91.25" y="65">for</text></g> <g class="non-terminal"><text x="224.75" y="65">software-property</text></g>
    <g class="terminal"><text x="358.25" y="65">and</text></g> <g class="non-terminal"><text
    x="491.75" y="65">software-property</text></g></g></g></g></svg>
- en: '[PRE93]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 191.0 92" width="191.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="95.5" y="35">Fun</text></g></g>
    <g><g class="terminal"><text x="95.5" y="65">Profit</text></g></g></g></g></svg>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 191.0 92" width="191.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="95.5" y="35">Fun</text></g></g>
    <g><g class="terminal"><text x="95.5" y="65">Profit</text></g></g></g></g></svg>
- en: '[PRE94]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 233.5 122" width="233.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="116.75" y="35">Robustness</text></g></g>
    <g><g class="terminal"><text x="116.75" y="65">Reliability</text></g></g> <g><g
    class="terminal"><text x="116.75" y="95">Security</text></g></g></g></g></svg>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 233.5 122" width="233.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="116.75" y="35">Robustness</text></g></g>
    <g><g class="terminal"><text x="116.75" y="65">Reliability</text></g></g> <g><g
    class="terminal"><text x="116.75" y="95">Security</text></g></g></g></g></svg>
- en: '[PRE95]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '(If you find that there is redundancy ("Robustness and Robustness") in here:
    In [our chapter on coverage-based fuzzing](GrammarCoverageFuzzer.html), we will
    show how to cover each expansion only once. And if you like some alternatives
    more than others, [probabilistic grammar fuzzing](ProbabilisticGrammarFuzzer.html)
    will be there for you.)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你在这里发现存在冗余（“鲁棒性和鲁棒性”）：在我们的 [基于覆盖的模糊测试章节](GrammarCoverageFuzzer.html) 中，我们将展示如何只覆盖每个扩展一次。如果你更喜欢某些替代方案，[概率语法模糊测试](ProbabilisticGrammarFuzzer.html)
    将为你提供。）
- en: Grammars as Mutation Seeds
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法作为变异种子
- en: One very useful property of grammars is that they produce mostly valid inputs.
    From a syntactical standpoint, the inputs are actually *always* valid, as they
    satisfy the constraints of the given grammar. (Of course, one needs a valid grammar
    in the first place.) However, there are also *semantic* properties that cannot
    be easily expressed in a grammar. If, say, for a URL, the port range is supposed
    to be between 1024 and 2048, this is hard to write in a grammar. If one has to
    satisfy more complex constraints, one quickly reaches the limits of what a grammar
    can express.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的一个非常有用的特性是它们产生的大多数输入都是有效的。从句法的角度来看，输入实际上是*始终*有效的，因为它们满足给定语法的约束。（当然，首先需要一个有效的语法。）然而，还有一些*语义*特性在语法中难以表达。例如，对于一个URL，端口号的范围应该在1024到2048之间，这在语法中很难写出来。如果必须满足更复杂的约束，很快就会达到语法的表达能力极限。
- en: One way around this is to attach constraints to grammars, as we will discuss
    [later in this book](FuzzingWithConstraints.html). Another possibility is to put
    together the strengths of grammar-based fuzzing and [mutation-based fuzzing](MutationFuzzer.html).
    The idea is to use the grammar-generated inputs as *seeds* for further mutation-based
    fuzzing. This way, we can explore not only *valid* inputs, but also check out
    the *boundaries* between valid and invalid inputs. This is particularly interesting
    as slightly invalid inputs allow finding parser errors (which are often abundant).
    As with fuzzing in general, it is the unexpected which reveals errors in programs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方法是给语法附加约束，正如我们将在本书[后面讨论的](FuzzingWithConstraints.html)。另一种可能性是将基于语法的模糊测试和基于[变异的模糊测试](MutationFuzzer.html)的优点结合起来。想法是使用语法生成的输入作为进一步基于变异的模糊测试的*种子*。这样，我们不仅可以探索*有效*的输入，还可以检查有效和无效输入之间的*边界*。这尤其有趣，因为略微无效的输入可以找到解析错误（这些错误通常很多）。与一般的模糊测试一样，意外的是揭示程序中错误的关键。
- en: 'To use our generated inputs as seeds, we can feed them directly into the mutation
    fuzzers introduced earlier:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们生成的输入作为种子，我们可以直接将它们输入到之前介绍的变异模糊测试器中：
- en: '[PRE98]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: While the first 10 `fuzz()` calls return the seeded inputs (as designed), the
    later ones again create arbitrary mutations. Using `MutationCoverageFuzzer` instead
    of `MutationFuzzer`, we could again have our search guided by coverage – and thus
    bring together the best of multiple worlds.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前10次`fuzz()`调用返回的是种子输入（按设计），但后续的调用又创建了任意的变异。使用`MutationCoverageFuzzer`而不是`MutationFuzzer`，我们可以再次通过覆盖率来引导搜索——从而将多个世界的优点结合起来。
- en: A Grammar Toolbox
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法工具箱
- en: Let us now introduce a few techniques that help us writing grammars.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍一些有助于我们编写语法的技巧。
- en: Escapes
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义
- en: 'With `<` and `>` delimiting nonterminals in our grammars, how can we actually
    express that some input should contain `<` and `>`? The answer is simple: Just
    introduce a symbol for them.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的语法中使用`<`和`>`来界定非终结符，我们如何实际上表达某些输入应该包含`<`和`>`呢？答案是简单的：只需为它们引入一个符号。
- en: '[PRE104]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In `simple_nonterminal_grammar`, neither the expansion for `<left-angle>` nor
    the expansion for `<right-angle>` can be mistaken for a nonterminal. Hence, we
    can produce as many as we want.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`simple_nonterminal_grammar`中，`<left-angle>`的展开和`<right-angle>`的展开都不可能被误认为是非终结符。因此，我们可以生成尽可能多的。
- en: (Note that this does not work with `simple_grammar_fuzzer()`, but rather with
    the `GrammarFuzzer` class we'll introduce in the next chapter.)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，这并不适用于`simple_grammar_fuzzer()`，而是适用于我们在下一章中将要介绍的`GrammarFuzzer`类。）
- en: Extending Grammars
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展语法
- en: In the course of this book, we frequently run into the issue of creating a grammar
    by *extending* an existing grammar with new features. Such an extension is very
    much like subclassing in object-oriented programming.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的进程中，我们经常遇到通过*扩展*现有语法以添加新功能来创建语法的问题。这种扩展在面向对象编程中非常类似于子类化。
- en: 'To create a new grammar $g''$ from an existing grammar $g$, we first copy $g$
    into $g''$, and then go and extend existing rules with new alternatives and/or
    add new symbols. Here''s an example, extending the above `nonterminal` grammar
    with a better rule for identifiers:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个现有语法$g$创建一个新的语法$g'$，我们首先将$g$复制到$g'$中，然后添加新的选择和/或添加新符号来扩展现有规则。以下是一个示例，扩展上述`nonterminal`语法以包含一个更好的标识符规则：
- en: '[PRE105]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Since such an extension of grammars is a common operation, we introduce a custom
    function `extend_grammar()` which first copies the given grammar and then updates
    it from a dictionary, using the Python dictionary `update()` method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种语法的扩展是一个常见的操作，我们引入了一个自定义函数`extend_grammar()`，它首先复制给定的语法，然后使用Python字典的`update()`方法从字典中更新它：
- en: '[PRE109]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This call to `extend_grammar()` extends `simple_nonterminal_grammar` to `nonterminal_grammar`
    just like the "manual" example above:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对 `extend_grammar()` 的调用将 `simple_nonterminal_grammar` 扩展到 `nonterminal_grammar`，就像上面的“手动”示例一样：
- en: '[PRE110]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Character Classes
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符类别
- en: In the above `nonterminal_grammar`, we have enumerated only the first few letters;
    indeed, enumerating all letters or digits in a grammar manually, as in `<idchar>
    ::= 'a' | 'b' | 'c' ...` is a bit painful.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `nonterminal_grammar` 中，我们只列出了前几个字母；实际上，手动枚举语法中的所有字母或数字，如 `<idchar> ::=
    'a' | 'b' | 'c' ...` 是一件痛苦的事情。
- en: 'However, remember that grammars are part of a program, and can thus also be
    constructed programmatically. We introduce a function `srange()` which constructs
    a list of characters in a string:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，语法是程序的一部分，因此也可以通过编程方式构建。我们引入了一个名为 `srange()` 的函数，该函数构建一个字符串中的字符列表：
- en: '[PRE111]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If we pass it the constant `string.ascii_letters`, which holds all ASCII letters,
    `srange()` returns a list of all ASCII letters:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们传递它常量 `string.ascii_letters`，它包含所有ASCII字母，`srange()` 返回所有ASCII字母的列表：
- en: '[PRE113]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We can use such constants in our grammar to quickly define identifiers:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的语法中使用这样的常量来快速定义标识符：
- en: '[PRE117]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The shortcut `crange(start, end)` returns a list of all characters in the ASCII
    range of `start` to (including) `end`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 短路 `crange(start, end)` 返回从 `start` 到（包括）`end` 的ASCII范围内的所有字符列表：
- en: '[PRE120]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We can use this to express ranges of characters:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这一点来表示字符范围：
- en: '[PRE121]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Grammar Shortcuts
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法快捷方式
- en: 'In the above `nonterminal_grammar`, as in other grammars, we have to express
    repetitions of characters using *recursion*, that is, by referring to the original
    definition:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `nonterminal_grammar` 中，就像在其他语法中一样，我们必须使用**递归**来表示字符的重复，即通过引用原始定义：
- en: '[PRE124]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: It could be a bit easier if we simply could state that a nonterminal should
    be a non-empty sequence of letters – for instance, as in
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够简单地声明一个非终结符应该是一个非空字母序列——例如，如下所示
- en: '[PRE126]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: where `+` denotes a non-empty repetition of the symbol it follows.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `+` 表示其后符号的非空重复。
- en: 'Operators such as `+` are frequently introduced as handy *shortcuts* in grammars.
    Formally, our grammars come in the so-called [Backus-Naur form](https://en.wikipedia.org/wiki/Backus-Naur_form),
    or *BNF* for short. Operators *extend* BNF to so-called _extended BNF*, or* EBNF*
    for short:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法中，像 `+` 这样的运算符经常被用作方便的**快捷方式**。正式来说，我们的语法采用所谓的[巴科斯-诺尔范式](https://en.wikipedia.org/wiki/Backus-Naur_form)，或简称**BNF**。运算符**扩展**了所谓的**扩展BNF**，或简称**EBNF**：
- en: The form `<symbol>?` indicates that `<symbol>` is optional – that is, it can
    occur 0 or 1 times.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<symbol>?` 的形式表示 `<symbol>` 是可选的——也就是说，它可以出现0次或1次。'
- en: The form `<symbol>+` indicates that `<symbol>` can occur 1 or more times repeatedly.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<symbol>+` 的形式表示 `<symbol>` 可以出现1次或多次重复。'
- en: The form `<symbol>*` indicates that `<symbol>` can occur 0 or more times. (In
    other words, it is an optional repetition.)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<symbol>*` 的形式表示 `<symbol>` 可以出现0次或多次。（换句话说，它是一个可选的重复。）'
- en: To make matters even more interesting, we would like to use *parentheses* with
    the above shortcuts. Thus, `(<foo><bar>)?` indicates that the sequence of `<foo>`
    and `<bar>` is optional.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，我们希望使用**括号**与上述快捷方式一起使用。因此，`(<foo><bar>)?` 表示 `<foo>` 和 `<bar>` 的序列是可选的。
- en: 'Using such operators, we can define the identifier rule in a simpler way. To
    this end, let us create a copy of the original grammar and modify the `<identifier>`
    rule:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的运算符，我们可以以更简单的方式定义标识符规则。为此，让我们创建原始语法的副本并修改 `<identifier>` 规则：
- en: '[PRE127]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Likewise, we can simplify the expression grammar. Consider how signs are optional,
    and how integers can be expressed as sequences of digits.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以简化表达式语法。考虑符号是可选的，以及整数可以表示为数字序列。
- en: '[PRE128]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Let us implement a function `convert_ebnf_grammar()` that takes such an EBNF
    grammar and automatically translates it into a BNF grammar.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个名为 `convert_ebnf_grammar()` 的函数，它接受这样的EBNF语法并将其自动转换为BNF语法。
- en: <details id="Excursion:-Implementing-convert_ebnf_grammar()"><summary>Implementing
    `convert_ebnf_grammar()`</summary>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-convert_ebnf_grammar()"><summary>实现 `convert_ebnf_grammar()`</summary>
- en: 'Our aim is to convert EBNF grammars such as the ones above into a regular BNF
    grammar. This is done by four rules:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是将像上面那样的EBNF语法转换为常规的BNF语法。这是通过四个规则完成的：
- en: An expression `(content)op`, where `op` is one of `?`, `+`, `*`, becomes `<new-symbol>op`,
    with a new rule `<new-symbol> ::= content`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式 `(content)op`，其中 `op` 是 `?`、`+`、`*` 之一，变为 `<new-symbol>op`，并添加一个新规则 `<new-symbol>
    ::= content`。
- en: An expression `<symbol>?` becomes `<new-symbol>`, where `<new-symbol> ::= <empty>
    | <symbol>`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式 `<symbol>?` 变为 `<new-symbol>`，其中 `<new-symbol> ::= <empty> | <symbol>`。
- en: An expression `<symbol>+` becomes `<new-symbol>`, where `<new-symbol> ::= <symbol>
    | <symbol><new-symbol>`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式 `<symbol>+` 变为 `<new-symbol>`，其中 `<new-symbol> ::= <symbol> | <symbol><new-symbol>`。
- en: An expression `<symbol>*` becomes `<new-symbol>`, where `<new-symbol> ::= <empty>
    | <symbol><new-symbol>`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表达式 `<symbol>*` 变为 `<new-symbol>`，其中 `<new-symbol> ::= <empty> | <symbol><new-symbol>`。
- en: Here, `<empty>` expands to the empty string, as in `<empty> ::=`. (This is also
    called an *epsilon expansion*.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<empty>` 扩展为空字符串，正如 `<empty> ::=`。 (这也可以称为 *epsilon 扩展*。)
- en: 'If these operators remind you of *regular expressions*, this is not by accident:
    Actually, any basic regular expression can be converted into a grammar using the
    above rules (and character classes with `crange()`, as defined above).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些运算符让你想起了 *正则表达式*，这并非偶然：实际上，任何基本正则表达式都可以使用上述规则（以及上面定义的 `crange()` 中的字符类）转换为语法。
- en: 'Applying these rules on the examples above yields the following results:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例上应用这些规则会产生以下结果：
- en: '`<idchar>+` becomes `<idchar><new-symbol>` with `<new-symbol> ::= <idchar>
    | <idchar><new-symbol>`.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<idchar>+` 变为 `<idchar><new-symbol>`，其中 `<new-symbol> ::= <idchar> | <idchar><new-symbol>`。'
- en: '`<integer>(.<integer>)?` becomes `<integer><new-symbol>` with `<new-symbol>
    ::= <empty> | .<integer>`.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<integer>(.<integer>)?` 变为 `<integer><new-symbol>`，其中 `<new-symbol> ::= <empty>
    | .<integer>`。'
- en: Let us implement these rules in three steps.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在三个步骤中实现这些规则。
- en: Creating New Symbols
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建新符号
- en: First, we need a mechanism to create new symbols. This is fairly straightforward.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一种创建新符号的机制。这相当直接。
- en: '[PRE129]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Expanding Parenthesized Expressions
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展括号表达式
- en: 'Next, we need a means to extract parenthesized expressions from our expansions
    and expand them according to the rules above. Let''s start with extracting expressions:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法从我们的扩展中提取括号表达式，并根据上述规则进行扩展。让我们从提取表达式开始：
- en: '[PRE131]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We can now use these to apply rule number 1, above, introducing new symbols
    for expressions in parentheses.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这些来应用上述第1条规则，为括号中的表达式引入新符号。
- en: '[PRE134]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This does the conversion as sketched above:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按照上述草图进行转换：
- en: '[PRE135]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'It even works for nested parenthesized expressions:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 即使对于嵌套的括号表达式也有效：
- en: '[PRE137]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Expanding Operators
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 扩展运算符
- en: After expanding parenthesized expressions, we now need to take care of symbols
    followed by operators (`?`, `*`, `+`). As with `convert_ebnf_parentheses()`, above,
    we first extract all symbols followed by an operator.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展括号表达式之后，我们现在需要处理跟在运算符后面的符号（`?`，`*`，`+`）。与上面的 `convert_ebnf_parentheses()`
    类似，我们首先提取所有跟在运算符后面的符号。
- en: '[PRE139]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Our converter extracts the symbol and the operator, and adds new symbols according
    to the rules laid out above.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的转换器提取符号和运算符，并根据上述规则添加新符号。
- en: '[PRE142]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: All Together
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全部一起
- en: 'We can combine the two, first extending parentheses and then operators:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个结合起来，首先扩展括号，然后是运算符：
- en: '[PRE145]</details>'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE145]</details>'
- en: 'Here''s an example of using `convert_ebnf_grammar()`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `convert_ebnf_grammar()` 的例子：
- en: '[PRE146]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Success! We have nicely converted the EBNF grammar into BNF.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经将EBNF语法优雅地转换为BNF。
- en: With character classes and EBNF grammar conversion, we have two powerful tools
    that make the writing of grammars easier. We will use these again and again as
    it comes to working with grammars.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符类和EBNF语法转换，我们有两个强大的工具，使编写语法变得更容易。我们将反复使用这些工具，当我们处理语法时。
- en: Grammar Extensions
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法扩展
- en: During the course of this book, we frequently want to specify *additional information*
    for grammars, such as [*probabilities*](ProbabilisticGrammarFuzzer.html) or [*constraints*](GeneratorGrammarFuzzer.html).
    To support these extensions, as well as possibly others, we define an *annotation*
    mechanism.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们经常需要为语法指定 *附加信息*，例如 [*概率*](ProbabilisticGrammarFuzzer.html) 或 [*约束*](GeneratorGrammarFuzzer.html)。为了支持这些扩展，以及可能的其他扩展，我们定义了一种
    *注释* 机制。
- en: Our concept for annotating grammars is to add *annotations* to individual expansions.
    To this end, we allow that an expansion cannot only be a string, but also a *pair*
    of a string and a set of attributes, as in
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对注释语法的概念是向单个扩展添加 *注释*。为此，我们允许扩展不仅可以是一个字符串，还可以是一个字符串和一组属性的 *对*，如下所示
- en: '[PRE150]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here, the `opts()` function would allow us to express annotations that apply
    to the individual expansions; in this case, the addition would be annotated with
    a `min_depth` value of 10, and the subtraction with a `max_depth` value of 2\.
    The meaning of these annotations is left to the individual algorithms dealing
    with the grammars; the general idea, though, is that they can be ignored.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`opts()`函数允许我们表达适用于单个扩展的注释；在这种情况下，加法将被注释为具有10的`min_depth`值，减法将被注释为具有2的`max_depth`值。这些注释的含义留给处理语法的各个算法来决定；然而，一般而言，它们可以被忽略。
- en: <details id="Excursion:-Implementing-opts()"><summary>Implementing `opts()`</summary>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-opts()"><summary>实现`opts()`</summary>
- en: 'Our `opts()` helper function returns a mapping of its arguments to values:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`opts()`辅助函数返回其参数到值的映射：
- en: '[PRE151]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'To deal with both expansion strings and pairs of expansions and annotations,
    we access the expansion string and the associated annotations via designated helper
    functions, `exp_string()` and `exp_opts()`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理扩展字符串以及扩展和注释的成对出现，我们通过指定的辅助函数`exp_string()`和`exp_opts()`来访问扩展字符串和相关注释：
- en: '[PRE154]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Finally, we define a helper function that sets a particular option:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义一个设置特定选项的辅助函数：
- en: '[PRE163]</details>'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE163]</details>'
- en: Checking Grammars
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查语法
- en: Since grammars are represented as strings, it is fairly easy to introduce errors.
    So let us introduce a helper function that checks a grammar for consistency.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 由于语法表示为字符串，因此引入错误相对容易。因此，让我们引入一个检查语法一致性的辅助函数。
- en: The helper function `is_valid_grammar()` iterates over a grammar to check whether
    all used symbols are defined, and vice versa, which is very useful for debugging;
    it also checks whether all symbols are reachable from the start symbol. You don't
    have to delve into details here, but as always, it is important to get the input
    data straight before we make use of it.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数`is_valid_grammar()`遍历语法以检查是否所有使用的符号都已定义，反之亦然，这对于调试非常有用；它还检查是否所有符号都从起始符号可达。你不必深入了解细节，但像往常一样，在使用输入数据之前确保输入数据正确是非常重要的。
- en: <details id="Excursion:-Implementing-is_valid_grammar()"><summary>Implementing
    `is_valid_grammar()`</summary>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-is_valid_grammar()"><summary>实现`is_valid_grammar()`</summary>
- en: '[PRE164]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: To make a grammar suitable for `is_valid_grammar()`, the following function
    may be useful. The function `trim_grammar()` automatically *removes* rules for
    nonterminals that are no longer needed. This is useful if you have added new rules
    that *remove* some extensions, rendering some nonterminals obsolete.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使语法适合`is_valid_grammar()`，以下函数可能很有用。函数`trim_grammar()`自动*删除*对于不再需要的非终端的规则。如果你添加了新的规则，这些规则*删除*了一些扩展，使得一些非终端变得过时，这很有用。
- en: '[PRE170]</details>'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE170]</details>'
- en: 'Let us make use of `is_valid_grammar()`. Our grammars defined above pass the
    test:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用`is_valid_grammar()`。我们定义的语法通过了测试：
- en: '[PRE171]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The check can also be applied to EBNF grammars:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 检查也可以应用于EBNF语法：
- en: '[PRE172]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'These do not pass the test, though:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，这些测试并没有通过：
- en: '[PRE173]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '(The `#type: ignore` annotations avoid static checkers flagging the above as
    errors).'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '（`#type: ignore`注释避免了静态检查器将上述内容标记为错误）。'
- en: From here on, we will always use `is_valid_grammar()` when defining a grammar.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在定义语法时，我们总会使用`is_valid_grammar()`。
- en: Lessons Learned
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Grammars are powerful tools to express and produce syntactically valid inputs.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法是表达和生成语法上有效输入的有力工具。
- en: Inputs produced from grammars can be used as is, or used as seeds for mutation-based
    fuzzing.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从语法生成的输入可以直接使用，或者用作基于变异的模糊测试的种子。
- en: Grammars can be extended with character classes and operators to make writing
    easier.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法可以通过字符类和运算符进行扩展，以简化编写过程。
- en: Next Steps
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: 'As they make a great foundation for generating software tests, we use grammars
    again and again in this book. As a sneak preview, we can use grammars to [fuzz
    configurations](ConfigurationFuzzer.html):'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们为生成软件测试提供了一个很好的基础，因此在这本书中我们反复使用语法。作为预览，我们可以使用语法来[fuzz配置](ConfigurationFuzzer.html)：
- en: '[PRE181]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We can use grammars for [fuzzing functions and APIs](APIFuzzer.html) and [fuzzing
    graphical user interfaces](WebFuzzer.html):'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用语法来进行[模糊测试函数和API](APIFuzzer.html)以及[模糊测试图形用户界面](WebFuzzer.html)：
- en: '[PRE182]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'We can assign [probabilities](ProbabilisticGrammarFuzzer.html) and [constraints](GeneratorGrammarFuzzer.html)
    to individual expansions:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将[概率](ProbabilisticGrammarFuzzer.html)和[约束](GeneratorGrammarFuzzer.html)分配给单个扩展：
- en: '[PRE183]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: All these extras become especially valuable as we can
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些额外功能都特别有价值，因为我们能够
- en: '*infer grammars automatically*, dropping the need to specify them manually,
    and'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*自动推断语法*，无需手动指定，并且'
- en: '*guide them towards specific goals* such as coverage or critical functions;'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*引导它们向特定目标前进*，例如覆盖率或关键功能；'
- en: which we also discuss for all techniques in this book.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也讨论了本书中所有技术。
- en: To get there, however, we still have a bit of homework to do. In particular,
    we first have to learn how to
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要达到这个目标，我们仍然有一些作业要做。特别是，我们首先必须学会如何
- en: '[create an efficient grammar fuzzer](GrammarFuzzer.html)'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建一个高效的语法模糊器](GrammarFuzzer.html)'
- en: Background
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: As one of the foundations of human language, grammars have been around as long
    as human language existed. The first *formalization* of generative grammars was
    by Dakṣiputra Pāṇini in 350 BC [[Dakṣiputra Pāṇini, 350 BCE](https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini%23A%E1%B9%A3%E1%B9%AD%C4%81dhy%C4%81y%C4%AB)].
    As a general means to express formal languages for both data and programs, their
    role in computer science cannot be overstated. The seminal work by Chomsky [[Chomsky
    *et al*, 1956](https://chomsky.info/wp-content/uploads/195609-.pdf)] introduced
    the central models of regular languages, context-free grammars, context-sensitive
    grammars, and universal grammars as they are used (and taught) in computer science
    as a means to specify input and programming languages ever since.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 作为人类语言的基础之一，语法与人类语言一样历史悠久。生成语法的首次*形式化*是由公元前350年的Dakṣiputra Pāṇini完成的 [[Dakṣiputra
    Pāṇini, 350 BCE](https://en.wikipedia.org/wiki/P%C4%81%E1%B9%87ini%23A%E1%B9%A3%E1%B9%AD%C4%81dhy%C4%81y%C4%AB)]。作为表达数据和程序形式语言的一般手段，它们在计算机科学中的作用不容小觑。Chomsky
    [[Chomsky *et al*, 1956](https://chomsky.info/wp-content/uploads/195609-.pdf)]
    的开创性工作引入了正则语言、上下文无关语法、上下文相关语法和通用语法的核心模型，这些模型自计算机科学中作为指定输入和编程语言的方法以来一直被使用（和教授）。
- en: 'The use of grammars for *producing* test inputs goes back to Burkhardt [[Burkhardt
    *et al*, 1967](https://doi.org/10.1007/BF02235512)], to be later rediscovered
    and applied by Hanford [[Hanford *et al*, 1970](https://doi.org/10.1147/sj.94.0242)]
    and Purdom [[Purdom *et al*, 1972](https://doi.org/10.1007/BF01932308)]. The most
    important use of grammar testing since then has been *compiler testing*. Actually,
    grammar-based testing is one important reason why compilers and Web browsers work
    as they should:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法来*生成*测试输入可以追溯到Burkhardt [[Burkhardt *et al*, 1967](https://doi.org/10.1007/BF02235512)]，后来被Hanford
    [[Hanford *et al*, 1970](https://doi.org/10.1147/sj.94.0242)] 和Purdom [[Purdom
    *et al*, 1972](https://doi.org/10.1007/BF01932308)] 重新发现并应用。从那时起，语法测试最重要的用途一直是*编译器测试*。实际上，基于语法的测试是编译器和Web浏览器能够正常工作的一个重要原因：
- en: The [CSmith](https://embed.cs.utah.edu/csmith/) tool [[Yang *et al*, 2011](https://doi.org/10.1145/1993498.1993532)]
    specifically targets C programs, starting with a C grammar and then applying additional
    steps, such as referring to variables and functions defined earlier or ensuring
    integer and type safety. Their authors have used it "to find and report more than
    400 previously unknown compiler bugs."
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CSmith](https://embed.cs.utah.edu/csmith/)工具 [[Yang *et al*, 2011](https://doi.org/10.1145/1993498.1993532)]专门针对C程序，从C语法开始，然后应用额外的步骤，例如引用之前定义的变量和函数或确保整数和类型安全。其作者们已经用它“找到并报告了400多个以前未知的编译器错误”。'
- en: The [LangFuzz](http://issta2016.cispa.saarland/interview-with-christian-holler/)
    work [[Holler *et al*, 2012](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final73.pdf)],
    which shares two authors with this book, uses a generic grammar to produce outputs,
    and is used day and night to generate JavaScript programs and test their interpreters;
    as of today, it has found more than 2,600 bugs in browsers such as Mozilla Firefox,
    Google Chrome, and Microsoft Edge.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本书共享两位作者的[LangFuzz](http://issta2016.cispa.saarland/interview-with-christian-holler/)工作
    [[Holler *et al*, 2012](https://www.usenix.org/system/files/conference/usenixsecurity12/sec12-final73.pdf)]，使用通用语法生成输出，并日夜不停地生成JavaScript程序并测试它们的解释器；截至今天，它已在Mozilla
    Firefox、Google Chrome和Microsoft Edge等浏览器中发现了超过2,600个错误。
- en: The [EMI Project](http://web.cs.ucdavis.edu/~su/emi-project/) [[Le *et al*,
    2014](https://doi.org/10.1145/2594291.2594334)] uses grammars to stress-test C
    compilers, transforming known tests into alternative programs that should be semantically
    equivalent over all inputs. Again, this has led to more than 100 bugs in C compilers
    being fixed.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[EMI项目](http://web.cs.ucdavis.edu/~su/emi-project/) [[Le *et al*, 2014](https://doi.org/10.1145/2594291.2594334)]
    使用语法来对C编译器进行压力测试，将已知的测试转换为在所有输入上语义等效的替代程序。这又导致了C编译器中超过100个错误的修复。'
- en: '[Grammarinator](https://github.com/renatahodovan/grammarinator) [[Hodován *et
    al*, 2018](https://www.researchgate.net/publication/328510752_Grammarinator_a_grammar-based_open_source_fuzzer)]
    is an open-source grammar fuzzer (written in Python!), using the popular ANTLR
    format as grammar specification. Like LangFuzz, it uses the grammar for both parsing
    and producing, and has found more than 100 issues in the *JerryScript* lightweight
    JavaScript engine and an associated platform.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Grammarinator](https://github.com/renatahodovan/grammarinator) [[Hodován 等人，2018](https://www.researchgate.net/publication/328510752_Grammarinator_a_grammar-based_open_source_fuzzer)]
    是一个开源的语法模糊器（用 Python 编写！），使用流行的 ANTLR 格式作为语法规范。像 LangFuzz 一样，它使用语法进行解析和生成，并在 *JerryScript*
    轻量级 JavaScript 引擎及其相关平台上发现了100多个问题。'
- en: '[Domato](https://github.com/googleprojectzero/domato) is a generic grammar
    generation engine that is specifically used for fuzzing DOM input. It has revealed
    a number of security issues in popular Web browsers.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Domato](https://github.com/googleprojectzero/domato) 是一个通用的语法生成引擎，专门用于模糊 DOM
    输入。它已经在流行的网络浏览器中揭示了许多安全问题。'
- en: Compilers and Web browsers, of course, are not only domains where grammars are
    needed for testing, but also domains where grammars are well-known. Our claim
    in this book is that grammars can be used to generate almost *any* input, and
    our aim is to empower you to do precisely that.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器和网络浏览器，当然，不仅是需要语法进行测试的领域，也是语法广为人知的领域。本书中的主张是，语法可以用来生成几乎 *任何* 输入，我们的目标是赋予你做到这一点的能力。
- en: Exercises
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: A JSON Grammar'
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 1：JSON 语法
- en: 'Take a look at the [JSON specification](http://www.json.org) and derive a grammar
    from it:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下 [JSON 规范](http://www.json.org)，并从中推导出一个语法：
- en: Use *character classes* to express valid characters
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *字符类* 来表达有效字符
- en: Use EBNF to express repetitions and optional parts
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EBNF 表达重复和可选部分
- en: Assume that
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设
- en: a string is a sequence of digits, ASCII letters, punctuation and space characters
    without quotes or escapes
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串是一系列数字、ASCII 字母、标点符号和空格字符的序列，没有引号或转义符。
- en: whitespace is just a single space.
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白只是一个空格。
- en: Use `is_valid_grammar()` to ensure the grammar is valid.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `is_valid_grammar()` 确保语法有效。
- en: Feed the grammar into `simple_grammar_fuzzer()`. Do you encounter any errors,
    and why?
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 将语法输入到 `simple_grammar_fuzzer()`。你是否遇到任何错误，为什么？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 2: Finding Bugs'
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：寻找错误
- en: 'The name `simple_grammar_fuzzer()` does not come by accident: The way it expands
    grammars is limited in several ways. What happens if you apply `simple_grammar_fuzzer()`
    on `nonterminal_grammar` and `expr_grammar`, as defined above, and why?'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `simple_grammar_fuzzer()` 并非偶然：它扩展语法的几种方式都有限制。如果你将 `simple_grammar_fuzzer()`
    应用于上面定义的 `nonterminal_grammar` 和 `expr_grammar`，会发生什么？为什么？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 3: Grammars with Regular Expressions'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：带有正则表达式的语法
- en: In a *grammar extended with regular expressions*, we can use the special form
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展了正则表达式的 *语法* 中，我们可以使用特殊形式
- en: '[PRE184]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: to include regular expressions in expansions. For instance, we can have a rule
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以包括正则表达式在扩展中。例如，我们可以有一个规则
- en: '[PRE185]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: to quickly express that an integer is an optional sign, followed by a sequence
    of digits.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以快速表达一个整数是可选的符号，后跟一系列数字。
- en: 'Part 1: Convert regular expressions'
  id: totrans-431
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：将正则表达式转换为
- en: 'Write a converter `convert_regex(r)` that takes a regular expression `r` and
    creates an equivalent grammar. Support the following regular expression constructs:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个转换器 `convert_regex(r)`，它接受一个正则表达式 `r` 并创建一个等效的语法。支持以下正则表达式构造：
- en: '`*`, `+`, `?`, `()` should work just in EBNFs, above.'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`、`+`、`?`、`()` 应在 EBNF 中正常工作。'
- en: '`a|b` should translate into a list of alternatives `[a, b]`.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a|b` 应转换为选择列表 `[a, b]`。'
- en: '`.` should match any character except newline.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.` 应匹配任何字符（除了换行符）。'
- en: '`[abc]` should translate into `srange("abc")`'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[abc]` 应转换为 `srange("abc")`'
- en: '`[^abc]` should translate into the set of ASCII characters *except* `srange("abc")`.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^abc]` 应转换为 ASCII 字符集 *除了* `srange("abc")`。'
- en: '`[a-b]` should translate into `crange(a, b)`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-b]` 应转换为 `crange(a, b)`。'
- en: '`[^a-b]` should translate into the set of ASCII characters *except* `crange(a,
    b)`.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[^a-b]` 应该转换为除了 `crange(a, b)` 的 ASCII 字符集。'
- en: 'Example: `convert_regex(r"[0-9]+")` should yield a grammar such as'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：`convert_regex(r"[0-9]+")` 应该生成一个如下的文法
- en: '[PRE186]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Part 2: Identify and expand regular expressions'
  id: totrans-443
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：识别和扩展正则表达式
- en: Write a converter `convert_regex_grammar(g)` that takes a EBNF grammar `g` containing
    regular expressions in the form `/.../` and creates an equivalent BNF grammar.
    Support the regular expression constructs as above.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个转换器 `convert_regex_grammar(g)`，它接收一个包含正则表达式形式的 EBNF 文法 `g`，并创建一个等效的 BNF
    文法。支持上述正则表达式构造。
- en: 'Example: `convert_regex_grammar({ "<integer>" : "/[+-]?[0-9]+/" })` should
    yield a grammar such as'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '示例：`convert_regex_grammar({ "<integer>" : "/[+-]?[0-9]+/" })` 应该生成一个如下的文法'
- en: '[PRE187]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Optional: Support *escapes* in regular expressions: `\c` translates to the
    literal character `c`; `\/` translates to `/` (and thus does not end the regular
    expression); `\\` translates to `\`.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 可选：在正则表达式中支持转义：`\c` 转换为字面字符 `c`；`\/` 转换为 `/`（因此不会结束正则表达式）；`\\` 转换为 `\`。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 4: Defining Grammars as Functions (Advanced)'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：将文法定义为函数（高级）
- en: 'To obtain a nicer syntax for specifying grammars, one can make use of Python
    constructs which then will be *parsed* by an additional function. For instance,
    we can imagine a grammar definition which uses `|` as a means to separate alternatives:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更简洁的语法指定语法，可以使用 Python 构造，然后由一个额外的函数进行解析。例如，我们可以想象一个使用 `|` 作为分隔备选方案的语法定义：
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: '[PRE188]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: If we execute `expression_grammar_fn()`, this will yield an error. Yet, the
    purpose of `expression_grammar_fn()` is not to be executed, but to be used as
    *data* from which the grammar will be constructed.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行 `expression_grammar_fn()`，这将产生一个错误。然而，`expression_grammar_fn()` 的目的不是被执行，而是作为
    *数据* 使用，从这些数据中构建文法。
- en: '[PRE189]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: To this end, we make use of the `ast` (abstract syntax tree) and `inspect` (code
    inspection) modules.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了此目的，我们使用了 `ast`（抽象语法树）和 `inspect`（代码检查）模块。
- en: '[PRE191]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: First, we obtain the source code of `expression_grammar_fn()`...
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取 `expression_grammar_fn()` 的源代码...
- en: '[PRE192]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '... which we then parse into an abstract syntax tree:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '...然后将其解析为抽象语法树：'
- en: '[PRE194]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: We can now parse the tree to find operators and alternatives. `get_alternatives()`
    iterates over all nodes `op` of the tree; If the node looks like a binary *or*
    (`|`) operation, we drill deeper and recurse. If not, we have reached a single
    production, and we try to get the expression from the production. We define the
    `to_expr` parameter depending on how we want to represent the production. In this
    case, we represent a single production by a single string.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以解析树以查找运算符和备选方案。`get_alternatives()` 遍历树中的所有节点 `op`；如果节点看起来像二进制 *或* (`|`)
    操作，我们将进一步深入并递归。如果不是，我们就到达了一个单一的产生式，并尝试从产生式中获取表达式。我们根据我们想要如何表示产生式来定义 `to_expr`
    参数。在这种情况下，我们用一个单独的字符串来表示一个单一的产生式。
- en: '[PRE195]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '`funct_parser()` takes the abstract syntax tree of a function (say, `expression_grammar_fn()`)
    and iterates over all assignments:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`funct_parser()` 接收一个函数的抽象语法树（例如，`expression_grammar_fn()`），并遍历所有赋值：'
- en: '[PRE196]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'The result is a grammar in our regular format:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个我们正则格式的文法：
- en: '[PRE197]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Part 1 (a): One Single Function'
  id: totrans-471
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分 (a)：一个单一函数
- en: Write a single function `define_grammar(fn)` that takes a grammar defined as
    function (such as `expression_grammar_fn()`) and returns a regular grammar.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个单独的函数 `define_grammar(fn)`，它接收一个定义为函数的文法（例如 `expression_grammar_fn()`），并返回一个正则文法。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Part 1 (b): Alternative representations'
  id: totrans-474
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分 (b)：替代表示法
- en: 'We note that the grammar representation we designed previously does not allow
    simple generation of alternatives such as `srange()` and `crange()`. Further,
    one may find the string representation of expressions limiting. It turns out that
    it is simple to extend our grammar definition to support grammars such as below:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，我们之前设计的语法表示不允许简单地生成如 `srange()` 和 `crange()` 这样的备选方案。此外，人们可能会发现表达式的字符串表示有限制。实际上，扩展我们的语法定义以支持如下语法是简单的：
- en: '[PRE200]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The grammar:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：
- en: '[PRE203]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '**Note.** The grammar data structure thus obtained is a little more detailed
    than the standard data structure. It represents each production as a tuple.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意。** 因此获得的语法数据结构比标准数据结构更详细。它将每个产生式表示为一个元组。'
- en: We note that we have not enabled `srange()` or `crange()` in the above grammar.
    How would you go about adding these? (*Hint:* wrap `define_expr()` to look for
    `ast.Call`)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，我们尚未在上面的语法中启用 `srange()` 或 `crange()`。你将如何添加这些？ (*提示：将 `define_expr()`
    包装起来以查找 `ast.Call`*)
- en: 'Part 2: Extended Grammars'
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：扩展语法
- en: Introduce an operator `*` that takes a pair `(min, max)` where `min` and `max`
    are the minimum and maximum number of repetitions, respectively. A missing value
    `min` stands for zero; a missing value `max` for infinity.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 引入一个操作符 `*`，它接受一个 `(min, max)` 对，其中 `min` 和 `max` 分别代表最小和最大重复次数。缺失的 `min` 值表示零；缺失的
    `max` 值表示无穷大。
- en: '[PRE204]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: With the `*` operator, we can generalize the EBNF operators – `?` becomes (0,1),
    `*` becomes (0,), and `+` becomes (1,). Write a converter that takes an extended
    grammar defined using `*`, parse it, and convert it into BNF.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `*` 操作符，我们可以泛化 EBNF 操作符——`?` 变为 (0,1)，`*` 变为 (0,), 和 `+` 变为 (1,)。编写一个转换器，它接受使用
    `*` 定义的扩展语法，解析它，并将其转换为 BNF。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Grammars.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-06-30 18:31:28+02:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Grammars.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容根据 [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
    许可。内容的一部分源代码，以及用于格式化和显示该内容的源代码，根据 [MIT 许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)
    许可。 [最后更改：2024-06-30 18:31:28+02:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Grammars.ipynb)
    • [引用](#citation) • [印记](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing with Grammars](https://www.fuzzingbook.org/html/Grammars.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Grammars.html](https://www.fuzzingbook.org/html/Grammars.html).
    Retrieved 2024-06-30 18:31:28+02:00.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler:
    "[使用语法进行模糊测试](https://www.fuzzingbook.org/html/Grammars.html)". 在 Andreas Zeller,
    Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler 的 "[模糊测试书籍](https://www.fuzzingbook.org/)",
    [https://www.fuzzingbook.org/html/Grammars.html](https://www.fuzzingbook.org/html/Grammars.html).
    Retrieved 2024-06-30 18:31:28+02:00.'
- en: '[PRE205]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
