- en: MAC and Key Derivation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAC和密钥派生
- en: 原文：[https://cryptobook.nakov.com/mac-and-key-derivation](https://cryptobook.nakov.com/mac-and-key-derivation)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://cryptobook.nakov.com/mac-and-key-derivation](https://cryptobook.nakov.com/mac-and-key-derivation)
- en: '**Message authentication codes** (**MAC**), **HMAC** (hash-based message authentication
    code) and **KDF** (key derivation functions) play important role in cryptography.
    Let''s explain when we need **MAC**, how to calculate **HMAC** and how it is related
    to key derivation functions.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息认证码**（**MAC**）、**HMAC**（基于哈希的消息认证码）和**KDF**（密钥派生函数）在密码学中扮演着重要的角色。让我们解释何时需要**MAC**，如何计算**HMAC**以及它与密钥派生函数的关系。'
- en: '[](#message-authentication-code-mac)Message Authentication Code (MAC)'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#message-authentication-code-mac)消息认证码（MAC）'
- en: '**M**essage **A**uthentication **C**ode (**MAC**) is cryptographic code, calculated
    by given **key** and given **message**:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**M**essage **A**uthentication **C**ode（**MAC**）是一种加密代码，通过给定的**密钥**和给定的**消息**计算得出：'
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Typically, it behaves **like a hash function**: a minor change in the message
    or in the key results to totally different **MAC value**. It should be practically
    infeasible to change the key or the message and get the same **MAC value**. MAC
    codes, like hashes, are **irreversible**: it is impossible to recover the original
    message or the key from the MAC code. MAC algorithms are also known as "**keyed
    hash functions**", because they behave like a hash function with a key.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它表现得**像哈希函数**：消息或密钥的微小变化会导致完全不同的**MAC值**。实际上，改变密钥或消息以获得相同的**MAC值**是不可能的。MAC代码，像哈希一样，是**不可逆的**：无法从MAC代码中恢复原始消息或密钥。MAC算法也被称为“**密钥哈希函数**”，因为它们具有带密钥的哈希函数的行为。
- en: 'For example, the MAC code can be calculated by the **HMAC-SHA256** algorithm
    like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MAC代码可以通过**HMAC-SHA256**算法这样计算：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The above HMAC-SHA256 calculation can be coded in Python like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上述HMAC-SHA256计算可以用Python这样编写：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the above code example: [https://repl.it/@nakov/HMAC-SHA256-in-Python](https://repl.it/@nakov/HMAC-SHA256-in-Python).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码示例：[https://repl.it/@nakov/HMAC-SHA256-in-Python](https://repl.it/@nakov/HMAC-SHA256-in-Python)。
- en: The MAC code is **digital authenticity code**, like a **digital signature**,
    but with **pre-shared key**. We shall learn more about digital signing and digital
    signatures later.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MAC代码是**数字真实性代码**，就像**数字签名**一样，但带有**预共享密钥**。我们将在以后学习更多关于数字签名和数字签名的内容。
- en: '[](#mac-algorithms)MAC Algorithms'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#mac-algorithms)MAC算法'
- en: Many **algorithms** for calculating message authentication codes (MAC) exist
    in modern cryptography. The most popular are based on **hashing** algorithms,
    like [**HMAC**](https://en.wikipedia.org/wiki/HMAC) (Hash-based MAC, e.g. HMAC-SHA256)
    and [**KMAC**](https://www.cryptosys.net/manapi/api_kmac.html) (Keccak-based MAC).
    Others are based on **symmetric ciphers**, like [**CMAC**](https://en.wikipedia.org/wiki/One-key_MAC)
    (Cipher-based MAC), [**GMAC**](https://en.wikipedia.org/wiki/Galois/Counter_Mode)
    (Galois MAC) and [**Poly1305**](https://en.wikipedia.org/wiki/Poly1305) (Bernstein's
    one-time authenticator). Other MAC algorithms include [**UMAC**](https://en.wikipedia.org/wiki/UMAC)
    (based on universal hashing), [**VMAC**](https://en.wikipedia.org/wiki/VMAC) (high-performance
    block cipher-based MAC) and [**SipHash**](https://en.wikipedia.org/wiki/SipHash)
    (simple, fast, secure MAC).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现代密码学中存在许多用于计算消息认证码（MAC）的**算法**。最流行的是基于**哈希**算法的，如[**HMAC**](https://en.wikipedia.org/wiki/HMAC)（基于哈希的MAC，例如HMAC-SHA256）和[**KMAC**](https://www.cryptosys.net/manapi/api_kmac.html)（基于Keccak的MAC）。其他基于**对称加密**，如[**CMAC**](https://en.wikipedia.org/wiki/One-key_MAC)（基于加密的MAC）、[**GMAC**](https://en.wikipedia.org/wiki/Galois/Counter_Mode)（Galois
    MAC）和[**Poly1305**](https://en.wikipedia.org/wiki/Poly1305)（Bernstein的一次性认证器）。其他MAC算法包括[**UMAC**](https://en.wikipedia.org/wiki/UMAC)（基于通用哈希）、[**VMAC**](https://en.wikipedia.org/wiki/VMAC)（基于高性能分组密码的MAC）和[**SipHash**](https://en.wikipedia.org/wiki/SipHash)（简单、快速、安全的MAC）。
- en: '[](#when-we-need-mac-codes)When We Need MAC Codes?'
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#when-we-need-mac-codes)我们需要MAC代码的情况？'
- en: 'A sample scenario for using MAC codes is like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MAC代码的一个示例场景如下：
- en: Two parties exchange somehow a certain secret **MAC key** (pre-shared **key**).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双方以某种方式交换一个特定的**MAC密钥**（预共享**密钥**）。
- en: We receive a **msg** + **auth_code** from somewhere (e.g. from Internet, from
    the blockchain, or from email message).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从某处（例如，从互联网、区块链或电子邮件消息）接收**msg** + **auth_code**。
- en: We want to be sure that the **msg** is **not tampered**, which means that both
    the **key** and **msg** are correct and match the MAC code.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要确保**msg**没有被**篡改**，这意味着**密钥**和**msg**都是正确的，并且与MAC代码匹配。
- en: In case of **tampered message**, the MAC code will be incorrect.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生**篡改消息**，MAC代码将是不正确的。
- en: '![](../Images/5a700f2951729d3dafd6e9dbe78a2a8d.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/5a700f2951729d3dafd6e9dbe78a2a8d.png)'
- en: '[](#authenticated-encryption-encrypt-decrypt-messages-using-mac)Authenticated
    Encryption: Encrypt / Decrypt Messages using MAC'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#authenticated-encryption-encrypt-decrypt-messages-using-mac)基于MAC的加密：使用MAC加密/解密消息'
- en: Another scenario to use **MAC codes** is for [**authenticated encryption**](https://en.wikipedia.org/wiki/Authenticated_encryption)**:**
    when we **encrypt a message** and we want to be sure the **decryption password
    is correct** and the decrypted message is the same like the original message before
    encryption.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用**MAC代码**的场景是用于**认证加密**：当我们**加密一条消息**并希望确保**解密密码是正确的**，并且解密后的消息与加密前的原始消息相同。
- en: First, we **derive a key** from the password. We can use this key for the MAC
    calculation algorithm (directly or hashed for better security).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们从密码中**导出一个密钥**。我们可以使用这个密钥进行MAC计算算法（直接或通过散列以获得更好的安全性）。
- en: Next, we **encrypt the message** using the derived key and store the ciphertext
    in the output.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用导出的密钥**加密消息**并将密文存储在输出中。
- en: Finally, we calculate the **MAC code** using the derived key and the original
    message and we append it to the output.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用导出的密钥和原始消息计算**MAC代码**并将其附加到输出中。
- en: 'When we **decrypt the encrypted message** (ciphertext + MAC), we proceed as
    follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们**解密加密的消息**（密文 + MAC）时，我们按照以下步骤进行：
- en: First, we **derive a key** from the password, entered by the user. It might
    be the correct password or wrong. We shall find out later.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们从用户输入的密码中**导出一个密钥**。这可能是不正确的密码或正确的密码。我们稍后会找出答案。
- en: Next, we **decrypt the message** using the derived key. It might be the original
    message or incorrect message (depends on the password entered).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用导出的密钥**解密消息**。这可能是一条原始消息或错误消息（取决于输入的密码）。
- en: Finally, we calculate a **MAC code** using the derived key + the decrypted message.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用导出的密钥加上解密的消息计算一个**MAC代码**。
- en: If the calculated MAC code matches the MAC code in the encrypted message, the
    **password is correct**.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计算出的MAC代码与加密消息中的MAC代码匹配，则**密码是正确的**。
- en: Otherwise, it will be proven that the decrypted message is not the original
    message and this means that the **password is incorrect**
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将证明解密后的消息不是原始消息，这意味着**密码是错误的**。
- en: Some **authenticated encryption algorithms** (such as **AES-GCM** and **ChaCha20-Poly1305**)
    integrate the MAC calculation into the encryption algorithm and the MAC verification
    into the decryption algorithm. We shall learn more about these algorithms later.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些**认证加密算法**（如**AES-GCM**和**ChaCha20-Poly1305**）将MAC计算集成到加密算法中，将MAC验证集成到解密算法中。我们稍后会了解更多关于这些算法的信息。
- en: The MAC is stored along with the ciphertext and it **does not reveal** the password
    or the original message. Storing the MAC code, visible to anyone is safe, and
    after decryption, we know whether the message is the original one or not (wrong
    password).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MAC代码与密文一起存储，它**不会泄露**密码或原始消息。存储可见给任何人的MAC代码是安全的，并且在解密后，我们知道消息是否是原始的（密码错误）。
- en: '[](#mac-based-pseudo-random-generator)MAC-Based Pseudo-Random Generator'
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[](#mac-based-pseudo-random-generator)基于MAC的伪随机生成器'
- en: 'Another application of MAC codes is for **pseudo-random generator** functions.
    We can start from certain **salt** (constant number or the current date and time
    or some other randomness) and some **seed** number (last random number generated,
    e.g. **0**). We can calculate the **next_seed** as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MAC代码的另一个应用是用于**伪随机生成器**函数。我们可以从一个特定的**盐**（常数或当前日期和时间或某些其他随机数）和一些**种子**数（最后生成的随机数，例如**0**）开始。我们可以按照以下方式计算**下一个种子**：
- en: <template id="B:2"></template>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <template id="B:2"></template>
