- en: MAC and Key Derivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://cryptobook.nakov.com/mac-and-key-derivation](https://cryptobook.nakov.com/mac-and-key-derivation)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Message authentication codes** (**MAC**), **HMAC** (hash-based message authentication
    code) and **KDF** (key derivation functions) play important role in cryptography.
    Let''s explain when we need **MAC**, how to calculate **HMAC** and how it is related
    to key derivation functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[](#message-authentication-code-mac)Message Authentication Code (MAC)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**M**essage **A**uthentication **C**ode (**MAC**) is cryptographic code, calculated
    by given **key** and given **message**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, it behaves **like a hash function**: a minor change in the message
    or in the key results to totally different **MAC value**. It should be practically
    infeasible to change the key or the message and get the same **MAC value**. MAC
    codes, like hashes, are **irreversible**: it is impossible to recover the original
    message or the key from the MAC code. MAC algorithms are also known as "**keyed
    hash functions**", because they behave like a hash function with a key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the MAC code can be calculated by the **HMAC-SHA256** algorithm
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The above HMAC-SHA256 calculation can be coded in Python like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the above code example: [https://repl.it/@nakov/HMAC-SHA256-in-Python](https://repl.it/@nakov/HMAC-SHA256-in-Python).'
  prefs: []
  type: TYPE_NORMAL
- en: The MAC code is **digital authenticity code**, like a **digital signature**,
    but with **pre-shared key**. We shall learn more about digital signing and digital
    signatures later.
  prefs: []
  type: TYPE_NORMAL
- en: '[](#mac-algorithms)MAC Algorithms'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many **algorithms** for calculating message authentication codes (MAC) exist
    in modern cryptography. The most popular are based on **hashing** algorithms,
    like [**HMAC**](https://en.wikipedia.org/wiki/HMAC) (Hash-based MAC, e.g. HMAC-SHA256)
    and [**KMAC**](https://www.cryptosys.net/manapi/api_kmac.html) (Keccak-based MAC).
    Others are based on **symmetric ciphers**, like [**CMAC**](https://en.wikipedia.org/wiki/One-key_MAC)
    (Cipher-based MAC), [**GMAC**](https://en.wikipedia.org/wiki/Galois/Counter_Mode)
    (Galois MAC) and [**Poly1305**](https://en.wikipedia.org/wiki/Poly1305) (Bernstein's
    one-time authenticator). Other MAC algorithms include [**UMAC**](https://en.wikipedia.org/wiki/UMAC)
    (based on universal hashing), [**VMAC**](https://en.wikipedia.org/wiki/VMAC) (high-performance
    block cipher-based MAC) and [**SipHash**](https://en.wikipedia.org/wiki/SipHash)
    (simple, fast, secure MAC).
  prefs: []
  type: TYPE_NORMAL
- en: '[](#when-we-need-mac-codes)When We Need MAC Codes?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A sample scenario for using MAC codes is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Two parties exchange somehow a certain secret **MAC key** (pre-shared **key**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We receive a **msg** + **auth_code** from somewhere (e.g. from Internet, from
    the blockchain, or from email message).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to be sure that the **msg** is **not tampered**, which means that both
    the **key** and **msg** are correct and match the MAC code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of **tampered message**, the MAC code will be incorrect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](../Images/5a700f2951729d3dafd6e9dbe78a2a8d.png)'
  prefs: []
  type: TYPE_IMG
- en: '[](#authenticated-encryption-encrypt-decrypt-messages-using-mac)Authenticated
    Encryption: Encrypt / Decrypt Messages using MAC'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another scenario to use **MAC codes** is for [**authenticated encryption**](https://en.wikipedia.org/wiki/Authenticated_encryption)**:**
    when we **encrypt a message** and we want to be sure the **decryption password
    is correct** and the decrypted message is the same like the original message before
    encryption.
  prefs: []
  type: TYPE_NORMAL
- en: First, we **derive a key** from the password. We can use this key for the MAC
    calculation algorithm (directly or hashed for better security).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we **encrypt the message** using the derived key and store the ciphertext
    in the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we calculate the **MAC code** using the derived key and the original
    message and we append it to the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we **decrypt the encrypted message** (ciphertext + MAC), we proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we **derive a key** from the password, entered by the user. It might
    be the correct password or wrong. We shall find out later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we **decrypt the message** using the derived key. It might be the original
    message or incorrect message (depends on the password entered).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we calculate a **MAC code** using the derived key + the decrypted message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the calculated MAC code matches the MAC code in the encrypted message, the
    **password is correct**.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it will be proven that the decrypted message is not the original
    message and this means that the **password is incorrect**
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some **authenticated encryption algorithms** (such as **AES-GCM** and **ChaCha20-Poly1305**)
    integrate the MAC calculation into the encryption algorithm and the MAC verification
    into the decryption algorithm. We shall learn more about these algorithms later.
  prefs: []
  type: TYPE_NORMAL
- en: The MAC is stored along with the ciphertext and it **does not reveal** the password
    or the original message. Storing the MAC code, visible to anyone is safe, and
    after decryption, we know whether the message is the original one or not (wrong
    password).
  prefs: []
  type: TYPE_NORMAL
- en: '[](#mac-based-pseudo-random-generator)MAC-Based Pseudo-Random Generator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another application of MAC codes is for **pseudo-random generator** functions.
    We can start from certain **salt** (constant number or the current date and time
    or some other randomness) and some **seed** number (last random number generated,
    e.g. **0**). We can calculate the **next_seed** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <template id="B:2"></template>
  prefs: []
  type: TYPE_NORMAL
