["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('KDcMjWX5ulU') \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import List, Callable, Dict, Tuple \n```", "```py\n>>> from [fuzzingbook.ConcolicFuzzer](ConcolicFuzzer.html) import <identifier> \n```", "```py\n>>> with ConcolicTracer() as _:\n>>>     _[cgi_decode]('a%20d') \n```", "```py\n>>> _.decls\n{'cgi_decode_s_str_1': 'String'} \n```", "```py\n>>> _.path\n[0 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"%\"),\n 1 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 1, 1) == \"+\"),\n str.substr(cgi_decode_s_str_1, 1, 1) == \"%\",\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"0\"),\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"1\"),\n str.substr(cgi_decode_s_str_1, 2, 1) == \"2\",\n str.substr(cgi_decode_s_str_1, 3, 1) == \"0\",\n 4 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"%\"),\n Not(5 < Length(cgi_decode_s_str_1))] \n```", "```py\n>>> assert _.context == (_.decls, _.path) \n```", "```py\n>>> _.zeval()\n('sat', {'s': ('A%20B', 'String')}) \n```", "```py\n>>> scf = SimpleConcolicFuzzer()\n>>> scf.add_trace(_, 'a%20d') \n```", "```py\n>>> scf = SimpleConcolicFuzzer()\n>>> for i in range(20):\n>>>     v = scf.fuzz()\n>>>     if v is None:\n>>>         break\n>>>     print(repr(v))\n>>>     with ExpectError(print_traceback=False):\n>>>         with ConcolicTracer() as _:\n>>>             _[cgi_decode](v)\n>>>     scf.add_trace(_, v)\n' '\n'%'\n''\n'AB'\n'A+'\n'%'\n'A'\n'AB'\n'+'\n\nIndexError: string index out of range (expected)\nIndexError: string index out of range (expected)\nIndexError: string index out of range (expected)\n\n'%'\n'A%'\n'%'\n'A+'\n'A'\n'AB'\n'A'\n'A+B'\n'ABC'\n\nIndexError: string index out of range (expected)\nIndexError: string index out of range (expected)\nIndexError: string index out of range (expected)\n\n'AB%'\n'A%'\n\nIndexError: string index out of range (expected) \n```", "```py\n>>> from [InformationFlow](InformationFlow.html) import INVENTORY_GRAMMAR, SQLException\n>>> cgf = ConcolicGrammarFuzzer(INVENTORY_GRAMMAR)\n>>> cgf.prune_tokens(prune_tokens)\n>>> for i in range(10):\n>>>     query = cgf.fuzz()\n>>>     print(query)\n>>>     with ConcolicTracer() as _:\n>>>         with ExpectError(print_traceback=False):\n>>>             try:\n>>>                 res = _[db_select](query)\n>>>                 print(repr(res))\n>>>             except SQLException as e:\n>>>                 print(e)\n>>>         cgf.update_grammar(_)\n>>>         print()\ninsert into H (DZxQ) values (60366,'QR',-21.2981,6,38.7)\nTable ('H') was not found\n\nselect 340.0 from i8g4\nTable ('i8g4') was not found\n\ndelete from months where -16.98==Q000\nInvalid WHERE ('-16.98==Q000')\n\nupdate uKt set D=d,:=m,c=R,R=C where A==Q==M\nTable ('uKt') was not found\n\ninsert into months (q491) values ('Ib^|}',2,'8/','k')\nColumn ('q491') was not found\n\nselect w from lU where 445==M(v/n*J!=a)>W-e/k-r(n)*G\nTable ('lU') was not found\n\nselect (r),k-Q*f>Z,((s)),i>N,f!=t from [FK9](FK9.html)\nTable ('FK9') was not found\n\nupdate m5 set name=U,name=W where (d*D>k)==(d)\nTable ('m5') was not found\n\nselect H2==h!=R,j-e+F*t,(L),p,W from p_\nTable ('p_') was not found\n\ndelete from vehicles where _(w)+q/D/x>(e+H>u*b)\nInvalid WHERE ('_(w)+q/D/x>(e+H>u*b)') \n```", "```py\ndef factorial(n):\n    if n < 0:\n        return None\n\n    if n == 0:\n        return 1\n\n    if n == 1:\n        return 1\n\n    v = 1\n    while n != 0:\n        v = v * n\n        n = n - 1\n\n    return v \n```", "```py\nfactorial(5) \n```", "```py\n120\n\n```", "```py\nfrom [Coverage](Coverage.html) import Coverage \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nclass ArcCoverage(Coverage):\n    def traceit(self, frame, event, args):\n        if event != 'return':\n            f = inspect.getframeinfo(frame)\n            self._trace.append((f.function, f.lineno))\n        return self.traceit\n\n    def arcs(self):\n        t = [i for f, i in self._trace]\n        return list(zip(t, t[1:])) \n```", "```py\nwith ArcCoverage() as cov:\n    factorial(5) \n```", "```py\nfrom [ControlFlow](ControlFlow.html) import to_graph, gen_cfg \n```", "```py\nto_graph(gen_cfg(inspect.getsource(factorial)), arcs=cov.arcs()) \n```", "```py\nlines = [i[1] for i in cov._trace if i[0] == 'factorial']\nsrc = {i + 1: s for i, s in enumerate(\n    inspect.getsource(factorial).split('\\n'))} \n```", "```py\nsrc[1] \n```", "```py\n'def factorial(n):'\n\n```", "```py\nsrc[2], src[3], src[4], src[5] \n```", "```py\n('    if n < 0:', '        return None', '', '    if n == 0:')\n\n```", "```py\nimport [z3](https://github.com/Z3Prover/z3#readme) \n```", "```py\nz3_ver = z3.get_version() \n```", "```py\nprint(z3_ver) \n```", "```py\n(4, 11, 2, 0)\n\n```", "```py\nassert z3_ver >= (4, 8, 13, 0), \\\n    f\"Please install z3-solver 4.8.13.0 or later - you have {z3_ver}\" \n```", "```py\n# z3.set_option('smt.string_solver', 'z3str3')\nz3.set_option('timeout', 30 * 1000)  # milliseconds \n```", "```py\nzn = z3.Int('n') \n```", "```py\nzn < 0 \n```", "```py\nz3.Not(zn < 0) \n```", "```py\nz3.solve(z3.Not(zn < 0)) \n```", "```py\n[n = 0]\n\n```", "```py\nx = z3.Real('x')\neqn = (2 * x**2 - 11 * x + 5 == 0)\nz3.solve(eqn) \n```", "```py\n[x = 5]\n\n```", "```py\nz3.solve(x != 5, eqn) \n```", "```py\n[x = 1/2]\n\n```", "```py\nz3.solve(zn < 0) \n```", "```py\n[n = -1]\n\n```", "```py\nwith cov as cov:\n    factorial(-1) \n```", "```py\nto_graph(gen_cfg(inspect.getsource(factorial)), arcs=cov.arcs()) \n```", "```py\nsrc[5] \n```", "```py\n'    if n == 0:'\n\n```", "```py\npredicates = [z3.Not(zn < 0), z3.Not(zn == 0)] \n```", "```py\nsrc[8] \n```", "```py\n'    if n == 1:'\n\n```", "```py\npredicates = [z3.Not(zn < 0), z3.Not(zn == 0), z3.Not(zn == 1)] \n```", "```py\nlast = len(predicates) - 1\nz3.solve(predicates[0:-1] + [z3.Not(predicates[-1])]) \n```", "```py\n[n = 1]\n\n```", "```py\nwith ConcolicTracer as _:\n    _.[function](args, ...) \n```", "```py\n_.decls \n```", "```py\n_.path \n```", "```py\n_.context \n```", "```py\nclass ConcolicTracer:\n  \"\"\"Trace function execution, tracking variables and path conditions\"\"\"\n\n    def __init__(self, context=None):\n  \"\"\"Constructor.\"\"\"\n        self.context = context if context is not None else ({}, [])\n        self.decls, self.path = self.context \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        return \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def __getitem__(self, fn):\n        self.fn = fn\n        self.fn_args = {i: None for i in inspect.signature(fn).parameters}\n        return self \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def __call__(self, *args):\n        self.result = self.fn(*self.concolic(args))\n        return self.result \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def concolic(self, args):\n        return args \n```", "```py\nwith ConcolicTracer() as _:\n    _[factorial](1) \n```", "```py\n_.decls \n```", "```py\n{}\n\n```", "```py\n_.path \n```", "```py\n[]\n\n```", "```py\ndef zproxy_create(cls, z_type, z3var, context, z_name, v=None):\n    z_value = cls(context, z3var(z_name), v)\n    context[0][z_name] = z_type  # add to decls\n    return z_value \n```", "```py\nclass zbool:\n    @classmethod\n    def create(cls, context, z_name, v):\n        return zproxy_create(cls, 'Bool', z3.Bool, context, z_name, v)\n\n    def __init__(self, context, z, v=None):\n        self.context = context\n        self.z = z\n        self.v = v\n        self.decl, self.path = self.context \n```", "```py\nwith ConcolicTracer() as _:\n    val = zbool.create(_.context, 'my_bool_arg', True) \n```", "```py\nval.z \n```", "```py\nval.v \n```", "```py\nTrue\n\n```", "```py\n_.context \n```", "```py\n({'my_bool_arg': 'Bool'}, [])\n\n```", "```py\nval.context \n```", "```py\n({'my_bool_arg': 'Bool'}, [])\n\n```", "```py\nclass zbool(zbool):\n    def __not__(self):\n        return zbool(self.context, z3.Not(self.z), not self.v) \n```", "```py\nwith ConcolicTracer() as _:\n    val = zbool.create(_.context, 'my_bool_arg', True).__not__() \n```", "```py\nval.z \n```", "```py\nval.v \n```", "```py\nFalse\n\n```", "```py\n_.context \n```", "```py\n({'my_bool_arg': 'Bool'}, [])\n\n```", "```py\nclass zbool(zbool):\n    def __bool__(self):\n        r, pred = (True, self.z) if self.v else (False, z3.Not(self.z))\n        self.path.append(pred)\n        return r \n```", "```py\nca = 5\nza = z3.Int('a') \n```", "```py\nwith ConcolicTracer() as _:\n    if zbool(_.context, za == z3.IntVal(5), ca == 5):\n        print('success') \n```", "```py\nsuccess\n\n```", "```py\n_.path \n```", "```py\n[5 == a]\n\n```", "```py\nclass zint(int):\n    def __new__(cls, context, zn, v, *args, **kw):\n        return int.__new__(cls, v, *args, **kw) \n```", "```py\nclass zint(zint):\n    @classmethod\n    def create(cls, context, zn, v=None):\n        return zproxy_create(cls, 'Int', z3.Int, context, zn, v)\n\n    def __init__(self, context, z, v=None):\n        self.z, self.v = z, v\n        self.context = context \n```", "```py\nclass zint(zint):\n    def __int__(self):\n        return self.v\n\n    def __pos__(self):\n        return self.v \n```", "```py\nwith ConcolicTracer() as _:\n    val = zint.create(_.context, 'int_arg', 0) \n```", "```py\nval.z \n```", "```py\nval.v \n```", "```py\n0\n\n```", "```py\n_.context \n```", "```py\n({'int_arg': 'Int'}, [])\n\n```", "```py\nclass zint(zint):\n    def _zv(self, o):\n        return (o.z, o.v) if isinstance(o, zint) else (z3.IntVal(o), o) \n```", "```py\nwith ConcolicTracer() as _:\n    val = zint.create(_.context, 'int_arg', 0) \n```", "```py\nval._zv(0) \n```", "```py\n(0, 0)\n\n```", "```py\nval._zv(val) \n```", "```py\n(int_arg, 0)\n\n```", "```py\nclass zint(zint):\n    def __ne__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, self.z != z, self.v != v)\n\n    def __eq__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, self.z == z, self.v == v) \n```", "```py\nclass zint(zint):\n    def __req__(self, other):\n        return self.__eq__(other) \n```", "```py\nwith ConcolicTracer() as _:\n    ia = zint.create(_.context, 'int_a', 0)\n    ib = zint.create(_.context, 'int_b', 0)\n    v1 = ia == ib\n    v2 = ia != ib\n    v3 = 0 != ib\n    print(v1.z, v2.z, v3.z) \n```", "```py\nint_a == int_b int_a != int_b 0 != int_b\n\n```", "```py\nclass zint(zint):\n    def __lt__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, self.z < z, self.v < v)\n\n    def __gt__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, self.z > z, self.v > v) \n```", "```py\nclass zint(zint):\n    def __le__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, z3.Or(self.z < z, self.z == z),\n                     self.v < v or self.v == v)\n\n    def __ge__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, z3.Or(self.z > z, self.z == z),\n                     self.v > v or self.v == v) \n```", "```py\nwith ConcolicTracer() as _:\n    ia = zint.create(_.context, 'int_a', 0)\n    ib = zint.create(_.context, 'int_b', 1)\n    v1 = ia > ib\n    v2 = ia < ib\n    print(v1.z, v2.z)\n    v3 = ia >= ib\n    v4 = ia <= ib\n    print(v3.z, v4.z) \n```", "```py\nint_a > int_b int_a < int_b\nOr(int_a > int_b, int_a == int_b) Or(int_a < int_b, int_a == int_b)\n\n```", "```py\nINT_BINARY_OPS = [\n    '__add__',\n    '__sub__',\n    '__mul__',\n    '__truediv__',\n    # '__div__',\n    '__mod__',\n    # '__divmod__',\n    '__pow__',\n    # '__lshift__',\n    # '__rshift__',\n    # '__and__',\n    # '__xor__',\n    # '__or__',\n    '__radd__',\n    '__rsub__',\n    '__rmul__',\n    '__rtruediv__',\n    # '__rdiv__',\n    '__rmod__',\n    # '__rdivmod__',\n    '__rpow__',\n    # '__rlshift__',\n    # '__rrshift__',\n    # '__rand__',\n    # '__rxor__',\n    # '__ror__',\n] \n```", "```py\ndef make_int_binary_wrapper(fname, fun, zfun):\n    def proxy(self, other):\n        z, v = self._zv(other)\n        z_ = zfun(self.z, z)\n        v_ = fun(self.v, v)\n        if isinstance(v_, float):\n            # we do not implement float results yet.\n            assert round(v_) == v_\n            v_ = round(v_)\n        return zint(self.context, z_, v_)\n\n    return proxy \n```", "```py\nINITIALIZER_LIST: List[Callable] = [] \n```", "```py\ndef initialize():\n    for fn in INITIALIZER_LIST:\n        fn() \n```", "```py\ndef init_concolic_1():\n    for fname in INT_BINARY_OPS:\n        fun = getattr(int, fname)\n        zfun = getattr(z3.ArithRef, fname)\n        setattr(zint, fname, make_int_binary_wrapper(fname, fun, zfun)) \n```", "```py\nINITIALIZER_LIST.append(init_concolic_1) \n```", "```py\ninit_concolic_1() \n```", "```py\nwith ConcolicTracer() as _:\n    ia = zint.create(_.context, 'int_a', 0)\n    ib = zint.create(_.context, 'int_b', 1)\n    print((ia + ib).z)\n    print((ia + 10).z)\n    print((11 + ib).z)\n    print((ia - ib).z)\n    print((ia * ib).z)\n    print((ia / ib).z)\n    print((ia ** ib).z) \n```", "```py\nint_a + int_b\nint_a + 10\n11 + int_b\nint_a - int_b\nint_a*int_b\nint_a/int_b\nint_a**int_b\n\n```", "```py\nINT_UNARY_OPS = [\n    '__neg__',\n    '__pos__',\n    # '__abs__',\n    # '__invert__',\n    # '__round__',\n    # '__ceil__',\n    # '__floor__',\n    # '__trunc__',\n] \n```", "```py\ndef make_int_unary_wrapper(fname, fun, zfun):\n    def proxy(self):\n        return zint(self.context, zfun(self.z), fun(self.v))\n\n    return proxy \n```", "```py\ndef init_concolic_2():\n    for fname in INT_UNARY_OPS:\n        fun = getattr(int, fname)\n        zfun = getattr(z3.ArithRef, fname)\n        setattr(zint, fname, make_int_unary_wrapper(fname, fun, zfun)) \n```", "```py\nINITIALIZER_LIST.append(init_concolic_2) \n```", "```py\ninit_concolic_2() \n```", "```py\nwith ConcolicTracer() as _:\n    ia = zint.create(_.context, 'int_a', 0)\n    print((-ia).z)\n    print((+ia).z) \n```", "```py\n-int_a\nint_a\n\n```", "```py\nclass zint(zint):\n    def __bool__(self):\n        # return zbool(self.context, self.z, self.v) <-- not allowed\n        # force registering boolean condition\n        if self != 0:\n            return True\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    za = zint.create(_.context, 'int_a', 1)\n    zb = zint.create(_.context, 'int_b', 0)\n    if za and zb:\n        print(1) \n```", "```py\n_.context \n```", "```py\n({'int_a': 'Int', 'int_b': 'Int'}, [0 != int_a, Not(0 != int_b)])\n\n```", "```py\n    (declare-const x Int)\n    ```", "```py\n    (declare-const b (_ BitVec 8))\n    ```", "```py\n    (declare-const x Real)\n    ```", "```py\n    (declare-const s String)\n    ```", "```py\n(assert\n    (and\n        (= a b)\n        (= a c)\n        (! b c)))\n```", "```py\n(or (< 0 (str.indexof (str.substr my_str1 7 19) \" where \" 0))\n    (= (str.indexof (str.substr my_str1 7 19) \" where \" 0) 0))\n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def smt_expr(self, show_decl=False, simplify=False, path=[]):\n        r = []\n        if show_decl:\n            for decl in self.decls:\n                v = self.decls[decl]\n                v = '(_ BitVec 8)' if v == 'BitVec' else v\n                r.append(\"(declare-const %s  %s)\" % (decl, v))\n        path = path if path else self.path\n        if path:\n            path = z3.And(path)\n            if show_decl:\n                if simplify:\n                    return '\\n'.join([\n                        *r,\n                        \"(assert %s)\" % z3.simplify(path).sexpr()\n                    ])\n                else:\n                    return '\\n'.join(\n                        [*r, \"(assert %s)\" % path.sexpr()])\n            else:\n                return z3.simplify(path).sexpr()\n        else:\n            return '' \n```", "```py\ndef triangle(a, b, c):\n    if a == b:\n        if b == c:\n            return 'equilateral'\n        else:\n            return 'isosceles'\n    else:\n        if b == c:\n            return 'isosceles'\n        else:\n            if a == c:\n                return 'isosceles'\n            else:\n                return 'scalene' \n```", "```py\ntriangle(1, 2, 1) \n```", "```py\n'isosceles'\n\n```", "```py\nwith ConcolicTracer() as _:\n    za = zint.create(_.context, 'int_a', 1)\n    zb = zint.create(_.context, 'int_b', 1)\n    zc = zint.create(_.context, 'int_c', 1)\n    triangle(za, zb, zc)\nprint(_.context) \n```", "```py\n({'int_a': 'Int', 'int_b': 'Int', 'int_c': 'Int'}, [int_a == int_b, int_b == int_c])\n\n```", "```py\nprint(_.smt_expr(show_decl=True)) \n```", "```py\n(declare-const int_a Int)\n(declare-const int_b Int)\n(declare-const int_c Int)\n(assert (and (= int_a int_b) (= int_b int_c)))\n\n```", "```py\nz3.solve(_.path) \n```", "```py\n[int_c = 0, int_a = 0, int_b = 0]\n\n```", "```py\nCOUNTER = 0 \n```", "```py\ndef fresh_name():\n    global COUNTER\n    COUNTER += 1\n    return COUNTER \n```", "```py\nfresh_name() \n```", "```py\n1\n\n```", "```py\ndef reset_counter():\n    global COUNTER\n    COUNTER = 0 \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def __enter__(self):\n        reset_counter()\n        return self\n\n    def __exit__(self, exc_type, exc_value, tb):\n        return \n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def concolic(self, args):\n        my_args = []\n        for name, arg in zip(self.fn_args, args):\n            t = type(arg).__name__\n            zwrap = globals()['z' + t]\n            vname = \"%s_%s_%s_%s\" % (self.fn.__name__, name, t, fresh_name())\n            my_args.append(zwrap.create(self.context, vname, arg))\n            self.fn_args[name] = vname\n        return my_args \n```", "```py\nwith ConcolicTracer() as _:\n    _[factorial](5) \n```", "```py\n_.context \n```", "```py\n({'factorial_n_int_1': 'Int'},\n [Not(0 > factorial_n_int_1),\n  Not(0 == factorial_n_int_1),\n  Not(1 == factorial_n_int_1),\n  0 != factorial_n_int_1,\n  0 != factorial_n_int_1 - 1,\n  0 != factorial_n_int_1 - 1 - 1,\n  0 != factorial_n_int_1 - 1 - 1 - 1,\n  0 != factorial_n_int_1 - 1 - 1 - 1 - 1,\n  Not(0 != factorial_n_int_1 - 1 - 1 - 1 - 1 - 1)])\n\n```", "```py\nprint(_.smt_expr(show_decl=True)) \n```", "```py\n(declare-const factorial_n_int_1 Int)\n(assert (let ((a!1 (distinct 0 (- (- (- factorial_n_int_1 1) 1) 1)))\n      (a!2 (- (- (- (- factorial_n_int_1 1) 1) 1) 1)))\n  (and (not (> 0 factorial_n_int_1))\n       (not (= 0 factorial_n_int_1))\n       (not (= 1 factorial_n_int_1))\n       (distinct 0 factorial_n_int_1)\n       (distinct 0 (- factorial_n_int_1 1))\n       (distinct 0 (- (- factorial_n_int_1 1) 1))\n       a!1\n       (distinct 0 a!2)\n       (not (distinct 0 (- a!2 1))))))\n\n```", "```py\nclass ConcolicTracer(ConcolicTracer):\n    def zeval(self, predicates=None, *,python=False, log=False):\n  \"\"\"Evaluate `predicates` in current context.\n - If `python` is set, use the z3 Python API; otherwise use z3 standalone.\n - If `log` is set, show input to z3.\n Return a pair (`result`, `solution`) where\n - `result` is either `'sat'` (satisfiable); then \n solution` is a mapping of variables to (value, type) pairs; or\n - `result` is not `'sat'`, indicating an error; then `solution` is `None`\n \"\"\"\n        if predicates is None:\n            path = self.path\n        else:\n            path = list(self.path)\n            for i in sorted(predicates):\n                if len(path) > i:\n                    path[i] = predicates[i]\n                else:\n                    path.append(predicates[i])\n        if log:\n            print('Predicates in path:')\n            for i, p in enumerate(path):\n                print(i, p)\n            print()\n\n        r, sol = (zeval_py if python else zeval_smt)(path, self, log)\n        if r == 'sat':\n            return r, {k: sol.get(self.fn_args[k], None) for k in self.fn_args}\n        else:\n            return r, None \n```", "```py\ndef zeval_py(path, cc, log):\n    for decl in cc.decls:\n        if cc.decls[decl] == 'BitVec':\n            v = \"z3.%s('%s', 8)\" % (cc.decls[decl], decl)\n        else:\n            v = \"z3.%s('%s')\" % (cc.decls[decl], decl)\n        exec(v)\n    s = z3.Solver()\n    s.add(z3.And(path))\n    if s.check() == z3.unsat:\n        return 'No Solutions', {}\n    elif s.check() == z3.unknown:\n        return 'Gave up', None\n    assert s.check() == z3.sat\n    m = s.model()\n    return 'sat', {d.name(): m[d] for d in m.decls()} \n```", "```py\nwith ConcolicTracer() as _:\n    _[factorial](5) \n```", "```py\n_.zeval(python=True) \n```", "```py\n('sat', {'n': 5})\n\n```", "```py\nimport [re](https://docs.python.org/3/library/re.html) \n```", "```py\nimport [subprocess](https://docs.python.org/3/library/subprocess.html) \n```", "```py\nSEXPR_TOKEN = r'''(?mx)\n \\s*(?:\n (?P<bra>\\()|\n (?P<ket>\\))|\n (?P<token>[^\"()\\s]+)|\n (?P<string>\"[^\"]*\")\n )''' \n```", "```py\ndef parse_sexp(sexp):\n    stack, res = [], []\n    for elements in re.finditer(SEXPR_TOKEN, sexp):\n        kind, value = [(t, v) for t, v in elements.groupdict().items() if v][0]\n        if kind == 'bra':\n            stack.append(res)\n            res = []\n        elif kind == 'ket':\n            last, res = res, stack.pop(-1)\n            res.append(last)\n        elif kind == 'token':\n            res.append(value)\n        elif kind == 'string':\n            res.append(value[1:-1])\n        else:\n            assert False\n    return res \n```", "```py\nparse_sexp('abcd (hello 123 (world \"hello world\"))') \n```", "```py\n['abcd', ['hello', '123', ['world', 'hello world']]]\n\n```", "```py\nimport [tempfile](https://docs.python.org/3/library/tempfile.html)\nimport [os](https://docs.python.org/3/library/os.html) \n```", "```py\nZ3_BINARY = 'z3'  # Z3 binary to invoke \n```", "```py\nZ3_OPTIONS = '-t:6000'  # Z3 options - a soft timeout of 6000 milliseconds \n```", "```py\ndef zeval_smt(path, cc, log):\n    s = cc.smt_expr(True, True, path)\n\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.smt',\n                                     delete=False) as f:\n        f.write(s + \"\\n\")\n        f.write(\"(check-sat)\\n\")\n        f.write(\"(get-model)\\n\")\n\n    if log:\n        print(open(f.name).read())\n\n    cmd = f\"{Z3_BINARY}  {Z3_OPTIONS}  {f.name}\"\n    if log:\n        print(cmd)\n\n    output = subprocess.getoutput(cmd)\n\n    os.remove(f.name)\n\n    if log:\n        print(output)\n\n    o = parse_sexp(output)\n    if not o:\n        return 'Gave up', None\n\n    kind = o[0]\n    if kind == 'unknown':\n        return 'Gave up', None\n    elif kind == 'timeout':\n        return 'Timeout', None\n    elif kind == 'unsat':\n        return 'No Solutions', {}\n\n    assert kind == 'sat', kind\n    if o[1][0] == 'model': # up to 4.8.8.0\n        return 'sat', {i[1]: (i[-1], i[-2]) for i in o[1][1:]}\n    else:\n        return 'sat', {i[1]: (i[-1], i[-2]) for i in o[1][0:]} \n```", "```py\nwith ConcolicTracer() as _:\n    _[factorial](5) \n```", "```py\n_.zeval(log=True) \n```", "```py\nPredicates in path:\n0 Not(0 > factorial_n_int_1)\n1 Not(0 == factorial_n_int_1)\n2 Not(1 == factorial_n_int_1)\n3 0 != factorial_n_int_1\n4 0 != factorial_n_int_1 - 1\n5 0 != factorial_n_int_1 - 1 - 1\n6 0 != factorial_n_int_1 - 1 - 1 - 1\n7 0 != factorial_n_int_1 - 1 - 1 - 1 - 1\n8 Not(0 != factorial_n_int_1 - 1 - 1 - 1 - 1 - 1)\n\n(declare-const factorial_n_int_1 Int)\n(assert (and (<= 0 factorial_n_int_1)\n     (not (= 0 factorial_n_int_1))\n     (not (= 1 factorial_n_int_1))\n     (not (= 2 factorial_n_int_1))\n     (not (= 3 factorial_n_int_1))\n     (not (= 4 factorial_n_int_1))\n     (= 5 factorial_n_int_1)))\n(check-sat)\n(get-model)\n\nz3 -t:6000 /var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmp9aqp4ftz.smt\nsat\n(\n  (define-fun factorial_n_int_1 () Int\n    5)\n)\n\n```", "```py\n('sat', {'n': ('5', 'Int')})\n\n```", "```py\nclass zstr(str):\n    def __new__(cls, context, zn, v):\n        return str.__new__(cls, v) \n```", "```py\nclass zstr(zstr):\n    @classmethod\n    def create(cls, context, zn, v=None):\n        return zproxy_create(cls, 'String', z3.String, context, zn, v)\n\n    def __init__(self, context, z, v=None):\n        self.context, self.z, self.v = context, z, v\n        self._len = zint(context, z3.Length(z), len(v))\n        #self.context[1].append(z3.Length(z) == z3.IntVal(len(v))) \n```", "```py\nclass zstr(zstr):\n    def _zv(self, o):\n        return (o.z, o.v) if isinstance(o, zstr) else (z3.StringVal(o), o) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Union, Optional, Dict, Generator, Set\n\ndef visit_z3_expr(\n        e: Union[z3.ExprRef, z3.QuantifierRef],\n        seen: Optional[Dict[Union[z3.ExprRef, z3.QuantifierRef], bool]] = None) -> \\\n        Generator[Union[z3.ExprRef, z3.QuantifierRef], None, None]:\n    if seen is None:\n        seen = {}\n    elif e in seen:\n        return\n\n    seen[e] = True\n    yield e\n\n    if z3.is_app(e):\n        for ch in e.children():\n            for e in visit_z3_expr(ch, seen):\n                yield e\n        return\n\n    if z3.is_quantifier(e):\n        for e in visit_z3_expr(e.body(), seen):\n            yield e\n        return\n\ndef is_z3_var(e: z3.ExprRef) -> bool:\n    return z3.is_const(e) and e.decl().kind() == z3.Z3_OP_UNINTERPRETED\n\ndef get_all_vars(e: z3.ExprRef) -> Set[z3.ExprRef]:\n    return {sub for sub in visit_z3_expr(e) if is_z3_var(sub)}\n\ndef z3_ord(str_expr: z3.SeqRef) -> z3.ArithRef:\n    return z3.parse_smt2_string(\n        f\"(assert (= 42 (str.to_code {str_expr.sexpr()})))\",\n        decls={str(c): c for c in get_all_vars(str_expr)}\n    )[0].children()[1]\n\ndef z3_chr(int_expr: z3.ArithRef) -> z3.SeqRef:\n    return z3.parse_smt2_string(\n        f\"(assert (= \\\"4\\\" (str.from_code {int_expr.sexpr()})))\",\n        decls={str(c): c for c in get_all_vars(int_expr)}\n    )[0].children()[1] \n```", "```py\ndef zord(context, c):\n    return z3_ord(c) \n```", "```py\nzc = z3.String('arg_%d' % fresh_name()) \n```", "```py\nwith ConcolicTracer() as _:\n    zi = zord(_.context, zc) \n```", "```py\n_.context \n```", "```py\n({}, [])\n\n```", "```py\nzi.sexpr() \n```", "```py\n'(str.to_code arg_2)'\n\n```", "```py\n(zi == 65).sexpr() \n```", "```py\n'(= (str.to_code arg_2) 65)'\n\n```", "```py\nz3.solve([zi == 65]) \n```", "```py\n[arg_2 = \"A\"]\n\n```", "```py\ndef zchr(context, i):\n    return z3_chr(i) \n```", "```py\ni = z3.Int('ival_%d' % fresh_name()) \n```", "```py\nwith ConcolicTracer() as _:\n    zc = zchr(_.context, i) \n```", "```py\n_.context \n```", "```py\n({}, [])\n\n```", "```py\n(zc== z3.StringVal('a')).sexpr() \n```", "```py\n'(= (str.from_code ival_1) \"a\")'\n\n```", "```py\nz3.solve([zc == z3.StringVal('a')]) \n```", "```py\n[ival_1 = 97]\n\n```", "```py\nclass zstr(zstr):\n    def __eq__(self, other):\n        z, v = self._zv(other)\n        return zbool(self.context, self.z == z, self.v == v)\n\n    def __req__(self, other):\n        return self.__eq__(other) \n```", "```py\ndef tstr1(s):\n    if s == 'h':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr1]('h') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('h', 'String')})\n\n```", "```py\ndef tstr1(s):\n    if s == 'hello world':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr1]('hello world') \n```", "```py\n_.context \n```", "```py\n({'tstr1_s_str_1': 'String'}, [tstr1_s_str_1 == \"hello world\"])\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('hello world', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def __len__(self):\n        raise NotImplemented() \n```", "```py\nclass zstr(zstr):\n    def length(self):\n        return self._len \n```", "```py\nwith ConcolicTracer() as _:\n    za = zstr.create(_.context, 'str_a', \"s\")\n    if za.length() > 0:\n        print(1) \n```", "```py\n1\n\n```", "```py\n_.context \n```", "```py\n({'str_a': 'String'}, [0 < Length(str_a)])\n\n```", "```py\ndef tstr2(s):\n    if s.length() > 1:\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr2]('hello world') \n```", "```py\n_.context \n```", "```py\n({'tstr2_s_str_1': 'String'}, [1 < Length(tstr2_s_str_1)])\n\n```", "```py\n_.zeval(log=True) \n```", "```py\nPredicates in path:\n0 1 < Length(tstr2_s_str_1)\n\n(declare-const tstr2_s_str_1 String)\n(assert (not (<= (str.len tstr2_s_str_1) 1)))\n(check-sat)\n(get-model)\n\nz3 -t:6000 /var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpwlyj0q93.smt\nsat\n(\n  (define-fun tstr2_s_str_1 () String\n    \"AB\")\n)\n\n```", "```py\n('sat', {'s': ('AB', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def __add__(self, other):\n        z, v = self._zv(other)\n        return zstr(self.context, self.z + z, self.v + v)\n\n    def __radd__(self, other):\n        return self.__add__(other) \n```", "```py\nwith ConcolicTracer() as _:\n    v1, v2 = [zstr.create(_.context, 'arg_%d' % fresh_name(), s)\n              for s in ['hello', 'world']]\n    if (v1 + ' ' + v2) == 'hello world':\n        print('hello world') \n```", "```py\nhello world\n\n```", "```py\n_.context \n```", "```py\n({'arg_1': 'String', 'arg_2': 'String'},\n [Concat(Concat(arg_1, \" \"), arg_2) == \"hello world\"])\n\n```", "```py\nclass zstr(zstr):\n    def __getitem__(self, idx):\n        if isinstance(idx, slice):\n            start, stop, step = idx.indices(len(self.v))\n            assert step == 1  # for now\n            assert stop >= start  # for now\n            rz = z3.SubString(self.z, start, stop - start)\n            rv = self.v[idx]\n        elif isinstance(idx, int):\n            rz = z3.SubString(self.z, idx, 1)\n            rv = self.v[idx]\n        else:\n            assert False  # for now\n        return zstr(self.context, rz, rv)\n\n    def __iter__(self):\n        return zstr_iterator(self.context, self) \n```", "```py\nclass zstr_iterator():\n    def __init__(self, context, zstr):\n        self.context = context\n        self._zstr = zstr\n        self._str_idx = 0\n        self._str_max = zstr._len  # intz is not an _int_\n\n    def __next__(self):\n        if self._str_idx == self._str_max:  # intz#eq\n            raise StopIteration\n        c = self._zstr[self._str_idx]\n        self._str_idx += 1\n        return c\n\n    def __len__(self):\n        return self._len \n```", "```py\ndef tstr3(s):\n    if s[0] == 'h' and s[1] == 'e' and s[3] == 'l':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr3]('hello') \n```", "```py\n_.context \n```", "```py\n({'tstr3_s_str_1': 'String'},\n [str.substr(tstr3_s_str_1, 0, 1) == \"h\",\n  str.substr(tstr3_s_str_1, 1, 1) == \"e\",\n  str.substr(tstr3_s_str_1, 3, 1) == \"l\"])\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('heAl', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def upper(self):\n        empty = ''\n        ne = 'empty_%d' % fresh_name()\n        result = zstr.create(self.context, ne, empty)\n        self.context[1].append(z3.StringVal(empty) == result.z)\n        cdiff = (ord('a') - ord('A'))\n        for i in self:\n            oz = zord(self.context, i.z)\n            uz = zchr(self.context, oz - cdiff)\n            rz = z3.And([oz >= ord('a'), oz <= ord('z')])\n            ov = ord(i.v)\n            uv = chr(ov - cdiff)\n            rv = ov >= ord('a') and ov <= ord('z')\n            if zbool(self.context, rz, rv):\n                i = zstr(self.context, uz, uv)\n            else:\n                i = zstr(self.context, i.z, i.v)\n            result += i\n        return result \n```", "```py\nclass zstr(zstr):\n    def lower(self):\n        empty = ''\n        ne = 'empty_%d' % fresh_name()\n        result = zstr.create(self.context, ne, empty)\n        self.context[1].append(z3.StringVal(empty) == result.z)\n        cdiff = (ord('a') - ord('A'))\n        for i in self:\n            oz = zord(self.context, i.z)\n            uz = zchr(self.context, oz + cdiff)\n            rz = z3.And([oz >= ord('A'), oz <= ord('Z')])\n            ov = ord(i.v)\n            uv = chr(ov + cdiff)\n            rv = ov >= ord('A') and ov <= ord('Z')\n            if zbool(self.context, rz, rv):\n                i = zstr(self.context, uz, uv)\n            else:\n                i = zstr(self.context, i.z, i.v)\n            result += i\n        return result \n```", "```py\ndef tstr4(s):\n    if s.upper() == 'H':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr4]('h') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('h', 'String')})\n\n```", "```py\ndef tstr5(s):\n    if s.lower() == 'hello world':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr5]('Hello World') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('Hello World', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def startswith(self, other, beg=0, end=None):\n        assert end is None  # for now\n        assert isinstance(beg, int)  # for now\n        zb = z3.IntVal(beg)\n\n        others = other if isinstance(other, tuple) else (other, )\n\n        last = False\n        for o in others:\n            z, v = self._zv(o)\n            r = z3.IndexOf(self.z, z, zb)\n            last = zbool(self.context, r == zb, self.v.startswith(v))\n            if last:\n                return last\n        return last \n```", "```py\ndef tstr6(s):\n    if s.startswith('hello'):\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr6]('hello world') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('helloAhello', 'String')})\n\n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr6]('my world') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def find(self, other, beg=0, end=None):\n        assert end is None  # for now\n        assert isinstance(beg, int)  # for now\n        zb = z3.IntVal(beg)\n        z, v = self._zv(other)\n        zi = z3.IndexOf(self.z, z, zb)\n        vi = self.v.find(v, beg, end)\n        return zint(self.context, zi, vi) \n```", "```py\ndef tstr7(s):\n    if s.find('world') != -1:\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr7]('hello world') \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('worldAworld', 'String')})\n\n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\nclass zstr(zstr):\n    def rstrip(self, chars=None):\n        if chars is None:\n            chars = string.whitespace\n        if self._len == 0:\n            return self\n        else:\n            last_idx = self._len - 1\n            cz = z3.SubString(self.z, last_idx.z, 1)\n            cv = self.v[-1]\n            zcheck_space = z3.Or([cz == z3.StringVal(char) for char in chars])\n            vcheck_space = any(cv == char for char in chars)\n            if zbool(self.context, zcheck_space, vcheck_space):\n                return zstr(self.context, z3.SubString(self.z, 0, last_idx.z),\n                            self.v[0:-1]).rstrip(chars)\n            else:\n                return self \n```", "```py\ndef tstr8(s):\n    if s.rstrip(' ') == 'a b':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr8]('a b   ')\n    print(r) \n```", "```py\nTrue\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('a b   ', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def lstrip(self, chars=None):\n        if chars is None:\n            chars = string.whitespace\n        if self._len == 0:\n            return self\n        else:\n            first_idx = 0\n            cz = z3.SubString(self.z, 0, 1)\n            cv = self.v[0]\n            zcheck_space = z3.Or([cz == z3.StringVal(char) for char in chars])\n            vcheck_space = any(cv == char for char in chars)\n            if zbool(self.context, zcheck_space, vcheck_space):\n                return zstr(self.context, z3.SubString(\n                    self.z, 1, self._len.z), self.v[1:]).lstrip(chars)\n            else:\n                return self \n```", "```py\ndef tstr9(s):\n    if s.lstrip(' ') == 'a b':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr9]('   a b')\n    print(r) \n```", "```py\nTrue\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('   a b', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def strip(self, chars=None):\n        return self.lstrip(chars).rstrip(chars) \n```", "```py\ndef tstr10(s):\n    if s.strip() == 'a b':\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr10]('    a b  ')\n    print(r) \n```", "```py\nTrue\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('\\\\u{c}\\\\u{a}\\\\u{9}\\\\u{a}a b\\\\u{d}\\\\u{d}', 'String')})\n\n```", "```py\nclass zstr(zstr):\n    def split(self, sep=None, maxsplit=-1):\n        assert sep is not None  # default space based split is complicated\n        assert maxsplit == -1  # for now.\n        zsep = z3.StringVal(sep)\n        zl = z3.Length(zsep)\n        # zi would be the length of prefix\n        zi = z3.IndexOf(self.z, zsep, z3.IntVal(0))\n        # Z3Bug: There is a bug in the `z3.IndexOf` method which returns\n        # `z3.SeqRef` instead of `z3.ArithRef`. So we need to fix it.\n        zi = z3.ArithRef(zi.ast, zi.ctx)\n\n        vi = self.v.find(sep)\n        if zbool(self.context, zi >= z3.IntVal(0), vi >= 0):\n            zprefix = z3.SubString(self.z, z3.IntVal(0), zi)\n            zmid = z3.SubString(self.z, zi, zl)\n            zsuffix = z3.SubString(self.z, zi + zl,\n                                   z3.Length(self.z))\n            return [zstr(self.context, zprefix, self.v[0:vi])] + zstr(\n                self.context, zsuffix, self.v[vi + len(sep):]).split(\n                    sep, maxsplit)\n        else:\n            return [self] \n```", "```py\ndef tstr11(s):\n    if s.split(',') == ['a', 'b', 'c']:\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[tstr11]('a,b,c')\n    print(r) \n```", "```py\nTrue\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('a,b,c', 'String')})\n\n```", "```py\ndef make_str_abort_wrapper(fun):\n    def proxy(*args, **kwargs):\n        raise Exception('%s Not implemented in `zstr`' % fun.__name__)\n    return proxy \n```", "```py\ndef init_concolic_3():\n    strmembers = inspect.getmembers(zstr, callable)\n    zstrmembers = {m[0] for m in strmembers if len(\n        m) == 2 and 'zstr' in m[1].__qualname__}\n    for name, fn in inspect.getmembers(str, callable):\n        # Omitted 'splitlines' as this is needed for formatting output in\n        # IPython/Jupyter\n        if name not in zstrmembers and name not in [\n            'splitlines',\n            '__class__',\n            '__contains__',\n            '__delattr__',\n            '__dir__',\n            '__format__',\n            '__ge__',\n            '__getattribute__',\n            '__getnewargs__',\n            '__gt__',\n            '__hash__',\n            '__le__',\n            '__len__',\n            '__lt__',\n            '__mod__',\n            '__mul__',\n            '__ne__',\n            '__reduce__',\n            '__reduce_ex__',\n            '__repr__',\n            '__rmod__',\n            '__rmul__',\n            '__setattr__',\n            '__sizeof__',\n                '__str__']:\n            setattr(zstr, name, make_str_abort_wrapper(fn)) \n```", "```py\nINITIALIZER_LIST.append(init_concolic_3) \n```", "```py\ninit_concolic_3() \n```", "```py\nwith ConcolicTracer() as _:\n    print(_[triangle](1, 2, 3)) \n```", "```py\nscalene\n\n```", "```py\n_.decls \n```", "```py\n{'triangle_a_int_1': 'Int',\n 'triangle_b_int_2': 'Int',\n 'triangle_c_int_3': 'Int'}\n\n```", "```py\n_.path \n```", "```py\n[Not(triangle_a_int_1 == triangle_b_int_2),\n Not(triangle_b_int_2 == triangle_c_int_3),\n Not(triangle_a_int_1 == triangle_c_int_3)]\n\n```", "```py\n_.zeval() \n```", "```py\n('sat',\n {'a': ('0', 'Int'), 'b': (['-', '2'], 'Int'), 'c': (['-', '1'], 'Int')})\n\n```", "```py\ntriangle(0, -2, -1) \n```", "```py\n'scalene'\n\n```", "```py\nza, zb, zc = [z3.Int(s) for s in _.decls.keys()] \n```", "```py\nza, zb, zc \n```", "```py\n(triangle_a_int_1, triangle_b_int_2, triangle_c_int_3)\n\n```", "```py\n_.zeval({1: zb == zc}) \n```", "```py\n('sat', {'a': ('1', 'Int'), 'b': ('0', 'Int'), 'c': ('0', 'Int')})\n\n```", "```py\ntriangle(1, 0, 1) \n```", "```py\n'isosceles'\n\n```", "```py\ndef cgi_decode(s):\n  \"\"\"Decode the CGI-encoded string `s`:\n * replace \"+\" by \" \"\n * replace \"%xx\" by the character with hex number xx.\n Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n\n    # Mapping of hex digits to their integer values\n    hex_values = {\n        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n    }\n\n    t = ''\n    i = 0\n    while i < s.length():\n        c = s[i]\n        if c == '+':\n            t += ' '\n        elif c == '%':\n            digit_high, digit_low = s[i + 1], s[i + 2]\n            i = i + 2\n            found = 0\n            v = 0\n            for key in hex_values:\n                if key == digit_high:\n                    found = found + 1\n                    v = hex_values[key] * 16\n                    break\n            for key in hex_values:\n                if key == digit_low:\n                    found = found + 1\n                    v = v + hex_values[key]\n                    break\n            if found == 2:\n                if v >= 128:\n                    # z3.StringVal(urllib.parse.unquote('%80')) <-- bug in z3\n                    raise ValueError(\"Invalid encoding\")\n                t = t + chr(v)\n            else:\n                raise ValueError(\"Invalid encoding\")\n        else:\n            t = t + c\n        i = i + 1\n    return t \n```", "```py\nwith ConcolicTracer() as _:\n    _[cgi_decode]('') \n```", "```py\n_.context \n```", "```py\n({'cgi_decode_s_str_1': 'String'}, [Not(0 < Length(cgi_decode_s_str_1))])\n\n```", "```py\nwith ConcolicTracer() as _:\n    _[cgi_decode]('a%20d') \n```", "```py\n_.decls \n```", "```py\n{'cgi_decode_s_str_1': 'String'}\n\n```", "```py\n_.path \n```", "```py\n[0 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"%\"),\n 1 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 1, 1) == \"+\"),\n str.substr(cgi_decode_s_str_1, 1, 1) == \"%\",\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"0\"),\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"1\"),\n str.substr(cgi_decode_s_str_1, 2, 1) == \"2\",\n str.substr(cgi_decode_s_str_1, 3, 1) == \"0\",\n 4 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"%\"),\n Not(5 < Length(cgi_decode_s_str_1))]\n\n```", "```py\nassert _.context == (_.decls, _.path) \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'s': ('A%20B', 'String')})\n\n```", "```py\n_.path[0] \n```", "```py\nzs = z3.String('cgi_decode_s_str_1') \n```", "```py\nz3.SubString(zs, 0, 1) == z3.StringVal('a') \n```", "```py\n(result, new_vars) = _.zeval({1: z3.SubString(zs, 0, 1) == z3.StringVal('+')}) \n```", "```py\nnew_vars \n```", "```py\n{'s': ('+%20A', 'String')}\n\n```", "```py\n(new_s, new_s_type) = new_vars['s'] \n```", "```py\nnew_s \n```", "```py\n'+%20A'\n\n```", "```py\nwith ConcolicTracer() as _:\n    _[cgi_decode](new_s) \n```", "```py\n_.path \n```", "```py\n[0 < Length(cgi_decode_s_str_1),\n str.substr(cgi_decode_s_str_1, 0, 1) == \"+\",\n 1 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 1, 1) == \"+\"),\n str.substr(cgi_decode_s_str_1, 1, 1) == \"%\",\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"0\"),\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"1\"),\n str.substr(cgi_decode_s_str_1, 2, 1) == \"2\",\n str.substr(cgi_decode_s_str_1, 3, 1) == \"0\",\n 4 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 4, 1) == \"%\"),\n Not(5 < Length(cgi_decode_s_str_1))]\n\n```", "```py\ndef round10(r):\n    while r % 10 != 0:\n        r += 1\n    return r \n```", "```py\nwith ConcolicTracer() as _:\n    r = _[round10](1) \n```", "```py\n_.context \n```", "```py\n({'round10_r_int_1': 'Int'},\n [0 != round10_r_int_1%10,\n  0 != (round10_r_int_1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1 + 1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)%10,\n  0 != (round10_r_int_1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)%10,\n  Not(0 !=\n      (round10_r_int_1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1)%10)])\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'r': (['-', '9'], 'Int')})\n\n```", "```py\ndef abs_value(a):\n    if a > 0:\n        return a\n    else:\n        return -a \n```", "```py\ndef abs_max(a, b):\n    a1 = abs_value(a)\n    b1 = abs_value(b)\n    if a1 > b1:\n        c = a1\n    else:\n        c = b1\n    return c \n```", "```py\nwith ConcolicTracer() as _:\n    _[abs_max](2, 1) \n```", "```py\n_.context \n```", "```py\n({'abs_max_a_int_1': 'Int', 'abs_max_b_int_2': 'Int'},\n [0 < abs_max_a_int_1, 0 < abs_max_b_int_2, abs_max_a_int_1 > abs_max_b_int_2])\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'a': ('2', 'Int'), 'b': ('1', 'Int')})\n\n```", "```py\nwith ConcolicTracer() as _:\n    _[abs_max](-2, -1) \n```", "```py\n_.context \n```", "```py\n({'abs_max_a_int_1': 'Int', 'abs_max_b_int_2': 'Int'},\n [Not(0 < abs_max_a_int_1),\n  Not(0 < abs_max_b_int_2),\n  -abs_max_a_int_1 > -abs_max_b_int_2])\n\n```", "```py\n_.zeval() \n```", "```py\n('sat', {'a': (['-', '1'], 'Int'), 'b': ('0', 'Int')})\n\n```", "```py\ndef factorial(n):\n    v = 1\n    while n != 0:\n        v *= n\n        n -= 1\n\n    return v \n```", "```py\ndef permutation(n, k):\n    return factorial(n) / factorial(n - k) \n```", "```py\ndef combination(n, k):\n    return permutation(n, k) / factorial(k) \n```", "```py\ndef binomial(n, k):\n    if n < 0 or k < 0 or n < k:\n        raise Exception('Invalid values')\n    return combination(n, k) \n```", "```py\nwith ConcolicTracer() as _:\n    v = _[binomial](4, 2) \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'n': ('4', 'Int'), 'k': ('2', 'Int')})\n\n```", "```py\nif __name__ == '__main__':\n    if z3.get_version() > (4, 8, 7, 0):\n        print(\"\"\"Note: The following example may not work with your Z3 version;\nsee https://github.com/Z3Prover/z3/issues/5763 for details.\nConsider `pip install z3-solver==4.8.7.0` as a workaround.\"\"\") \n```", "```py\nNote: The following example may not work with your Z3 version;\nsee https://github.com/Z3Prover/z3/issues/5763 for details.\nConsider `pip install z3-solver==4.8.7.0` as a workaround.\n\n```", "```py\nfrom [InformationFlow](InformationFlow.html) import DB, sample_db, update_inventory \n```", "```py\nfrom [GrammarMiner](GrammarMiner.html) import VEHICLES  # minor dependency \n```", "```py\ndb = sample_db()\nfor V in VEHICLES:\n    update_inventory(db, V) \n```", "```py\ndb.db \n```", "```py\n{'inventory': ({'year': int, 'kind': str, 'company': str, 'model': str},\n  [{'year': 1997, 'kind': 'van', 'company': 'Ford', 'model': 'E350'},\n   {'year': 2000, 'kind': 'car', 'company': 'Mercury', 'model': 'Cougar'},\n   {'year': 1999, 'kind': 'car', 'company': 'Chevy', 'model': 'Venture'}])}\n\n```", "```py\nclass ConcolicDB(DB):\n    def table(self, t_name):\n        for k, v in self.db:\n            if t_name == k:\n                return v\n        raise SQLException('Table (%s) was not found' % repr(t_name))\n\n    def column(self, decl, c_name):\n        for k in decl:\n            if c_name == k:\n                return decl[k]\n        raise SQLException('Column (%s) was not found' % repr(c_name)) \n```", "```py\ndef db_select(s):\n    my_db = ConcolicDB()\n    my_db.db = [(k, v) for (k, v) in db.db.items()]\n    r = my_db.sql(s)\n    return r \n```", "```py\nwith ConcolicTracer() as _:\n    _[db_select]('select kind from inventory') \n```", "```py\n_.path \n```", "```py\n[0 == IndexOf(db_select_s_str_1, \"select \", 0),\n 0 == IndexOf(db_select_s_str_1, \"select \", 0),\n Not(0 >\n     IndexOf(str.substr(db_select_s_str_1, 7, 19),\n             \" from \",\n             0)),\n Not(Or(0 <\n        IndexOf(str.substr(db_select_s_str_1, 7, 19),\n                \" where \",\n                0),\n        0 ==\n        IndexOf(str.substr(db_select_s_str_1, 7, 19),\n                \" where \",\n                0))),\n str.substr(str.substr(db_select_s_str_1, 7, 19), 10, 9) ==\n \"inventory\"]\n\n```", "```py\n_.zeval() \n```", "```py\n('Gave up', None)\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\ndef hang_if_no_space(s):\n    i = 0\n    while True:\n        if i < s.length():\n            if s[i] == ' ':\n                break\n        i += 1 \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectTimeout, ExpectError \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nclass TraceNode:\n    def __init__(self, smt_val, parent, info):\n        # This is the smt that lead to this node\n        self._smt_val = z3.simplify(smt_val) if smt_val is not None else None\n\n        # This is the predicate that this node might perform at a future point\n        self.smt = None\n        self.info = info\n        self.parent = parent\n        self.children = {}\n        self.path = None\n        self.tree = None\n        self._pattern = None\n        self.log = True\n\n    def no(self): return self.children.get(self.tree.no_bit)\n\n    def yes(self): return self.children.get(self.tree.yes_bit)\n\n    def get_children(self): return (self.no(), self.yes())\n\n    def __str__(self):\n        return 'TraceNode[%s]' % ','.join(self.children.keys()) \n```", "```py\nclass PlausibleChild:\n    def __init__(self, parent, cond, tree):\n        self.parent = parent\n        self.cond = cond\n        self.tree = tree\n        self._smt_val = None\n\n    def __repr__(self):\n        return 'PlausibleChild[%s]' % (self.parent.pattern() + ':' + self.cond) \n```", "```py\nclass PlausibleChild(PlausibleChild):\n    def smt_val(self):\n        if self._smt_val is not None:\n            return self._smt_val\n        # if the parent has other children, then that child would have updatd the parent's smt\n        # Hence, we can use that child's smt_value's opposite as our value.\n        assert self.parent.smt is not None\n        if self.cond == self.tree.no_bit:\n            self._smt_val = z3.Not(self.parent.smt)\n        else:\n            self._smt_val = self.parent.smt\n        return self._smt_val\n\n    def cc(self):\n        if self.parent.info.get('cc') is not None:\n            return self.parent.info['cc']\n        # if there is a plausible child node, it means that there can\n        # be at most one child.\n        siblings = list(self.parent.children.values())\n        assert len(siblings) == 1\n        # We expect at the other child to have cc\n        return siblings[0].info['cc'] \n```", "```py\nclass PlausibleChild(PlausibleChild):\n    def path_expression(self):\n        path_to_root = self.parent.get_path_to_root()\n        assert path_to_root[0]._smt_val is None\n        return [i._smt_val for i in path_to_root[1:]] + [self.smt_val()] \n```", "```py\nclass TraceTree:\n    def __init__(self):\n        self.root = TraceNode(smt_val=None, parent=None, info={'num': 0})\n        self.root.tree = self\n        self.leaves = {}\n        self.no_bit, self.yes_bit = '0', '1'\n\n        pprefix = ':'\n        for bit in [self.no_bit, self.yes_bit]:\n            self.leaves[pprefix + bit] = PlausibleChild(self.root, bit, self)\n        self.completed_paths = {} \n```", "```py\nclass TraceTree(TraceTree):\n    def add_trace(self, tracer, string):\n        last = self.root\n        i = 0\n        for i, elt in enumerate(tracer.path):\n            last = last.add_child(elt=elt, i=i + 1, cc=tracer, string=string)\n        last.add_child(elt=z3.BoolVal(True), i=i + 1, cc=tracer, string=string) \n```", "```py\nclass TraceNode(TraceNode):\n    def bit(self):\n        if self._smt_val is None:\n            return None\n        return self.tree.no_bit if self._smt_val.decl(\n        ).name() == 'not' else self.tree.yes_bit\n\n    def pattern(self):\n        if self._pattern is not None:\n            return self._pattern\n        path = self.get_path_to_root()\n        assert path[0]._smt_val is None\n        assert path[0].parent is None\n\n        self._pattern = ''.join([p.bit() for p in path[1:]])\n        return self._pattern \n```", "```py\nclass TraceNode(TraceNode):\n    def add_child(self, elt, i, cc, string):\n        if elt == z3.BoolVal(True):\n            # No more exploration here. Simply unregister the leaves of *this*\n            # node and possibly register them in completed nodes, and exit\n            for bit in [self.tree.no_bit, self.tree.yes_bit]:\n                child_leaf = self.pattern() + ':' + bit\n                if child_leaf in self.tree.leaves:\n                    del self.tree.leaves[child_leaf]\n            self.tree.completed_paths[self.pattern()] = self\n            return None\n\n        child_node = TraceNode(smt_val=elt,\n                               parent=self,\n                               info={'num': i, 'cc': cc, 'string': string})\n        child_node.tree = self.tree\n\n        # bit represents the path that child took from this node.\n        bit = child_node.bit()\n\n        # first we update our smt decision\n        if bit == self.tree.yes_bit:  # yes, which means the smt can be used as is\n            if self.smt is not None:\n                assert self.smt == child_node._smt_val\n            else:\n                self.smt = child_node._smt_val\n        # no, which means we have to negate it to get the decision.\n        elif bit == self.tree.no_bit:\n            smt_ = z3.simplify(z3.Not(child_node._smt_val))\n            if self.smt is not None:\n                assert smt_ == self.smt\n            else:\n                self.smt = smt_\n        else:\n            assert False\n\n        if bit in self.children:\n            #    if self.log:\n            #print(elt, child_node.bit(), i, string)\n            #print(i,'overwriting', bit,'=>',self.children[bit],'with',child_node)\n            child_node = self.children[bit]\n            #self.children[bit] = child_node\n            #child_node.children = old.children\n        else:\n            self.children[bit] = child_node\n\n        # At this point, we have to unregister any leaves that correspond to this child from tree,\n        # and add the plausible children of this child as leaves to be explored. Note that\n        # if it is the end (z3.True), we do not have any more children.\n        child_leaf = self.pattern() + ':' + bit\n        if child_leaf in self.tree.leaves:\n            del self.tree.leaves[child_leaf]\n\n        pprefix = child_node.pattern() + ':'\n\n        # Plausible children.\n        for bit in [self.tree.no_bit, self.tree.yes_bit]:\n            self.tree.leaves[pprefix +\n                             bit] = PlausibleChild(child_node, bit, self.tree)\n        return child_node \n```", "```py\nclass TraceNode(TraceNode):\n    def get_path_to_root(self):\n        if self.path is not None:\n            return self.path\n        parent_path = []\n        if self.parent is not None:\n            parent_path = self.parent.get_path_to_root()\n        self.path = parent_path + [self]\n        return self.path \n```", "```py\nclass SimpleConcolicFuzzer(Fuzzer):\n    def __init__(self):\n        self.ct = TraceTree()\n        self.max_tries = 1000\n        self.last = None\n        self.last_idx = None \n```", "```py\nwith ExpectTimeout(2):\n    with ConcolicTracer() as _:\n        _[hang_if_no_space]('ab d') \n```", "```py\n_.path \n```", "```py\n[0 < Length(hang_if_no_space_s_str_1),\n Not(str.substr(hang_if_no_space_s_str_1, 0, 1) == \" \"),\n 1 < Length(hang_if_no_space_s_str_1),\n Not(str.substr(hang_if_no_space_s_str_1, 1, 1) == \" \"),\n 2 < Length(hang_if_no_space_s_str_1),\n str.substr(hang_if_no_space_s_str_1, 2, 1) == \" \"]\n\n```", "```py\nscf = SimpleConcolicFuzzer()\nscf.ct.add_trace(_, 'ab d') \n```", "```py\n[i._smt_val for i in scf.ct.root.get_children(\n)[0].get_children(\n)[0].get_children(\n)[0].get_children(\n)[0].get_children(\n)[0].get_children(\n)[1].get_path_to_root()] \n```", "```py\n[None,\n Not(Length(hang_if_no_space_s_str_1) <= 0),\n Not(str.substr(hang_if_no_space_s_str_1, 0, 1) == \" \"),\n Not(Length(hang_if_no_space_s_str_1) <= 1),\n Not(str.substr(hang_if_no_space_s_str_1, 1, 1) == \" \"),\n Not(Length(hang_if_no_space_s_str_1) <= 2),\n str.substr(hang_if_no_space_s_str_1, 2, 1) == \" \"]\n\n```", "```py\nfor key in scf.ct.leaves:\n    print(key, '\\t', scf.ct.leaves[key]) \n```", "```py\n:1 \t PlausibleChild[:1]\n0:1 \t PlausibleChild[0:1]\n00:1 \t PlausibleChild[00:1]\n000:1 \t PlausibleChild[000:1]\n0000:1 \t PlausibleChild[0000:1]\n00000:0 \t PlausibleChild[00000:0]\n\n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import display_tree \n```", "```py\nTREE_NODES = {} \n```", "```py\ndef my_extract_node(tnode, id):\n    key, node, parent = tnode\n    if node is None:\n        # return '? (%s:%s)' % (parent.pattern(), key) , [], ''\n        return '?', [], ''\n    if node.smt is None:\n        return '* %s' % node.info.get('string', ''), [], ''\n\n    no, yes = node.get_children()\n    num = str(node.info.get('num'))\n    children = [('0', no, node), ('1', yes, node)]\n    TREE_NODES[id] = 0\n    return \"(%s) %s\" % (num, str(node.smt)), children, '' \n```", "```py\ndef my_edge_attr(dot, start_node, stop_node):\n    # the edges are always drawn '0:NO' first.\n    if TREE_NODES[start_node] == 0:\n        color, label = 'red', '0'\n        TREE_NODES[start_node] = 1\n    else:\n        color, label = 'blue', '1'\n        TREE_NODES[start_node] = 2\n    dot.edge(repr(start_node), repr(stop_node), color=color, label=label) \n```", "```py\ndef display_trace_tree(root):\n    TREE_NODES.clear()\n    return display_tree(\n        ('', root, None), extract_node=my_extract_node, edge_attr=my_edge_attr) \n```", "```py\ndisplay_trace_tree(scf.ct.root) \n```", "```py\nscf.ct.leaves['00000:0'] \n```", "```py\nPlausibleChild[00000:0]\n\n```", "```py\nscf.ct.leaves['00000:0'].path_expression() \n```", "```py\n[Not(Length(hang_if_no_space_s_str_1) <= 0),\n Not(str.substr(hang_if_no_space_s_str_1, 0, 1) == \" \"),\n Not(Length(hang_if_no_space_s_str_1) <= 1),\n Not(str.substr(hang_if_no_space_s_str_1, 1, 1) == \" \"),\n Not(Length(hang_if_no_space_s_str_1) <= 2),\n Not(str.substr(hang_if_no_space_s_str_1, 2, 1) == \" \")]\n\n```", "```py\nscf.ct.leaves[':1'] \n```", "```py\nPlausibleChild[:1]\n\n```", "```py\nscf.ct.leaves[':1'].path_expression() \n```", "```py\n[Length(hang_if_no_space_s_str_1) <= 0]\n\n```", "```py\nclass SimpleConcolicFuzzer(SimpleConcolicFuzzer):\n    def add_trace(self, trace, s):\n        self.ct.add_trace(trace, s)\n\n    def next_choice(self):\n        #lst = sorted(list(self.ct.leaves.keys()), key=len)\n        c = random.choice(list(self.ct.leaves.keys()))\n        #c = lst[0]\n        return self.ct.leaves[c] \n```", "```py\nscf = SimpleConcolicFuzzer()\nscf.add_trace(_, 'ab d')\nnode = scf.next_choice() \n```", "```py\nnode \n```", "```py\nPlausibleChild[0000:1]\n\n```", "```py\nnode.path_expression() \n```", "```py\n[Not(Length(hang_if_no_space_s_str_1) <= 0),\n Not(str.substr(hang_if_no_space_s_str_1, 0, 1) == \" \"),\n Not(Length(hang_if_no_space_s_str_1) <= 1),\n Not(str.substr(hang_if_no_space_s_str_1, 1, 1) == \" \"),\n Length(hang_if_no_space_s_str_1) <= 2]\n\n```", "```py\nclass SimpleConcolicFuzzer(SimpleConcolicFuzzer):\n    def get_newpath(self):\n        node = self.next_choice()\n        path = node.path_expression()\n        return path, node.cc() \n```", "```py\nscf = SimpleConcolicFuzzer()\nscf.add_trace(_, 'abcd')\npath, cc = scf.get_newpath()\npath \n```", "```py\n[Length(hang_if_no_space_s_str_1) <= 0]\n\n```", "```py\nclass SimpleConcolicFuzzer(SimpleConcolicFuzzer):\n    def fuzz(self):\n        if self.ct.root.children == {}:\n            # a random value to generate comparisons. This would be\n            # the initial value around which we explore with concolic\n            # fuzzing.\n            # str_len = random.randint(1,100)\n            # return ' '*str_len\n            return ' '\n        for i in range(self.max_tries):\n            path, last = self.get_newpath()\n            s, v = zeval_smt(path, last, log=False)\n            if s != 'sat':\n                # raise Exception(\"Unexpected UNSAT\")\n                continue\n\n            val = list(v.values())[0]\n            elt, typ = val\n\n            # make sure that we do not retry the tried paths\n            # The tracer we add here is incomplete. This gets updated when\n            # the add_trace is called from the concolic fuzzer context.\n            # self.add_trace(ConcolicTracer((last.decls, path)), elt)\n            if typ == 'Int':\n                if len(elt) == 2 and elt[0] == '-':  # negative numbers are [-, x]\n                    return -1*int(elt[1])\n                return int(elt)\n            elif typ == 'String':\n                return elt\n            return elt\n        return None \n```", "```py\nwith ConcolicTracer() as _:\n    _[cgi_decode]('a+c') \n```", "```py\n_.path \n```", "```py\n[0 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 0, 1) == \"%\"),\n 1 < Length(cgi_decode_s_str_1),\n str.substr(cgi_decode_s_str_1, 1, 1) == \"+\",\n 2 < Length(cgi_decode_s_str_1),\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"+\"),\n Not(str.substr(cgi_decode_s_str_1, 2, 1) == \"%\"),\n Not(3 < Length(cgi_decode_s_str_1))]\n\n```", "```py\nscf = SimpleConcolicFuzzer()\nscf.add_trace(_, 'a+c') \n```", "```py\ndisplay_trace_tree(scf.ct.root) \n```", "```py\nv = scf.fuzz()\nprint(v) \n```", "```py\nA+\n\n```", "```py\nwith ExpectError():\n    with ConcolicTracer() as _:\n        _[cgi_decode](v) \n```", "```py\nscf.add_trace(_, v) \n```", "```py\ndisplay_trace_tree(scf.ct.root) \n```", "```py\nscf = SimpleConcolicFuzzer()\nfor i in range(10):\n    v = scf.fuzz()\n    print(repr(v))\n    if v is None:\n        continue\n    with ConcolicTracer() as _:\n        with ExpectError(print_traceback=False):\n            # z3.StringVal(urllib.parse.unquote('%80')) <-- bug in z3\n            _[cgi_decode](v)\n    scf.add_trace(_, v) \n```", "```py\n' '\n''\n'+'\n'%'\n'+A'\n'++'\n'AB'\n'++A'\n'A%'\n'+AB'\n\n```", "```py\nIndexError: string index out of range (expected)\nIndexError: string index out of range (expected)\n\n```", "```py\ndisplay_trace_tree(scf.ct.root) \n```", "```py\nfrom [InformationFlow](InformationFlow.html) import INVENTORY_GRAMMAR, SQLException \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer \n```", "```py\nclass ConcolicGrammarFuzzer(GrammarFuzzer):\n    def tree_to_string(self, tree):\n        symbol, children, *_ = tree\n        e = ''\n        if children:\n            return e.join([self.tree_to_string(c) for c in children])\n        else:\n            return e if symbol in self.grammar else symbol\n\n    def prune_tree(self, tree, tokens):\n        name, children = tree\n        children = self.coalesce(children)\n        if name in tokens:\n            return (name, [(self.tree_to_string(tree), [])])\n        else:\n            return (name, [self.prune_tree(c, tokens) for c in children])\n\n    def coalesce(self, children):\n        last = ''\n        new_lst = []\n        for cn, cc in children:\n            if cn not in self.grammar:\n                last += cn\n            else:\n                if last:\n                    new_lst.append((last, []))\n                    last = ''\n                new_lst.append((cn, cc))\n        if last:\n            new_lst.append((last, []))\n        return new_lst \n```", "```py\ntgf = ConcolicGrammarFuzzer(INVENTORY_GRAMMAR)\nwhile True:\n    qtree = tgf.fuzz_tree()\n    query = str(tgf.tree_to_string(qtree))\n    if query.startswith('select'):\n        break \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nwith ExpectError():\n    print(repr(query))\n    with ConcolicTracer() as _:\n        res = _[db_select](str(query))\n    print(repr(res)) \n```", "```py\n'select t4(I,N)!=b(k)/O!=(K4(:/Z)) from I7'\n\n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34717/2536269233.py\", line 4, in <module>\n    res = _[db_select](str(query))\n          ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34717/2687284210.py\", line 3, in __call__\n    self.result = self.fn(*self.concolic(args))\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34717/1994573112.py\", line 4, in db_select\n    r = my_db.sql(s)\n        ^^^^^^^^^^^^\n  File \"InformationFlow.ipynb\", line 65, in sql\n    return method(query[len(key):])\n           ^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"InformationFlow.ipynb\", line 84, in do_select\n    _, table = self.table(t_name)\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34717/2474817571.py\", line 6, in table\n    raise SQLException('Table (%s) was not found' % repr(t_name))\nInformationFlow.SQLException: Table ('I7') was not found (expected)\n\n```", "```py\nfor i, p in enumerate(_.path):\n    print(i, p) \n```", "```py\n0 0 == IndexOf(db_select_s_str_1, \"select \", 0)\n1 0 == IndexOf(db_select_s_str_1, \"select \", 0)\n2 Not(0 >\n    IndexOf(str.substr(db_select_s_str_1, 7, 34),\n            \" from \",\n            0))\n3 Not(Or(0 <\n       IndexOf(str.substr(db_select_s_str_1, 7, 34),\n               \" where \",\n               0),\n       0 ==\n       IndexOf(str.substr(db_select_s_str_1, 7, 34),\n               \" where \",\n               0)))\n4 Not(str.substr(str.substr(db_select_s_str_1, 7, 34), 32, 2) ==\n    \"inventory\")\n\n```", "```py\nnew_path = _.path[0:-1] + [z3.Not(_.path[-1])] \n```", "```py\nnew_ = ConcolicTracer((_.decls, new_path))\nnew_.fn = _.fn\nnew_.fn_args = _.fn_args \n```", "```py\nnew_.zeval() \n```", "```py\n('No Solutions', None)\n\n```", "```py\nprint(_.path[-1])\nz3.solve(z3.Not(_.path[-1])) \n```", "```py\nNot(str.substr(str.substr(db_select_s_str_1, 7, 34), 32, 2) ==\n    \"inventory\")\nno solution\n\n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import display_tree \n```", "```py\nprune_tokens = [\n    '<value>', '<table>', '<column>', '<literals>', '<exprs>', '<bexpr>'\n]\ndt = tgf.prune_tree(qtree, prune_tokens)\ndisplay_tree(dt) \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import START_SYMBOL \n```", "```py\ndef span(node, g, node_start=0):\n    hm = {}\n    k, cs = node\n    end_i = node_start\n    new_cs = []\n    for c in cs:\n        chm, (ck, child_start, child_end, gcs) = span(c, g, end_i)\n        new_cs.append((ck, child_start, child_end, gcs))\n        end_i = child_end\n        hm.update(chm)\n    node_end = end_i if cs else node_start + len(k)\n    if k in g and k != START_SYMBOL:\n        hm[k] = (node_start, node_end - node_start)\n    return hm, (k, node_start, node_end, new_cs) \n```", "```py\nspan_hm, _n = span(dt, INVENTORY_GRAMMAR) \n```", "```py\nspan_hm \n```", "```py\n{'<exprs>': (7, 26), '<table>': (39, 2), '<query>': (0, 41)}\n\n```", "```py\nprint(\"query:\", query)\nfor k in span_hm:\n    start, l = span_hm[k]\n    print(k, query[start:start + l]) \n```", "```py\nquery: select t4(I,N)!=b(k)/O!=(K4(:/Z)) from I7\n<exprs> t4(I,N)!=b(k)/O!=(K4(:/Z))\n<table> I7\n<query> select t4(I,N)!=b(k)/O!=(K4(:/Z)) from I7\n\n```", "```py\ndef unwrap_substrings(s):\n    assert s.decl().name() == 'str.substr'\n    cs, frm, l = s.children()\n    fl = frm.as_long()\n    ll = l.as_long()\n    if cs.decl().name() == 'str.substr':\n        newfrm, _l = unwrap_substrings(cs)\n        return (fl + newfrm, ll)\n    else:\n        return (fl, ll) \n```", "```py\ndef traverse_z3(p, hm):\n    def z3_as_string(v):\n        return v.as_string()\n\n    n = p.decl().name()\n    if n == 'not':\n        return traverse_z3(p.children()[0], hm)\n    elif n == '=':\n        i, j = p.children()\n        if isinstance(i, (int, z3.IntNumRef)):\n            return traverse_z3(j, hm)\n        elif isinstance(j, (int, z3.IntNumRef)):\n            return traverse_z3(i, hm)\n        else:\n            if i.is_string() and j.is_string():\n                if i.is_string_value():\n                    cs, frm, l = j.children()\n                    if (isinstance(frm, z3.IntNumRef)\n                            and isinstance(l, z3.IntNumRef)):\n                        hm[z3_as_string(i)] = unwrap_substrings(j)\n                elif j.is_string_value():\n                    cs, frm, l = i.children()\n                    if (isinstance(frm, z3.IntNumRef)\n                            and isinstance(l, z3.IntNumRef)):\n                        hm[z3_as_string(j)] = unwrap_substrings(i)\n            else:\n                assert False  # for now\n    elif n == '<' or n == '>':\n        i, j = p.children()\n        if isinstance(i, (int, z3.IntNumRef)):\n            return traverse_z3(j, hm)\n        elif isinstance(j, (int, z3.IntNumRef)):\n            return traverse_z3(i, hm)\n        else:\n            assert False\n    return p \n```", "```py\ncomparisons: Dict[str, Tuple] = {}\nfor p in _.path:\n    traverse_z3(p, comparisons)\ncomparisons \n```", "```py\n{'inventory': (39, 2)}\n\n```", "```py\ndef find_alternatives(spans, cmp):\n    alts = {}\n    for key in spans:\n        start, l = spans[key]\n        rset = set(range(start, start + l))\n        for ckey in cmp:\n            cstart, cl = cmp[ckey]\n            cset = set(range(cstart, cstart + cl))\n            # if rset.issubset(cset): <- ignoring subsets for now.\n            if rset == cset:\n                if key not in alts:\n                    alts[key] = set()\n                alts[key].add(ckey)\n    return alts \n```", "```py\nalternatives = find_alternatives(span_hm, comparisons)\nalternatives \n```", "```py\n{'<table>': {'inventory'}}\n\n```", "```py\nINVENTORY_GRAMMAR_NEW = dict(INVENTORY_GRAMMAR) \n```", "```py\nfor k in alternatives:\n    INVENTORY_GRAMMAR_NEW[k] = INVENTORY_GRAMMAR_NEW[k] + list(alternatives[k]) \n```", "```py\nINVENTORY_GRAMMAR_NEW['<table>'] \n```", "```py\n['<word>', 'inventory']\n\n```", "```py\ncgf = ConcolicGrammarFuzzer(INVENTORY_GRAMMAR_NEW) \n```", "```py\nfor i in range(10):\n    qtree = cgf.fuzz_tree()\n    query = cgf.tree_to_string(qtree)\n    print(query)\n    with ExpectError(print_traceback=False):\n        try:\n            with ConcolicTracer() as _:\n                res = _[db_select](query)\n            print(repr(res))\n        except SQLException as e:\n            print(e)\n        print() \n```", "```py\ninsert into inventory (i9Oam41gsP2,h97,q8J:.70J) values ('.q')\nColumn ('i9Oam41gsP2') was not found\n\nselect C from wy where R/s/y>_-X-.+C/u==(((---6.5)))\nTable ('wy') was not found\n\nupdate T set I=gj5 where (-8.6/O*.-W)==s-O<Z((R),((N==(:))))\nTable ('T') was not found\n\nupdate inventory set f=o,V=Q6 where l0!=(((((-5)))==(rGJ)))\nColumn ('f') was not found\n\ndelete from j where T==5.58\nTable ('j') was not found\n\ninsert into inventory (py75) values ('R','/','fd8g',3883.0)\nColumn ('py75') was not found\n\nupdate inventory set GY5=X where G-g/z(w)<2.5\nColumn ('GY5') was not found\n\nupdate nb0 set i=K,b=R,u=: where D>A\nTable ('nb0') was not found\n\ninsert into inventory (P,wmE,U,F) values (50,'/',--6.2)\nColumn ('P') was not found\n\ndelete from GTV3_ where :-M!=t>n+R/x+r*a/t-r-V\nTable ('GTV3_') was not found\n\n```", "```py\ngf = GrammarFuzzer(INVENTORY_GRAMMAR)\nfor i in range(10):\n    query = gf.fuzz()\n    print(query)\n    with ExpectError(print_traceback=False):\n        try:\n            res = db_select(query)\n            print(repr(res))\n        except SQLException as e:\n            print(e)\n        print() \n```", "```py\ninsert into UCu4 (E,xM:lOq6,u38p,W54G3b0) values (':',1.835)\nTable ('UCu4') was not found\n\ninsert into B81 (Np) values ('h')\nTable ('B81') was not found\n\ndelete from w where Xn((T))>a(8.8,g)/h+t-P-j+L\nTable ('w') was not found\n\nupdate q75 set L=z4 where ((QUy+N))==A/P-L*ao(R)/I\nTable ('q75') was not found\n\nupdate q3 set x=F where l(N)-P-S+t==e\nTable ('q3') was not found\n\nupdate Dy06rr set h=F where (z!=Q)==(((a<q)))\nTable ('Dy06rr') was not found\n\ndelete from Z where V(7)>a==O(mA,j(g)*:,s,B)-5-eD(c,F!=n)==eO41Xy\nTable ('Z') was not found\n\nselect 1.8 from U3X8p\nTable ('U3X8p') was not found\n\nupdate N set w=X9,A=w,M=Z where ((b!=c))==U/N<I\nTable ('N') was not found\n\ninsert into I1 (g,_Q,y8e0) values (5.7,'.&',05.2)\nTable ('I1') was not found\n\n```", "```py\nclass ConcolicGrammarFuzzer(ConcolicGrammarFuzzer):\n    def prune_tokens(self, tokens):\n        self.prune_tokens = tokens\n\n    def update_grammar(self, trace):\n        self.comparisons = {}\n        for p in trace.path:\n            traverse_z3(p, self.comparisons)\n        alternatives = find_alternatives(self.span_range, self.comparisons)\n        if self.log:\n            print('Alternatives:', alternatives, 'Span:', self.span_range)\n        new_grammar = dict(self.grammar)\n        for k in alternatives:\n            new_grammar[k] = list(set(new_grammar[k] + list(alternatives[k])))\n        self.grammar = new_grammar \n```", "```py\nclass ConcolicGrammarFuzzer(ConcolicGrammarFuzzer):\n    def fuzz(self):\n        qtree = self.fuzz_tree()\n        self.pruned_tree = self.prune_tree(qtree, self.prune_tokens)\n        query = self.tree_to_string(qtree)\n        self.span_range, _n = span(self.pruned_tree, self.grammar)\n        return query \n```", "```py\ninventory = db.db.pop('inventory', None) \n```", "```py\ndb.db['vehicles'] = inventory\ndb.db['months'] = ({\n    'month': int,\n    'name': str\n}, [{\n    'month': i + 1,\n    'name': m\n} for i, m in enumerate([\n    'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct',\n    'nov', 'dec'\n])])\ndb.db \n```", "```py\n{'vehicles': ({'year': int, 'kind': str, 'company': str, 'model': str},\n  [{'year': 1997, 'kind': 'van', 'company': 'Ford', 'model': 'E350'},\n   {'year': 2000, 'kind': 'car', 'company': 'Mercury', 'model': 'Cougar'},\n   {'year': 1999, 'kind': 'car', 'company': 'Chevy', 'model': 'Venture'}]),\n 'months': ({'month': int, 'name': str},\n  [{'month': 1, 'name': 'jan'},\n   {'month': 2, 'name': 'feb'},\n   {'month': 3, 'name': 'mar'},\n   {'month': 4, 'name': 'apr'},\n   {'month': 5, 'name': 'may'},\n   {'month': 6, 'name': 'jun'},\n   {'month': 7, 'name': 'jul'},\n   {'month': 8, 'name': 'aug'},\n   {'month': 9, 'name': 'sep'},\n   {'month': 10, 'name': 'oct'},\n   {'month': 11, 'name': 'nov'},\n   {'month': 12, 'name': 'dec'}])}\n\n```", "```py\ncgf = ConcolicGrammarFuzzer(INVENTORY_GRAMMAR)\ncgf.prune_tokens(prune_tokens)\nfor i in range(10):\n    query = cgf.fuzz()\n    print(query)\n    with ConcolicTracer() as _:\n        with ExpectError(print_traceback=False):\n            try:\n                res = _[db_select](query)\n                print(repr(res))\n            except SQLException as e:\n                print(e)\n        cgf.update_grammar(_)\n        print() \n```", "```py\nselect Qq6L,(X) from LYg0 where ((x<w))!=(A)\nTable ('LYg0') was not found\n\nupdate vehicles set l=b,E=u,v=E,h=I where (N)==W*i*_-x\nColumn ('l') was not found\n\nupdate Xw set h=w,x=w,F=l,U=g where R==j<o\nTable ('Xw') was not found\n\ninsert into months (q) values ('*','u',43.6)\nColumn ('q') was not found\n\nselect y-A-F+x>Q/b+i==j==w!=r,j,d from months\nInvalid WHERE ('(y-A-F+x>Q/b+i==j==w!=r,j,d)')\n\nselect ((J/F-K-M+w*n)),(:<O==(f)) from vehicles\nInvalid WHERE ('(((J/F-K-M+w*n)),(:<O==(f)))')\n\ninsert into months (Ui) values (82)\nColumn ('Ui') was not found\n\ninsert into Zn1 (month) values (5)\nTable ('Zn1') was not found\n\nupdate b set month=t,month=cY,name=p,name=T where S/O==-2\nTable ('b') was not found\n\ndelete from vehicles where (Q)+s(t)-B(n,E)>T/i-E(u)\nInvalid WHERE ('(Q)+s(t)-B(n,E)>T/i-E(u)')\n\n```", "```py\nclass zfloat(float):\n    def __new__(cls, context, zn, v, *args, **kw):\n        return float.__new__(cls, v, *args, **kw) \n```", "```py\nclass zfloat(zfloat):\n    @classmethod\n    def create(cls, context, zn, v=None):\n        return zproxy_create(cls, 'Real', z3.Real, context, zn, v)\n\n    def __init__(self, context, z, v=None):\n        self.z, self.v = z, v\n        self.context = context \n```", "```py\nclass zfloat(zfloat):\n    def _zv(self, o):\n        return (o.z, o.v) if isinstance(o, zfloat) else (z3.RealVal(o), o) \n```", "```py\nclass zfloat(zfloat):\n    def __bool__(self):\n        # force registering boolean condition\n        if self != 0.0:\n            return True\n        return False \n```", "```py\ndef make_float_bool_wrapper(fname, fun, zfun):\n    def proxy(self, other):\n        z, v = self._zv(other)\n        z_ = zfun(self.z, z)\n        v_ = fun(self.v, v)\n        return zbool(self.context, z_, v_)\n\n    return proxy \n```", "```py\nFLOAT_BOOL_OPS = [\n    '__eq__',\n    # '__req__',\n    '__ne__',\n    # '__rne__',\n    '__gt__',\n    '__lt__',\n    '__le__',\n    '__ge__',\n] \n```", "```py\nfor fname in FLOAT_BOOL_OPS:\n    fun = getattr(float, fname)\n    zfun = getattr(z3.ArithRef, fname)\n    setattr(zfloat, fname, make_float_bool_wrapper(fname, fun, zfun)) \n```", "```py\ndef make_float_binary_wrapper(fname, fun, zfun):\n    def proxy(self, other):\n        z, v = self._zv(other)\n        z_ = zfun(self.z, z)\n        v_ = fun(self.v, v)\n        return zfloat(self.context, z_, v_)\n\n    return proxy \n```", "```py\nFLOAT_BINARY_OPS = [\n    '__add__',\n    '__sub__',\n    '__mul__',\n    '__truediv__',\n    # '__div__',\n    '__mod__',\n    # '__divmod__',\n    '__pow__',\n    # '__lshift__',\n    # '__rshift__',\n    # '__and__',\n    # '__xor__',\n    # '__or__',\n    '__radd__',\n    '__rsub__',\n    '__rmul__',\n    '__rtruediv__',\n    # '__rdiv__',\n    '__rmod__',\n    # '__rdivmod__',\n    '__rpow__',\n    # '__rlshift__',\n    # '__rrshift__',\n    # '__rand__',\n    # '__rxor__',\n    # '__ror__',\n] \n```", "```py\nfor fname in FLOAT_BINARY_OPS:\n    fun = getattr(float, fname)\n    zfun = getattr(z3.ArithRef, fname)\n    setattr(zfloat, fname, make_float_binary_wrapper(fname, fun, zfun)) \n```", "```py\nwith ConcolicTracer() as _:\n    za = zfloat.create(_.context, 'float_a', 1.0)\n    zb = zfloat.create(_.context, 'float_b', 0.0)\n    if za * zb:\n        print(1) \n```", "```py\n_.context \n```", "```py\n({'float_a': 'Real', 'float_b': 'Real'}, [Not(float_a*float_b != 0)])\n\n```", "```py\ndef make_int_binary_wrapper(fname, fun, zfun):\n    def proxy(self, other):\n        z, v = self._zv(other)\n        z_ = zfun(self.z, z)\n        v_ = fun(self.v, v)\n        if isinstance(v_, float):\n            return zfloat(self.context, z_, v_)\n        elif isinstance(v_, int):\n            return zint(self.context, z_, v_)\n        else:\n            assert False\n\n    return proxy \n```", "```py\nfor fname in INT_BINARY_OPS:\n    fun = getattr(int, fname)\n    zfun = getattr(z3.ArithRef, fname)\n    setattr(zint, fname, make_int_binary_wrapper(fname, fun, zfun)) \n```", "```py\nwith ConcolicTracer() as _:\n    v = _[binomial](4, 2) \n```", "```py\n_.zeval() \n```", "```py\n('sat', {'n': ('4', 'Int'), 'k': ('2', 'Int')})\n\n```", "```py\ndef make_int_bit_wrapper(fname, fun, zfun):\n    def proxy(self, other):\n        z, v = self._zv(other)\n        z_ = z3.BV2Int(\n            zfun(\n                z3.Int2BV(\n                    self.z, num_bits=64), z3.Int2BV(\n                    z, num_bits=64)))\n        v_ = fun(self.v, v)\n        return zint(self.context, z_, v_)\n\n    return proxy \n```", "```py\nBIT_OPS = [\n    '__lshift__',\n    '__rshift__',\n    '__and__',\n    '__xor__',\n    '__or__',\n    '__rlshift__',\n    '__rrshift__',\n    '__rand__',\n    '__rxor__',\n    '__ror__',\n] \n```", "```py\ndef init_concolic_4():\n    for fname in BIT_OPS:\n        fun = getattr(int, fname)\n        zfun = getattr(z3.BitVecRef, fname)\n        setattr(zint, fname, make_int_bit_wrapper(fname, fun, zfun)) \n```", "```py\nINITIALIZER_LIST.append(init_concolic_4) \n```", "```py\ninit_concolic_4() \n```", "```py\nclass zint(zint):\n    def __invert__(self):\n        return zint(self.context, z3.BV2Int(\n            ~z3.Int2BV(self.z, num_bits=64)), ~self.v) \n```", "```py\ndef my_fn(a, b):\n    o_ = (a | b)\n    a_ = (a & b)\n    if o_ & ~a_:\n        return True\n    else:\n        return False \n```", "```py\nwith ConcolicTracer() as _:\n    print(_[my_fn](2, 1)) \n```", "```py\nTrue\n\n```", "```py\n_.zeval(log=True) \n```", "```py\nPredicates in path:\n0 0 !=\nBV2Int(int2bv(BV2Int(int2bv(my_fn_a_int_1) |\n                     int2bv(my_fn_b_int_2))) &\n       int2bv(BV2Int(~int2bv(BV2Int(int2bv(my_fn_a_int_1) &\n                                    int2bv(my_fn_b_int_2))))))\n\n(declare-const my_fn_a_int_1 Int)\n(declare-const my_fn_b_int_2 Int)\n(assert (let ((a!1 (bvnot (bvor (bvnot ((_ int2bv 64) my_fn_a_int_1))\n                        (bvnot ((_ int2bv 64) my_fn_b_int_2))))))\n(let ((a!2 (bvor (bvnot (bvor ((_ int2bv 64) my_fn_a_int_1)\n                              ((_ int2bv 64) my_fn_b_int_2)))\n                 a!1)))\n  (not (= 0 (bv2int (bvnot a!2)))))))\n(check-sat)\n(get-model)\n\nz3 -t:6000 /var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpi5jlhyxm.smt\nsat\n(\n  (define-fun my_fn_a_int_1 () Int\n    (- 1))\n  (define-fun my_fn_b_int_2 () Int\n    (- 9223372036854775809))\n)\n\n```", "```py\n('sat', {'a': (['-', '1'], 'Int'), 'b': (['-', '9223372036854775809'], 'Int')})\n\n```", "```py\n@incollection{fuzzingbook2024:ConcolicFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Concolic Fuzzing},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/ConcolicFuzzer.html}},\n    note = {Retrieved 2024-11-09 17:07:29+01:00},\n    url = {https://www.fuzzingbook.org/html/ConcolicFuzzer.html},\n    urldate = {2024-11-09 17:07:29+01:00}\n}\n\n```"]