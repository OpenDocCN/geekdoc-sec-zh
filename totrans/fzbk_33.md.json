["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('Nr1xbKj_WRQ') \n```", "```py\n>>> from [fuzzingbook.PythonFuzzer](PythonFuzzer.html) import <identifier> \n```", "```py\n>>> fuzzer = PythonFuzzer()\n>>> print(fuzzer.fuzz())\ndef R():\n    break \n```", "```py\n>>> fuzzer = PythonFuzzer('<While>')\n>>> print(fuzzer.fuzz())\nwhile {set()[set():set():set()]}:\n    C = set()\n    D @= set()\n    break\nelse:\n    return \n```", "```py\n>>> sorted(list(PYTHON_AST_GRAMMAR.keys()))\n['<Assert>',\n '<Assign>',\n '<Attribute>',\n '<AugAssign>',\n '<BinOp>',\n '<BoolOp>',\n '<Break>',\n '<Call>',\n '<Compare>',\n '<Constant>',\n '<Continue>',\n '<Delete>',\n '<Dict>',\n '<EmptySet>',\n '<Expr>',\n '<For>',\n '<FunctionDef>',\n '<If>',\n '<List>',\n '<Module>',\n '<Name>',\n '<Pass>',\n '<Return>',\n '<Set>',\n '<Slice>',\n '<Starred>',\n '<Subscript>',\n '<Tuple>',\n '<UnaryOp>',\n '<While>',\n '<With>',\n '<arg>',\n '<arg_list>',\n '<args>',\n '<args_param>',\n '<arguments>',\n '<bool>',\n '<boolop>',\n '<cmpop>',\n '<cmpop_list>',\n '<cmpops>',\n '<decorator_list_param>',\n '<defaults_param>',\n '<digit>',\n '<digits>',\n '<expr>',\n '<expr_list>',\n '<exprs>',\n '<float>',\n '<func>',\n '<id>',\n '<id_continue>',\n '<id_start>',\n '<identifier>',\n '<integer>',\n '<keyword>',\n '<keyword_list>',\n '<keywords>',\n '<keywords_param>',\n '<kw_defaults_param>',\n '<kwarg>',\n '<kwonlyargs_param>',\n '<lhs_Attribute>',\n '<lhs_List>',\n '<lhs_Name>',\n '<lhs_Starred>',\n '<lhs_Subscript>',\n '<lhs_Tuple>',\n '<lhs_expr>',\n '<lhs_exprs>',\n '<literal>',\n '<mod>',\n '<none>',\n '<nonempty_expr_list>',\n '<nonempty_lhs_expr_list>',\n '<nonempty_stmt_list>',\n '<nonzerodigit>',\n '<not_double_quotes>',\n '<not_single_quotes>',\n '<operator>',\n '<orelse_param>',\n '<posonlyargs_param>',\n '<returns>',\n '<start>',\n '<stmt>',\n '<stmt_list>',\n '<stmts>',\n '<string>',\n '<type_comment>',\n '<type_ignore>',\n '<type_ignore_list>',\n '<type_ignore_param>',\n '<type_ignores>',\n '<unaryop>',\n '<vararg>',\n '<withitem>',\n '<withitem_list>',\n '<withitems>'] \n```", "```py\n>>> python_ast_grammar = convert_ebnf_grammar(PYTHON_AST_GRAMMAR) \n```", "```py\n>>> solver = ISLaSolver(python_ast_grammar, start_symbol='<FunctionDef>') \n```", "```py\n>>> ast_string = str(solver.solve())\n>>> ast_string\n'FunctionDef(name=\\'y\\', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])' \n```", "```py\n>>> from [ast](https://docs.python.org/3/library/ast.html) import *\n>>> abstract_syntax_tree = eval(ast_string) \n```", "```py\n>>> ast.fix_missing_locations(abstract_syntax_tree)\n>>> print(ast.unparse(abstract_syntax_tree))\n@set()\ndef y():\n    return \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [Grammars](Grammars.html) import Grammar\nfrom [Grammars](Grammars.html) import is_valid_grammar, convert_ebnf_grammar, extend_grammar, trim_grammar \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Optional \n```", "```py\nEXPR_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<expr>\"],\n\n    \"<expr>\":\n        [\"<term> + <expr>\", \"<term> - <expr>\", \"<term>\"],\n\n    \"<term>\":\n        [\"<factor> * <term>\", \"<factor> / <term>\", \"<factor>\"],\n\n    \"<factor>\":\n        [\"+<factor>\",\n         \"-<factor>\",\n         \"(<expr>)\",\n         \"<integer>.<integer>\",\n         \"<integer>\"],\n\n    \"<integer>\":\n        [\"<digit><integer>\", \"<digit>\"],\n\n    \"<digit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n} \n```", "```py\nassert is_valid_grammar(EXPR_GRAMMAR) \n```", "```py\nfrom [isla.solver](https://rindphi.github.io/isla/) import ISLaSolver \n```", "```py\nexpr_solver = ISLaSolver(EXPR_GRAMMAR)\nfor _ in range(10):\n    print(expr_solver.solve()) \n```", "```py\n4.3 + 512 / -(7 / 6 - 0 / 9 * 1 * 1) * +8.3 / 7 * 4 / 6\n(4 / 7 + 1) / (4) / 9 / 8 + 4 / (3 + 6 - 7)\n+--(--(-9) * (4 * 7 + (4) + 4) + --(+(3)) - 6 + 0 / 7 + 7)\n(2 * 6 + 0 - 5) * 4 - +1 * (2 - 2) / 8 / 6\n(+-(0 - (1) * 7 / 3)) / ((1 * 3 + 8) + 9 - +1 / --0) - 5 * (-+939.491)\n+2.9 * 0 / 501.19814 / --+--(6.05002)\n+-8.8 / (1) * -+1 + -8 + 9 - 3 / 8 * 6 + 4 * 3 * 5\n(+(8 / 9 - 1 - 7)) + ---06.30 / +4.39\n8786.82 - +01.170 / 9.2 - +(7) + 1 * 9 - 0\n+-6 * 0 / 5 * (-(1.7 * +(-1 / +4.9 * 5 * 1 * 2) + -4.2 + (6 + -5) / (4 * 3 + 4)))\n\n```", "```py\nexpr_solver.check('2 + 2') \n```", "```py\nTrue\n\n```", "```py\nexpr_solver.check('2 +  2') \n```", "```py\nError parsing \"2 +  2\" starting with \"<start>\"\n\n```", "```py\nFalse\n\n```", "```py\nexpr_solver.check('2+2') \n```", "```py\nError parsing \"2+2\" starting with \"<start>\"\n\n```", "```py\nFalse\n\n```", "```py\nexpr_solver.check('2 + 2    # should be 4') \n```", "```py\nError parsing \"2 + 2    # should be 4\" starting with \"<start>\"\n\n```", "```py\nFalse\n\n```", "```py\nexpr_solver.check('2 + \\\\\\n2')  # An expression split over two lines \n```", "```py\nError parsing \"2 + \\\n2\" starting with \"<start>\"\n\n```", "```py\nFalse\n\n```", "```py\ndef main():\n    print(\"Hello, world!\")  # A simple example \n```", "```py\nmain() \n```", "```py\nHello, world!\n\n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nmain_source = inspect.getsource(main)\nprint(main_source) \n```", "```py\ndef main():\n    print(\"Hello, world!\")  # A simple example\n\n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html) \n```", "```py\nmain_tree = ast.parse(main_source) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import show_ast \n```", "```py\nshow_ast(main_tree) \n```", "```py\nprint(ast.dump(main_tree, indent=4)) \n```", "```py\nModule(\n    body=[\n        FunctionDef(\n            name='main',\n            args=arguments(\n                posonlyargs=[],\n                args=[],\n                kwonlyargs=[],\n                kw_defaults=[],\n                defaults=[]),\n            body=[\n                Expr(\n                    value=Call(\n                        func=Name(id='print', ctx=Load()),\n                        args=[\n                            Constant(value='Hello, world!')],\n                        keywords=[]))],\n            decorator_list=[])],\n    type_ignores=[])\n\n```", "```py\nfrom [ast](https://docs.python.org/3/library/ast.html) import * \n```", "```py\nmy_main_tree = Module(\n    body=[\n        FunctionDef(\n            name='main',\n            args=arguments(\n                posonlyargs=[],\n                args=[],\n                kwonlyargs=[],\n                kw_defaults=[],\n                defaults=[]),\n            body=[\n                Expr(\n                    value=Call(\n                        func=Name(id='print', ctx=Load()),\n                        args=[\n                            Constant(value='Hello, world!')],\n                        keywords=[]))],\n            decorator_list=[])],\n    type_ignores=[]) \n```", "```py\nmy_main_tree = fix_missing_locations(my_main_tree)  # required for trees built from constructors\nmy_main_code = compile(my_main_tree, filename='<unknown>', mode='exec') \n```", "```py\ndel main  # This deletes the definition of main() \n```", "```py\nexec(my_main_code)  # This defines main() again from `code` \n```", "```py\nmain() \n```", "```py\nHello, world!\n\n```", "```py\nprint(ast.unparse(my_main_tree)) \n```", "```py\ndef main():\n    print('Hello, world!')\n\n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\nANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH = (string.digits + string.ascii_letters + string.punctuation + ' ').replace('\"', '').replace('\\\\', '')\nANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH = (string.digits + string.ascii_letters + string.punctuation + ' ').replace(\"'\", '').replace('\\\\', '') \n```", "```py\nANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH \n```", "```py\n\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&'()*+,-./:;<=>?@[]^_`{|}~ \"\n\n```", "```py\nANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH \n```", "```py\n'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&()*+,-./:;<=>?@[]^_`{|}~ '\n\n```", "```py\nPYTHON_AST_CONSTANTS_GRAMMAR: Grammar = {\n    '<start>': [ '<expr>' ],\n\n    # Expressions\n    '<expr>': [ '<Constant>', '<Expr>' ],\n    '<Expr>': [ 'Expr(value=<expr>)' ],\n\n    # Constants\n    '<Constant>': [ 'Constant(value=<literal>)' ],\n    '<literal>': [ '<string>', '<integer>', '<float>', '<bool>', '<none>' ],\n\n    # Strings\n    '<string>': [ '\"<not_double_quotes>*\"', \"'<not_single_quotes>*'\" ],\n    '<not_double_quotes>': list(ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH),\n    '<not_single_quotes>': list(ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH),\n    # FIXME: The actual rules for Python strings are also more complex:\n    # https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals\n\n    # Numbers\n    '<integer>': [ '<digit>', '<nonzerodigit><digits>' ],\n    '<float>': [ '<integer>.<integer>' ],\n    '<nonzerodigit>': ['1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    '<digits>': [ '<digit><digits>', '<digit>' ],\n    '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n    # FIXME: There are _many_ more ways to express numbers in Python; see\n    # https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals\n\n    # More\n    '<bool>': [ 'True', 'False' ],\n    '<none>': [ 'None' ],\n\n    # FIXME: Not supported: bytes, format strings, regex strings...\n} \n```", "```py\nassert is_valid_grammar(PYTHON_AST_CONSTANTS_GRAMMAR) \n```", "```py\nconstants_grammar = convert_ebnf_grammar(PYTHON_AST_CONSTANTS_GRAMMAR)\nconstants_solver = ISLaSolver(constants_grammar)\nconstants_tree_str = str(constants_solver.solve())\nprint(constants_tree_str) \n```", "```py\nExpr(value=Constant(value=None))\n\n```", "```py\nconstants_tree = eval(constants_tree_str)\nast.unparse(constants_tree) \n```", "```py\n'None'\n\n```", "```py\ndef test_samples(grammar: Grammar, iterations: int = 10, start_symbol = None, log: bool = True):\n    g = convert_ebnf_grammar(grammar)\n    solver = ISLaSolver(g, start_symbol=start_symbol, max_number_free_instantiations=iterations)\n    for i in range(iterations):\n        tree_str = str(solver.solve())\n        tree = eval(tree_str)\n        ast.fix_missing_locations(tree)\n        if log:\n            code = ast.unparse(tree)\n            print(f'{code:40} # {tree_str}') \n```", "```py\ntest_samples(PYTHON_AST_CONSTANTS_GRAMMAR) \n```", "```py\nFalse                                    # Expr(value=Constant(value=False))\n2                                        # Constant(value=2)\nNone                                     # Constant(value=None)\n'#'                                      # Constant(value=\"#\")\n550.81                                   # Constant(value=550.81)\nTrue                                     # Constant(value=True)\n'.'                                      # Constant(value='.')\n467                                      # Constant(value=467)\n7894                                     # Constant(value=7894)\n263                                      # Constant(value=263)\n\n```", "```py\nsample_constant_code = \"4711\"\nsample_constant_ast = ast.parse(sample_constant_code).body[0]  # get the `Expr` node\nsample_constant_ast_str = ast.dump(sample_constant_ast)\nprint(sample_constant_ast_str) \n```", "```py\nExpr(value=Constant(value=4711))\n\n```", "```py\nconstant_solver = ISLaSolver(constants_grammar)\nconstant_solver.check(sample_constant_ast_str) \n```", "```py\nTrue\n\n```", "```py\nast.unparse(Constant(value=-1)) \n```", "```py\n'-1'\n\n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import quiz \n```", "```py\nprint(ast.dump(ast.parse('-1'))) \n```", "```py\nModule(body=[Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))], type_ignores=[])\n\n```", "```py\nsample_constant_code = \"-1\"\nsample_constant_ast = ast.parse(sample_constant_code).body[0]  # get the `Expr` node\nsample_constant_ast_str = ast.dump(sample_constant_ast)\nconstant_solver = ISLaSolver(constants_grammar)\nconstant_solver.check(sample_constant_ast_str) \n```", "```py\nError parsing \"Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))\" starting with \"<start>\"\n\n```", "```py\nFalse\n\n```", "```py\nprint(ast.dump(ast.parse(\"{ 'a': set() }\"), indent=4)) \n```", "```py\nModule(\n    body=[\n        Expr(\n            value=Dict(\n                keys=[\n                    Constant(value='a')],\n                values=[\n                    Call(\n                        func=Name(id='set', ctx=Load()),\n                        args=[],\n                        keywords=[])]))],\n    type_ignores=[])\n\n```", "```py\nPYTHON_AST_COMPOSITES_GRAMMAR: Grammar = extend_grammar(\n    PYTHON_AST_CONSTANTS_GRAMMAR, {\n    '<expr>': PYTHON_AST_CONSTANTS_GRAMMAR['<expr>'] + [\n        '<Dict>', '<Set>', '<List>', '<Tuple>'\n    ],\n\n    '<Dict>': [ 'Dict(keys=<expr_list>, values=<expr_list>)' ],\n    '<Set>': [ 'Set(elts=<nonempty_expr_list>)', '<EmptySet>' ],\n    '<EmptySet>': [ 'Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])' ],\n    '<List>': [\n        'List(elts=<expr_list>, ctx=Load())',\n        'List(elts=<expr_list>, ctx=Del())',\n    ],\n    '<Tuple>': [\n        'Tuple(elts=<expr_list>, ctx=Load())',\n        'Tuple(elts=<expr_list>, ctx=Del())',\n    ],\n\n    # Lists of expressions\n    '<expr_list>': [ '[<exprs>?]' ],\n    '<nonempty_expr_list>': [ '[<exprs>]' ],\n    '<exprs>': [ '<expr>', '<exprs>, <expr>' ],\n}) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_COMPOSITES_GRAMMAR) \n```", "```py\nfor elt in [ '<Constant>', '<Dict>', '<Set>', '<List>', '<Tuple>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_COMPOSITES_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Constant>\n'c'                                      # Constant(value='c')\n96.7                                     # Constant(value=96.7)\nNone                                     # Constant(value=None)\nFalse                                    # Constant(value=False)\n505                                      # Constant(value=505)\n'U'                                      # Constant(value=\"U\")\nTrue                                     # Constant(value=True)\n41398                                    # Constant(value=41398)\n24                                       # Constant(value=24)\n72                                       # Constant(value=72)\n\n<Dict>\n{}                                       # Dict(keys=[], values=[List(elts=[Dict(keys=[List(elts=[Constant(value=9.63)], ctx=Load())], values=[Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Set(elts=[Constant(value=True), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])], ctx=Load())]), Constant(value=2), Tuple(elts=[Constant(value=''), Constant(value=False), Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), Expr(value=List(elts=[Constant(value=None)], ctx=Load())), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Del())])\n{577: ''}                                # Dict(keys=[Constant(value=577), Constant(value=34), Constant(value=286), Constant(value=7051)], values=[Constant(value=\"\")])\n{90: 14}                                 # Dict(keys=[Constant(value=90)], values=[Constant(value=14), Constant(value=88), Constant(value=435)])\n{\"nF}[ (^{bXBrwzf-P@geW'.]~G>;O2i&/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|<Y6lD+%I\": 'Gym]A&K;70{jJLC\"DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F>_<a}kI2norf9H[T,lXt=w6@Z*1$xs`\"R3'} # Dict(keys=[Constant(value=\"nF}[ (^{bXBrwzf-P@geW'.]~G>;O2i&/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|<Y6lD+%I\")], values=[Constant(value='Gym]A&K;70{jJLC\"DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F>_<a}kI2norf9H[T,lXt=w6@Z*1$xs`\"R3')])\n{}                                       # Dict(keys=[], values=[])\n{}                                       # Dict(keys=[], values=[])\n{}                                       # Dict(keys=[], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=True), Constant(value=687596.53), Dict(keys=[Set(elts=[Expr(value=Set(elts=[Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), Constant(value=34.676)]))])], values=[Set(elts=[Set(elts=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())], ctx=Del())])])]), List(elts=[], ctx=Load())])\n{}                                       # Dict(keys=[], values=[])\n{}                                       # Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], values=[])\n{}                                       # Dict(keys=[Tuple(elts=[], ctx=Del())], values=[])\n\n<Set>\n{\n[], 79.2}                              # Set(elts=[Expr(value=List(elts=[], ctx=Del())), Constant(value=79.2)])\nset()                                    # Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])\n{{{False: [set()], None: []}, (({20: set()},),)}} # Set(elts=[Set(elts=[Dict(keys=[Constant(value=False), Constant(value=None)], values=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), List(elts=[], ctx=Del())]), Tuple(elts=[Tuple(elts=[Dict(keys=[Constant(value=20)], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=True), List(elts=[], ctx=Del())])], ctx=Load())], ctx=Del())])])\n{'Z'}                                    # Set(elts=[Constant(value='Z')])\n{3763, ''}                               # Set(elts=[Constant(value=3763), Constant(value=\"\")])\n{475, 136, 95, 841, 58}                  # Set(elts=[Constant(value=475), Constant(value=136), Constant(value=95), Constant(value=841), Constant(value=58)])\n{\"F3Ye]1UZz&sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ'h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK<9A*#i}yTx>{.\"} # Set(elts=[Constant(value=\"F3Ye]1UZz&sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ'h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK<9A*#i}yTx>{.\")])\n{66, 7}                                  # Set(elts=[Constant(value=66), Constant(value=7)])\n{set(), '', None, '_P[', 'L}w,6'}        # Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=''), Constant(value=None), Constant(value='_P['), Constant(value='L}w,6')])\n{'51I{Ef&u;kThXbRo]cV/8)Q@W>4|=J7lHge\"+^y%(rv<q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY'} # Set(elts=[Constant(value='51I{Ef&u;kThXbRo]cV/8)Q@W>4|=J7lHge\"+^y%(rv<q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY')])\n\n<List>\n[[], {831.3: (7, set(), {('1',)})}]      # List(elts=[List(elts=[], ctx=Load()), Dict(keys=[Constant(value=831.30), Constant(value=None), Expr(value=Tuple(elts=[Constant(value=\"\"), Constant(value=True), Constant(value=False)], ctx=Del()))], values=[Tuple(elts=[Constant(value=7), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Set(elts=[Tuple(elts=[Constant(value='1')], ctx=Load())])], ctx=Load())])], ctx=Del())\n[22]                                     # List(elts=[Constant(value=22)], ctx=Load())\n[64]                                     # List(elts=[Constant(value=64)], ctx=Load())\n[56]                                     # List(elts=[Constant(value=56)], ctx=Del())\n[9589]                                   # List(elts=[Constant(value=9589)], ctx=Load())\n[780]                                    # List(elts=[Constant(value=780)], ctx=Del())\n[164, 47]                                # List(elts=[Constant(value=164), Constant(value=47)], ctx=Load())\n[\"^dG@0 N26zE73qSfX,>xhPlW#j.1cQO4bF+A:LZR'CT=$i_\", 'tJI`]gD_M/8yu!%<n~&H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO'] # List(elts=[Constant(value=\"^dG@0 N26zE73qSfX,>xhPlW#j.1cQO4bF+A:LZR'CT=$i_\"), Constant(value=\"tJI`]gD_M/8yu!%<n~&H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO\")], ctx=Load())\n['e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw\"li|Mq?_UI45$)zNh#gDcs;!-d[,(~{>bYrE<.RQ27}&moSk+vjP=6y9'] # List(elts=[Constant(value='e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw\"li|Mq?_UI45$)zNh#gDcs;!-d[,(~{>bYrE<.RQ27}&moSk+vjP=6y9')], ctx=Load())\n[set(), set()]                           # List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())\n\n<Tuple>\n()                                       # Tuple(elts=[], ctx=Load())\n(set(),)                                 # Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())\n(set(), [], \n1.4, [[None], True], {set(): (False, {set()})}) # Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Del()), Expr(value=Constant(value=1.4)), List(elts=[List(elts=[Constant(value=None)], ctx=Load()), Constant(value=True)], ctx=Load()), Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), Expr(value=Constant(value=False))], values=[Tuple(elts=[Constant(value=False), Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])], ctx=Load())])], ctx=Del())\n('',)                                    # Tuple(elts=[Constant(value=\"\")], ctx=Load())\n(93,)                                    # Tuple(elts=[Constant(value=93)], ctx=Load())\n(28371613, 51, 892, 45, 10678, '')       # Tuple(elts=[Constant(value=28371613), Constant(value=51), Constant(value=892), Constant(value=45), Constant(value=10678), Constant(value='')], ctx=Del())\n(72, 632)                                # Tuple(elts=[Constant(value=72), Constant(value=632)], ctx=Load())\n('p[R#U', '5JRh~3', 'aAI>V+LBk60Ogp')    # Tuple(elts=[Constant(value='p[R#U'), Constant(value=\"5JRh~3\"), Constant(value=\"aAI>V+LBk60Ogp\")], ctx=Load())\n(363,)                                   # Tuple(elts=[Constant(value=363)], ctx=Del())\n('a*wyz!$CcJ.TDj?<8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&B(PbH1_ZInkimvSV4x> u{+2gs)h\"e9NA;76]=E-0;',) # Tuple(elts=[Constant(value='a*wyz!$CcJ.TDj?<8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&B(PbH1_ZInkimvSV4x> u{+2gs)h\"e9NA;76]=E-0;')], ctx=Load())\n\n```", "```py\nprint(ast.unparse(Set(elts=[]))) \n```", "```py\n{*()}\n\n```", "```py\n{*()} \n```", "```py\nset()\n\n```", "```py\nprint(ast.dump(ast.parse(\"2 + 2 is not False\"), indent=4)) \n```", "```py\nModule(\n    body=[\n        Expr(\n            value=Compare(\n                left=BinOp(\n                    left=Constant(value=2),\n                    op=Add(),\n                    right=Constant(value=2)),\n                ops=[\n                    IsNot()],\n                comparators=[\n                    Constant(value=False)]))],\n    type_ignores=[])\n\n```", "```py\nPYTHON_AST_EXPRS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_COMPOSITES_GRAMMAR, {\n    '<expr>': PYTHON_AST_COMPOSITES_GRAMMAR['<expr>'] + [\n        '<BoolOp>', '<BinOp>', '<UnaryOp>', '<Compare>',\n    ],\n\n    # Booleans: and or\n    '<BoolOp>': [ 'BoolOp(op=<boolop>, values=<expr_list>)' ],\n    '<boolop>': [ 'And()', 'Or()' ],\n\n    # Binary operators: + - * ...\n    '<BinOp>': [ 'BinOp(left=<expr>, op=<operator>, right=<expr>)' ],\n    '<operator>': [ 'Add()', 'Sub()', 'Mult()', 'MatMult()',\n                   'Div()', 'Mod()', 'Pow()',\n                   'LShift()', 'RShift()', 'BitOr()', 'BitXor()', 'BitAnd()',\n                   'FloorDiv()' ],\n\n    # Unary operators: not + - ...\n    '<UnaryOp>': [ 'UnaryOp(op=<unaryop>, operand=<expr>)'],\n    '<unaryop>': [ 'Invert()', 'Not()', 'UAdd()', 'USub()' ],\n\n    # Comparisons: == != < <= > >= is in ...\n    '<Compare>': [ 'Compare(left=<expr>, ops=<cmpop_list>, comparators=<expr_list>)'],\n    '<cmpop_list>': [ '[<cmpops>?]' ],\n    '<cmpops>': [ '<cmpop>', '<cmpop>, <cmpops>' ],\n    '<cmpop>': [ 'Eq()', 'NotEq()', 'Lt()', 'LtE()', 'Gt()', 'GtE()',\n                 'Is()', 'IsNot()', 'In()', 'NotIn()' ],\n\n    # FIXME: There's a few more expressions: GeneratorExp, Await, YieldFrom, ...\n}) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_EXPRS_GRAMMAR) \n```", "```py\nfor elt in [ '<BoolOp>', '<BinOp>', '<UnaryOp>', '<Compare>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_EXPRS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<BoolOp>\n() and {-([]) / (set(), set()), {\nTrue: set()}} # BoolOp(op=And(), values=[BoolOp(op=Or(), values=[]), Set(elts=[BinOp(left=UnaryOp(op=USub(), operand=Compare(left=List(elts=[], ctx=Del()), ops=[], comparators=[])), op=Div(), right=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())), Dict(keys=[Expr(value=Constant(value=True))], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Load())])])])\n(set(), set(), set() @ set() | set() + set()) and set() ** (set() ^ set()) * set() # BoolOp(op=And(), values=[Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitOr(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))], ctx=Del()), BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nset() % (set() >> set()) - (set() << set()) or set() & set() # BoolOp(op=Or(), values=[BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Sub(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n'8' or 6                                 # BoolOp(op=Or(), values=[Constant(value='8'), Constant(value=6)])\n~+123.95                                 # BoolOp(op=Or(), values=[UnaryOp(op=Invert(), operand=UnaryOp(op=UAdd(), operand=Constant(value=123.95)))])\nnot False // None                        # BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=BinOp(left=Constant(value=False), op=FloorDiv(), right=Constant(value=None)))])\n'S' and 6180 in 397494                   # BoolOp(op=And(), values=[Constant(value=\"S\"), Compare(left=Constant(value=6180), ops=[In()], comparators=[Constant(value=397494)])])\n41                                       # BoolOp(op=And(), values=[Constant(value=41)])\n214                                      # BoolOp(op=Or(), values=[Constant(value=214)])\n5818 and \"N1qoR6ak 2UJTWyh>!B)/#YKe0]=w{E.-Q`F[5'&^9cA~<V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT\" and 70 and 884 # BoolOp(op=And(), values=[Constant(value=5818), Constant(value=\"N1qoR6ak 2UJTWyh>!B)/#YKe0]=w{E.-Q`F[5'&^9cA~<V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT\"), Constant(value=70), Constant(value=884)])\n\n<BinOp>\n{} - 33                                  # BinOp(left=Expr(value=Dict(keys=[], values=[Tuple(elts=[UnaryOp(op=Invert(), operand=List(elts=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), Tuple(elts=[], ctx=Del()), BoolOp(op=And(), values=[Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load())])], ctx=Del())), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]))], ctx=Del())])), op=Sub(), right=Constant(value=33))\nset() / (set() << set()) * (set() >> set()) // (set() @ set() & set()) # BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Mult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=FloorDiv(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))\nNone ^ False                             # BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))\n-'' + +7719.5                            # BinOp(left=UnaryOp(op=USub(), operand=Constant(value=\"\")), op=Add(), right=UnaryOp(op=UAdd(), operand=Constant(value=7719.5)))\n(set() or 906) >> ('F') | (not (True)) % ((set() and set()) << False) # BinOp(left=BinOp(left=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Constant(value=906)]), op=RShift(), right=BoolOp(op=Or(), values=[Constant(value='F')])), op=BitOr(), right=BinOp(left=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Constant(value=True)])), op=Mod(), right=BinOp(left=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])]), op=LShift(), right=Constant(value=False))))\n((set()) > None != set()) | ((set()))    # BinOp(left=Compare(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Gt(), NotEq()], comparators=[Constant(value=None), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), op=BitOr(), right=Compare(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[Constant(value=True)]))\n524 - 188                                # BinOp(left=Constant(value=524), op=Sub(), right=Constant(value=188))\n6214 / 81                                # BinOp(left=Constant(value=6214), op=Div(), right=Constant(value=81))\n26 / 43                                  # BinOp(left=Constant(value=26), op=Div(), right=Constant(value=43))\n\"s85;3Rw?ST!NI]_-eJ(x7'kG|z}C^&fWLnY[Z,rV*Qj.`Ed%:4<t\" ^ '/$ao6 U{2cim@hHtF>b+vX)KBg1l=qyMDp~O0#A9uPa+l' # BinOp(left=Constant(value=\"s85;3Rw?ST!NI]_-eJ(x7'kG|z}C^&fWLnY[Z,rV*Qj.`Ed%:4<t\"), op=BitXor(), right=Constant(value=\"/$ao6 U{2cim@hHtF>b+vX)KBg1l=qyMDp~O0#A9uPa+l\"))\n\n<UnaryOp>\n+(set(), \n[])                            # UnaryOp(op=UAdd(), operand=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Expr(value=List(elts=[], ctx=Del()))], ctx=Del()))\n~(None)                                  # UnaryOp(op=Invert(), operand=BoolOp(op=Or(), values=[Constant(value=None)]))\n-(((not {set(), set()})) & {set(): set(), (): set()}) # UnaryOp(op=USub(), operand=BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), op=BitAnd(), right=Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())])))\n-((set() + set()) % ((set() << set()) / (set() ^ set()))) ** (set() // set() >> set() * set()) # UnaryOp(op=USub(), operand=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))), op=Pow(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))))\n-True                                    # UnaryOp(op=USub(), operand=Constant(value=True))\n+(4.3 @ (823 - '&') | '')                # UnaryOp(op=UAdd(), operand=BinOp(left=BinOp(left=Constant(value=4.30), op=MatMult(), right=BinOp(left=Constant(value=823), op=Sub(), right=Constant(value='&'))), op=BitOr(), right=Constant(value=\"\")))\n~(False <= 51 not in 959)                # UnaryOp(op=Invert(), operand=BoolOp(op=And(), values=[Compare(left=Constant(value=False), ops=[LtE(), NotIn()], comparators=[Constant(value=51), Constant(value=959)])]))\n~17                                      # UnaryOp(op=Invert(), operand=Constant(value=17))\nnot 26                                   # UnaryOp(op=Not(), operand=Constant(value=26))\n-68                                      # UnaryOp(op=USub(), operand=Constant(value=68))\n\n<Compare>\n()                                       # Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[Expr(value=Constant(value=8)), Tuple(elts=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], values=[]), Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Del())]), UnaryOp(op=UAdd(), operand=BinOp(left=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), op=Add(), right=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())))], ctx=Del())])\n(set() & set()) / (set() @ (set() - set())) not in set() ^ set() # Compare(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))), ops=[NotIn()], comparators=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nset() % set() // None << (set() - set() >> set() ** set()) <= set() | set() > set() + set() # Compare(left=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Constant(value=None)), op=LShift(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))), ops=[LtE(), Gt()], comparators=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Constant(value=True)])\n-632.86 != (not ~(not ('')))             # Compare(left=UnaryOp(op=USub(), operand=Constant(value=632.860)), ops=[NotEq()], comparators=[UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Constant(value='')]))))])\n'' >= 717 is not False                   # Compare(left=Constant(value=\"\"), ops=[GtE(), IsNot(), Eq()], comparators=[Constant(value=717), Constant(value=False)])\n15 < 39                                  # Compare(left=Constant(value=15), ops=[Lt(), Is(), Gt(), In()], comparators=[Constant(value=39)])\n548 != 934688                            # Compare(left=Constant(value=548), ops=[NotEq(), LtE()], comparators=[Constant(value=934688)])\n\"w-xSGA8TI{%pRcq6e!_E:}P]9LM/&b1+7*lBDnvu)[o`3dY|Oj~JU<#Z'rH;g,f>@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ \" in 425 # Compare(left=Constant(value=\"w-xSGA8TI{%pRcq6e!_E:}P]9LM/&b1+7*lBDnvu)[o`3dY|Oj~JU<#Z'rH;g,f>@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ \"), ops=[In()], comparators=[Constant(value=425), Constant(value=21270)])\n'H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf& E`uG}w?PY:' >= 'nCALds|1zjq4BZ$\"ab*@_(e<!rT=iUW~05+,Q>oNSxRVpF' # Compare(left=Constant(value='H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf& E`uG}w?PY:'), ops=[GtE(), Gt(), NotIn(), IsNot(), GtE()], comparators=[Constant(value='nCALds|1zjq4BZ$\"ab*@_(e<!rT=iUW~05+,Q>oNSxRVpF')])\n6.3                                      # Compare(left=Constant(value=6.3), ops=[], comparators=[])\n\n```", "```py\nexpr_iterations = 20\nbad_syntax = 0\nbad_type = 0\nast_exprs_grammar = convert_ebnf_grammar(PYTHON_AST_EXPRS_GRAMMAR)\nexpr_solver = ISLaSolver(ast_exprs_grammar, max_number_free_instantiations=expr_iterations)\nfor i in range(expr_iterations):\n    expr_tree = eval(str(expr_solver.solve()))\n    expr_tree = fix_missing_locations(expr_tree)\n    expr_str = ast.unparse(expr_tree)\n    print(i, expr_str)\n    try:\n        ...  # insert parsing code here\n    except SyntaxError:\n        bad_syntax += 1\n    except TypeError:\n        bad_type += 1\n\n    try:\n        ...  # <-- insert evaluation code here\n    except TypeError:\n        bad_type += 1\n    except SyntaxError:\n        bad_syntax += 1\n\nprint(f\"Bad syntax: {bad_syntax}/{expr_iterations}\")\nprint(f\"Bad type: {bad_type}/{expr_iterations}\") \n```", "```py\n0 set()\n1 \n2 [\n~(False,) >> {635: (set() @ set() & set(),), 99.1 not in set() ** set(): {[set() ^ set()]}}]\n3 (set() * set() - (set() + set())) / ((set() ^ set()) % set() | set() << set() % set())\n4 not None\n5 -+(True and '#' and 'x')\n6 (8876 > 46 in 36 != 50)\n7 24\n8 \"LfDW-kSM|tpB&+V*RgQ7U]3xq)zh~n^`wTdie5jvPN: A2K?$ZGJ(X;%@sr9mcIu!}OC/1><b=y'0H8o_.4lFYa{6[,>E?\"\n9 'o,awXihgeM[581Bln\"RA60^k2N_L=d$C`7U~f)(&ZG]#m+DqF|PjpIQ<.4ur@ T!-W}Vs:Y{*zOEJb3StHK>?y%c/;iv9'\n10 ((set()) < set() is set()) >= ((set()))\n11 ((set())) == ((set()) <= set())\n12 \n13 \n14 set()\n15 set()\n16 []\n17 \n18 ((() or 'k5'))\n19 () | []\nBad syntax: 0/20\nBad type: 0/20\n\n```", "```py\nID_START = string.ascii_letters + '_'\nID_CONTINUE = ID_START + string.digits \n```", "```py\nID_CONTINUE \n```", "```py\n'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'\n\n```", "```py\nprint(ast.dump(ast.parse(\"xyzzy(a, b=c)\"), indent=4)) \n```", "```py\nModule(\n    body=[\n        Expr(\n            value=Call(\n                func=Name(id='xyzzy', ctx=Load()),\n                args=[\n                    Name(id='a', ctx=Load())],\n                keywords=[\n                    keyword(\n                        arg='b',\n                        value=Name(id='c', ctx=Load()))]))],\n    type_ignores=[])\n\n```", "```py\nPYTHON_AST_IDS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_EXPRS_GRAMMAR, {\n    '<expr>': PYTHON_AST_EXPRS_GRAMMAR['<expr>'] + [\n        '<Name>', '<Call>'\n    ],\n\n    # Identifiers\n    '<Name>': [\n        'Name(id=<identifier>, ctx=Load())',\n        'Name(id=<identifier>, ctx=Del())'\n    ],\n    '<identifier>': [ \"'<id>'\" ],\n    '<id>': [ '<id_start><id_continue>*' ],\n    '<id_start>': list(ID_START),\n    '<id_continue>': list(ID_CONTINUE),\n    # FIXME: Actual rules are a bit more complex; see\n    # https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n\n    # Function Calls\n    '<Call>': [ 'Call(func=<func><args_param><keywords_param>)' ],\n    '<args_param>': [ ', args=<expr_list>' ],\n    '<keywords_param>': [ ', keywords=<keyword_list>' ],\n    '<func>': [ '<expr>' ],  # Actually <Expr>, but this is more readable and parses 90%\n    '<keyword_list>': [ '[<keywords>?]' ],\n    '<keywords>': [ '<keyword>', '<keyword>, <keywords>' ],\n    '<keyword>': [ 'keyword(arg=<identifier>, value=<expr>)' ]\n}) \n```", "```py\n# do import this unconditionally\nif sys.version_info >= (3, 13):\n    PYTHON_AST_IDS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_IDS_GRAMMAR, {\n        # As of 3.13, args and keywords parameters are optional\n        '<Call>': [ 'Call(func=<func><args_param>?<keywords_param>?)' ],\n    }) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_IDS_GRAMMAR) \n```", "```py\nfor elt in [ '<Name>', '<Call>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_IDS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Name>\nn                                        # Name(id='n', ctx=Load())\nvmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz # Name(id='vmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz', ctx=Del())\nh                                        # Name(id='h', ctx=Load())\nL                                        # Name(id='L', ctx=Del())\nM                                        # Name(id='M', ctx=Load())\ng                                        # Name(id='g', ctx=Del())\nP                                        # Name(id='P', ctx=Del())\nIt                                       # Name(id='It', ctx=Del())\njGn7g                                    # Name(id='jGn7g', ctx=Load())\npsj                                      # Name(id='psj', ctx=Del())\n\n<Call>\n{{set(): set()}(+set())}(m7K, (), u=[set() // set()]) # Call(func=Set(elts=[Call(func=Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), args=[UnaryOp(op=UAdd(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], keywords=[])]), args=[Name(id='m7K', ctx=Del()), Tuple(elts=[], ctx=Load())], keywords=[keyword(arg='u', value=List(elts=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load()))])\n(())(set(), None, \nU, j=False, i=set())  # Call(func=Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[BoolOp(op=And(), values=[])]), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=None), Expr(value=Name(id='U', ctx=Load()))], keywords=[keyword(arg='j', value=Constant(value=False)), keyword(arg='i', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n[set(), set(), set()](set(), (set(),), T=set(), L=set(), y=set()) # Call(func=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())], keywords=[keyword(arg='T', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='L', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='y', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n(set() - set() ** set() % (set() @ set()))(set() * set(), set() << set(), W=set() / set()) # Call(func=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))), args=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='W', value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))])\n(set() >> set())((set() | set()) ^ set(), g=set() & set(), B=set() + set()) # Call(func=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), args=[BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='g', value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), keyword(arg='B', value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))])\n''(-(not 48.9), Q=~70, FmD=True, h=set()) # Call(func=Constant(value=''), args=[UnaryOp(op=USub(), operand=UnaryOp(op=Not(), operand=Constant(value=48.9)))], keywords=[keyword(arg='Q', value=UnaryOp(op=Invert(), operand=Constant(value=70))), keyword(arg='FmD', value=Constant(value=True)), keyword(arg='h', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n((set() in set()) > set())(None, v=set()) # Call(func=Compare(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), ops=[Gt()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), args=[Compare(left=Constant(value=None), ops=[], comparators=[])], keywords=[keyword(arg='v', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n''(set(), V, l, t, _, zM=H)              # Call(func=Constant(value=\"\"), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Name(id='V', ctx=Load()), Name(id='l', ctx=Load()), Name(id='t', ctx=Del()), Name(id='_', ctx=Load())], keywords=[keyword(arg='zM', value=Name(id='H', ctx=Load()))])\nxTzqJe5gQ(n80d, qkw=b)                   # Call(func=Name(id='xTzqJe5gQ', ctx=Del()), args=[Name(id='n80d', ctx=Load())], keywords=[keyword(arg='qkw', value=Name(id='b', ctx=Del()))])\nk(set(), set(), set(), E, o=c)           # Call(func=Name(id='k', ctx=Load()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Name(id='E', ctx=Load())], keywords=[keyword(arg='o', value=Name(id='c', ctx=Load()))])\n\n```", "```py\nast_ids_grammar = convert_ebnf_grammar(PYTHON_AST_IDS_GRAMMAR) \n```", "```py\nid_solver = ISLaSolver(ast_ids_grammar, start_symbol='<id>')\nassert id_solver.check('open') \n```", "```py\nname_solver = ISLaSolver(ast_ids_grammar)\nassert name_solver.check(\"Name(id='open', ctx=Load())\") \n```", "```py\ncall_solver = ISLaSolver(ast_ids_grammar, start_symbol='<keyword_list>')\nassert call_solver.check('[]') \n```", "```py\ncall_str = ast.dump(ast.parse('open(\"foo.txt\", \"r\")').body[0].value)\nprint(call_str)\ncall_solver = ISLaSolver(ast_ids_grammar)\nassert call_solver.check(call_str) \n```", "```py\nCall(func=Name(id='open', ctx=Load()), args=[Constant(value='foo.txt'), Constant(value='r')], keywords=[])\n\n```", "```py\nprint(ast.dump(ast.parse(\"a[b].c\"), indent=4)) \n```", "```py\nModule(\n    body=[\n        Expr(\n            value=Attribute(\n                value=Subscript(\n                    value=Name(id='a', ctx=Load()),\n                    slice=Name(id='b', ctx=Load()),\n                    ctx=Load()),\n                attr='c',\n                ctx=Load()))],\n    type_ignores=[])\n\n```", "```py\nPYTHON_AST_ATTRS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_IDS_GRAMMAR, {\n    '<expr>': PYTHON_AST_IDS_GRAMMAR['<expr>'] + [\n        '<Attribute>', '<Subscript>', '<Starred>',\n    ],\n\n    # Attributes\n    '<Attribute>': [\n        'Attribute(value=<expr>, attr=<identifier>, ctx=Load())',\n        'Attribute(value=<expr>, attr=<identifier>, ctx=Del())',\n    ],\n\n    # Subscripts\n    '<Subscript>': [\n        'Subscript(value=<expr>, slice=<Slice>, ctx=Load())',\n        'Subscript(value=<expr>, slice=<Slice>, ctx=Del())',\n    ],\n    '<Slice>': [\n        'Slice()',\n        'Slice(<expr>)',\n        'Slice(<expr>, <expr>)',\n        'Slice(<expr>, <expr>, <expr>)',\n    ],\n\n    # Starred\n    '<Starred>': [\n        'Starred(value=<expr>, ctx=Load())',\n        'Starred(value=<expr>, ctx=Del())',\n    ],\n\n    # We're extending the set of callers a bit\n    '<func>': [ '<Name>', '<Attribute>', '<Subscript>' ],\n}) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_ATTRS_GRAMMAR) \n```", "```py\nfor elt in [ '<Attribute>', '<Subscript>', '<Starred>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_ATTRS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Attribute>\n{}.zZ                                    # Attribute(value=Dict(keys=[BoolOp(op=Or(), values=[Expr(value=UnaryOp(op=UAdd(), operand=Call(func=Name(id='e', ctx=Del()), args=[], keywords=[]))), BinOp(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]), Starred(value=Attribute(value=Tuple(elts=[Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())])], ctx=Load()), attr='HV', ctx=Load()), ctx=Del())], values=[]), attr='zZ', ctx=Del())\nOON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp._Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP # Attribute(value=Name(id='OON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp', ctx=Load()), attr='_Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP', ctx=Del())\n175 .M                                   # Attribute(value=Constant(value=175), attr='M', ctx=Del())\n*[set() * set() + set() / set()][(set() << set(), set() % set(), set() ** (set() & set())):].Wn # Attribute(value=Starred(value=Subscript(value=List(elts=[BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Add(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))], ctx=Load()), slice=Slice(Tuple(elts=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))], ctx=Del())), ctx=Load()), ctx=Load()), attr='Wn', ctx=Del())\n((-+set()[:]()[set():set():set()] | (not ~set().E())) @ '' // (None ^ False)).B # Attribute(value=BinOp(left=BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Del()))), op=BitOr(), right=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='E', ctx=Del()), args=[], keywords=[])))), op=MatMult(), right=Constant(value='')), op=FloorDiv(), right=BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))), attr='B', ctx=Load())\n((99.8) >> (True)['HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK<{c~*3}f$OandqF1%&4IJ\"MjZ>^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z':'S']).yM # Attribute(value=BinOp(left=BoolOp(op=And(), values=[Constant(value=99.8)]), op=RShift(), right=Subscript(value=BoolOp(op=And(), values=[Constant(value=True)]), slice=Slice(Constant(value='HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK<{c~*3}f$OandqF1%&4IJ\"MjZ>^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z'), Constant(value=\"S\")), ctx=Del())), attr='yM', ctx=Del())\n(((set()) < set() == set()) not in set()).l # Attribute(value=Compare(left=Compare(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Lt(), Eq()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), ops=[NotIn()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id='c', ctx=Del())]), attr='l', ctx=Del())\nvlL.CZ                                   # Attribute(value=Name(id='vlL', ctx=Load()), attr='CZ', ctx=Del())\nw.nyuCk                                  # Attribute(value=Name(id='w', ctx=Del()), attr='nyuCk', ctx=Load())\nJs.Za                                    # Attribute(value=Name(id='Js', ctx=Load()), attr='Za', ctx=Load())\n\n<Subscript>\n{279.0 >> [], -*set()[:][:](set(), set(), ())}[{}:] # Subscript(value=Set(elts=[BinOp(left=Constant(value=279.0), op=RShift(), right=List(elts=[BoolOp(op=And(), values=[])], ctx=Del())), UnaryOp(op=USub(), operand=Call(func=Subscript(value=Subscript(value=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(), ctx=Del()), slice=Slice(), ctx=Load()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], keywords=[]))]), slice=Slice(Dict(keys=[], values=[Name(id='U', ctx=Load())])), ctx=Del())\n(set()).y[():b:\nset()]                   # Subscript(value=Attribute(value=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), attr='y', ctx=Load()), slice=Slice(Tuple(elts=[], ctx=Del()), Name(id='b', ctx=Del()), Expr(value=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]))), ctx=Del())\n(set() << set() - set()).c[[set() @ set() // set()]:*(set() & set()).z] # Subscript(value=Attribute(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), attr='c', ctx=Load()), slice=Slice(List(elts=[BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load()), Starred(value=Attribute(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), attr='z', ctx=Del()), ctx=Del())), ctx=Load())\n((set() | set()) ^ set() ** set())[set() * set():(set() + set()) / set()] # Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Load())\nNone['t':]                               # Subscript(value=Constant(value=None), slice=Slice(Constant(value=\"t\")), ctx=Load())\n(not set().H(~set(), N=set()))[M():n():set()] # Subscript(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='H', ctx=Del()), args=[UnaryOp(op=Invert(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='N', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])), slice=Slice(Call(func=Name(id='M', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='n', ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Del())\nFalse[1632:]                             # Subscript(value=Constant(value=False), slice=Slice(Constant(value=1632)), ctx=Del())\n(('') % +(94 or True))[True or ((t)) is set() <= Q:] # Subscript(value=BinOp(left=BoolOp(op=Or(), values=[Constant(value='')]), op=Mod(), right=UnaryOp(op=UAdd(), operand=BoolOp(op=Or(), values=[Constant(value=94), Constant(value=True)]))), slice=Slice(BoolOp(op=Or(), values=[Constant(value=True), Compare(left=Compare(left=Compare(left=Name(id='t', ctx=Load()), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), ops=[Is(), LtE()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Name(id='Q', ctx=Load()), Name(id='r', ctx=Del())])])), ctx=Load())\nl7oUAETh5yCvxmRcgJ8[vtk3XeH:midn6Wa4]    # Subscript(value=Name(id='l7oUAETh5yCvxmRcgJ8', ctx=Load()), slice=Slice(Name(id='vtk3XeH', ctx=Load()), Name(id='midn6Wa4', ctx=Load())), ctx=Load())\nJN0GQSzfYw1MLI2up6[gD9VZbsK_lqjrPOFB:]   # Subscript(value=Name(id='JN0GQSzfYw1MLI2up6', ctx=Load()), slice=Slice(Name(id='gD9VZbsK_lqjrPOFB', ctx=Del())), ctx=Load())\n\n<Starred>\n*[]                                      # Starred(value=List(elts=[], ctx=Del()), ctx=Load())\n*(\n{{set().j(K.J, Q=set()): (+*(set())[set():set():set()],)}, 440.7}) >> i # Starred(value=BinOp(left=BoolOp(op=And(), values=[Expr(value=Set(elts=[Dict(keys=[Call(func=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='j', ctx=Del()), args=[Attribute(value=Name(id='K', ctx=Del()), attr='J', ctx=Load())], keywords=[keyword(arg='Q', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])], values=[Tuple(elts=[UnaryOp(op=UAdd(), operand=Starred(value=Subscript(value=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Load()), ctx=Load()))], ctx=Del())]), Constant(value=440.7)]))]), op=RShift(), right=Name(id='i', ctx=Load())), ctx=Del())\n*[set(), set(), set() @ set()][(set(), set() - set(), set() % set() / set() ** set()):] # Starred(value=Subscript(value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load()), slice=Slice(Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))], ctx=Load())), ctx=Del()), ctx=Load())\n*(set() ^ set()) & (set() << set()) + set() | set() * set() # Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=BitOr(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Del())\n*'g'                                     # Starred(value=Constant(value='g'), ctx=Load())\n*-None                                   # Starred(value=UnaryOp(op=USub(), operand=Constant(value=None)), ctx=Del())\n*9523[:](set(), -set(), not ~set(), (not not set())[-(set() // set()):]) # Starred(value=Call(func=Subscript(value=Constant(value=9523), slice=Slice(), ctx=Del()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), UnaryOp(op=USub(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Not(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), slice=Slice(UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), BoolOp(op=Or(), values=[])), ctx=Load())], keywords=[]), ctx=Del())\n*False                                   # Starred(value=Constant(value=False), ctx=Load())\n*X(Y(q=set()), I=U(), D=set())           # Starred(value=Call(func=Name(id='X', ctx=Load()), args=[Call(func=Name(id='Y', ctx=Load()), args=[], keywords=[keyword(arg='q', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])], keywords=[keyword(arg='I', value=Call(func=Name(id='U', ctx=Load()), args=[], keywords=[])), keyword(arg='D', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]), ctx=Del())\n*'#'                                     # Starred(value=Constant(value=\"#\"), ctx=Del())\n\n```", "```py\nPYTHON_AST_ASSIGNMENTS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_ATTRS_GRAMMAR, {\n    '<start>': [ '<stmt>' ],\n\n    '<stmt>': [\n        '<Assign>', '<AugAssign>',\n        '<Expr>'\n    ],\n\n    # Assignments\n    '<Assign>': [\n        'Assign(targets=<nonempty_lhs_expr_list>, value=<expr><type_comment>?)',\n    ],\n    '<type_comment>': [ ', type_comment=<string>' ],\n    '<AugAssign>': [\n        'AugAssign(target=<lhs_expr>, op=<operator>, value=<expr>)',\n    ],\n\n    # Lists of left-hand side expressions\n    # '<lhs_expr_list>': [ '[<lhs_exprs>?]' ],\n    '<nonempty_lhs_expr_list>': [ '[<lhs_exprs>]' ],\n    '<lhs_exprs>': [ '<lhs_expr>', '<lhs_exprs>, <lhs_expr>' ],\n\n    # On the left-hand side of assignments, we allow a number of structures\n    '<lhs_expr>': [\n        '<lhs_Name>',  # Most common\n        '<lhs_List>', '<lhs_Tuple>',\n        '<lhs_Attribute>',\n        '<lhs_Subscript>',\n        '<lhs_Starred>',\n    ],\n\n    '<lhs_Name>': [ 'Name(id=<identifier>, ctx=Store())', ],\n\n    '<lhs_List>': [\n        'List(elts=<nonempty_lhs_expr_list>, ctx=Store())',\n    ],\n    '<lhs_Tuple>': [\n        'Tuple(elts=<nonempty_lhs_expr_list>, ctx=Store())',\n    ],\n    '<lhs_Attribute>': [\n        'Attribute(value=<lhs_expr>, attr=<identifier>, ctx=Store())',\n    ],\n    '<lhs_Subscript>': [\n        'Subscript(value=<lhs_expr>, slice=<Slice>, ctx=Store())',\n    ],\n    '<lhs_Starred>': [\n        'Starred(value=<lhs_expr>, ctx=Store())',\n    ],\n}) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_ASSIGNMENTS_GRAMMAR) \n```", "```py\nfor elt in ['<Assign>', '<AugAssign>']:\n    print(elt)\n    test_samples(PYTHON_AST_ASSIGNMENTS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Assign>\n*[(r,), (V, C[set():set()]), Z[set():].WDY3i] = () # type: * # Assign(targets=[Starred(value=List(elts=[Tuple(elts=[Name(id='r', ctx=Store())], ctx=Store()), Tuple(elts=[Name(id='V', ctx=Store()), Subscript(value=Name(id='C', ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], ctx=Store()), Attribute(value=Subscript(value=Name(id='Z', ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), attr='WDY3i', ctx=Store())], ctx=Store()), ctx=Store())], value=Tuple(elts=[], ctx=Load()), type_comment='*')\nh[set():set():set()][set():*set():set()[:]()][:] = [set()].Yzt # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='h', ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Load()), Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(), ctx=Store())], value=Attribute(value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), attr='Yzt', ctx=Load()))\nN[:][:][set():set():set()][{}:][:] = \nExcXjv1h # type: R # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='N', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Dict(keys=[], values=[])), ctx=Store()), slice=Slice(BoolOp(op=Or(), values=[])), ctx=Store())], value=Expr(value=Name(id='ExcXjv1h', ctx=Del())), type_comment=\"R\")\nH[:][:][set():set():set()] = -set() # type: y{ # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='H', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=UnaryOp(op=USub(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), type_comment='y{')\nK[:][:] = a[:][set():set()] = False # type: USsF # Assign(targets=[Subscript(value=Subscript(value=Name(id='K', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='a', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Constant(value=False), type_comment=\"USsF\")\nB[set():set()] = set()[:] << (set()[:]) # type: K # Assign(targets=[Subscript(value=Name(id='B', ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), op=LShift(), right=Compare(left=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[])), type_comment='K')\nsKC = fm = (*set().y, *{set()}) # type: L^}3QF # Assign(targets=[Name(id='sKC', ctx=Store()), Name(id='fm', ctx=Store())], value=Tuple(elts=[Starred(value=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='y', ctx=Del()), ctx=Del()), Starred(value=Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), ctx=Load())], ctx=Del()), type_comment='L^}3QF')\nS = n = I = [set(), set(), F] # type: 8-h # Assign(targets=[Name(id='S', ctx=Store()), Name(id='n', ctx=Store()), Name(id='I', ctx=Store())], value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Name(id='F', ctx=Load())], ctx=Load()), type_comment=\"8-h\")\ngy = set() % set() @ set() - (set() & set()) # type: .~ # Assign(targets=[Name(id='gy', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), type_comment=\".~\")\ncnoOWRu = set() * (set() >> set() ^ set() + set()) # type: ['Ox# # Assign(targets=[Name(id='cnoOWRu', ctx=Store())], value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))), type_comment=\"['Ox#\")\n\n<AugAssign>\nK <<= set()                              # AugAssign(target=Name(id='K', ctx=Store()), op=LShift(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))\n(_, [A]).H ^= (*{}.a[set() | set():set():], False) # AugAssign(target=Attribute(value=Tuple(elts=[Name(id='_', ctx=Store()), List(elts=[Name(id='A', ctx=Store())], ctx=Store())], ctx=Store()), attr='H', ctx=Store()), op=BitXor(), value=Tuple(elts=[Subscript(value=Attribute(value=Starred(value=Dict(keys=[], values=[]), ctx=Del()), attr='a', ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BoolOp(op=Or(), values=[])), ctx=Load()), Constant(value=False)], ctx=Load()))\n*i[:][:][y():set()] -= [~(\nset())]       # AugAssign(target=Subscript(value=Starred(value=Subscript(value=Subscript(value=Name(id='i', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), ctx=Store()), slice=Slice(Call(func=Name(id='y', ctx=Del()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), op=Sub(), value=List(elts=[UnaryOp(op=Invert(), operand=Compare(left=Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ops=[], comparators=[]))], ctx=Load()))\nt3lmH[(set(), set()):] //= oxNerA8       # AugAssign(target=Subscript(value=Name(id='t3lmH', ctx=Store()), slice=Slice(Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())), ctx=Store()), op=FloorDiv(), value=Name(id='oxNerA8', ctx=Load()))\npdnk2WaQFLs @= {*[set()].Qc[set().x:]}   # AugAssign(target=Name(id='pdnk2WaQFLs', ctx=Store()), op=MatMult(), value=Set(elts=[Subscript(value=Starred(value=Attribute(value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), attr='Qc', ctx=Load()), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='x', ctx=Load())), ctx=Del())]))\nYMy **= (set() + (set() & set())) / (None % (set() >> set())) # AugAssign(target=Name(id='YMy', ctx=Store()), op=Pow(), value=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Constant(value=None), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))))\nrXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15 *= +'h' # AugAssign(target=Name(id='rXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15', ctx=Store()), op=Mult(), value=UnaryOp(op=UAdd(), operand=Constant(value=\"h\")))\nPFUN += not True[set():](991.2, J=None, k=False) # AugAssign(target=Name(id='PFUN', ctx=Store()), op=Add(), value=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[Constant(value=991.2)], keywords=[keyword(arg='J', value=Constant(value=None)), keyword(arg='k', value=Constant(value=False))])))\ng ^= (-set()).m(set(), , u=-set(), h=set()) # AugAssign(target=Name(id='g', ctx=Store()), op=BitXor(), value=Call(func=Attribute(value=UnaryOp(op=USub(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), attr='m', ctx=Load()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BoolOp(op=And(), values=[])], keywords=[keyword(arg='u', value=UnaryOp(op=USub(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), keyword(arg='h', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]))\nCe |= 448                                # AugAssign(target=Name(id='Ce', ctx=Store()), op=BitOr(), value=Constant(value=448))\n\n```", "```py\nPYTHON_AST_STMTS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_ASSIGNMENTS_GRAMMAR, {\n    '<start>': [ '<stmt>' ],\n\n    '<stmt>': PYTHON_AST_ASSIGNMENTS_GRAMMAR['<stmt>'] + [\n        '<For>', '<While>', '<If>',\n        '<Return>', '<Delete>', '<Assert>',\n        '<Pass>', '<Break>', '<Continue>',\n        '<With>'\n    ],\n\n    # Control structures\n    '<For>': [\n        'For(target=<lhs_expr>, iter=<expr>, body=<nonempty_stmt_list>, orelse=<stmt_list><type_comment>)'\n    ],\n    '<stmt_list>': [ '[<stmts>?]' ],\n    '<nonempty_stmt_list>': [ '[<stmts>]' ],\n    '<stmts>': [ '<stmt>', '<stmt>, <stmts>' ],\n\n    '<While>': [\n        'While(test=<expr>, body=<nonempty_stmt_list>, orelse=<stmt_list>)'\n    ],\n\n    '<If>': [\n        'If(test=<expr>, body=<nonempty_stmt_list><orelse_param>)'\n    ],\n    '<orelse_param>': [\n        ', orelse=<stmt_list>'\n    ],\n\n    '<With>': [\n        'With(items=<withitem_list>, body=<nonempty_stmt_list><type_comment>?)'\n    ],\n    '<withitem_list>': [ '[<withitems>?]' ],\n    '<withitems>': [ '<withitem>', '<withitems>, <withitem>' ],\n    '<withitem>': [\n        'withitem(context_expr=<expr>)',\n        'withitem(context_expr=<expr>, optional_vars=<lhs_expr>)',\n    ],\n\n    # Other statements\n    '<Return>': [\n        'Return()',\n        'Return(value=<expr>)'\n    ],\n    '<Delete>': [\n        'Delete(targets=<expr_list>)'\n    ],\n    '<Assert>': [\n        'Assert(test=<expr>)',\n        'Assert(test=<expr>, msg=<expr>)'\n    ],\n    '<Pass>': [ 'Pass()'],\n    '<Break>': [ 'Break()' ],\n    '<Continue>': [ 'Continue()']\n\n    # FIXME: A few more: AsyncFor, AsyncWith, Match, Try, TryStar\n    # Import, ImportFrom, Global, Nonlocal...\n}) \n```", "```py\n# do import this unconditionally\nif sys.version_info >= (3, 13):\n    PYTHON_AST_STMTS_GRAMMAR: Grammar = \\\n        extend_grammar(PYTHON_AST_STMTS_GRAMMAR, {\n        # As of 3.13, orelse is optional\n        '<If>': [\n            'If(test=<expr>, body=<nonempty_stmt_list><orelse_param>?)'\n        ],\n    }) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_STMTS_GRAMMAR) \n```", "```py\nfor elt in PYTHON_AST_STMTS_GRAMMAR['<stmt>']:\n    print(elt)\n    test_samples(PYTHON_AST_STMTS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Assign>\n*[v[:][:][:]][{}:+*set()[:]()] = (XDBoW_Av,).L4 = (32.6,) # type:  # Assign(targets=[Starred(value=Subscript(value=List(elts=[Subscript(value=Subscript(value=Subscript(value=Name(id='v', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store())], ctx=Store()), slice=Slice(Dict(keys=[], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), UnaryOp(op=UAdd(), operand=Starred(value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]), ctx=Load()))), ctx=Store()), ctx=Store()), Attribute(value=Tuple(elts=[Name(id='XDBoW_Av', ctx=Store())], ctx=Store()), attr='L4', ctx=Store())], value=Tuple(elts=[Constant(value=32.6)], ctx=Load()), type_comment=\"\")\ng[:][set():][[]::set()] = set()[:]       # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='g', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), BoolOp(op=And(), values=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Compare(left=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]))\nW[:] = y[:][set():set():set()] = \nK18E # type: N # Assign(targets=[Subscript(value=Name(id='W', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='y', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Expr(value=Name(id='K18E', ctx=Load())), type_comment='N')\nV = _ = (set() | set()).E # type: i0     # Assign(targets=[Name(id='V', ctx=Store()), Name(id='_', ctx=Store())], value=Attribute(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), attr='E', ctx=Del()), type_comment=\"i0\")\ncZIujm3gC = eMePLrNVy9z2 # type: Wd~OC6+v02ey # Assign(targets=[Name(id='cZIujm3gC', ctx=Store())], value=Name(id='eMePLrNVy9z2', ctx=Del()), type_comment='Wd~OC6+v02ey')\nYf0lcOSaT = *[{set()}.b, (set(), set())] # type: *H<u&~|  # Assign(targets=[Name(id='Yf0lcOSaT', ctx=Store())], value=Starred(value=List(elts=[Attribute(value=Set(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), attr='b', ctx=Load()), Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Load()), ctx=Del()), type_comment=\"*H<u&~| \")\nN = i = ((set() ^ set()) & set()) * (set() + set()) # type: +ps # Assign(targets=[Name(id='N', ctx=Store()), Name(id='i', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), type_comment=\"+ps\")\nm = P = set() @ set() << set() // set() # type: ]J # Assign(targets=[Name(id='m', ctx=Store()), Name(id='P', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), type_comment=']J')\nj = O = 18 % (set() / set()) # type: R?$6 # Assign(targets=[Name(id='j', ctx=Store()), Name(id='O', ctx=Store())], value=BinOp(left=Constant(value=18), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), type_comment=\"R?$6\")\nTGFJsqKdXkwb65xYnpHRh7UtQi4u = False # type: q(Q>GHPBsa!|bUV9&$w`Su.8-hAi3}7)#=LDx@5\"?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F< # Assign(targets=[Name(id='TGFJsqKdXkwb65xYnpHRh7UtQi4u', ctx=Store())], value=Constant(value=False), type_comment='q(Q>GHPBsa!|bUV9&$w`Su.8-hAi3}7)#=LDx@5\"?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F<')\n\n<AugAssign>\n(*krT_.qL2x,)[~[\nset(), None, {}[:]].L:] //= (,) # AugAssign(target=Subscript(value=Tuple(elts=[Attribute(value=Starred(value=Name(id='krT_', ctx=Store()), ctx=Store()), attr='qL2x', ctx=Store())], ctx=Store()), slice=Slice(UnaryOp(op=Invert(), operand=Attribute(value=List(elts=[Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Constant(value=None), Subscript(value=Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], values=[]), slice=Slice(), ctx=Del())], ctx=Load()), attr='L', ctx=Load()))), ctx=Store()), op=FloorDiv(), value=Tuple(elts=[BoolOp(op=And(), values=[])], ctx=Del()))\n[h[:], F[:], l[:][set():Z]] -= U(*set() | set()) # AugAssign(target=List(elts=[Subscript(value=Name(id='h', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Name(id='F', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='l', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id='Z', ctx=Load())), ctx=Store())], ctx=Store()), op=Sub(), value=Call(func=Name(id='U', ctx=Del()), args=[BinOp(left=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Del()), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], keywords=[]))\nQ[[]:set()][[]:set()[:]:set()[:]] &= *(set(),).b # AugAssign(target=Subscript(value=Subscript(value=Name(id='Q', ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())), ctx=Store()), op=BitAnd(), value=Starred(value=Attribute(value=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), attr='b', ctx=Del()), ctx=Load()))\nwnBzQMG <<= {set() @ set() ^ set() ** set() / set()} # AugAssign(target=Name(id='wnBzQMG', ctx=Store()), op=LShift(), value=Set(elts=[BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))]))\nPsdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6 *= 48.5 # AugAssign(target=Name(id='Psdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6', ctx=Store()), op=Mult(), value=Constant(value=48.5))\na %= ''                                  # AugAssign(target=Name(id='a', ctx=Store()), op=Mod(), value=Constant(value=\"\"))\nJ += -True                               # AugAssign(target=Name(id='J', ctx=Store()), op=Add(), value=UnaryOp(op=USub(), operand=Constant(value=True)))\noU >>= set()[set():set():set()](E=set(), H=set()) # AugAssign(target=Name(id='oU', ctx=Store()), op=RShift(), value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[], keywords=[keyword(arg='E', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='H', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]))\nN //= not +(not 7927416330)              # AugAssign(target=Name(id='N', ctx=Store()), op=FloorDiv(), value=UnaryOp(op=Not(), operand=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Constant(value=7927416330)))))\ns += '' or False or 8888 .W((set()), v=set(), Y=set()) # AugAssign(target=Name(id='s', ctx=Store()), op=Add(), value=BoolOp(op=Or(), values=[Constant(value=''), Constant(value=False), Call(func=Attribute(value=Constant(value=8888), attr='W', ctx=Load()), args=[Compare(left=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[])], keywords=[keyword(arg='v', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='Y', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])]))\n\n<Expr>\n\n*{(None, n, [] << +R()[{}.r::set().I])} # Expr(value=Expr(value=Starred(value=Set(elts=[Tuple(elts=[Constant(value=None), Name(id='n', ctx=Load()), BinOp(left=List(elts=[], ctx=Del()), op=LShift(), right=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Name(id='R', ctx=Del()), args=[], keywords=[]), slice=Slice(Attribute(value=Dict(keys=[], values=[]), attr='r', ctx=Del()), BoolOp(op=Or(), values=[]), Compare(left=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='I', ctx=Load()), ops=[], comparators=[])), ctx=Del())))], ctx=Load())]), ctx=Del())))\n(*((set() ^ set()) - (set() | set())) / (set() % set()), [set(), set() >> set(), set() // set(), set() + set()])[:] # Expr(value=Subscript(value=Tuple(elts=[Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Load()), List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load())], ctx=Del()), slice=Slice(), ctx=Load()))\n851648.62 * True & 0                     # Expr(value=BinOp(left=BinOp(left=Constant(value=851648.62), op=Mult(), right=Constant(value=True)), op=BitAnd(), right=Constant(value=0)))\nnot -((set() @ set()) ** set()[:]())[set().z(_=set()):] # Expr(value=UnaryOp(op=Not(), operand=UnaryOp(op=USub(), operand=Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Pow(), right=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), slice=Slice(Call(func=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='z', ctx=Del()), args=[], keywords=[keyword(arg='_', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])), ctx=Load()))))\n'N'                                      # Expr(value=BoolOp(op=And(), values=[Constant(value=\"N\")]))\n(not ~'f')[~False:+(17 == ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6)] # Expr(value=Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Constant(value='f'))), slice=Slice(UnaryOp(op=Invert(), operand=Constant(value=False)), UnaryOp(op=UAdd(), operand=Compare(left=Constant(value=17), ops=[Eq()], comparators=[Name(id='ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6', ctx=Load()), Name(id='FcVkWZ0hQsONnpzGLrXut4vFIDiUBa', ctx=Load())]))), ctx=Del()))\ni                                        # Expr(value=Name(id='i', ctx=Load()))\no2                                       # Expr(value=Name(id='o2', ctx=Del()))\nAR                                       # Expr(value=Name(id='AR', ctx=Load()))\nY                                        # Expr(value=Name(id='Y', ctx=Del()))\n\n<For>\nfor U, [D, I] in []: # type: j\n    set()\n    m /= set() # For(target=Tuple(elts=[Name(id='U', ctx=Store()), List(elts=[Name(id='D', ctx=Store()), Name(id='I', ctx=Store())], ctx=Store())], ctx=Store()), iter=Compare(left=List(elts=[], ctx=Load()), ops=[Eq()], comparators=[]), body=[Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='m', ctx=Store()), op=Div(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[], type_comment=\"j\")\nfor *O.s in {}: # type: }\n    with :\n        break\n    assert set()\nelse:\n    pass\n    return # For(target=Starred(value=Attribute(value=Name(id='O', ctx=Store()), attr='s', ctx=Store()), ctx=Store()), iter=Dict(keys=[], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), body=[With(items=[], body=[Break()]), Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[Pass(), Return()], type_comment='}')\nfor q[:][set():set():set()] in *set(): # type: \n    return\n    return\nelse:\n    continue\n    continue # For(target=Subscript(value=Subscript(value=Name(id='q', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Load()), body=[Return(), Return()], orelse=[Continue(), Continue()], type_comment=\"\")\nfor g[:][set():] in \nset(): # type: \n    return\nelse:\n    l = set()\n    return # For(target=Subscript(value=Subscript(value=Name(id='g', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), body=[Return()], orelse=[Assign(targets=[Name(id='l', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()], type_comment=\"\")\nfor v in set().F(): # type: \n    if set():\n        return\n    return # For(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return()], orelse=[], type_comment=\"\")\nfor Z[:] in +set(): # type: \n    del \n    return\nelse:\n    while set():\n        return # For(target=Subscript(value=Name(id='Z', ctx=Store()), slice=Slice(), ctx=Store()), iter=UnaryOp(op=UAdd(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), body=[Delete(targets=[]), Return()], orelse=[While(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], type_comment=\"\")\nfor z[set():set()] in (): # type: L\n    for o in set(): # type: \n        return\nelse:\n    return\n    return # For(target=Subscript(value=Name(id='z', ctx=Store()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Tuple(elts=[], ctx=Load()), body=[For(target=Name(id='o', ctx=Store()), iter=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment='')], orelse=[Return(), Return()], type_comment=\"L\")\nfor G[:] in True .KA: # type: \n    assert set(), set()\nelse:\n    return # For(target=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), iter=Attribute(value=Constant(value=True), attr='KA', ctx=Del()), body=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[Return()], type_comment='')\nfor b[:][set() ^ set():] in e[set():]: # type: #\n    return\nelse:\n    return # For(target=Subscript(value=Subscript(value=Name(id='b', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BoolOp(op=And(), values=[])), ctx=Store()), iter=Subscript(value=Name(id='e', ctx=Load()), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Load()), body=[Return()], orelse=[Return()], type_comment='#')\nfor LNx in *wu: # type: ckM<v\n    return k\nelse:\n    return # For(target=Name(id='LNx', ctx=Store()), iter=Starred(value=Name(id='wu', ctx=Del()), ctx=Del()), body=[Return(value=Name(id='k', ctx=Del()))], orelse=[Return()], type_comment=\"ckM<v\")\n\n<While>\nwhile \nk:\n    pass                       # While(test=BoolOp(op=Or(), values=[Expr(value=Name(id='k', ctx=Load()))]), body=[Pass()], orelse=[])\nwhile *set()[set().e:]:\n    del \n    with :\n        return\n    return\n    continue\nelse:\n    break\n    return # While(test=Subscript(value=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='e', ctx=Load())), ctx=Load()), body=[Delete(targets=[]), With(items=[], body=[Return()]), Return(), Continue()], orelse=[Break(), Return()])\nwhile {}:\n    for H[:] in set(): # type: \n        return\n    else:\n        return\nelse:\n    l |= set()\n    while set():\n        return # While(test=Dict(keys=[], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), body=[For(target=Subscript(value=Name(id='H', ctx=Store()), slice=Slice(), ctx=Store()), iter=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[Return()], type_comment='')], orelse=[AugAssign(target=Name(id='l', ctx=Store()), op=BitOr(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), While(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])])\nwhile 'C':\n    set()\n    return\nelse:\n    t = set()\n    if set():\n        return\n    return\n    return # While(test=Constant(value=\"C\"), body=[Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()])\nwhile (not set()) == set():\n    assert set()\n    return\nelse:\n    assert set(), set()\n    return # While(test=Compare(left=UnaryOp(op=Not(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ops=[Eq()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()])\nwhile () @ set():\n    return [set(), set()]\n    return\n    return\n    return\nelse:\n    return set()[:]() # While(test=BinOp(left=Tuple(elts=[], ctx=Del()), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), body=[Return(value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())), Return(), Return(), Return()], orelse=[Return(value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]))])\nwhile *(set(),):\n    (h,) //= X\n    E <<= set()\nelse:\n    P *= set().W # While(test=Starred(value=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), body=[AugAssign(target=Tuple(elts=[Name(id='h', ctx=Store())], ctx=Store()), op=FloorDiv(), value=Name(id='X', ctx=Del())), AugAssign(target=Name(id='E', ctx=Store()), op=LShift(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id='P', ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='W', ctx=Del()))])\nwhile [{set() + set()}]:\n    *[u] ^= {set() & set() >> set(), set() / set()}\nelse:\n    s.N %= set()\n    m **= set() # While(test=List(elts=[Set(elts=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])], ctx=Load()), body=[AugAssign(target=Starred(value=List(elts=[Name(id='u', ctx=Store())], ctx=Store()), ctx=Store()), op=BitXor(), value=Set(elts=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]))], orelse=[AugAssign(target=Attribute(value=Name(id='s', ctx=Store()), attr='N', ctx=Store()), op=Mod(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='m', ctx=Store()), op=Pow(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nwhile False:\n    with set(), set(): # type: ^B\n        x -= set()\nelse:\n    v = +5 # type: % # While(test=Constant(value=False), body=[With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Name(id='x', ctx=Store()), op=Sub(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], type_comment='^B')], orelse=[Assign(targets=[Name(id='v', ctx=Store())], value=UnaryOp(op=UAdd(), operand=Constant(value=5)), type_comment='%')])\nwhile ~Y():\n    T = set()\n    return\n    return\nelse:\n    p = set()[:]() # While(test=UnaryOp(op=Invert(), operand=Call(func=Name(id='Y', ctx=Del()), args=[], keywords=[])), body=[Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return(), Return()], orelse=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]))])\n\n<If>\nif :\n    return\n    for [a] in set(): # type: \n        break\n    pass\n    continue\n    return\nelse:\n    del set()[:] # If(test=BoolOp(op=Or(), values=[]), body=[Return(), For(target=List(elts=[Name(id='a', ctx=Store())], ctx=Store()), iter=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Break()], orelse=[], type_comment=\"\"), Pass(), Continue(), Return()], orelse=[Delete(targets=[Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())])])\nif set()[:]():\n    set()\n    u %= set()\n    return\nelse:\n    return\n    return # If(test=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='u', ctx=Store()), op=Mod(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Return(), Return()])\nif None >= set():\n    assert set(), set().q\n    return\n    return\nelse:\n    return # If(test=Compare(left=Constant(value=None), ops=[GtE()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), msg=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='q', ctx=Del())), Return(), Return()], orelse=[Return()])\nif +va:\n    while set():\n        return\n    if set():\n        return\nelse:\n    Z = *set() # If(test=UnaryOp(op=UAdd(), operand=Name(id='va', ctx=Load())), body=[While(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), If(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], orelse=[Assign(targets=[Name(id='Z', ctx=Store())], value=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Del()))])\nif \nset() << []:\n    with :\n        return\n    assert ()\nelse:\n    j &= set()\n    return set() # If(test=Expr(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=List(elts=[], ctx=Load()))), body=[With(items=[], body=[Return()]), Assert(test=Tuple(elts=[], ctx=Del()))], orelse=[AugAssign(target=Name(id='j', ctx=Store()), op=BitAnd(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nif {set(): set()}:\n    G[:] **= set()\nelse:\n    (Q,) += set() # If(test=Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), op=Pow(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Tuple(elts=[Name(id='Q', ctx=Store())], ctx=Store()), op=Add(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nif *(set(),):\n    h |= set()\n    D >>= set()\nelse:\n    *W /= r # If(test=Starred(value=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Load()), body=[AugAssign(target=Name(id='h', ctx=Store()), op=BitOr(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='D', ctx=Store()), op=RShift(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Starred(value=Name(id='W', ctx=Store()), ctx=Store()), op=Div(), value=Name(id='r', ctx=Del()))])\nif {[set(), set(), set()]}:\n    w[:].N ^= set().F\nelse:\n    L[:].z *= set().C # If(test=Set(elts=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del())]), body=[AugAssign(target=Attribute(value=Subscript(value=Name(id='w', ctx=Store()), slice=Slice(), ctx=Store()), attr='N', ctx=Store()), op=BitXor(), value=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Load()))], orelse=[AugAssign(target=Attribute(value=Subscript(value=Name(id='L', ctx=Store()), slice=Slice(), ctx=Store()), attr='z', ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='C', ctx=Load()))])\nif 192:\n    return\n    k //= set()\nelse:\n    y -= set()\n    d @= set() # If(test=Constant(value=192), body=[Return(), AugAssign(target=Name(id='k', ctx=Store()), op=FloorDiv(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id='y', ctx=Store()), op=Sub(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='d', ctx=Store()), op=MatMult(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nif not True[set():set()]:\n    S = False\nelse:\n    E = J = set() # If(test=UnaryOp(op=Not(), operand=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Load())), body=[Assign(targets=[Name(id='S', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='E', ctx=Store()), Name(id='J', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\n\n<Return>\nreturn ()                                # Return(value=Tuple(elts=[], ctx=Load()))\nreturn                                   # Return()\nreturn *[{set(): g(), set().k: set()[:], set(): False}, set()] # Return(value=Starred(value=List(elts=[Dict(keys=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='k', ctx=Load()), Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])], values=[Call(func=Name(id='g', ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Constant(value=False)]), BoolOp(op=Or(), values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])], ctx=Del()), ctx=Load()))\nreturn O2sIF9wuGDe5hBzM10X7a >> (not \n{[*(set(), set())[set() ^ set():set() % set()]].idboHj}) # Return(value=BinOp(left=Name(id='O2sIF9wuGDe5hBzM10X7a', ctx=Del()), op=RShift(), right=UnaryOp(op=Not(), operand=Expr(value=Set(elts=[Attribute(value=List(elts=[Starred(value=Subscript(value=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Load()), ctx=Del())], ctx=Load()), attr='idboHj', ctx=Del())])))))\nreturn ((set() | set()) << set() - set()) @ (set() ** set() * (set() / set())) # Return(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=MatMult(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))))\nreturn 7.33                              # Return(value=Constant(value=7.33))\nreturn 'G'                               # Return(value=Constant(value=\"G\"))\nreturn ~-None & set()[:](set(), X=set()) // +set()[:].c(set()[:], set()[:], l=set(), Q=set()) # Return(value=BinOp(left=UnaryOp(op=Invert(), operand=UnaryOp(op=USub(), operand=Constant(value=None))), op=BitAnd(), right=BinOp(left=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='X', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]), op=FloorDiv(), right=UnaryOp(op=UAdd(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr='c', ctx=Del()), args=[Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())], keywords=[keyword(arg='l', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='Q', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])))))\nreturn (set() + set() and 24)[''[set() | set():set() % set():set()]:] # Return(value=Subscript(value=BoolOp(op=And(), values=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Constant(value=24)]), slice=Slice(Subscript(value=Constant(value=''), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Load())), ctx=Load()))\nreturn (oiLk < set() != set()) > 496 <= True # Return(value=Compare(left=Compare(left=Name(id='oiLk', ctx=Del()), ops=[Lt(), NotEq()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Name(id='f8', ctx=Del())]), ops=[Gt(), LtE()], comparators=[Constant(value=496), Constant(value=True)]))\n\n<Delete>\ndel ((not {(set()[:]().PTA2)[*set():\n{}]})) // True, [] # Delete(targets=[BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Subscript(value=BoolOp(op=And(), values=[Attribute(value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), attr='PTA2', ctx=Load())]), slice=Slice(Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Del()), Expr(value=Dict(keys=[], values=[]))), ctx=Load())])), ops=[], comparators=[Tuple(elts=[Name(id='G', ctx=Load())], ctx=Load())]), op=FloorDiv(), right=Constant(value=True)), List(elts=[], ctx=Del())])\ndel [set(), set(), set() / set()], *().QD, y4iFkwX # Delete(targets=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load()), Attribute(value=Starred(value=Tuple(elts=[], ctx=Del()), ctx=Load()), attr='QD', ctx=Del()), Name(id='y4iFkwX', ctx=Del())])\ndel set(), set(), set() ^ set(), set() % set() >> set() - set() @ set() # Delete(targets=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))))])\ndel set() << set(), set() | set(), set() ** set(), set() * (set() + set()) # Delete(targets=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))])\ndel 6                                    # Delete(targets=[Constant(value=6)])\ndel '_'                                  # Delete(targets=[Constant(value='_')])\ndel ~50.413, +-set()[:][set() & set():].F_(set() + set(), set()[:], L=set(), Z=set()) # Delete(targets=[UnaryOp(op=Invert(), operand=Constant(value=50.413)), UnaryOp(op=UAdd(), operand=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), slice=Slice(BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Load()), attr='F_', ctx=Del()), args=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del())], keywords=[keyword(arg='L', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), keyword(arg='Z', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])))])\ndel set() or None or z(), (set() and set())[False:c():T()] # Delete(targets=[BoolOp(op=Or(), values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=None), Call(func=Name(id='z', ctx=Del()), args=[], keywords=[])]), Subscript(value=BoolOp(op=And(), values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), slice=Slice(Constant(value=False), Call(func=Name(id='c', ctx=Del()), args=[], keywords=[]), Call(func=Name(id='T', ctx=Load()), args=[], keywords=[])), ctx=Del())])\ndel ''                                   # Delete(targets=[Constant(value=\"\")])\ndel k5vofh3xGZH == R1rc                  # Delete(targets=[Compare(left=Name(id='k5vofh3xGZH', ctx=Load()), ops=[Eq()], comparators=[Name(id='R1rc', ctx=Del()), Name(id='HPJup', ctx=Del())])])\n\n<Assert>\nassert {}                                # Assert(test=Dict(keys=[], values=[List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Constant(value=6.7), Attribute(value=BoolOp(op=Or(), values=[]), attr='Q', ctx=Del()), Compare(left=Expr(value=UnaryOp(op=Invert(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ops=[NotIn()], comparators=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])], ctx=Del())]))\nassert Z4mcX(set(), o=set()), ICkz[*(set() ^ set(),):] # Assert(test=Call(func=Name(id='Z4mcX', ctx=Del()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='o', value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))]), msg=Subscript(value=Name(id='ICkz', ctx=Load()), slice=Slice(Starred(value=Tuple(elts=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], ctx=Load()), ctx=Load())), ctx=Load()))\nassert [().H, {().h}, *(set(),)[*set() / set():set() // set()]] # Assert(test=List(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr='H', ctx=Del()), Set(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr='h', ctx=Load())]), Subscript(value=Starred(value=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), slice=Slice(Starred(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Load()), BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Del())], ctx=Load()))\nassert set() ** set() % (set() - set()), (set() >> (set() & set())) + (set() | set()) * (set() << set()) # Assert(test=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), msg=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=RShift(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), op=Add(), right=BinOp(left=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))))\nassert None                              # Assert(test=Constant(value=None))\nassert True                              # Assert(test=Constant(value=True))\nassert not 331                           # Assert(test=UnaryOp(op=Not(), operand=Constant(value=331)))\nassert -set()[:].x(set(), set()), +(not (set()[:]())[:]) # Assert(test=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr='x', ctx=Load()), args=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], keywords=[])), msg=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Subscript(value=BoolOp(op=And(), values=[Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])]), slice=Slice(), ctx=Load()))))\nassert 'X' @ (set())[False:set()]['':][False:][9:'Rbw':'m'] # Assert(test=BinOp(left=Constant(value='X'), op=MatMult(), right=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Constant(value=False), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), ctx=Del()), slice=Slice(Constant(value=\"\")), ctx=Load()), slice=Slice(Constant(value=False)), ctx=Load()), slice=Slice(Constant(value=9), Constant(value=\"Rbw\"), Constant(value=\"m\")), ctx=Del())))\nassert bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd # Assert(test=Name(id='bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd', ctx=Del()))\n\n<Pass>\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\npass                                     # Pass()\n\n<Break>\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\nbreak                                    # Break()\n\n<Continue>\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\ncontinue                                 # Continue()\n\n<With>\nwith :\n    [c, (y,)] //= {}\n    with set(), set(): # type: t\n        return # With(items=[], body=[AugAssign(target=List(elts=[Name(id='c', ctx=Store()), Tuple(elts=[Name(id='y', ctx=Store())], ctx=Store())], ctx=Store()), op=FloorDiv(), value=Dict(keys=[], values=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='e', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], body=[Return()], type_comment='t')])\nwith set() as C, *set() as *P: # type: \n    while (set())[:]:\n        break # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='C', ctx=Store())), withitem(context_expr=Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Del()), optional_vars=Starred(value=Name(id='P', ctx=Store()), ctx=Store()))], body=[While(test=Subscript(value=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(), ctx=Load()), body=[Break()], orelse=[])], type_comment=\"\")\nwith '' as G[:]._: # type: H!\n    del set(), set(), set()\n    set()\n    pass\n    continue # With(items=[withitem(context_expr=Constant(value=''), optional_vars=Attribute(value=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), attr='_', ctx=Store()))], body=[Delete(targets=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])]), Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Pass(), Continue()], type_comment=\"H!\")\nwith : # type: |S9vg\n    for B in set(): # type: \n        return # With(items=[withitem(context_expr=BoolOp(op=And(), values=[]))], body=[For(target=Name(id='B', ctx=Store()), iter=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment=\"\")], type_comment='|S9vg')\nwith () as Y[:]: # type: t>A\n    b = E = set() # With(items=[withitem(context_expr=Tuple(elts=[], ctx=Load()), optional_vars=Subscript(value=Name(id='Y', ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assign(targets=[Name(id='b', ctx=Store()), Name(id='E', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], type_comment=\"t>A\")\nwith set(), set() as K[:]: # type: f\n    if set():\n        return\n    return\n    return # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id='K', ctx=Store()), slice=Slice(), ctx=Store()))], body=[If(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()], type_comment=\"f\")\nwith set(), set(), [], set() as r[:]: # type: n\n    assert set()\n    return\n    return # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), withitem(context_expr=List(elts=[], ctx=Del())), withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id='r', ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return(), Return()], type_comment='n')\nwith set() as v: # type: $5a?@c\n    assert set(), set()\n    return\n    return\n    return # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='v', ctx=Store()))], body=[Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return(), Return(), Return()], type_comment=\"$5a?@c\")\nwith set() as j: # type:  j\n    return set()[:]()\n    return\n    return\n    return # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='j', ctx=Store()))], body=[Return(value=Call(func=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[])), Return(), Return(), Return()], type_comment=' j')\nwith set(): # type: \n    J[:] &= set() * set()\n    h /= I\n    return # With(items=[withitem(context_expr=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Subscript(value=Name(id='J', ctx=Store()), slice=Slice(), ctx=Store()), op=BitAnd(), value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), AugAssign(target=Name(id='h', ctx=Store()), op=Div(), value=Name(id='I', ctx=Load())), Return()], type_comment='')\n\n```", "```py\nwith_tree = ast.parse(\"\"\"\nwith open('foo.txt') as myfile:\n content = myfile.readlines()\n if content is not None:\n print(content)\n\"\"\") \n```", "```py\npython_ast_stmts_grammar = convert_ebnf_grammar(PYTHON_AST_STMTS_GRAMMAR)\nwith_tree_str = ast.dump(with_tree.body[0])  # get the `With(...)` subtree\nprint(with_tree_str)\nwith_solver = ISLaSolver(python_ast_stmts_grammar)\nassert with_solver.check(with_tree_str) \n```", "```py\nWith(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Constant(value='foo.txt')], keywords=[]), optional_vars=Name(id='myfile', ctx=Store()))], body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='myfile', ctx=Load()), attr='readlines', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='content', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]))], orelse=[])])\n\n```", "```py\nprint(ast.dump(ast.parse(\"\"\"\ndef f(a, b=1):\n pass\n\"\"\"\n), indent=4)) \n```", "```py\nModule(\n    body=[\n        FunctionDef(\n            name='f',\n            args=arguments(\n                posonlyargs=[],\n                args=[\n                    arg(arg='a'),\n                    arg(arg='b')],\n                kwonlyargs=[],\n                kw_defaults=[],\n                defaults=[\n                    Constant(value=1)]),\n            body=[\n                Pass()],\n            decorator_list=[])],\n    type_ignores=[])\n\n```", "```py\nPYTHON_AST_DEFS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_STMTS_GRAMMAR, {\n    '<stmt>': PYTHON_AST_STMTS_GRAMMAR['<stmt>'] + [ '<FunctionDef>' ],\n\n    '<FunctionDef>': [\n        'FunctionDef(name=<identifier>, args=<arguments>, body=<nonempty_stmt_list><decorator_list_param><returns>?<type_comment>?)'\n    ],\n    '<decorator_list_param>': [\n        ', decorator_list=<expr_list>'\n    ],\n\n    '<arguments>': [\n        'arguments(<posonlyargs_param>args=<arg_list><vararg>?<kwonlyargs_param><kw_defaults_param><kwarg>?<defaults_param>)'\n    ],\n    '<posonlyargs_param>': [\n        'posonlyargs=<arg_list>, '\n    ],\n    '<kwonlyargs_param>': [\n        ', kwonlyargs=<arg_list>'\n    ],\n    '<kw_defaults_param>': [\n        ', kw_defaults=<expr_list>'\n    ],\n    '<defaults_param>': [\n        ', defaults=<expr_list>'\n    ],\n\n    '<arg_list>': [ '[<args>?]' ],\n    '<args>': [ '<arg>', '<arg>, <arg>' ],\n    '<arg>': [ 'arg(arg=<identifier>)' ],\n\n    '<vararg>': [ ', vararg=<arg>' ],\n    '<kwarg>': [ ', kwarg=<arg>' ],\n    '<returns>': [ ', returns=<expr>' ],\n\n    # FIXME: Not handled: AsyncFunctionDef, ClassDef\n}) \n```", "```py\n# do import this unconditionally\nif sys.version_info >= (3, 12):\n    PYTHON_AST_DEFS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_DEFS_GRAMMAR, {\n    '<FunctionDef>': [\n        'FunctionDef(name=<identifier>, args=<arguments>, body=<nonempty_stmt_list><decorator_list_param><returns>?<type_comment>?<type_params>?)'\n    ],\n    '<type_params>': [\n        ', type_params=<type_param_list>',\n    ],\n    '<type_param_list>': [ '[<type_param>?]' ],\n    '<type_param>': [ '<TypeVar>', '<ParamSpec>', '<TypeVarTuple>' ],\n    '<TypeVar>': [\n        'TypeVar(name=<identifier>(, bound=<expr>)?)'\n    ],\n    '<ParamSpec>': [\n        'ParamSpec(name=<identifier>)'\n    ],\n    '<TypeVarTuple>': [\n        'TypeVarTuple(name=<identifier>)'\n    ]\n    }) \n```", "```py\n# do import this unconditionally\nif sys.version_info >= (3, 13):\n    PYTHON_AST_DEFS_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_DEFS_GRAMMAR, {\n    '<FunctionDef>': [\n        'FunctionDef(name=<identifier>, args=<arguments>, body=<nonempty_stmt_list><decorator_list_param>?<returns>?<type_comment>?<type_params>?)'\n    ],\n    '<arguments>': [\n        'arguments(<posonlyargs_param>?args=<arg_list><vararg>?<kwonlyargs_param>?<kw_defaults_param>?<kwarg>?<defaults_param>?)'\n    ],\n    }) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_DEFS_GRAMMAR) \n```", "```py\nfor elt in [ '<arguments>', '<FunctionDef>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_DEFS_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<arguments>\ni, /, Wr, x                              # arguments(posonlyargs=[arg(arg='i')], args=[arg(arg='Wr'), arg(arg='x')], kwonlyargs=[], kw_defaults=[List(elts=[UnaryOp(op=UAdd(), operand=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Dict(keys=[], values=[]), Name(id='P', ctx=Load())], ctx=Load())], defaults=[])\nG, /, h=, *e, u=set(), **R3              # arguments(posonlyargs=[arg(arg='G')], args=[arg(arg='h')], vararg=arg(arg='e'), kwonlyargs=[arg(arg='u')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ctx=Del())], kwarg=arg(arg='R3'), defaults=[BoolOp(op=Or(), values=[])])\nn, C, /, s, T=set(), *S, L=set(), **j    # arguments(posonlyargs=[arg(arg='n'), arg(arg='C')], args=[arg(arg='s'), arg(arg='T')], vararg=arg(arg='S'), kwonlyargs=[arg(arg='L')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='j'), defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])\nF, z, /, Q, N, *Y, X=set(), **g          # arguments(posonlyargs=[arg(arg='F'), arg(arg='z')], args=[arg(arg='Q'), arg(arg='N')], vararg=arg(arg='Y'), kwonlyargs=[arg(arg='X'), arg(arg='I')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='g'), defaults=[])\nA=set(), /, B=set(), f=set(), *O6, K=set(), **Z # arguments(posonlyargs=[arg(arg='A')], args=[arg(arg='B'), arg(arg='f')], vararg=arg(arg='O6'), kwonlyargs=[arg(arg='K')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='Z'), defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])\np, y=set(), /, H=\nset(), *l, Jo=set(), **V # arguments(posonlyargs=[arg(arg='p'), arg(arg='y')], args=[arg(arg='H')], vararg=arg(arg='l'), kwonlyargs=[arg(arg='Jo')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='V'), defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Expr(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nm, /, U, c, *w, **o                      # arguments(posonlyargs=[arg(arg='m')], args=[arg(arg='U'), arg(arg='c')], vararg=arg(arg='w'), kwonlyargs=[arg(arg='b'), arg(arg='q')], kw_defaults=[], kwarg=arg(arg='o'), defaults=[])\nk, v, /, E, t=set() % set(), *_, **rR    # arguments(posonlyargs=[arg(arg='k'), arg(arg='v')], args=[arg(arg='E'), arg(arg='t')], vararg=arg(arg='_'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='rR'), defaults=[BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))])\nM, /, D, *d, a=set(), **Z                # arguments(posonlyargs=[arg(arg='M')], args=[arg(arg='D')], vararg=arg(arg='d'), kwonlyargs=[arg(arg='a')], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Del())], kwarg=arg(arg='Z'), defaults=[])\nn, Y, /, g, y=set(), *z, **U             # arguments(posonlyargs=[arg(arg='n'), arg(arg='Y')], args=[arg(arg='g'), arg(arg='y')], vararg=arg(arg='z'), kwonlyargs=[], kw_defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='U'), defaults=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])])\n\n<FunctionDef>\ndef U():\n    return                      # FunctionDef(name='U', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])\ndef F():\n    pass                        # FunctionDef(name='F', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])\ndef u() -> set(): # type: \n    continue  # FunctionDef(name='u', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment=\"\")\ndef D() -> set(): # type: \n    break     # FunctionDef(name='D', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment='')\ndef w(): # type: \n    return             # FunctionDef(name='w', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment='')\ndef g() -> set(): # type: \n    return    # FunctionDef(name='g', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment='')\ndef q() -> set(): # type: \n    return    # FunctionDef(name='q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment='')\ndef W() -> set():\n    return             # FunctionDef(name='W', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))\ndef I() -> set():\n    return             # FunctionDef(name='I', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))\ndef n() -> set(): # type: \n    return    # FunctionDef(name='n', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment=\"\")\n\n```", "```py\nPYTHON_AST_MODULE_GRAMMAR: Grammar = extend_grammar(PYTHON_AST_DEFS_GRAMMAR, {\n    '<start>': [ '<mod>' ],\n    '<mod>': [ '<Module>' ],\n    '<Module>': [ 'Module(body=<nonempty_stmt_list><type_ignore_param>)'],\n\n    '<type_ignore_param>': [ ', type_ignores=<type_ignore_list>' ],\n    '<type_ignore_list>': [ '[<type_ignores>?]' ],\n    '<type_ignores>': [ '<type_ignore>', '<type_ignore>, <type_ignore>' ],\n    '<type_ignore>': [ 'TypeIgnore(lineno=<integer>, tag=<string>)' ],\n}) \n```", "```py\n# do import this unconditionally\nif sys.version_info >= (3, 13):\n    PYTHON_AST_MODULE_GRAMMAR: Grammar = \\\n        extend_grammar(PYTHON_AST_MODULE_GRAMMAR, {\n        # As of 3.13, the type_ignore parameter is optional\n        '<Module>': [ 'Module(body=<nonempty_stmt_list><type_ignore_param>?)'],\n    }) \n```", "```py\nassert is_valid_grammar(PYTHON_AST_MODULE_GRAMMAR) \n```", "```py\nfor elt in [ '<Module>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_MODULE_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<Module>\nEESc9e.w @ {\n[*(not set())[y():set():{}]], } # Module(body=[Expr(value=BinOp(left=Attribute(value=Name(id='EESc9e', ctx=Del()), attr='w', ctx=Load()), op=MatMult(), right=Set(elts=[Expr(value=List(elts=[Starred(value=Subscript(value=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])), slice=Slice(Call(func=Name(id='y', ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Dict(keys=[], values=[])), ctx=Load()), ctx=Load())], ctx=Del())), BoolOp(op=And(), values=[])])))], type_ignores=[])\nwhile (None, ''):\n    m = set()\n    del \n    return\nelse:\n    break\n    with :\n        return\n    pass\nreturn\ncontinue # Module(body=[While(test=Tuple(elts=[Constant(value=None), Constant(value='')], ctx=Load()), body=[Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Delete(targets=[]), Return()], orelse=[Break(), With(items=[], body=[Return()]), Pass()]), Return(), Continue()], type_ignores=[TypeIgnore(lineno=27, tag=''), TypeIgnore(lineno=2, tag=\"h\")])\nfor I.V in set()[:]: # type: \n    return # Module(body=[For(target=Attribute(value=Name(id='I', ctx=Store()), attr='V', ctx=Store()), iter=Subscript(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), body=[Return()], orelse=[], type_comment=\"\")], type_ignores=[TypeIgnore(lineno=131, tag='[bm')])\ndef Q():\n    return\nassert set().a\nreturn # Module(body=[FunctionDef(name='Q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[]), Assert(test=Attribute(value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), attr='a', ctx=Del())), Return()], type_ignores=[TypeIgnore(lineno=56, tag=\"M\")])\nif set():\n    return\n*h <<= set()        # Module(body=[If(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), AugAssign(target=Starred(value=Name(id='h', ctx=Store()), ctx=Store()), op=LShift(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=8, tag=\"\"), TypeIgnore(lineno=5, tag=\"\")])\nreturn [set()]\nassert (set(), set()), [] # Module(body=[Return(value=List(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Load())), Assert(test=Tuple(elts=[Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])], ctx=Del()), msg=List(elts=[], ctx=Del()))], type_ignores=[TypeIgnore(lineno=89, tag=\"\"), TypeIgnore(lineno=0, tag=\"Q\")])\nD |= set()                               # Module(body=[AugAssign(target=Name(id='D', ctx=Store()), op=BitOr(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=74, tag='1'), TypeIgnore(lineno=90, tag=\"\")])\n[o, j] += *set() % set() ** set()        # Module(body=[AugAssign(target=List(elts=[Name(id='o', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), op=Add(), value=Starred(value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))), ctx=Del()))], type_ignores=[TypeIgnore(lineno=3980, tag=\"7'Z\")])\nx[:] /= set()\ni -= set() & set()         # Module(body=[AugAssign(target=Subscript(value=Name(id='x', ctx=Store()), slice=Slice(), ctx=Store()), op=Div(), value=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Sub(), value=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])))], type_ignores=[TypeIgnore(lineno=40, tag='W2j')])\ns //= -(set() * set())                   # Module(body=[AugAssign(target=Name(id='s', ctx=Store()), op=FloorDiv(), value=UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))))], type_ignores=[TypeIgnore(lineno=665, tag=\"\"), TypeIgnore(lineno=5, tag=\"\")])\n\n```", "```py\nPYTHON_AST_GRAMMAR = PYTHON_AST_MODULE_GRAMMAR\npython_ast_grammar = convert_ebnf_grammar(PYTHON_AST_GRAMMAR) \n```", "```py\nfor elt in [ '<FunctionDef>' ]:\n    print(elt)\n    test_samples(PYTHON_AST_GRAMMAR, start_symbol=elt)\n    print() \n```", "```py\n<FunctionDef>\ndef w():\n    pass                        # FunctionDef(name='w', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])\ndef a():\n    break                       # FunctionDef(name='a', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[])\ndef o():\n    return                      # FunctionDef(name='o', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])\ndef v(): # type: \n    continue           # FunctionDef(name='v', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], type_comment='')\ndef j(): # type: \n    return             # FunctionDef(name='j', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment=\"\")\ndef k():\n    return\n    return           # FunctionDef(name='k', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Return()], decorator_list=[])\ndef Q() -> set(): # type: \n    return    # FunctionDef(name='Q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), type_comment='')\ndef d() -> None:\n    return\n    assert set(), set()\n    return # FunctionDef(name='d', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Assert(test=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[])), Return()], decorator_list=[], returns=Constant(value=None))\ndef K() -> set():\n    return             # FunctionDef(name='K', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id=\"set\", ctx=Load()), args=[], keywords=[]))\ndef y(): # type: \n    return             # FunctionDef(name='y', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment='')\n\n```", "```py\nclass PythonFuzzer(ISLaSolver):\n  \"\"\"Produce Python code.\"\"\"\n\n    def __init__(self,\n                 start_symbol: Optional[str] = None, *,\n                 grammar: Optional[Grammar] = None,\n                 constraint: Optional[str] =None,\n                 **kw_params) -> None:\n  \"\"\"Produce Python code. Parameters are:\n\n * `start_symbol`: The grammatical entity to be generated (default: `<FunctionDef>`)\n * `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and\n * `constraint` an ISLa constraint (if any).\n\n Additional keyword parameters are passed to the `ISLaSolver` superclass.\n \"\"\"\n        if start_symbol is None:\n            start_symbol = '<FunctionDef>'\n        if grammar is None:\n            grammar = PYTHON_AST_GRAMMAR\n        assert start_symbol in grammar\n\n        g = convert_ebnf_grammar(grammar)\n        if constraint is None:\n            super().__init__(g, start_symbol=start_symbol, **kw_params)\n        else:\n            super().__init__(g, constraint, start_symbol=start_symbol, **kw_params)\n\n    def fuzz(self) -> str:\n  \"\"\"Produce a Python code string.\"\"\"\n        abstract_syntax_tree = eval(str(self.solve()))\n        ast.fix_missing_locations(abstract_syntax_tree)\n        return ast.unparse(abstract_syntax_tree) \n```", "```py\nfuzzer = PythonFuzzer()\nprint(fuzzer.fuzz()) \n```", "```py\ndef L():\n    continue\n\n```", "```py\nfuzzer = PythonFuzzer('<While>')\nprint(fuzzer.fuzz()) \n```", "```py\nwhile (set()[set():set()], *(set())):\n    if {}:\n        while set():\n            continue\n        break\n    else:\n        del \n        return\n\n```", "```py\nsorted(list(PYTHON_AST_GRAMMAR.keys())) \n```", "```py\n['<Assert>',\n '<Assign>',\n '<Attribute>',\n '<AugAssign>',\n '<BinOp>',\n '<BoolOp>',\n '<Break>',\n '<Call>',\n '<Compare>',\n '<Constant>',\n '<Continue>',\n '<Delete>',\n '<Dict>',\n '<EmptySet>',\n '<Expr>',\n '<For>',\n '<FunctionDef>',\n '<If>',\n '<List>',\n '<Module>',\n '<Name>',\n '<Pass>',\n '<Return>',\n '<Set>',\n '<Slice>',\n '<Starred>',\n '<Subscript>',\n '<Tuple>',\n '<UnaryOp>',\n '<While>',\n '<With>',\n '<arg>',\n '<arg_list>',\n '<args>',\n '<args_param>',\n '<arguments>',\n '<bool>',\n '<boolop>',\n '<cmpop>',\n '<cmpop_list>',\n '<cmpops>',\n '<decorator_list_param>',\n '<defaults_param>',\n '<digit>',\n '<digits>',\n '<expr>',\n '<expr_list>',\n '<exprs>',\n '<float>',\n '<func>',\n '<id>',\n '<id_continue>',\n '<id_start>',\n '<identifier>',\n '<integer>',\n '<keyword>',\n '<keyword_list>',\n '<keywords>',\n '<keywords_param>',\n '<kw_defaults_param>',\n '<kwarg>',\n '<kwonlyargs_param>',\n '<lhs_Attribute>',\n '<lhs_List>',\n '<lhs_Name>',\n '<lhs_Starred>',\n '<lhs_Subscript>',\n '<lhs_Tuple>',\n '<lhs_expr>',\n '<lhs_exprs>',\n '<literal>',\n '<mod>',\n '<none>',\n '<nonempty_expr_list>',\n '<nonempty_lhs_expr_list>',\n '<nonempty_stmt_list>',\n '<nonzerodigit>',\n '<not_double_quotes>',\n '<not_single_quotes>',\n '<operator>',\n '<orelse_param>',\n '<posonlyargs_param>',\n '<returns>',\n '<start>',\n '<stmt>',\n '<stmt_list>',\n '<stmts>',\n '<string>',\n '<type_comment>',\n '<type_ignore>',\n '<type_ignore_list>',\n '<type_ignore_param>',\n '<type_ignores>',\n '<unaryop>',\n '<vararg>',\n '<withitem>',\n '<withitem_list>',\n '<withitems>']\n\n```", "```py\nPYTHON_AST_GRAMMAR['<FunctionDef>'] \n```", "```py\n['FunctionDef(name=<identifier>, args=<arguments>, body=<nonempty_stmt_list><decorator_list_param><returns>?<type_comment>?)']\n\n```", "```py\npython_ast_grammar_without_decorators: Grammar = extend_grammar(PYTHON_AST_GRAMMAR,\n{\n    '<FunctionDef>' :\n        ['FunctionDef(name=<identifier>, args=<arguments>, body=<nonempty_stmt_list>, decorator_list=[])']\n}) \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nwith ExpectError():\n    assert is_valid_grammar(python_ast_grammar_without_decorators) \n```", "```py\n'<decorator_list_param>': defined, but not used. Consider applying trim_grammar() on the grammar\n'<returns>': defined, but not used. Consider applying trim_grammar() on the grammar\n'<decorator_list_param>': unreachable from <start>. Consider applying trim_grammar() on the grammar\n'<returns>': unreachable from <start>. Consider applying trim_grammar() on the grammar\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_17604/3611578183.py\", line 2, in <module>\n    assert is_valid_grammar(python_ast_grammar_without_decorators)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\npython_ast_grammar_without_decorators = trim_grammar(python_ast_grammar_without_decorators) \n```", "```py\nassert is_valid_grammar(python_ast_grammar_without_decorators) \n```", "```py\nfuzzer = PythonFuzzer(grammar=python_ast_grammar_without_decorators)\nprint(fuzzer.fuzz()) \n```", "```py\ndef X():\n    break\n\n```", "```py\nfuzzer = PythonFuzzer(constraint='str.len(<id>) = 10')\nprint(fuzzer.fuzz()) \n```", "```py\ndef yWOOLwypwp(): # type: \n    return\n\n```", "```py\n# Also works (the <identifier> has quotes)\nfuzzer = PythonFuzzer(constraint='<FunctionDef>.<identifier> = \"\\'my_favorite_function\\'\"')\nprint(fuzzer.fuzz()) \n```", "```py\n@[set(), set()]\n@set() | {}\n@(-*set())[set():():\nset()[:]()]\ndef my_favorite_function(dlFf=Qr, l1M=set(), *) -> 942.5:\n    return\n\n```", "```py\nfuzzer = PythonFuzzer(constraint=\n\"\"\"\n exists <integer> x:\n (inside(x, <nonempty_stmt_list>) and str.to.int(x) > 1000)\n\"\"\")\nprint(fuzzer.fuzz()) \n```", "```py\n@[set(), +set(), \nset()]\n@{set(): set(), set(): set()}\n@(set(), *set() & set())\ndef l(r, a, /, *uXLV, _=set()[:], **Z) -> sdTYWE9b or {set(), set().R}.Vy != z1vw([]):\n    del 1007\n\n```", "```py\n# This will not work with ISLa 2\nfuzzer = PythonFuzzer(constraint=\"\"\"\n forall <FunctionDef> def: count(def, \"<stmt>\", \"3\")\n\"\"\")\nprint(fuzzer.fuzz()) \n```", "```py\n@3.91\ndef V8(w, /, *, t=set(), C5D=set(), **foT6):\n    if *{}.S[:] - ((set()) not in set() in set()):\n        pass\n    else:\n        return\n\n```", "```py\nfuzzer = PythonFuzzer(constraint='<FunctionDef>..<expr_list> = \"[]\"')\nprint(fuzzer.fuzz()) \n```", "```py\ndef l(Jws4IzSPx_O2ajk687obQB3mflULCTJWnAv9GHg0YRtVNycueKFDMihZ5rXd1pqEo, /, *, **g):\n    return\n\n```", "```py\ndef sum(a, b):    # A simple example\n    the_sum = a + b\n    return the_sum \n```", "```py\nsum_source = inspect.getsource(sum)\nsum_tree = ast.parse(sum_source)\nprint(ast.unparse(sum_tree)) \n```", "```py\ndef sum(a, b):\n    the_sum = a + b\n    return the_sum\n\n```", "```py\nsum_str = ast.dump(sum_tree)\nsum_str \n```", "```py\n\"Module(body=[FunctionDef(name='sum', args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='the_sum', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load()))), Return(value=Name(id='the_sum', ctx=Load()))], decorator_list=[])], type_ignores=[])\"\n\n```", "```py\nsolver = ISLaSolver(python_ast_grammar)\nassert solver.check(sum_str) \n```", "```py\nsum_tree = solver.parse(sum_str) \n```", "```py\nlen(repr(sum_tree)) \n```", "```py\n8737\n\n```", "```py\nrepr(sum_tree)[:200] \n```", "```py\n\"DerivationTree('<start>', (DerivationTree('<mod>', (DerivationTree('<Module>', (DerivationTree('Module(body=', (), id=495073), DerivationTree('<nonempty_stmt_list>', (DerivationTree('[', (), id=495071\"\n\n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import display_tree \n```", "```py\ndisplay_tree(sum_tree) \n```", "```py\npython_ast_grammar['<start>'] \n```", "```py\n['<mod>']\n\n```", "```py\npython_ast_grammar['<mod>'] \n```", "```py\n['<Module>']\n\n```", "```py\npython_ast_grammar['<Module>'] \n```", "```py\n['Module(body=<nonempty_stmt_list><type_ignore_param>)']\n\n```", "```py\nstr(sum_tree) \n```", "```py\n\"Module(body=[FunctionDef(name='sum', args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='the_sum', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load()))), Return(value=Name(id='the_sum', ctx=Load()))], decorator_list=[])], type_ignores=[])\"\n\n```", "```py\nsum_ast = ast.fix_missing_locations(eval(str(sum_tree)))\nprint(ast.unparse(sum_ast)) \n```", "```py\ndef sum(a, b):\n    the_sum = a + b\n    return the_sum\n\n```", "```py\nsum_mutated_tree = solver.mutate(sum_str, min_mutations=1, max_mutations=1) \n```", "```py\nsum_mutated_ast = ast.fix_missing_locations(eval(str(sum_mutated_tree)))\nprint(ast.unparse(sum_mutated_ast)) \n```", "```py\ndef sum(a, b):\n    the_sum = a + b\n    return the_sum\n\n```", "```py\nsum_mutated_tree = solver.mutate(sum_str, min_mutations=10, max_mutations=20) \n```", "```py\nsum_mutated_ast = ast.fix_missing_locations(eval(str(sum_mutated_tree)))\nprint(ast.unparse(sum_mutated_ast)) \n```", "```py\ndef sum(a, b):\n    the_9GuWCvL4cpgyi37K5I_ = a + b\n    return the_jXHPe1oqMG\n\n```", "```py\ndef has_distributive_law(tree) -> bool:\n    for node in walk(tree):  # iterate over all nodes in `tree`\n        # print(node)\n        if isinstance(node, ast.BinOp):\n            if isinstance(node.op, ast.Mult):\n                if isinstance(node.right, ast.BinOp):\n                    if isinstance(node.right.op, ast.Add):\n                        return True\n\n                if isinstance(node.left, ast.BinOp):\n                    if isinstance(node.left.op, ast.Add):\n                        return True\n\n    return False \n```", "```py\nshow_ast(ast.parse(\"1 + (2 * 3)\")) \n```", "```py\nhas_distributive_law(ast.parse(\"1 * (2 + 3)\")) \n```", "```py\nTrue\n\n```", "```py\nhas_distributive_law(ast.parse(\"(1 + 2) * 3\")) \n```", "```py\nTrue\n\n```", "```py\nhas_distributive_law(ast.parse(\"1 + (2 * 3)\")) \n```", "```py\nFalse\n\n```", "```py\nhas_distributive_law(ast.parse(\"def f(a, b):\\n return a * (b + 10)\")) \n```", "```py\nTrue\n\n```", "```py\ndef how_many_mutations(code: str) -> int:\n    solver = ISLaSolver(python_ast_grammar)\n\n    code_ast = ast.parse(code)\n    code_ast = ast.fix_missing_locations(code_ast)\n    code_ast_str = ast.dump(code_ast)\n    code_derivation_tree = solver.parse(code_ast_str)\n    mutations = 0\n    mutated_code_ast = code_ast\n\n    while not has_distributive_law(mutated_code_ast):\n        mutations += 1\n        if mutations % 100 == 0:\n            print(f'{mutations}...', end='')\n\n        mutated_code_str = str(solver.mutate(code_derivation_tree))\n        mutated_code_ast = eval(mutated_code_str)\n        # mutated_code_ast = ast.fix_missing_locations(mutated_code_ast)\n        # print(ast.dump(mutated_code_ast))\n        # print(ast.unparse(mutated_code_ast))\n\n    return mutations \n```", "```py\nassert how_many_mutations('1 * (2 + 3)') == 0 \n```", "```py\nhow_many_mutations('2 + 2')    # <-- Note: this can take a minute \n```", "```py\n54\n\n```", "```py\nhow_many_mutations('2')  # <-- Note: this can take several minutes \n```", "```py\n100...200...300...400...500...600...700...800...900...1000...1100...1200...1300...1400...1500...1600...1700...1800...1900...2000...2100...2200...2300...2400...2500...\n\n```", "```py\n2500\n\n```", "```py\nfrom [Coverage](Coverage.html) import Coverage \n```", "```py\nmult_ast = ast.parse(\"1 * 2\")\nwith Coverage() as cov:\n    has_distributive_law(mult_ast) \n```", "```py\ncov.coverage() \n```", "```py\n{('_handle_fromlist', 1217),\n ('_handle_fromlist', 1218),\n ('_handle_fromlist', 1225),\n ('_handle_fromlist', 1229),\n ('_handle_fromlist', 1241),\n ('has_distributive_law', 2),\n ('has_distributive_law', 4),\n ('has_distributive_law', 5),\n ('has_distributive_law', 6),\n ('has_distributive_law', 10),\n ('has_distributive_law', 14),\n ('iter_child_nodes', 272),\n ('iter_child_nodes', 273),\n ('iter_child_nodes', 274),\n ('iter_child_nodes', 275),\n ('iter_child_nodes', 276),\n ('iter_child_nodes', 277),\n ('iter_child_nodes', 278),\n ('iter_fields', 260),\n ('iter_fields', 261),\n ('iter_fields', 262),\n ('walk', 386),\n ('walk', 387),\n ('walk', 388),\n ('walk', 389),\n ('walk', 390),\n ('walk', 391)}\n\n```", "```py\ndef show_coverage(cov, fun):\n    fun_lines, fun_start = inspect.getsourcelines(fun)\n    fun_name = fun.__name__\n    coverage = cov.coverage()\n    for line in range(len(fun_lines)):\n        if (fun_name, line + fun_start) in coverage:\n            print('# ', end='')  # covered lines\n        else:\n            print('  ', end='')  # uncovered lines\n        print(line + fun_start, fun_lines[line], end='') \n```", "```py\nshow_coverage(cov, has_distributive_law) \n```", "```py\n  1 def has_distributive_law(tree) -> bool:\n# 2     for node in walk(tree):  # iterate over all nodes in `tree`\n  3         # print(node)\n# 4         if isinstance(node, ast.BinOp):\n# 5             if isinstance(node.op, ast.Mult):\n# 6                 if isinstance(node.right, ast.BinOp):\n  7                     if isinstance(node.right.op, ast.Add):\n  8                         return True\n  9 \n# 10                 if isinstance(node.left, ast.BinOp):\n  11                     if isinstance(node.left.op, ast.Add):\n  12                         return True\n  13 \n# 14     return False\n\n```", "```py\ndef ast_fitness(code_ast) -> int:\n    with Coverage() as cov:\n        has_distributive_law(code_ast)\n    lines = set()\n    for (name, line) in cov.coverage():\n        if name == has_distributive_law.__name__:\n            lines.add(line)\n    return len(lines) \n```", "```py\nast_fitness(ast.parse(\"1\")) \n```", "```py\n3\n\n```", "```py\nast_fitness(ast.parse(\"1 + 1\")) \n```", "```py\n4\n\n```", "```py\nast_fitness(ast.parse(\"1 * 2\")) \n```", "```py\n6\n\n```", "```py\nast_fitness(ast.parse(\"1 * (2 + 3)\")) \n```", "```py\n6\n\n```", "```py\ndef tree_fitness(tree) -> float:\n    code_str = str(tree)\n    code_ast = ast.fix_missing_locations(eval(code_str))\n    fitness = ast_fitness(code_ast)\n    # print(ast.unparse(code_ast), f\"\\n=> Fitness = {fitness}\\n\")\n    return fitness + 1 / len(code_str) \n```", "```py\ntree_fitness(sum_tree) \n```", "```py\n4.002666666666666\n\n```", "```py\ndef initial_population(tree):\n    return [ (tree, tree_fitness(tree)) ] \n```", "```py\nsum_population = initial_population(sum_tree) \n```", "```py\nlen(sum_population) \n```", "```py\n1\n\n```", "```py\nOFFSPRING = 2 \n```", "```py\ndef evolve(population, min_fitness=-1):\n    solver = ISLaSolver(python_ast_grammar)\n\n    for (candidate, _) in list(population):\n        for i in range(OFFSPRING):\n            child = solver.mutate(candidate, min_mutations=1, max_mutations=1)\n            child_fitness = tree_fitness(child)\n            if child_fitness > min_fitness:\n                population.append((child, child_fitness))\n    return population \n```", "```py\nsum_population = evolve(sum_population)\nlen(sum_population) \n```", "```py\n3\n\n```", "```py\nsum_population = evolve(sum_population)\nlen(sum_population) \n```", "```py\n9\n\n```", "```py\nsum_population = evolve(sum_population)\nlen(sum_population) \n```", "```py\n27\n\n```", "```py\nsum_population = evolve(sum_population)\nlen(sum_population) \n```", "```py\n81\n\n```", "```py\nsum_population = evolve(sum_population)\nlen(sum_population) \n```", "```py\n243\n\n```", "```py\nPOPULATION_SIZE = 100 \n```", "```py\ndef get_fitness(elem):\n    (candidate, fitness) = elem\n    return fitness\n\ndef select(population):\n    population = sorted(population, key=get_fitness, reverse=True)\n    population = population[:POPULATION_SIZE]\n    return population \n```", "```py\nsum_population = select(sum_population)\nlen(sum_population) \n```", "```py\n100\n\n```", "```py\nGENERATIONS = 100  # Upper bound \n```", "```py\ntrial = 1\nfound = False\n\nwhile not found:\n    sum_population = initial_population(sum_tree)\n    prev_best_fitness = -1\n\n    for generation in range(GENERATIONS):\n        sum_population = evolve(sum_population, min_fitness=prev_best_fitness)\n        sum_population = select(sum_population)\n        best_candidate, best_fitness = sum_population[0]\n        if best_fitness > prev_best_fitness:\n            print(f\"Generation {generation}: found new best candidate (fitness={best_fitness}):\")\n            best_ast = ast.fix_missing_locations(eval(str(best_candidate)))\n            print(ast.unparse(best_ast))\n            prev_best_fitness = best_fitness\n\n            if has_distributive_law(best_ast):\n                print(\"Done!\")\n                found = True\n                break\n\n    trial = trial + 1\n    print(f\"\\n\\nRestarting; trial #{trial}\") \n```", "```py\nGeneration 0: found new best candidate (fitness=4.002666666666666):\ndef sum(a, b):\n    the_sum = a + b\n    return the_sum\nGeneration 1: found new best candidate (fitness=4.0027027027027025):\ndef sum(a, b):\n    the_sum = a + b\n    return FE\nGeneration 4: found new best candidate (fitness=4.002865329512894):\ndef sum():\n    the_sum = a + b\n    return the_sum\nGeneration 5: found new best candidate (fitness=6.00094696969697):\nif set()[:] * *set():\n\n    def sum(a, b):\n        mc = a + b\n        return FE\nelse:\n    M = set()\ncontinue\n\nset().f[set():set()]()\nGeneration 7: found new best candidate (fitness=7.002364066193853):\ndef sum(a, b):\n    mc = (a + b) * ()\n    return FE\nDone!\n\nRestarting; trial #2\n\n```", "```py\nprint(ast.unparse(best_ast)) \n```", "```py\ndef sum(a, b):\n    mc = (a + b) * ()\n    return FE\n\n```", "```py\nassert has_distributive_law(best_ast) \n```", "```py\nassert '<BinOp>' in python_ast_grammar['<expr>'] \n```", "```py\nlen(python_ast_grammar['<expr>']) \n```", "```py\n15\n\n```", "```py\nassert 'Add()' in python_ast_grammar['<operator>']\nassert 'Mult()' in python_ast_grammar['<operator>'] \n```", "```py\nlen(python_ast_grammar['<operator>']) \n```", "```py\n13\n\n```", "```py\n(len(python_ast_grammar['<expr>'])       # chances of choosing a `BinOp`\n* len(python_ast_grammar['<operator>'])  # chances of choosing a `*`\n* len(python_ast_grammar['<expr>'])      # chances of choosing a `BinOp` as a child\n* len(python_ast_grammar['<operator>'])  # chances of choosing a `+`\n/ 2)   # two chances - one for the left child, one for the right \n```", "```py\n19012.5\n\n```", "```py\n@incollection{fuzzingbook2024:PythonFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Testing Compilers},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/PythonFuzzer.html}},\n    note = {Retrieved 2024-11-24 21:37:28+01:00},\n    url = {https://www.fuzzingbook.org/html/PythonFuzzer.html},\n    urldate = {2024-11-24 21:37:28+01:00}\n}\n\n```"]