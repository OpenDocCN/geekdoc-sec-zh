["```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nimport [Coverage](Coverage.html)\nimport [Intro_Testing](Intro_Testing.html) \n```", "```py\n>>> from [fuzzingbook.DynamicInvariants](DynamicInvariants.html) import <identifier> \n```", "```py\n>>> def sum(a, b):\n>>>     return a + b\n>>> with TypeAnnotator() as type_annotator:\n>>>     sum(1, 2)\n>>>     sum(-4, -5)\n>>>     sum(0, 0) \n```", "```py\n>>> print(type_annotator.typed_functions())\ndef sum(a: int, b: int) -> int:\n    return a + b \n```", "```py\n>>> with InvariantAnnotator() as inv_annotator:\n>>>     sum(1, 2)\n>>>     sum(-4, -5)\n>>>     sum(0, 0) \n```", "```py\n>>> print(inv_annotator.functions_with_invariants())\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: a == return_value - b)\n@postcondition(lambda return_value, b, a: b == return_value - a)\n@postcondition(lambda return_value, b, a: isinstance(return_value, int))\n@postcondition(lambda return_value, b, a: return_value == a + b)\n@postcondition(lambda return_value, b, a: return_value == b + a)\ndef sum(a, b):\n    return a + b \n```", "```py\ndef any_sqrt(x):\n    assert x >= 0  # Precondition\n\n    ...\n\n    assert result * result == x  # Postcondition\n    return result \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\ndef my_sqrt(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError, ExpectTimeout \n```", "```py\nwith ExpectError():\n    my_sqrt(\"foo\") \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/829521914.py\", line 2, in <module>\n    my_sqrt(\"foo\")\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2661069967.py\", line 4, in my_sqrt\n    guess = x / 2\n            ~~^~~\nTypeError: unsupported operand type(s) for /: 'str' and 'int' (expected)\n\n```", "```py\nwith ExpectError():\n    x = my_sqrt(0.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/1975547953.py\", line 2, in <module>\n    x = my_sqrt(0.0)\n        ^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2661069967.py\", line 7, in my_sqrt\n    guess = (approx + x / approx) / 2\n                      ~~^~~~~~~~\nZeroDivisionError: float division by zero (expected)\n\n```", "```py\nwith ExpectTimeout(1):\n    x = my_sqrt(-1.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/1349814288.py\", line 2, in <module>\n    x = my_sqrt(-1.0)\n        ^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2661069967.py\", line 5, in my_sqrt\n    while approx != guess:\n          ^^^^^^^^^^^^^^^\n  File \"Timeout.ipynb\", line 43, in timeout_handler\n    raise TimeoutError()\nTimeoutError (expected)\n\n```", "```py\ndef my_sqrt_with_type_annotations(x: float) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    return my_sqrt(x) \n```", "```py\n# import enforce \n```", "```py\n# @enforce.runtime_validation\n# def my_sqrt_with_checked_type_annotations(x: float) -> float:\n#     \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n#     return my_sqrt(x) \n```", "```py\n# with ExpectError():\n#     my_sqrt_with_checked_type_annotations(True) \n```", "```py\n# my_sqrt(True) \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html)\nimport [tempfile](https://docs.python.org/3/library/tempfile.html) \n```", "```py\nf = tempfile.NamedTemporaryFile(mode='w', suffix='.py')\nf.name \n```", "```py\n'/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpe7k1dgu9.py'\n\n```", "```py\nf.write(inspect.getsource(my_sqrt))\nf.write('\\n')\nf.write(inspect.getsource(my_sqrt_with_type_annotations))\nf.write('\\n')\nf.write(\"print(my_sqrt_with_type_annotations('123'))\\n\")\nf.flush() \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import print_file \n```", "```py\nprint_file(f.name) \n```", "```py\ndef my_sqrt(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\ndef my_sqrt_with_type_annotations(x: float) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    return my_sqrt(x)\n\nprint(my_sqrt_with_type_annotations('123'))\n\n```", "```py\nimport [subprocess](https://docs.python.org/3/library/subprocess.html) \n```", "```py\nresult = subprocess.run([\"mypy\", \"--strict\", f.name], universal_newlines=True, stdout=subprocess.PIPE)\ndel f  # Delete temporary file \n```", "```py\nprint(result.stdout) \n```", "```py\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpe7k1dgu9.py:1: error: Function is missing a type annotation  [no-untyped-def]\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpe7k1dgu9.py:12: error: Returning Any from function declared to return \"float\"  [no-any-return]\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpe7k1dgu9.py:12: error: Call to untyped function \"my_sqrt\" in typed context  [no-untyped-call]\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/tmpe7k1dgu9.py:14: error: Argument 1 to \"my_sqrt_with_type_annotations\" has incompatible type \"str\"; expected \"float\"  [arg-type]\nFound 4 errors in 1 file (checked 1 source file)\n\n```", "```py\ny = my_sqrt(25.0)\ny \n```", "```py\n5.0\n\n```", "```py\ny = my_sqrt(2.0)\ny \n```", "```py\n1.414213562373095\n\n```", "```py\nwith Tracker() as tracker:\n    function_to_be_tracked(...)\ninfo = tracker.collected_information() \n```", "```py\nimport [sys](https://docs.python.org/3/library/sys.html) \n```", "```py\nclass Tracker:\n    def __init__(self, log=False):\n        self._log = log\n        self.reset()\n\n    def reset(self):\n        self._calls = {}\n        self._stack = []\n\n    def traceit(self):\n  \"\"\"Placeholder to be overloaded in subclasses\"\"\"\n        pass\n\n    # Start of `with` block\n    def __enter__(self):\n        self.original_trace_function = sys.gettrace()\n        sys.settrace(self.traceit)\n        return self\n\n    # End of `with` block\n    def __exit__(self, exc_type, exc_value, tb):\n        sys.settrace(self.original_trace_function) \n```", "```py\nclass CallTracker(Tracker):\n    def traceit(self, frame, event, arg):\n  \"\"\"Tracking function: Record all calls and all args\"\"\"\n        if event == \"call\":\n            self.trace_call(frame, event, arg)\n        elif event == \"return\":\n            self.trace_return(frame, event, arg)\n\n        return self.traceit \n```", "```py\nclass CallTracker(CallTracker):\n    def trace_call(self, frame, event, arg):\n  \"\"\"Save current function name and args on the stack\"\"\"\n        code = frame.f_code\n        function_name = code.co_name\n        arguments = get_arguments(frame)\n        self._stack.append((function_name, arguments))\n\n        if self._log:\n            print(simple_call_string(function_name, arguments)) \n```", "```py\ndef get_arguments(frame):\n  \"\"\"Return call arguments in the given frame\"\"\"\n    # When called, all arguments are local variables\n    local_variables = dict(frame.f_locals)  # explicit copy\n    arguments = [(var, frame.f_locals[var]) for var in local_variables]\n    arguments.reverse()  # Want same order as call\n    return arguments \n```", "```py\nclass CallTracker(CallTracker):\n    def trace_return(self, frame, event, arg):\n  \"\"\"Get return value and store complete call with arguments and return value\"\"\"\n        code = frame.f_code\n        function_name = code.co_name\n        return_value = arg\n        # TODO: Could call get_arguments() here to also retrieve _final_ values of argument variables\n\n        called_function_name, called_arguments = self._stack.pop()\n        assert function_name == called_function_name\n\n        if self._log:\n            print(simple_call_string(function_name, called_arguments), \"returns\", return_value)\n\n        self.add_call(function_name, called_arguments, return_value) \n```", "```py\ndef simple_call_string(function_name, argument_list, return_value=None):\n  \"\"\"Return function_name(arg[0], arg[1], ...) as a string\"\"\"\n    call = function_name + \"(\" + \\\n        \", \".join([var + \"=\" + repr(value)\n                   for (var, value) in argument_list]) + \")\"\n\n    if return_value is not None:\n        call += \" = \" + repr(return_value)\n\n    return call \n```", "```py\nclass CallTracker(CallTracker):\n    def add_call(self, function_name, arguments, return_value=None):\n  \"\"\"Add given call to list of calls\"\"\"\n        if function_name not in self._calls:\n            self._calls[function_name] = []\n        self._calls[function_name].append((arguments, return_value)) \n```", "```py\nclass CallTracker(CallTracker):\n    def calls(self, function_name=None):\n  \"\"\"Return list of calls for function_name, \n or a mapping function_name -> calls for all functions tracked\"\"\"\n        if function_name is None:\n            return self._calls\n\n        return self._calls[function_name] \n```", "```py\nwith CallTracker(log=True) as tracker:\n    y = my_sqrt(25)\n    y = my_sqrt(2.0) \n```", "```py\nmy_sqrt(x=25)\nmy_sqrt(x=25) returns 5.0\nmy_sqrt(x=2.0)\nmy_sqrt(x=2.0) returns 1.414213562373095\n__exit__(tb=None, exc_value=None, exc_type=None, self=<__main__.CallTracker object at 0x10b64c920>)\n\n```", "```py\ncalls = tracker.calls('my_sqrt')\ncalls \n```", "```py\n[([('x', 25)], 5.0), ([('x', 2.0)], 1.414213562373095)]\n\n```", "```py\nmy_sqrt_argument_list, my_sqrt_return_value = calls[0]\nsimple_call_string('my_sqrt', my_sqrt_argument_list, my_sqrt_return_value) \n```", "```py\n'my_sqrt(x=25) = 5.0'\n\n```", "```py\ndef hello(name):\n    print(\"Hello,\", name) \n```", "```py\nwith CallTracker() as tracker:\n    hello(\"world\") \n```", "```py\nHello, world\n\n```", "```py\nhello_calls = tracker.calls('hello')\nhello_calls \n```", "```py\n[([('name', 'world')], None)]\n\n```", "```py\nhello_argument_list, hello_return_value = hello_calls[0]\nsimple_call_string('hello', hello_argument_list, hello_return_value) \n```", "```py\n\"hello(name='world')\"\n\n```", "```py\ntype(4) \n```", "```py\nint\n\n```", "```py\ntype(2.0) \n```", "```py\nfloat\n\n```", "```py\ntype([4]) \n```", "```py\nlist\n\n```", "```py\nparameter, value = my_sqrt_argument_list[0]\nparameter, type(value) \n```", "```py\n('x', int)\n\n```", "```py\ntype(my_sqrt_return_value) \n```", "```py\nfloat\n\n```", "```py\ndef my_sqrt_annotated(x: float) -> float:\n    return my_sqrt(x) \n```", "```py\nmy_sqrt_annotated.__annotations__ \n```", "```py\n{'x': float, 'return': float}\n\n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html)\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nmy_sqrt_source = inspect.getsource(my_sqrt)\nmy_sqrt_source \n```", "```py\n'def my_sqrt(x):\\n    \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\\n    approx = None\\n    guess = x / 2\\n    while approx != guess:\\n        approx = guess\\n        guess = (approx + x / approx) / 2\\n    return approx\\n'\n\n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import print_content \n```", "```py\nprint_content(my_sqrt_source, '.py') \n```", "```py\ndef my_sqrt(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nmy_sqrt_ast = ast.parse(my_sqrt_source) \n```", "```py\nprint(ast.dump(my_sqrt_ast, indent=4)) \n```", "```py\nModule(\n    body=[\n        FunctionDef(\n            name='my_sqrt',\n            args=arguments(\n                posonlyargs=[],\n                args=[\n                    arg(arg='x')],\n                kwonlyargs=[],\n                kw_defaults=[],\n                defaults=[]),\n            body=[\n                Expr(\n                    value=Constant(value='Computes the square root of x, using the Newton-Raphson method')),\n                Assign(\n                    targets=[\n                        Name(id='approx', ctx=Store())],\n                    value=Constant(value=None)),\n                Assign(\n                    targets=[\n                        Name(id='guess', ctx=Store())],\n                    value=BinOp(\n                        left=Name(id='x', ctx=Load()),\n                        op=Div(),\n                        right=Constant(value=2))),\n                While(\n                    test=Compare(\n                        left=Name(id='approx', ctx=Load()),\n                        ops=[\n                            NotEq()],\n                        comparators=[\n                            Name(id='guess', ctx=Load())]),\n                    body=[\n                        Assign(\n                            targets=[\n                                Name(id='approx', ctx=Store())],\n                            value=Name(id='guess', ctx=Load())),\n                        Assign(\n                            targets=[\n                                Name(id='guess', ctx=Store())],\n                            value=BinOp(\n                                left=BinOp(\n                                    left=Name(id='approx', ctx=Load()),\n                                    op=Add(),\n                                    right=BinOp(\n                                        left=Name(id='x', ctx=Load()),\n                                        op=Div(),\n                                        right=Name(id='approx', ctx=Load()))),\n                                op=Div(),\n                                right=Constant(value=2)))],\n                    orelse=[]),\n                Return(\n                    value=Name(id='approx', ctx=Load()))],\n            decorator_list=[],\n            type_params=[])],\n    type_ignores=[])\n\n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import rich_output \n```", "```py\nif rich_output():\n    import [showast](https://pypi.org/project/showast/)\n    showast.show_ast(my_sqrt_ast) \n```", "```py\nprint_content(ast.unparse(my_sqrt_ast), '.py') \n```", "```py\ndef my_sqrt(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\ndef parse_type(name):\n    class ValueVisitor(ast.NodeVisitor):\n        def visit_Expr(self, node):\n            self.value_node = node.value\n\n    tree = ast.parse(name)\n    name_visitor = ValueVisitor()\n    name_visitor.visit(tree)\n    return name_visitor.value_node \n```", "```py\nprint(ast.dump(parse_type('int'))) \n```", "```py\nName(id='int', ctx=Load())\n\n```", "```py\nprint(ast.dump(parse_type('[object]'))) \n```", "```py\nList(elts=[Name(id='object', ctx=Load())], ctx=Load())\n\n```", "```py\nTypeTransformer({'x': 'int'}, 'float').visit(ast) \n```", "```py\nclass TypeTransformer(ast.NodeTransformer):\n    def __init__(self, argument_types, return_type=None):\n        self.argument_types = argument_types\n        self.return_type = return_type\n        super().__init__() \n```", "```py\nclass TypeTransformer(TypeTransformer):\n    def visit_FunctionDef(self, node):\n  \"\"\"Add annotation to function\"\"\"\n        # Set argument types\n        new_args = []\n        for arg in node.args.args:\n            new_args.append(self.annotate_arg(arg))\n\n        new_arguments = ast.arguments(\n            node.args.posonlyargs,\n            new_args,\n            node.args.vararg,\n            node.args.kwonlyargs,\n            node.args.kw_defaults,\n            node.args.kwarg,\n            node.args.defaults\n        )\n\n        # Set return type\n        if self.return_type is not None:\n            node.returns = parse_type(self.return_type)\n\n        return ast.copy_location(\n            ast.FunctionDef(node.name, new_arguments, \n                            node.body, node.decorator_list,\n                            node.returns), node) \n```", "```py\nclass TypeTransformer(TypeTransformer):\n    def annotate_arg(self, arg):\n  \"\"\"Add annotation to single function argument\"\"\"\n        arg_name = arg.arg\n        if arg_name in self.argument_types:\n            arg.annotation = parse_type(self.argument_types[arg_name])\n        return arg \n```", "```py\nnew_ast = TypeTransformer({'x': 'int'}, 'float').visit(my_sqrt_ast) \n```", "```py\nprint_content(ast.unparse(new_ast), '.py') \n```", "```py\ndef my_sqrt(x: int) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nhello_source = inspect.getsource(hello) \n```", "```py\nhello_ast = ast.parse(hello_source) \n```", "```py\nnew_ast = TypeTransformer({'name': 'str'}, 'None').visit(hello_ast) \n```", "```py\nprint_content(ast.unparse(new_ast), '.py') \n```", "```py\ndef hello(name: str) -> None:\n    print('Hello,', name)\n\n```", "```py\ndef type_string(value):\n    return type(value).__name__ \n```", "```py\ntype_string(4) \n```", "```py\n'int'\n\n```", "```py\ntype_string([]) \n```", "```py\n'list'\n\n```", "```py\ntype_string([3]) \n```", "```py\n'list'\n\n```", "```py\nwith CallTracker() as tracker:\n    y = my_sqrt(25.0)\n    y = my_sqrt(2.0) \n```", "```py\ntracker.calls() \n```", "```py\n{'my_sqrt': [([('x', 25.0)], 5.0), ([('x', 2.0)], 1.414213562373095)]}\n\n```", "```py\ndef annotate_types(calls):\n    annotated_functions = {}\n\n    for function_name in calls:\n        try:\n            annotated_functions[function_name] = annotate_function_with_types(function_name, calls[function_name])\n        except KeyError:\n            continue\n\n    return annotated_functions \n```", "```py\ndef annotate_function_with_types(function_name, function_calls):\n    function = globals()[function_name]  # May raise KeyError for internal functions\n    function_code = inspect.getsource(function)\n    function_ast = ast.parse(function_code)\n    return annotate_function_ast_with_types(function_ast, function_calls) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Any \n```", "```py\ndef annotate_function_ast_with_types(function_ast, function_calls):\n    parameter_types = {}\n    return_type = None\n\n    for calls_seen in function_calls:\n        args, return_value = calls_seen\n        if return_value is not None:\n            if return_type is not None and return_type != type_string(return_value):\n                return_type = 'Any'\n            else:\n                return_type = type_string(return_value)\n\n        for parameter, value in args:\n            try:\n                different_type = parameter_types[parameter] != type_string(value)\n            except KeyError:\n                different_type = False\n\n            if different_type:\n                parameter_types[parameter] = 'Any'\n            else:\n                parameter_types[parameter] = type_string(value)\n\n    annotated_function_ast = TypeTransformer(parameter_types, return_type).visit(function_ast)\n    return annotated_function_ast \n```", "```py\nprint_content(ast.unparse(annotate_types(tracker.calls())['my_sqrt']), '.py') \n```", "```py\ndef my_sqrt(x: float) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nclass TypeTracker(CallTracker):\n    pass \n```", "```py\nclass TypeAnnotator(TypeTracker):\n    def typed_functions_ast(self, function_name=None):\n        if function_name is None:\n            return annotate_types(self.calls())\n\n        return annotate_function_with_types(function_name, \n                                            self.calls(function_name))\n\n    def typed_functions(self, function_name=None):\n        if function_name is None:\n            functions = ''\n            for f_name in self.calls():\n                try:\n                    f_text = ast.unparse(self.typed_functions_ast(f_name))\n                except KeyError:\n                    f_text = ''\n                functions += f_text\n            return functions\n\n        return ast.unparse(self.typed_functions_ast(function_name)) \n```", "```py\nwith TypeAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = my_sqrt(2.0) \n```", "```py\nprint_content(annotator.typed_functions(), '.py') \n```", "```py\ndef my_sqrt(x: float) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nwith TypeAnnotator() as annotator:\n    hello('type annotations')\n    y = my_sqrt(1.0) \n```", "```py\nHello, type annotations\n\n```", "```py\nprint_content(annotator.typed_functions(), '.py') \n```", "```py\ndef hello(name: str):\n    print('Hello,', name)def my_sqrt(x: float) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nwith CallTracker() as tracker:\n    y = my_sqrt(25.0)\n    y = my_sqrt(4) \n```", "```py\nprint_content(ast.unparse(annotate_types(tracker.calls())['my_sqrt']), '.py') \n```", "```py\ndef my_sqrt(x: Any) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\ndef sum3(a, b, c):\n    return a + b + c \n```", "```py\nwith TypeAnnotator() as annotator:\n    y = sum3(1.0, 2.0, 3.0)\ny \n```", "```py\n6.0\n\n```", "```py\nprint_content(annotator.typed_functions(), '.py') \n```", "```py\ndef sum3(a: float, b: float, c: float) -> float:\n    return a + b + c\n\n```", "```py\nwith TypeAnnotator() as annotator:\n    y = sum3(1, 2, 3)\ny \n```", "```py\n6\n\n```", "```py\nprint_content(annotator.typed_functions(), '.py') \n```", "```py\ndef sum3(a: int, b: int, c: int) -> int:\n    return a + b + c\n\n```", "```py\nwith TypeAnnotator() as annotator:\n    y = sum3(\"one\", \"two\", \"three\")\ny \n```", "```py\n'onetwothree'\n\n```", "```py\nprint_content(annotator.typed_functions(), '.py') \n```", "```py\ndef sum3(a: str, b: str, c: str) -> str:\n    return a + b + c\n\n```", "```py\nwith TypeAnnotator() as annotator:\n    y = sum3(1, 2, 3)\n    y = sum3(\"one\", \"two\", \"three\") \n```", "```py\ntyped_sum3_def = annotator.typed_functions('sum3') \n```", "```py\nprint_content(typed_sum3_def, '.py') \n```", "```py\ndef sum3(a: Any, b: Any, c: Any) -> Any:\n    return a + b + c\n\n```", "```py\ndef my_sqrt_with_invariants(x):\n    assert x >= 0  # Precondition\n\n    ...\n\n    assert result * result == x  # Postcondition\n    return result \n```", "```py\n@precondition lambda x: x >= 0\n@postcondition lambda return_value, x: return_value * return_value == x\ndef my_sqrt_with_invariants(x):\n    # normal code without assertions\n    ... \n```", "```py\nimport [functools](https://docs.python.org/3/library/functools.html) \n```", "```py\ndef condition(precondition=None, postcondition=None):\n    def decorator(func):\n        @functools.wraps(func) # preserves name, docstring, etc\n        def wrapper(*args, **kwargs):\n            if precondition is not None:\n               assert precondition(*args, **kwargs), \"Precondition violated\"\n\n            retval = func(*args, **kwargs) # call original function or method\n            if postcondition is not None:\n               assert postcondition(retval, *args, **kwargs), \"Postcondition violated\"\n\n            return retval\n        return wrapper\n    return decorator\n\ndef precondition(check):\n    return condition(precondition=check)\n\ndef postcondition(check):\n    return condition(postcondition=check) \n```", "```py\n@precondition(lambda x: x > 0)\ndef my_sqrt_with_precondition(x):\n    return my_sqrt(x) \n```", "```py\nwith ExpectError():\n    my_sqrt_with_precondition(-1.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2353876897.py\", line 2, in <module>\n    my_sqrt_with_precondition(-1.0)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 6, in wrapper\n    assert precondition(*args, **kwargs), \"Precondition violated\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Precondition violated (expected)\n\n```", "```py\nEPSILON = 1e-5 \n```", "```py\n@postcondition(lambda ret, x: ret * ret - x < EPSILON)\ndef my_sqrt_with_postcondition(x):\n    return my_sqrt(x) \n```", "```py\ny = my_sqrt_with_postcondition(2.0)\ny \n```", "```py\n1.414213562373095\n\n```", "```py\n@postcondition(lambda ret, x: ret * ret - x < EPSILON)\ndef buggy_my_sqrt_with_postcondition(x):\n    return my_sqrt(x) + 0.1 \n```", "```py\nwith ExpectError():\n    y = buggy_my_sqrt_with_postcondition(2.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/1985029262.py\", line 2, in <module>\n    y = buggy_my_sqrt_with_postcondition(2.0)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 10, in wrapper\n    assert postcondition(retval, *args, **kwargs), \"Postcondition violated\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Postcondition violated (expected)\n\n```", "```py\nINVARIANT_PROPERTIES = [\n    \"X < 0\",\n    \"X <= 0\",\n    \"X > 0\",\n    \"X >= 0\",\n    \"X == 0\",\n    \"X != 0\",\n] \n```", "```py\nINVARIANT_PROPERTIES += [\n    \"X == Y\",\n    \"X > Y\",\n    \"X < Y\",\n    \"X >= Y\",\n    \"X <= Y\",\n] \n```", "```py\nINVARIANT_PROPERTIES += [\n    \"isinstance(X, bool)\",\n    \"isinstance(X, int)\",\n    \"isinstance(X, float)\",\n    \"isinstance(X, list)\",\n    \"isinstance(X, dict)\",\n] \n```", "```py\nINVARIANT_PROPERTIES += [\n    \"X == Y + Z\",\n    \"X == Y * Z\",\n    \"X == Y - Z\",\n    \"X == Y / Z\",\n] \n```", "```py\nINVARIANT_PROPERTIES += [\n    \"X < Y < Z\",\n    \"X <= Y <= Z\",\n    \"X > Y > Z\",\n    \"X >= Y >= Z\",\n] \n```", "```py\nINVARIANT_PROPERTIES += [\n    \"X == len(Y)\",\n    \"X == sum(Y)\",\n    \"X.startswith(Y)\",\n] \n```", "```py\ndef metavars(prop):\n    metavar_list = []\n\n    class ArgVisitor(ast.NodeVisitor):\n        def visit_Name(self, node):\n            if node.id.isupper():\n                metavar_list.append(node.id)\n\n    ArgVisitor().visit(ast.parse(prop))\n    return metavar_list \n```", "```py\nassert metavars(\"X < 0\") == ['X'] \n```", "```py\nassert metavars(\"X.startswith(Y)\") == ['X', 'Y'] \n```", "```py\nassert metavars(\"isinstance(X, str)\") == ['X'] \n```", "```py\ndef instantiate_prop_ast(prop, var_names):\n    class NameTransformer(ast.NodeTransformer):\n        def visit_Name(self, node):\n            if node.id not in mapping:\n                return node\n            return ast.Name(id=mapping[node.id], ctx=ast.Load())\n\n    meta_variables = metavars(prop)\n    assert len(meta_variables) == len(var_names)\n\n    mapping = {}\n    for i in range(0, len(meta_variables)):\n        mapping[meta_variables[i]] = var_names[i]\n\n    prop_ast = ast.parse(prop, mode='eval')\n    new_ast = NameTransformer().visit(prop_ast)\n\n    return new_ast \n```", "```py\ndef instantiate_prop(prop, var_names):\n    prop_ast = instantiate_prop_ast(prop, var_names)\n    prop_text = ast.unparse(prop_ast).strip()\n    while prop_text.startswith('(') and prop_text.endswith(')'):\n        prop_text = prop_text[1:-1]\n    return prop_text \n```", "```py\nassert instantiate_prop(\"X > Y\", ['a', 'b']) == 'a > b' \n```", "```py\nassert instantiate_prop(\"X.startswith(Y)\", ['x', 'y']) == 'x.startswith(y)' \n```", "```py\ndef prop_function_text(prop):\n    return \"lambda \" + \", \".join(metavars(prop)) + \": \" + prop\n\ndef prop_function(prop):\n    return eval(prop_function_text(prop)) \n```", "```py\nprop_function_text(\"X > Y\") \n```", "```py\n'lambda X, Y: X > Y'\n\n```", "```py\np = prop_function(\"X > Y\")\np(100, 1) \n```", "```py\nTrue\n\n```", "```py\np(1, 100) \n```", "```py\nFalse\n\n```", "```py\nimport [itertools](https://docs.python.org/3/library/itertools.html) \n```", "```py\nfor combination in itertools.permutations([1.0, 2.0, 3.0], 2):\n    print(combination) \n```", "```py\n(1.0, 2.0)\n(1.0, 3.0)\n(2.0, 1.0)\n(2.0, 3.0)\n(3.0, 1.0)\n(3.0, 2.0)\n\n```", "```py\ndef true_property_instantiations(prop, vars_and_values, log=False):\n    instantiations = set()\n    p = prop_function(prop)\n\n    len_metavars = len(metavars(prop))\n    for combination in itertools.permutations(vars_and_values, len_metavars):\n        args = [value for var_name, value in combination]\n        var_names = [var_name for var_name, value in combination]\n\n        try:\n            result = p(*args)\n        except:\n            result = None\n\n        if log:\n            print(prop, combination, result)\n        if result:\n            instantiations.add((prop, tuple(var_names)))\n\n    return instantiations \n```", "```py\ninvs = true_property_instantiations(\"X < Y\", [('x', -1), ('y', 1)], log=True)\ninvs \n```", "```py\nX < Y (('x', -1), ('y', 1)) True\nX < Y (('y', 1), ('x', -1)) False\n\n```", "```py\n{('X < Y', ('x', 'y'))}\n\n```", "```py\nfor prop, var_names in invs:\n    print(instantiate_prop(prop, var_names)) \n```", "```py\nx < y\n\n```", "```py\ninvs = true_property_instantiations(\"X < 0\", [('x', -1), ('y', 1)], log=True) \n```", "```py\nX < 0 (('x', -1),) True\nX < 0 (('y', 1),) False\n\n```", "```py\nfor prop, var_names in invs:\n    print(instantiate_prop(prop, var_names)) \n```", "```py\nx < 0\n\n```", "```py\nclass InvariantTracker(CallTracker):\n    def __init__(self, props=None, **kwargs):\n        if props is None:\n            props = INVARIANT_PROPERTIES\n\n        self.props = props\n        super().__init__(**kwargs) \n```", "```py\nRETURN_VALUE = 'return_value' \n```", "```py\nclass InvariantTracker(InvariantTracker):\n    def invariants(self, function_name=None):\n        if function_name is None:\n            return {function_name: self.invariants(function_name) for function_name in self.calls()}\n\n        invariants = None\n        for variables, return_value in self.calls(function_name):\n            vars_and_values = variables + [(RETURN_VALUE, return_value)]\n\n            s = set()\n            for prop in self.props:\n                s |= true_property_instantiations(prop, vars_and_values, self._log)\n            if invariants is None:\n                invariants = s\n            else:\n                invariants &= s\n\n        return invariants \n```", "```py\nwith InvariantTracker() as tracker:\n    y = my_sqrt(25.0)\n    y = my_sqrt(10.0)\n\ntracker.calls() \n```", "```py\n{'my_sqrt': [([('x', 25.0)], 5.0), ([('x', 10.0)], 3.162277660168379)]}\n\n```", "```py\ninvs = tracker.invariants('my_sqrt')\ninvs \n```", "```py\n{('X != 0', ('return_value',)),\n ('X != 0', ('x',)),\n ('X < Y', ('return_value', 'x')),\n ('X <= Y', ('return_value', 'x')),\n ('X > 0', ('return_value',)),\n ('X > 0', ('x',)),\n ('X > Y', ('x', 'return_value')),\n ('X >= 0', ('return_value',)),\n ('X >= 0', ('x',)),\n ('X >= Y', ('x', 'return_value')),\n ('isinstance(X, float)', ('return_value',)),\n ('isinstance(X, float)', ('x',))}\n\n```", "```py\ndef pretty_invariants(invariants):\n    props = []\n    for (prop, var_names) in invariants:\n        props.append(instantiate_prop(prop, var_names))\n    return sorted(props) \n```", "```py\npretty_invariants(invs) \n```", "```py\n['isinstance(return_value, float)',\n 'isinstance(x, float)',\n 'return_value != 0',\n 'return_value < x',\n 'return_value <= x',\n 'return_value > 0',\n 'return_value >= 0',\n 'x != 0',\n 'x > 0',\n 'x > return_value',\n 'x >= 0',\n 'x >= return_value']\n\n```", "```py\nmy_sqrt(0.01) \n```", "```py\n0.1\n\n```", "```py\nwith InvariantTracker() as tracker:\n    y = my_sqrt(25.0)\n    y = my_sqrt(10.0)\n    y = my_sqrt(0.01)\n\npretty_invariants(tracker.invariants('my_sqrt')) \n```", "```py\n['isinstance(return_value, float)',\n 'isinstance(x, float)',\n 'return_value != 0',\n 'return_value > 0',\n 'return_value >= 0',\n 'x != 0',\n 'x > 0',\n 'x >= 0']\n\n```", "```py\nwith InvariantTracker() as tracker:\n    y = sum3(1, 2, 3)\n    y = sum3(-4, -5, -6)\n\npretty_invariants(tracker.invariants('sum3')) \n```", "```py\n['a != 0',\n 'b != 0',\n 'c != 0',\n 'isinstance(a, int)',\n 'isinstance(b, int)',\n 'isinstance(c, int)',\n 'isinstance(return_value, int)',\n 'return_value != 0']\n\n```", "```py\nwith InvariantTracker() as tracker:\n    y = sum3('a', 'b', 'c')\n    y = sum3('f', 'e', 'd')\n\npretty_invariants(tracker.invariants('sum3')) \n```", "```py\n['a != 0',\n 'a < return_value',\n 'a <= return_value',\n 'b != 0',\n 'c != 0',\n 'return_value != 0',\n 'return_value > a',\n 'return_value >= a',\n 'return_value.startswith(a)']\n\n```", "```py\nwith InvariantTracker() as tracker:\n    y = sum3('a', 'b', 'c')\n    y = sum3('c', 'b', 'a')\n    y = sum3(-4, -5, -6)\n    y = sum3(0, 0, 0)\n\npretty_invariants(tracker.invariants('sum3')) \n```", "```py\n[]\n\n```", "```py\nclass InvariantAnnotator(InvariantTracker):\n    def params(self, function_name):\n        arguments, return_value = self.calls(function_name)[0]\n        return \", \".join(arg_name for (arg_name, arg_value) in arguments) \n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = sum3(1, 2, 3) \n```", "```py\nannotator.params('my_sqrt') \n```", "```py\n'x'\n\n```", "```py\nannotator.params('sum3') \n```", "```py\n'c, b, a'\n\n```", "```py\nclass InvariantAnnotator(InvariantAnnotator):\n    def preconditions(self, function_name):\n        conditions = []\n\n        for inv in pretty_invariants(self.invariants(function_name)):\n            if inv.find(RETURN_VALUE) >= 0:\n                continue  # Postcondition\n\n            cond = \"@precondition(lambda \" + self.params(function_name) + \": \" + inv + \")\"\n            conditions.append(cond)\n\n        return conditions \n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = my_sqrt(0.01)\n    y = sum3(1, 2, 3) \n```", "```py\nannotator.preconditions('my_sqrt') \n```", "```py\n['@precondition(lambda x: isinstance(x, float))',\n '@precondition(lambda x: x != 0)',\n '@precondition(lambda x: x > 0)',\n '@precondition(lambda x: x >= 0)']\n\n```", "```py\nclass InvariantAnnotator(InvariantAnnotator):\n    def postconditions(self, function_name):\n        conditions = []\n\n        for inv in pretty_invariants(self.invariants(function_name)):\n            if inv.find(RETURN_VALUE) < 0:\n                continue  # Precondition\n\n            cond = (\"@postcondition(lambda \" + \n                RETURN_VALUE + \", \" + self.params(function_name) + \": \" + inv + \")\")\n            conditions.append(cond)\n\n        return conditions \n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = my_sqrt(0.01)\n    y = sum3(1, 2, 3) \n```", "```py\nannotator.postconditions('my_sqrt') \n```", "```py\n['@postcondition(lambda return_value, x: isinstance(return_value, float))',\n '@postcondition(lambda return_value, x: return_value != 0)',\n '@postcondition(lambda return_value, x: return_value > 0)',\n '@postcondition(lambda return_value, x: return_value >= 0)']\n\n```", "```py\nclass InvariantAnnotator(InvariantAnnotator):\n    def functions_with_invariants(self):\n        functions = \"\"\n        for function_name in self.invariants():\n            try:\n                function = self.function_with_invariants(function_name)\n            except KeyError:\n                continue\n            functions += function\n        return functions\n\n    def function_with_invariants(self, function_name):\n        function = globals()[function_name]  # Can throw KeyError\n        source = inspect.getsource(function)\n        return \"\\n\".join(self.preconditions(function_name) + \n                         self.postconditions(function_name)) + '\\n' + source \n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = my_sqrt(0.01)\n    y = sum3(1, 2, 3) \n```", "```py\nprint_content(annotator.function_with_invariants('my_sqrt'), '.py') \n```", "```py\n@precondition(lambda x: isinstance(x, float))\n@precondition(lambda x: x != 0)\n@precondition(lambda x: x > 0)\n@precondition(lambda x: x >= 0)\n@postcondition(lambda return_value, x: isinstance(return_value, float))\n@postcondition(lambda return_value, x: return_value != 0)\n@postcondition(lambda return_value, x: return_value > 0)\n@postcondition(lambda return_value, x: return_value >= 0)\ndef my_sqrt(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\ndef list_length(L):\n    if L == []:\n        length = 0\n    else:\n        length = 1 + list_length(L[1:])\n    return length \n```", "```py\nwith InvariantAnnotator() as annotator:\n    length = list_length([1, 2, 3])\n\nprint_content(annotator.functions_with_invariants(), '.py') \n```", "```py\n@precondition(lambda L: L != 0)\n@precondition(lambda L: isinstance(L, list))\n@postcondition(lambda return_value, L: isinstance(return_value, int))\n@postcondition(lambda return_value, L: return_value == len(L))\n@postcondition(lambda return_value, L: return_value >= 0)\ndef list_length(L):\n    if L == []:\n        length = 0\n    else:\n        length = 1 + list_length(L[1:])\n    return length\n\n```", "```py\ndef sum2(a, b):\n    return a + b \n```", "```py\nwith InvariantAnnotator() as annotator:\n    sum2(31, 45)\n    sum2(0, 0)\n    sum2(-1, -5) \n```", "```py\nprint_content(annotator.functions_with_invariants(), '.py') \n```", "```py\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: a == return_value - b)\n@postcondition(lambda return_value, b, a: b == return_value - a)\n@postcondition(lambda return_value, b, a: isinstance(return_value, int))\n@postcondition(lambda return_value, b, a: return_value == a + b)\n@postcondition(lambda return_value, b, a: return_value == b + a)\ndef sum2(a, b):\n    return a + b\n\n```", "```py\ndef print_sum(a, b):\n    print(a + b) \n```", "```py\nwith InvariantAnnotator() as annotator:\n    print_sum(31, 45)\n    print_sum(0, 0)\n    print_sum(-1, -5) \n```", "```py\n76\n0\n-6\n\n```", "```py\nprint_content(annotator.functions_with_invariants(), '.py') \n```", "```py\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: return_value != 0)\ndef print_sum(a, b):\n    print(a + b)\n\n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = my_sqrt(25.0)\n    y = my_sqrt(0.01) \n```", "```py\nmy_sqrt_def = annotator.functions_with_invariants()\nmy_sqrt_def = my_sqrt_def.replace('my_sqrt', 'my_sqrt_annotated') \n```", "```py\nprint_content(my_sqrt_def, '.py') \n```", "```py\n@precondition(lambda x: isinstance(x, float))\n@precondition(lambda x: x != 0)\n@precondition(lambda x: x > 0)\n@precondition(lambda x: x >= 0)\n@postcondition(lambda return_value, x: isinstance(return_value, float))\n@postcondition(lambda return_value, x: return_value != 0)\n@postcondition(lambda return_value, x: return_value > 0)\n@postcondition(lambda return_value, x: return_value >= 0)\ndef my_sqrt_annotated(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx\n\n```", "```py\nexec(my_sqrt_def) \n```", "```py\nwith ExpectError():\n    my_sqrt_annotated(-1.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/3390953352.py\", line 2, in <module>\n    my_sqrt_annotated(-1.0)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 8, in wrapper\n    retval = func(*args, **kwargs) # call original function or method\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 8, in wrapper\n    retval = func(*args, **kwargs) # call original function or method\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 6, in wrapper\n    assert precondition(*args, **kwargs), \"Precondition violated\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Precondition violated (expected)\n\n```", "```py\nwith ExpectTimeout(1):\n    my_sqrt(-1.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2605599394.py\", line 2, in <module>\n    my_sqrt(-1.0)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2661069967.py\", line 5, in my_sqrt\n    while approx != guess:\n          ^^^^^^^^^^^^^^^\n  File \"Timeout.ipynb\", line 43, in timeout_handler\n    raise TimeoutError()\nTimeoutError (expected)\n\n```", "```py\nmy_sqrt_def = my_sqrt_def.replace('my_sqrt_annotated', 'my_sqrt_negative')\nmy_sqrt_def = my_sqrt_def.replace('return approx', 'return -approx') \n```", "```py\nprint_content(my_sqrt_def, '.py') \n```", "```py\n@precondition(lambda x: isinstance(x, float))\n@precondition(lambda x: x != 0)\n@precondition(lambda x: x > 0)\n@precondition(lambda x: x >= 0)\n@postcondition(lambda return_value, x: isinstance(return_value, float))\n@postcondition(lambda return_value, x: return_value != 0)\n@postcondition(lambda return_value, x: return_value > 0)\n@postcondition(lambda return_value, x: return_value >= 0)\ndef my_sqrt_negative(x):\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx = None\n    guess = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return -approx\n\n```", "```py\nexec(my_sqrt_def) \n```", "```py\nwith ExpectError():\n    my_sqrt_negative(2.0) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2428286732.py\", line 2, in <module>\n    my_sqrt_negative(2.0)  # type: ignore\n    ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 8, in wrapper\n    retval = func(*args, **kwargs) # call original function or method\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 8, in wrapper\n    retval = func(*args, **kwargs) # call original function or method\n             ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 8, in wrapper\n    retval = func(*args, **kwargs) # call original function or method\n             ^^^^^^^^^^^^^^^^^^^^^\n  [Previous line repeated 4 more times]\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 10, in wrapper\n    assert postcondition(retval, *args, **kwargs), \"Postcondition violated\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Postcondition violated (expected)\n\n```", "```py\nwith InvariantAnnotator() as annotator:\n    y = sum2(2, 2)\nprint_content(annotator.functions_with_invariants(), '.py') \n```", "```py\n@precondition(lambda b, a: a != 0)\n@precondition(lambda b, a: a <= b)\n@precondition(lambda b, a: a == b)\n@precondition(lambda b, a: a > 0)\n@precondition(lambda b, a: a >= 0)\n@precondition(lambda b, a: a >= b)\n@precondition(lambda b, a: b != 0)\n@precondition(lambda b, a: b <= a)\n@precondition(lambda b, a: b == a)\n@precondition(lambda b, a: b > 0)\n@precondition(lambda b, a: b >= 0)\n@precondition(lambda b, a: b >= a)\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: a < return_value)\n@postcondition(lambda return_value, b, a: a <= b <= return_value)\n@postcondition(lambda return_value, b, a: a <= return_value)\n@postcondition(lambda return_value, b, a: a == return_value - b)\n@postcondition(lambda return_value, b, a: a == return_value / b)\n@postcondition(lambda return_value, b, a: b < return_value)\n@postcondition(lambda return_value, b, a: b <= a <= return_value)\n@postcondition(lambda return_value, b, a: b <= return_value)\n@postcondition(lambda return_value, b, a: b == return_value - a)\n@postcondition(lambda return_value, b, a: b == return_value / a)\n@postcondition(lambda return_value, b, a: isinstance(return_value, int))\n@postcondition(lambda return_value, b, a: return_value != 0)\n@postcondition(lambda return_value, b, a: return_value == a * b)\n@postcondition(lambda return_value, b, a: return_value == a + b)\n@postcondition(lambda return_value, b, a: return_value == b * a)\n@postcondition(lambda return_value, b, a: return_value == b + a)\n@postcondition(lambda return_value, b, a: return_value > 0)\n@postcondition(lambda return_value, b, a: return_value > a)\n@postcondition(lambda return_value, b, a: return_value > b)\n@postcondition(lambda return_value, b, a: return_value >= 0)\n@postcondition(lambda return_value, b, a: return_value >= a)\n@postcondition(lambda return_value, b, a: return_value >= a >= b)\n@postcondition(lambda return_value, b, a: return_value >= b)\n@postcondition(lambda return_value, b, a: return_value >= b >= a)\ndef sum2(a, b):\n    return a + b\n\n```", "```py\nwith InvariantAnnotator() as annotator:\n    length = sum2(1, 2)\n    length = sum2(-1, -2)\n    length = sum2(0, 0)\n\nprint_content(annotator.functions_with_invariants(), '.py') \n```", "```py\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: a == return_value - b)\n@postcondition(lambda return_value, b, a: b == return_value - a)\n@postcondition(lambda return_value, b, a: isinstance(return_value, int))\n@postcondition(lambda return_value, b, a: return_value == a + b)\n@postcondition(lambda return_value, b, a: return_value == b + a)\ndef sum2(a, b):\n    return a + b\n\n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer  # minor dependency\nfrom [Grammars](Grammars.html) import is_valid_grammar, crange  # minor dependency\nfrom [Grammars](Grammars.html) import convert_ebnf_grammar, Grammar  # minor dependency \n```", "```py\nSUM2_EBNF_GRAMMAR: Grammar = {\n    \"<start>\": [\"<sum2>\"],\n    \"<sum2>\": [\"sum2(<int>, <int>)\"],\n    \"<int>\": [\"<_int>\"],\n    \"<_int>\": [\"(-)?<leaddigit><digit>*\", \"0\"],\n    \"<leaddigit>\": crange('1', '9'),\n    \"<digit>\": crange('0', '9')\n} \n```", "```py\nassert is_valid_grammar(SUM2_EBNF_GRAMMAR) \n```", "```py\nsum2_grammar =  convert_ebnf_grammar(SUM2_EBNF_GRAMMAR) \n```", "```py\nsum2_fuzzer = GrammarFuzzer(sum2_grammar)\n[sum2_fuzzer.fuzz() for i in range(10)] \n```", "```py\n['sum2(60, 3)',\n 'sum2(-4, 0)',\n 'sum2(-579, 34)',\n 'sum2(3, 0)',\n 'sum2(-8, 0)',\n 'sum2(0, 8)',\n 'sum2(3, -9)',\n 'sum2(0, 0)',\n 'sum2(0, 5)',\n 'sum2(-3181, 0)']\n\n```", "```py\nwith InvariantAnnotator() as annotator:\n    for i in range(10):\n        eval(sum2_fuzzer.fuzz())\n\nprint_content(annotator.function_with_invariants('sum2'), '.py') \n```", "```py\n@precondition(lambda b, a: a != 0)\n@precondition(lambda b, a: isinstance(a, int))\n@precondition(lambda b, a: isinstance(b, int))\n@postcondition(lambda return_value, b, a: a == return_value - b)\n@postcondition(lambda return_value, b, a: b == return_value - a)\n@postcondition(lambda return_value, b, a: isinstance(return_value, int))\n@postcondition(lambda return_value, b, a: return_value != 0)\n@postcondition(lambda return_value, b, a: return_value == a + b)\n@postcondition(lambda return_value, b, a: return_value == b + a)\ndef sum2(a, b):\n    return a + b\n\n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Union, Optional \n```", "```py\ndef my_sqrt_with_union_type(x: Union[int, float]) -> float: \n    ... \n```", "```py\ndef my_sqrt_with_local_types(x: Union[int, float]) -> float:\n  \"\"\"Computes the square root of x, using the Newton-Raphson method\"\"\"\n    approx: Optional[float] = None\n    guess: float = x / 2\n    while approx != guess:\n        approx = guess\n        guess = (approx + x / approx) / 2\n    return approx \n```", "```py\n@precondition(lambda s: len(s) > 0)\ndef remove_first_char(s):\n    return s[1:] \n```", "```py\nwith ExpectError():\n    remove_first_char('') \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2212034949.py\", line 2, in <module>\n    remove_first_char('')\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/906718213.py\", line 6, in wrapper\n    assert precondition(*args, **kwargs), \"Precondition violated\"\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Precondition violated (expected)\n\n```", "```py\ndef verbose_condition(precondition=None, postcondition=None, doc='Unknown'):\n    def decorator(func):\n        @functools.wraps(func) # preserves name, docstring, etc\n        def wrapper(*args, **kwargs):\n            if precondition is not None:\n                assert precondition(*args, **kwargs), \"Precondition violated: \" + doc\n\n            retval = func(*args, **kwargs) # call original function or method\n            if postcondition is not None:\n                assert postcondition(retval, *args, **kwargs), \"Postcondition violated: \" + doc\n\n            return retval\n        return wrapper\n    return decorator \n```", "```py\ndef verbose_precondition(check, **kwargs):\n    return verbose_condition(precondition=check, doc=kwargs.get('doc', 'Unknown')) \n```", "```py\ndef verbose_postcondition(check, **kwargs):\n    return verbose_condition(postcondition=check, doc=kwargs.get('doc', 'Unknown')) \n```", "```py\n@verbose_precondition(lambda s: len(s) > 0, doc=\"len(s) > 0\")\ndef remove_first_char(s):\n    return s[1:]\n\nremove_first_char('abc') \n```", "```py\n'bc'\n\n```", "```py\nwith ExpectError():\n    remove_first_char('') \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/2212034949.py\", line 2, in <module>\n    remove_first_char('')\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_35443/860932556.py\", line 6, in wrapper\n    assert precondition(*args, **kwargs), \"Precondition violated: \" + doc\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError: Precondition violated: len(s) > 0 (expected)\n\n```", "```py\ndef my_sqrt(x):\n    'Computes the square root of x, using the Newton-Raphson method'\n    assert isinstance(x, int), 'violated precondition'\n    assert (x > 0), 'violated precondition'\n    approx = None\n    guess = (x / 2)\n    while (approx != guess):\n        approx = guess\n        guess = ((approx + (x / approx)) / 2)\n    return_value = approx\n    assert (return_value < x), 'violated postcondition'\n    assert isinstance(return_value, float), 'violated postcondition'\n    return approx \n```", "```py\n@incollection{fuzzingbook2024:DynamicInvariants,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Mining Function Specifications},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/DynamicInvariants.html}},\n    note = {Retrieved 2024-11-09 17:07:29+01:00},\n    url = {https://www.fuzzingbook.org/html/DynamicInvariants.html},\n    urldate = {2024-11-09 17:07:29+01:00}\n}\n\n```"]