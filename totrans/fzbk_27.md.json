["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('AJfRBF8NEWU') \n```", "```py\n>>> from [fuzzingbook.SymbolicFuzzer](SymbolicFuzzer.html) import <identifier> \n```", "```py\ndef gcd(a: int, b: int) -> int:\n    if a < b:\n        c: int = a\n        a = b\n        b = c\n\n    while b != 0:\n        c: int = a\n        a = b\n        b = c % b\n\n    return a \n```", "```py\n>>> gcd_fuzzer = SymbolicFuzzer(gcd, max_tries=10, max_iter=10, max_depth=10)\n>>> for i in range(10):\n>>>     args = gcd_fuzzer.fuzz()\n>>>     print(args)\n{'a': 8, 'b': 3}\n{'a': 1, 'b': 2}\n{'a': 2, 'b': 5}\n{'a': 7, 'b': 6}\n{'a': 9, 'b': 10}\n{'a': 4, 'b': 4}\n{'a': 10, 'b': 9}\n{'a': 2, 'b': 10}\n{'a': 14, 'b': 7}\n{'a': 3, 'b': 2} \n```", "```py\n>>> for i in range(10):\n>>>     args = gcd_fuzzer.fuzz()\n>>>     a = args['a'].as_long()\n>>>     b = args['b'].as_long()\n>>>     d = gcd(a, b)\n>>>     print(f\"gcd({a}, {b}) = {d}\")\ngcd(0, 8) = 8\ngcd(-1, 10) = -1\ngcd(13, 2) = 1\ngcd(0, 10) = 10\ngcd(6, 7) = 1\ngcd(14, 2) = 2\ngcd(-1, 11) = -1\ngcd(15, 0) = 15\ngcd(0, -1) = -1\ngcd(-3, -2) = -1 \n```", "```py\ndef check_triangle(a: int, b: int, c: int) -> str:\n    if a == b:\n        if a == c:\n            if b == c:\n                return \"Equilateral\"\n            else:\n                return \"Isosceles\"\n        else:\n            return \"Isosceles\"\n    else:\n        if b != c:\n            if a == c:\n                return \"Isosceles\"\n            else:\n                return \"Scalene\"\n        else:\n            return \"Isosceles\" \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nfrom [ControlFlow](ControlFlow.html) import PyCFG, to_graph, gen_cfg \n```", "```py\ndef show_cfg(fn, **kwargs):\n    return to_graph(gen_cfg(inspect.getsource(fn)), **kwargs) \n```", "```py\nshow_cfg(check_triangle) \n```", "```py\npaths = {\n    '<path 1>': ([1, 2, 3, 4, 5], 'Equilateral'),\n    '<path 2>': ([1, 2, 3, 4, 7], 'Isosceles'),\n    '<path 3>': ([1, 2, 3, 9], 'Isosceles'),\n    '<path 4>': ([1, 2, 11, 12, 13], 'Isosceles'),\n    '<path 5>': ([1, 2, 11, 12, 15], 'Scalene'),\n    '<path 6>': ([1, 2, 11, 17], 'Isosceles'),\n} \n```", "```py\n1: check_triangle(a, b, c)\n2: if (a == b) -> True\n3: if (a == c) -> True\n4: if (b == c) -> True\n5: return 'Equilateral' \n```", "```py\nimport [z3](https://github.com/Z3Prover/z3#readme) \n```", "```py\nz3_ver = z3.get_version()\nprint(z3_ver) \n```", "```py\n(4, 11, 2, 0)\n\n```", "```py\nassert z3_ver >= (4, 8, 6, 0), \"Please check z3 version\" \n```", "```py\ndef get_annotations(fn):\n    sig = inspect.signature(fn)\n    return ([(i.name, i.annotation)\n             for i in sig.parameters.values()], sig.return_annotation) \n```", "```py\nparams, ret = get_annotations(check_triangle)\nparams, ret \n```", "```py\n([('a', int), ('b', int), ('c', int)], str)\n\n```", "```py\nSYM_VARS = {\n    int: (\n        z3.Int, z3.IntVal), float: (\n            z3.Real, z3.RealVal), str: (\n                z3.String, z3.StringVal)} \n```", "```py\ndef get_symbolicparams(fn):\n    params, ret = get_annotations(fn)\n    return [SYM_VARS[typ][0](name)\n            for name, typ in params], SYM_VARS[ret][0]('__return__') \n```", "```py\n(a, b, c), r = get_symbolicparams(check_triangle)\na, b, c, r \n```", "```py\n(a, b, c, __return__)\n\n```", "```py\nz3.solve(a == b, a == c, b == c) \n```", "```py\n[a = 0, b = 0, c = 0]\n\n```", "```py\nfrom [ConcolicFuzzer](ConcolicFuzzer.html) import ArcCoverage  # minor dependency \n```", "```py\nwith ArcCoverage() as cov:\n    assert check_triangle(0, 0, 0) == 'Equilateral'\ncov._trace, cov.arcs() \n```", "```py\n([('check_triangle', 1),\n  ('check_triangle', 2),\n  ('check_triangle', 3),\n  ('check_triangle', 4),\n  ('check_triangle', 5),\n  ('__exit__', 102),\n  ('__exit__', 105)],\n [(1, 2), (2, 3), (3, 4), (4, 5), (5, 102), (102, 105)])\n\n```", "```py\nshow_cfg(check_triangle, arcs=cov.arcs()) \n```", "```py\nz3.solve(a == b, a == c, z3.Not(b == c)) \n```", "```py\nno solution\n\n```", "```py\nz3.solve(a == b, z3.Not(a == c)) \n```", "```py\n[b = 1, c = 0, a = 1]\n\n```", "```py\nwith ArcCoverage() as cov:\n    assert check_triangle(1, 1, 0) == 'Isosceles'\n[i for fn, i in cov._trace if fn == 'check_triangle'] \n```", "```py\n[1, 2, 3, 9]\n\n```", "```py\npaths['<path 3>'] \n```", "```py\n([1, 2, 3, 9], 'Isosceles')\n\n```", "```py\nz3.solve(z3.Not(a == b), b != c, a == c) \n```", "```py\n[b = 0, c = 1, a = 1]\n\n```", "```py\npre_condition = z3.And(a > 0, b > 0, c > 0) \n```", "```py\nz3.solve(pre_condition, z3.Not(a == b), b != c, a == c) \n```", "```py\n[c = 2, b = 1, a = 2]\n\n```", "```py\nwith ArcCoverage() as cov:\n    assert check_triangle(1, 2, 1) == 'Isosceles'\n[i for fn, i in cov._trace if fn == 'check_triangle'] \n```", "```py\n[1, 2, 11, 12, 13]\n\n```", "```py\npaths['<path 4>'] \n```", "```py\n([1, 2, 11, 12, 13], 'Isosceles')\n\n```", "```py\nz3.solve(pre_condition, z3.Not(a == b), b != c, z3.Not(a == c)) \n```", "```py\n[a = 1, c = 3, b = 2]\n\n```", "```py\nwith ArcCoverage() as cov:\n    assert check_triangle(3, 1, 2) == 'Scalene' \n```", "```py\npaths['<path 5>'] \n```", "```py\n([1, 2, 11, 12, 15], 'Scalene')\n\n```", "```py\nz3.solve(pre_condition, z3.Not(a == b), z3.Not(b != c)) \n```", "```py\n[c = 2, a = 1, b = 2]\n\n```", "```py\nwith ArcCoverage() as cov:\n    assert check_triangle(2, 1, 1) == 'Isosceles'\n[i for fn, i in cov._trace if fn == 'check_triangle'] \n```", "```py\n[1, 2, 11, 17]\n\n```", "```py\npaths['<path 6>'] \n```", "```py\n([1, 2, 11, 17], 'Isosceles')\n\n```", "```py\nseen = [z3.And(a == 2, b == 1, c == 1)] \n```", "```py\nz3.solve(pre_condition, z3.Not(z3.Or(seen)), z3.Not(a == b), z3.Not(b != c)) \n```", "```py\n[c = 2, a = 1, b = 2]\n\n```", "```py\nseen.append(z3.And(a == 1, b == 2, c == 2)) \n```", "```py\nz3.solve(pre_condition, z3.Not(z3.Or(seen)), z3.Not(a == b), z3.Not(b != c)) \n```", "```py\n[c = 1, a = 3, b = 1]\n\n```", "```py\nclass VisualizedArcCoverage(ArcCoverage):\n    def show_coverage(self, fn):\n        src = fn if isinstance(fn, str) else inspect.getsource(fn)\n        covered = set([lineno for method, lineno in self._trace])\n        for i, s in enumerate(src.split('\\n')):\n            print('%s  %2d: %s' % ('#' if i + 1 in covered else ' ', i + 1, s)) \n```", "```py\nwith VisualizedArcCoverage() as cov:\n    assert check_triangle(0, 0, 0) == 'Equilateral'\n    assert check_triangle(1, 1, 0) == 'Isosceles'\n    assert check_triangle(1, 2, 1) == 'Isosceles'\n    assert check_triangle(3, 1, 2) == 'Scalene'\n    assert check_triangle(2, 1, 1) == 'Isosceles' \n```", "```py\ncov.show_coverage(check_triangle) \n```", "```py\n#  1: def check_triangle(a: int, b: int, c: int) -> str:\n#  2:     if a == b:\n#  3:         if a == c:\n#  4:             if b == c:\n#  5:                 return \"Equilateral\"\n   6:             else:\n   7:                 return \"Isosceles\"\n   8:         else:\n#  9:             return \"Isosceles\"\n  10:     else:\n# 11:         if b != c:\n# 12:             if a == c:\n# 13:                 return \"Isosceles\"\n  14:             else:\n# 15:                 return \"Scalene\"\n  16:         else:\n# 17:             return \"Isosceles\"\n  18: \n\n```", "```py\ndef abs_value(x: float) -> float:\n    if x < 0:\n        v: float = -x\n    else:\n        v: float = x\n    return v \n```", "```py\nshow_cfg(abs_value) \n```", "```py\n(x,), r = get_symbolicparams(abs_value) \n```", "```py\nl2_T = x < 0\nl2_F = z3.Not(x < 0) \n```", "```py\nv_0 = z3.Real('v_0')\nl3 = z3.And(l2_T, v_0 == -x) \n```", "```py\nv_1 = z3.Real('v_1')\nl5 = z3.And(l2_F, v_1 == x) \n```", "```py\nv = z3.Real('v')\nfor s in [z3.And(l3, v == v_0), z3.And(l5, v == v_1)]:\n    z3.solve(x != 0, s) \n```", "```py\n[x = -1/2, v_0 = 1/2, v = 1/2]\n[v_1 = 1, x = 1, v = 1]\n\n```", "```py\nv = z3.Real('v')\nl6 = z3.Or(z3.And(l3, v == v_0), z3.And(l5, v == v_1))\nz3.solve(l6) \n```", "```py\n[v_1 = 1/2, x = -1/4, v_0 = 1/4, v = 1/4]\n\n```", "```py\ns = z3.Solver()\ns.add(l6)\nfor i in range(5):\n    if s.check() == z3.sat:\n        m = s.model()\n        x_val = m[x]\n        print(m)\n    else:\n        print('no solution')\n        break\n    s.add(z3.Not(x == x_val))\ns \n```", "```py\n[v_1 = 1/2, x = 1/2, v_0 = 0, v = 1/2]\n[v_1 = 0, x = 0, v = 0]\n[v_1 = 1/4, x = 1/4, v = 1/4]\n[v_1 = 1/8, x = 1/8, v = 1/8]\n[v_1 = 1/16, x = 1/16, v = 1/16]\n\n```", "```py\ns.add(x < 0)\nfor i in range(5):\n    if s.check() == z3.sat:\n        m = s.model()\n        x_val = m[x]\n        print(m)\n    else:\n        print('no solution')\n        break\n    s.add(z3.Not(x == x_val)) \n```", "```py\n[x = -1/32, v_0 = 1/32, v = 1/32]\n[x = -33/32, v_0 = 33/32, v = 33/32]\n[x = -65/32, v_0 = 65/32, v = 65/32]\n[x = -97/32, v_0 = 97/32, v = 97/32]\n[x = -129/32, v_0 = 129/32, v = 129/32]\n\n```", "```py\ns \n```", "```py\nabs_value_summary = l6\nabs_value_summary \n```", "```py\nz3.simplify(l6) \n```", "```py\n(define-fun  abs-value  ((x  Int))  Int\n  (if  (>  x  0)\n  x\n  (*  -1  x))) \n```", "```py\n(declare-fun  abs-value  (Int)  Int)\n(assert  (forall  ((x  Int))\n  (=  (abs-value  x)\n  (if  (>  x  0)\n  x\n  (*  -1  x))))) \n```", "```py\n(> (abs-value x) (abs-value y))\n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html) \n```", "```py\ndef prefix_vars(astnode, prefix):\n    if isinstance(astnode, ast.BoolOp):\n        return ast.BoolOp(astnode.op,\n                          [prefix_vars(i, prefix) for i in astnode.values], [])\n    elif isinstance(astnode, ast.BinOp):\n        return ast.BinOp(\n            prefix_vars(astnode.left, prefix), astnode.op,\n            prefix_vars(astnode.right, prefix))\n    elif isinstance(astnode, ast.UnaryOp):\n        return ast.UnaryOp(astnode.op, prefix_vars(astnode.operand, prefix))\n    elif isinstance(astnode, ast.Call):\n        return ast.Call(prefix_vars(astnode.func, prefix),\n                        [prefix_vars(i, prefix) for i in astnode.args],\n                        astnode.keywords)\n    elif isinstance(astnode, ast.Compare):\n        return ast.Compare(\n            prefix_vars(astnode.left, prefix), astnode.ops,\n            [prefix_vars(i, prefix) for i in astnode.comparators])\n    elif isinstance(astnode, ast.Name):\n        if astnode.id in {'And', 'Or', 'Not'}:\n            return ast.Name('z3.%s' % (astnode.id), astnode.ctx)\n        else:\n            return ast.Name('%s%s' % (prefix, astnode.id), astnode.ctx)\n    elif isinstance(astnode, ast.Return):\n        return ast.Return(prefix_vars(astnode.value, env))\n    else:\n        return astnode \n```", "```py\nxy_ast = ast.parse('x+y') \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import rich_output \n```", "```py\nif rich_output():\n    # Normally, this will do\n    from [showast](https://pypi.org/project/showast/) import show_ast\nelse:\n    def show_ast(tree):\n        ast.dump(tree, indent=4) \n```", "```py\nshow_ast(xy_ast) \n```", "```py\nxy_ast \n```", "```py\n<ast.Module at 0x116dfa6e0>\n\n```", "```py\nxy_ast.body[0] \n```", "```py\n<ast.Expr at 0x116dfa4a0>\n\n```", "```py\nxy_ast.body[0].value \n```", "```py\n<ast.BinOp at 0x116dfa2c0>\n\n```", "```py\ndef get_expression(src):\n    return ast.parse(src).body[0].value \n```", "```py\ne = get_expression('x+y')\ne \n```", "```py\n<ast.BinOp at 0x116df8a00>\n\n```", "```py\ndef to_src(astnode):\n    return ast.unparse(astnode).strip() \n```", "```py\nto_src(e) \n```", "```py\n'x + y'\n\n```", "```py\nabs_value_summary_ast = get_expression(str(abs_value_summary))\nprint(to_src(prefix_vars(abs_value_summary_ast, 'x1_'))) \n```", "```py\nz3.Or(z3.And(z3.And(x1_x < 0, x1_v_0 == -x1_x), x1_v == x1_v_0), z3.And(z3.And(z3.Not(x1_x < 0), x1_v_1 == x1_x), x1_v == x1_v_1))\n\n```", "```py\ndef z3_names_and_types(z3_ast):\n    hm = {}\n    children = z3_ast.children()\n    if children:\n        for c in children:\n            hm.update(z3_names_and_types(c))\n    else:\n        # HACK.. How else to distinguish literals and vars?\n        if (str(z3_ast.decl()) != str(z3_ast.sort())):\n            hm[\"%s\" % str(z3_ast.decl())] = 'z3.%s' % str(z3_ast.sort())\n        else:\n            pass\n    return hm \n```", "```py\nabs_value_declarations = z3_names_and_types(abs_value_summary)\nabs_value_declarations \n```", "```py\n{'x': 'z3.Real', 'v_0': 'z3.Real', 'v': 'z3.Real', 'v_1': 'z3.Real'}\n\n```", "```py\ndef used_identifiers(src):\n    def names(astnode):\n        lst = []\n        if isinstance(astnode, ast.BoolOp):\n            for i in astnode.values:\n                lst.extend(names(i))\n        elif isinstance(astnode, ast.BinOp):\n            lst.extend(names(astnode.left))\n            lst.extend(names(astnode.right))\n        elif isinstance(astnode, ast.UnaryOp):\n            lst.extend(names(astnode.operand))\n        elif isinstance(astnode, ast.Call):\n            for i in astnode.args:\n                lst.extend(names(i))\n        elif isinstance(astnode, ast.Compare):\n            lst.extend(names(astnode.left))\n            for i in astnode.comparators:\n                lst.extend(names(i))\n        elif isinstance(astnode, ast.Name):\n            lst.append(astnode.id)\n        elif isinstance(astnode, ast.Expr):\n            lst.extend(names(astnode.value))\n        elif isinstance(astnode, (ast.Num, ast.Str, ast.Tuple, ast.NameConstant)):\n            pass\n        elif isinstance(astnode, ast.Assign):\n            for t in astnode.targets:\n                lst.extend(names(t))\n            lst.extend(names(astnode.value))\n        elif isinstance(astnode, ast.Module):\n            for b in astnode.body:\n                lst.extend(names(b))\n        else:\n            raise Exception(str(astnode))\n        return list(set(lst))\n    return names(ast.parse(src)) \n```", "```py\nused_identifiers(str(abs_value_summary)) \n```", "```py\n['v_0', 'x', 'v', 'v_1']\n\n```", "```py\nfunction_summaries = {}\nfunction_summaries['abs_value'] = {\n    'predicate': str(abs_value_summary),\n    'vars': abs_value_declarations} \n```", "```py\nSYM_VARS_STR = {\n    k.__name__: (\"z3.%s\" % v1.__name__, \"z3.%s\" % v2.__name__)\n    for k, (v1, v2) in SYM_VARS.items()\n}\nSYM_VARS_STR \n```", "```py\n{'int': ('z3.Int', 'z3.IntVal'),\n 'float': ('z3.Real', 'z3.RealVal'),\n 'str': ('z3.String', 'z3.StringVal')}\n\n```", "```py\ndef translate_to_z3_name(v):\n    return SYM_VARS_STR[v][0] \n```", "```py\ndef declarations(astnode, hm=None):\n    if hm is None:\n        hm = {}\n    if isinstance(astnode, ast.Module):\n        for b in astnode.body:\n            declarations(b, hm)\n    elif isinstance(astnode, ast.FunctionDef):\n        # hm[astnode.name + '__return__'] = \\\n        # translate_to_z3_name(astnode.returns.id)\n        for a in astnode.args.args:\n            hm[a.arg] = translate_to_z3_name(a.annotation.id)\n        for b in astnode.body:\n            declarations(b, hm)\n    elif isinstance(astnode, ast.Call):\n        # get declarations from the function summary.\n        n = astnode.function\n        assert isinstance(n, ast.Name)  # for now.\n        name = n.id\n        hm.update(dict(function_summaries[name]['vars']))\n    elif isinstance(astnode, ast.AnnAssign):\n        assert isinstance(astnode.target, ast.Name)\n        hm[astnode.target.id] = translate_to_z3_name(astnode.annotation.id)\n    elif isinstance(astnode, ast.Assign):\n        # verify it is already defined\n        for t in astnode.targets:\n            assert isinstance(t, ast.Name)\n            assert t.id in hm\n    elif isinstance(astnode, ast.AugAssign):\n        assert isinstance(astnode.target, ast.Name)\n        assert astnode.target.id in hm\n    elif isinstance(astnode, (ast.If, ast.For, ast.While)):\n        for b in astnode.body:\n            declarations(b, hm)\n        for b in astnode.orelse:\n            declarations(b, hm)\n    elif isinstance(astnode, ast.Return):\n        pass\n    else:\n        raise Exception(str(astnode))\n    return hm \n```", "```py\ndeclarations(ast.parse('s: int = 3\\np: float = 4.0\\ns += 1')) \n```", "```py\n{'s': 'z3.Int', 'p': 'z3.Real'}\n\n```", "```py\ndef used_vars(fn):\n    return declarations(ast.parse(inspect.getsource(fn))) \n```", "```py\nused_vars(check_triangle) \n```", "```py\n{'a': 'z3.Int', 'b': 'z3.Int', 'c': 'z3.Int'}\n\n```", "```py\nused_vars(abs_value) \n```", "```py\n{'x': 'z3.Real', 'v': 'z3.Real'}\n\n```", "```py\ndef define_symbolic_vars(fn_vars, prefix):\n    sym_var_dec = ', '.join([prefix + n for n in fn_vars])\n    sym_var_def = ', '.join([\"%s('%s%s')\" % (t, prefix, n)\n                             for n, t in fn_vars.items()])\n    return \"%s = %s\" % (sym_var_dec, sym_var_def) \n```", "```py\ndefine_symbolic_vars(abs_value_declarations, '') \n```", "```py\n\"x, v_0, v, v_1 = z3.Real('x'), z3.Real('v_0'), z3.Real('v'), z3.Real('v_1')\"\n\n```", "```py\ndef gen_fn_summary(prefix, fn):\n    summary = function_summaries[fn.__name__]['predicate']\n    fn_vars = function_summaries[fn.__name__]['vars']\n    decl = define_symbolic_vars(fn_vars, prefix)\n    summary_ast = get_expression(summary)\n    return decl, to_src(prefix_vars(summary_ast, prefix)) \n```", "```py\ngen_fn_summary('a_', abs_value) \n```", "```py\n(\"a_x, a_v_0, a_v, a_v_1 = z3.Real('a_x'), z3.Real('a_v_0'), z3.Real('a_v'), z3.Real('a_v_1')\",\n 'z3.Or(z3.And(z3.And(a_x < 0, a_v_0 == -a_x), a_v == a_v_0), z3.And(z3.And(z3.Not(a_x < 0), a_v_1 == a_x), a_v == a_v_1))')\n\n```", "```py\ngen_fn_summary('b_', abs_value) \n```", "```py\n(\"b_x, b_v_0, b_v, b_v_1 = z3.Real('b_x'), z3.Real('b_v_0'), z3.Real('b_v'), z3.Real('b_v_1')\",\n 'z3.Or(z3.And(z3.And(b_x < 0, b_v_0 == -b_x), b_v == b_v_0), z3.And(z3.And(z3.Not(b_x < 0), b_v_1 == b_x), b_v == b_v_1))')\n\n```", "```py\ndef abs_max(a: float, b: float):\n    a1: float = abs_value(a)\n    b1: float = abs_value(b)\n    if a1 > b1:\n        c: float = a1\n    else:\n        c: float = b1\n    return c \n```", "```py\na = z3.Real('a')\nb = z3.Real('b') \n```", "```py\na1 = z3.Real('a1') \n```", "```py\nd, v = gen_fn_summary('abs1_', abs_value)\nd, v \n```", "```py\n(\"abs1_x, abs1_v_0, abs1_v, abs1_v_1 = z3.Real('abs1_x'), z3.Real('abs1_v_0'), z3.Real('abs1_v'), z3.Real('abs1_v_1')\",\n 'z3.Or(z3.And(z3.And(abs1_x < 0, abs1_v_0 == -abs1_x), abs1_v == abs1_v_0), z3.And(z3.And(z3.Not(abs1_x < 0), abs1_v_1 == abs1_x), abs1_v == abs1_v_1))')\n\n```", "```py\nl2_src = \"l2 = z3.And(a == abs1_x, a1 == abs1_v, %s)\" % v\nl2_src \n```", "```py\n'l2 = z3.And(a == abs1_x, a1 == abs1_v, z3.Or(z3.And(z3.And(abs1_x < 0, abs1_v_0 == -abs1_x), abs1_v == abs1_v_0), z3.And(z3.And(z3.Not(abs1_x < 0), abs1_v_1 == abs1_x), abs1_v == abs1_v_1)))'\n\n```", "```py\nexec(d)\nexec(l2_src) \n```", "```py\nl2 \n```", "```py\nb1 = z3.Real('b1')\nd, v = gen_fn_summary('abs2_', abs_value)\nl3_src = \"l3_ = z3.And(b == abs2_x, b1 == abs2_v, %s)\" % v\nexec(d)\nexec(l3_src) \n```", "```py\nl3_ \n```", "```py\nl3 = z3.And(l2, l3_) \n```", "```py\nl3 \n```", "```py\nz3.simplify(l3) \n```", "```py\nl4_cond = a1 > b1\nl4 = z3.And(l3, l4_cond) \n```", "```py\nc_0 = z3.Real('c_0')\nl5 = z3.And(l4, c_0 == a1) \n```", "```py\nl6 = z3.And(l3, z3.Not(l4_cond)) \n```", "```py\nc_1 = z3.Real('c_1')\nl7 = z3.And(l6, c_1 == b1) \n```", "```py\ns1 = z3.Solver()\ns1.add(l5)\ns1.check() \n```", "```py\nm1 = s1.model()\nsorted([(d, m1[d]) for d in m1.decls() if not d.name(\n).startswith('abs')], key=lambda x: x[0].name()) \n```", "```py\n[(a, 1/2), (a1, 1/2), (b, -1/4), (b1, 1/4), (c_0, 1/2)]\n\n```", "```py\ns2 = z3.Solver()\ns2.add(l7)\ns2.check() \n```", "```py\nm2 = s2.model()\nsorted([(d, m2[d]) for d in m2.decls() if not d.name(\n).startswith('abs')], key=lambda x: x[0].name()) \n```", "```py\n[(a, -1/2), (a1, 1/2), (b, 1/2), (b1, 1/2), (c_1, 1/2)]\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\nclass SimpleSymbolicFuzzer(Fuzzer):\n  \"\"\"Simple symbolic fuzzer\"\"\"\n\n    def __init__(self, fn, **kwargs):\n  \"\"\"Constructor.\n `fn` is the function to be fuzzed.\n Possible keyword parameters:\n * `max_depth` - the depth to which one should attempt\n to trace the execution (default 100) \n * `max_tries` - the maximum number of attempts\n we will try to produce a value before giving up (default 100)\n * `max_iter` - the number of iterations we will attempt (default 100).\n \"\"\"\n        self.fn_name = fn.__name__\n        py_cfg = PyCFG()\n        py_cfg.gen_cfg(inspect.getsource(fn))\n        self.fnenter, self.fnexit = py_cfg.functions[self.fn_name]\n        self.used_variables = used_vars(fn)\n        self.fn_args = list(inspect.signature(fn).parameters)\n        self.z3 = z3.Solver()\n\n        self.paths = None\n        self.last_path = None\n\n        self.options(kwargs)\n        self.process()\n\n    def process(self):\n        ...  # to be defined later \n```", "```py\nMAX_DEPTH = 100 \n```", "```py\nMAX_TRIES = 100 \n```", "```py\nMAX_ITER = 100 \n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def options(self, kwargs):\n        self.max_depth = kwargs.get('max_depth', MAX_DEPTH)\n        self.max_tries = kwargs.get('max_tries', MAX_TRIES)\n        self.max_iter = kwargs.get('max_iter', MAX_ITER)\n        self._options = kwargs \n```", "```py\nsymfz_ct = SimpleSymbolicFuzzer(check_triangle) \n```", "```py\nsymfz_ct.fnenter, symfz_ct.fnexit \n```", "```py\n(id:9 line[1] parents: [] : enter: check_triangle(a, b, c),\n id:10 line[1] parents: [14, 15, 16, 19, 20, 21] : exit: check_triangle(a, b, c))\n\n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def get_all_paths(self, fenter, depth=0):\n        if depth > self.max_depth:\n            raise Exception('Maximum depth exceeded')\n        if not fenter.children:\n            return [[(0, fenter)]]\n\n        fnpaths = []\n        for idx, child in enumerate(fenter.children):\n            child_paths = self.get_all_paths(child, depth + 1)\n            for path in child_paths:\n                # In a conditional branch, idx is 0 for IF, and 1 for Else\n                fnpaths.append([(idx, fenter)] + path)\n        return fnpaths \n```", "```py\nsymfz_ct = SimpleSymbolicFuzzer(check_triangle)\nall_paths = symfz_ct.get_all_paths(symfz_ct.fnenter) \n```", "```py\nlen(all_paths) \n```", "```py\n6\n\n```", "```py\nall_paths[1] \n```", "```py\n[(0, id:24 line[1] parents: [] : enter: check_triangle(a, b, c)),\n (0, id:26 line[2] parents: [24] : _if: a == b),\n (0, id:27 line[3] parents: [26] : _if: a == c),\n (1, id:28 line[4] parents: [27] : _if: b == c),\n (0, id:30 line[7] parents: [28] : return 'Isosceles'),\n (0,\n  id:25 line[1] parents: [29, 30, 31, 34, 35, 36] : exit: check_triangle(a, b, c))]\n\n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def process(self):\n        self.paths = self.get_all_paths(self.fnenter)\n        self.last_path = len(self.paths) \n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def extract_constraints(self, path):\n        predicates = []\n        for (idx, elt) in path:\n            if isinstance(elt.ast_node, ast.AnnAssign):\n                if elt.ast_node.target.id in {'_if', '_while'}:\n                    s = to_src(elt.ast_node.annotation)\n                    predicates.append((\"%s\" if idx == 0 else \"z3.Not(%s)\") % s)\n                elif isinstance(elt.ast_node.annotation, ast.Call):\n                    assert elt.ast_node.annotation.func.id == self.fn_name\n                else:\n                    node = elt.ast_node\n                    t = ast.Compare(node.target, [ast.Eq()], [node.value])\n                    predicates.append(to_src(t))\n            elif isinstance(elt.ast_node, ast.Assign):\n                node = elt.ast_node\n                t = ast.Compare(node.targets[0], [ast.Eq()], [node.value])\n                predicates.append(to_src(t))\n            else:\n                pass\n        return predicates \n```", "```py\nsymfz_ct = SimpleSymbolicFuzzer(check_triangle)\nall_paths = symfz_ct.get_all_paths(symfz_ct.fnenter)\nsymfz_ct.extract_constraints(all_paths[0]) \n```", "```py\n['a == b', 'a == c', 'b == c']\n\n```", "```py\nconstraints = symfz_ct.extract_constraints(all_paths[1])\nconstraints \n```", "```py\n['a == b', 'a == c', 'z3.Not(b == c)']\n\n```", "```py\nfrom [contextlib](https://docs.python.org/3/library/contextlib.html) import contextmanager \n```", "```py\n@contextmanager\ndef checkpoint(z3solver):\n    z3solver.push()\n    yield z3solver\n    z3solver.pop() \n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def solve_path_constraint(self, path):\n        # re-initializing does not seem problematic.\n        # a = z3.Int('a').get_id() remains the same.\n        constraints = self.extract_constraints(path)\n        decl = define_symbolic_vars(self.used_variables, '')\n        exec(decl)\n\n        solutions = {}\n        with checkpoint(self.z3):\n            st = 'self.z3.add(%s)' % ', '.join(constraints)\n            eval(st)\n            if self.z3.check() != z3.sat:\n                return {}\n            m = self.z3.model()\n            solutions = {d.name(): m[d] for d in m.decls()}\n            my_args = {k: solutions.get(k, None) for k in self.fn_args}\n        predicate = 'z3.And(%s)' % ','.join(\n            [\"%s == %s\" % (k, v) for k, v in my_args.items()])\n        eval('self.z3.add(z3.Not(%s))' % predicate)\n        return my_args \n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def get_next_path(self):\n        self.last_path -= 1\n        if self.last_path == -1:\n            self.last_path = len(self.paths) - 1\n        return self.paths[self.last_path] \n```", "```py\nclass SimpleSymbolicFuzzer(SimpleSymbolicFuzzer):\n    def fuzz(self):\n  \"\"\"Produce one solution for each path.\n Returns a mapping of variable names to (symbolic) Z3 values.\"\"\"\n        for i in range(self.max_tries):\n            res = self.solve_path_constraint(self.get_next_path())\n            if res:\n                return res\n\n        return {} \n```", "```py\na, b, c = None, None, None\nsymfz_ct = SimpleSymbolicFuzzer(check_triangle)\nfor i in range(1, 10):\n    args = symfz_ct.fuzz()\n    res = check_triangle(args['a'].as_long(),\n                         args['b'].as_long(),\n                         args['c'].as_long())\n    print(args, \"result:\", res) \n```", "```py\n{'a': 2, 'b': 3, 'c': 3} result: Isosceles\n{'a': 6, 'b': 4, 'c': 5} result: Scalene\n{'a': 8, 'b': 7, 'c': 8} result: Isosceles\n{'a': 9, 'b': 9, 'c': 10} result: Isosceles\n{'a': 11, 'b': 11, 'c': 11} result: Equilateral\n{'a': 13, 'b': 12, 'c': 12} result: Isosceles\n{'a': 16, 'b': 14, 'c': 15} result: Scalene\n{'a': 18, 'b': 17, 'c': 18} result: Isosceles\n{'a': 19, 'b': 19, 'c': 20} result: Isosceles\n\n```", "```py\nsymfz_av = SimpleSymbolicFuzzer(abs_value)\nfor i in range(1, 10):\n    args = symfz_av.fuzz()\n    abs_res = abs_value(args['x'].numerator_as_long() /\n                        args['x'].denominator_as_long())\n    print(args, \"result:\", abs_res) \n```", "```py\n{'x': 0} result: 0.0\n{'x': -1/2} result: 0.5\n{'x': 1/2} result: 0.5\n{'x': -1/4} result: 0.25\n{'x': 1/4} result: 0.25\n{'x': -3/8} result: 0.375\n{'x': 1/8} result: 0.125\n{'x': -3/2} result: 1.5\n{'x': 1/16} result: 0.0625\n\n```", "```py\ndef gcd(a: int, b: int) -> int:\n    if a < b:\n        c: int = a\n        a = b\n        b = c\n\n    while b != 0:\n        c: int = a\n        a = b\n        b = c % b\n\n    return a \n```", "```py\nshow_cfg(gcd) \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nwith ExpectError():\n    symfz_gcd = SimpleSymbolicFuzzer(gcd, max_depth=1000, max_iter=10)\n    for i in range(1, 100):\n        r = symfz_gcd.fuzz()\n        v = gcd(r['a'].as_long(), r['b'].as_long())\n        print(r, v) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/3731434224.py\", line 2, in <module>\n    symfz_gcd = SimpleSymbolicFuzzer(gcd, max_depth=1000, max_iter=10)\n                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/2089833100.py\", line 26, in __init__\n    self.process()\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/4234366425.py\", line 3, in process\n    self.paths = self.get_all_paths(self.fnenter)\n                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/228300930.py\", line 10, in get_all_paths\n    child_paths = self.get_all_paths(child, depth + 1)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/228300930.py\", line 10, in get_all_paths\n    child_paths = self.get_all_paths(child, depth + 1)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/228300930.py\", line 10, in get_all_paths\n    child_paths = self.get_all_paths(child, depth + 1)\n                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  [Previous line repeated 998 more times]\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/228300930.py\", line 4, in get_all_paths\n    raise Exception('Maximum depth exceeded')\nException: Maximum depth exceeded (expected)\n\n```", "```py\nclass SymbolicFuzzer(SimpleSymbolicFuzzer):\n  \"\"\"Symbolic fuzzing with reassignments and loop unrolling\"\"\"\n\n    def options(self, kwargs):\n        super().options(kwargs) \n```", "```py\ndef rename_variables(astnode, env):\n    if isinstance(astnode, ast.BoolOp):\n        fn = 'z3.And' if isinstance(astnode.op, ast.And) else 'z3.Or'\n        return ast.Call(\n            ast.Name(fn, None),\n            [rename_variables(i, env) for i in astnode.values], [])\n    elif isinstance(astnode, ast.BinOp):\n        return ast.BinOp(\n            rename_variables(astnode.left, env), astnode.op,\n            rename_variables(astnode.right, env))\n    elif isinstance(astnode, ast.UnaryOp):\n        if isinstance(astnode.op, ast.Not):\n            return ast.Call(\n                ast.Name('z3.Not', None),\n                [rename_variables(astnode.operand, env)], [])\n        else:\n            return ast.UnaryOp(astnode.op,\n                               rename_variables(astnode.operand, env))\n    elif isinstance(astnode, ast.Call):\n        return ast.Call(astnode.func,\n                        [rename_variables(i, env) for i in astnode.args],\n                        astnode.keywords)\n    elif isinstance(astnode, ast.Compare):\n        return ast.Compare(\n            rename_variables(astnode.left, env), astnode.ops,\n            [rename_variables(i, env) for i in astnode.comparators])\n    elif isinstance(astnode, ast.Name):\n        if astnode.id not in env:\n            env[astnode.id] = 0\n        num = env[astnode.id]\n        return ast.Name('_%s_%d' % (astnode.id, num), astnode.ctx)\n    elif isinstance(astnode, ast.Return):\n        return ast.Return(rename_variables(astnode.value, env))\n    else:\n        return astnode \n```", "```py\nenv = {'x': 1} \n```", "```py\nba = get_expression('x == 1 and y == 2')\ntype(ba) \n```", "```py\nast.BoolOp\n\n```", "```py\nassert to_src(rename_variables(ba, env)) == 'z3.And(_x_1 == 1, _y_0 == 2)' \n```", "```py\nbo = get_expression('x == 1 or y == 2')\ntype(bo.op) \n```", "```py\nast.Or\n\n```", "```py\nassert to_src(rename_variables(bo, env)) == 'z3.Or(_x_1 == 1, _y_0 == 2)' \n```", "```py\nb = get_expression('x + y')\ntype(b) \n```", "```py\nast.BinOp\n\n```", "```py\nassert to_src(rename_variables(b, env)) == '_x_1 + _y_0' \n```", "```py\nu = get_expression('-y')\ntype(u) \n```", "```py\nast.UnaryOp\n\n```", "```py\nassert to_src(rename_variables(u, env)) == '-_y_0' \n```", "```py\nun = get_expression('not y')\ntype(un.op) \n```", "```py\nast.Not\n\n```", "```py\nassert to_src(rename_variables(un, env)) == 'z3.Not(_y_0)' \n```", "```py\nc = get_expression('x == y')\ntype(c) \n```", "```py\nast.Compare\n\n```", "```py\nassert to_src(rename_variables(c, env)) == '_x_1 == _y_0' \n```", "```py\nf = get_expression('fn(x,y)')\ntype(f) \n```", "```py\nast.Call\n\n```", "```py\nassert to_src(rename_variables(f, env)) == 'fn(_x_1, _y_0)' \n```", "```py\nenv \n```", "```py\n{'x': 1, 'y': 0}\n\n```", "```py\nclass PNode:\n    def __init__(self, idx, cfgnode, parent=None, order=0, seen=None):\n        self.seen = {} if seen is None else seen\n        self.max_iter = MAX_ITER\n        self.idx, self.cfgnode, self.parent, self.order = idx, cfgnode, parent, order\n\n    def __repr__(self):\n        return \"PNode:%d[%s order:%d]\" % (self.idx, str(self.cfgnode),\n                                          self.order) \n```", "```py\ncfg = PyCFG()\ncfg.gen_cfg(inspect.getsource(gcd))\ngcd_fnenter, _ = cfg.functions['gcd'] \n```", "```py\nPNode(0, gcd_fnenter) \n```", "```py\nPNode:0[id:27 line[1] parents: [] : enter: gcd(a, b) order:0]\n\n```", "```py\nclass PNode(PNode):\n    def copy(self, order):\n        p = PNode(self.idx, self.cfgnode, self.parent, order, self.seen)\n        assert p.order == order\n        return p \n```", "```py\nPNode(0, gcd_fnenter).copy(1) \n```", "```py\nPNode:0[id:27 line[1] parents: [] : enter: gcd(a, b) order:1]\n\n```", "```py\nclass PNode(PNode):\n    def explore(self):\n        ret = []\n        for (i, n) in enumerate(self.cfgnode.children):\n            key = \"[%d]%s\" % (self.idx + 1, n)\n            ccount = self.seen.get(key, 0)\n            if ccount > self.max_iter:\n                continue  # drop this child\n            self.seen[key] = ccount + 1\n            pn = PNode(self.idx + 1, n, self.copy(i), seen=self.seen)\n            ret.append(pn)\n        return ret \n```", "```py\nPNode(0, gcd_fnenter).explore() \n```", "```py\n[PNode:1[id:29 line[2] parents: [27] : _if: a < b order:0]]\n\n```", "```py\nPNode(0, gcd_fnenter).explore()[0].explore() \n```", "```py\n[PNode:2[id:30 line[3] parents: [29] : c: int = a order:0],\n PNode:2[id:33 line[7] parents: [32, 29, 36] : _while: b != 0 order:0]]\n\n```", "```py\nclass PNode(PNode):\n    def get_path_to_root(self):\n        path = []\n        n = self\n        while n:\n            path.append(n)\n            n = n.parent\n        return list(reversed(path)) \n```", "```py\np = PNode(0, gcd_fnenter)\n[s.get_path_to_root() for s in p.explore()[0].explore()[0].explore()[0].explore()] \n```", "```py\n[[PNode:0[id:27 line[1] parents: [] : enter: gcd(a, b) order:0],\n  PNode:1[id:29 line[2] parents: [27] : _if: a < b order:0],\n  PNode:2[id:30 line[3] parents: [29] : c: int = a order:0],\n  PNode:3[id:31 line[4] parents: [30] : a = b order:0],\n  PNode:4[id:32 line[5] parents: [31] : b = c order:0]]]\n\n```", "```py\nclass PNode(PNode):\n    def __str__(self):\n        path = self.get_path_to_root()\n        ssa_path = to_single_assignment_predicates(path)\n        return ', '.join([to_src(p) for p in ssa_path]) \n```", "```py\ndef to_single_assignment_predicates(path):\n    env = {}\n    new_path = []\n    for i, node in enumerate(path):\n        ast_node = node.cfgnode.ast_node\n        new_node = None\n        if isinstance(ast_node, ast.AnnAssign) and ast_node.target.id in {\n                'exit'}:\n            new_node = None\n        elif isinstance(ast_node, ast.AnnAssign) and ast_node.target.id in {'enter'}:\n            args = [\n                ast.parse(\n                    \"%s == _%s_0\" %\n                    (a.id, a.id)).body[0].value for a in ast_node.annotation.args]\n            new_node = ast.Call(ast.Name('z3.And', None), args, [])\n        elif isinstance(ast_node, ast.AnnAssign) and ast_node.target.id in {'_if', '_while'}:\n            new_node = rename_variables(ast_node.annotation, env)\n            if node.order != 0:\n                assert node.order == 1\n                new_node = ast.Call(ast.Name('z3.Not', None), [new_node], [])\n        elif isinstance(ast_node, ast.AnnAssign):\n            assigned = ast_node.target.id\n            val = [rename_variables(ast_node.value, env)]\n            env[assigned] = 0 if assigned not in env else env[assigned] + 1\n            target = ast.Name('_%s_%d' %\n                              (ast_node.target.id, env[assigned]), None)\n            new_node = ast.Expr(ast.Compare(target, [ast.Eq()], val))\n        elif isinstance(ast_node, ast.Assign):\n            assigned = ast_node.targets[0].id\n            val = [rename_variables(ast_node.value, env)]\n            env[assigned] = 0 if assigned not in env else env[assigned] + 1\n            target = ast.Name('_%s_%d' %\n                              (ast_node.targets[0].id, env[assigned]), None)\n            new_node = ast.Expr(ast.Compare(target, [ast.Eq()], val))\n        elif isinstance(ast_node, (ast.Return, ast.Pass)):\n            new_node = None\n        else:\n            s = \"NI %s  %s\" % (type(ast_node), ast_node.target.id)\n            raise Exception(s)\n        new_path.append(new_node)\n    return new_path \n```", "```py\np = PNode(0, gcd_fnenter)\npath = p.explore()[0].explore()[0].explore()[0].get_path_to_root()\nspath = to_single_assignment_predicates(path) \n```", "```py\n[to_src(s) for s in spath] \n```", "```py\n['z3.And(a == _a_0, b == _b_0)', '_a_0 < _b_0', '_c_0 == _a_0', '_a_1 == _b_0']\n\n```", "```py\ndef identifiers_with_types(identifiers, defined):\n    with_types = dict(defined)\n    for i in identifiers:\n        if i[0] == '_':\n            nxt = i[1:].find('_', 1)\n            name = i[1:nxt + 1]\n            assert name in defined\n            typ = defined[name]\n            with_types[i] = typ\n    return with_types \n```", "```py\nclass SymbolicFuzzer(SymbolicFuzzer):\n    def extract_constraints(self, path):\n        return [to_src(p) for p in to_single_assignment_predicates(path) if p] \n```", "```py\nclass SymbolicFuzzer(SymbolicFuzzer):\n    def solve_path_constraint(self, path):\n        # re-initializing does not seem problematic.\n        # a = z3.Int('a').get_id() remains the same.\n        constraints = self.extract_constraints(path)\n        identifiers = [\n            c for i in constraints for c in used_identifiers(i)]  # <- changes\n        with_types = identifiers_with_types(\n            identifiers, self.used_variables)  # <- changes\n        decl = define_symbolic_vars(with_types, '')\n        exec(decl)\n\n        solutions = {}\n        with checkpoint(self.z3):\n            st = 'self.z3.add(%s)' % ', '.join(constraints)\n            eval(st)\n            if self.z3.check() != z3.sat:\n                return {}\n            m = self.z3.model()\n            solutions = {d.name(): m[d] for d in m.decls()}\n            my_args = {k: solutions.get(k, None) for k in self.fn_args}\n\n        predicate = 'z3.And(%s)' % ','.join(\n            [\"%s == %s\" % (k, v) for k, v in my_args.items()])\n        eval('self.z3.add(z3.Not(%s))' % predicate)\n\n        return my_args \n```", "```py\nclass SymbolicFuzzer(SymbolicFuzzer):\n    def get_all_paths(self, fenter):\n        path_lst = [PNode(0, fenter)]\n        completed = []\n        for i in range(self.max_iter):\n            new_paths = [PNode(0, fenter)]\n            for path in path_lst:\n                # explore each path once\n                if path.cfgnode.children:\n                    np = path.explore()\n                    for p in np:\n                        if path.idx > self.max_depth:\n                            break\n                        new_paths.append(p)\n                else:\n                    completed.append(path)\n            path_lst = new_paths\n        return completed + path_lst \n```", "```py\nasymfz_gcd = SymbolicFuzzer(\n    gcd, max_iter=10, max_tries=10, max_depth=10)\nall_paths = asymfz_gcd.get_all_paths(asymfz_gcd.fnenter) \n```", "```py\nlen(all_paths) \n```", "```py\n38\n\n```", "```py\nall_paths[37].get_path_to_root() \n```", "```py\n[PNode:0[id:40 line[1] parents: [] : enter: gcd(a, b) order:0],\n PNode:1[id:42 line[2] parents: [40] : _if: a < b order:1],\n PNode:2[id:46 line[7] parents: [45, 42, 49] : _while: b != 0 order:0],\n PNode:3[id:47 line[8] parents: [46] : c: int = a order:0],\n PNode:4[id:48 line[9] parents: [47] : a = b order:0],\n PNode:5[id:49 line[10] parents: [48] : b = c % b order:0],\n PNode:6[id:46 line[7] parents: [45, 42, 49] : _while: b != 0 order:0],\n PNode:7[id:47 line[8] parents: [46] : c: int = a order:0],\n PNode:8[id:48 line[9] parents: [47] : a = b order:0],\n PNode:9[id:49 line[10] parents: [48] : b = c % b order:0],\n PNode:10[id:46 line[7] parents: [45, 42, 49] : _while: b != 0 order:0]]\n\n```", "```py\nfor s in to_single_assignment_predicates(all_paths[37].get_path_to_root()):\n    if s is not None:\n        print(to_src(s)) \n```", "```py\nz3.And(a == _a_0, b == _b_0)\nz3.Not(_a_0 < _b_0)\n_b_0 != 0\n_c_0 == _a_0\n_a_1 == _b_0\n_b_1 == _c_0 % _b_0\n_b_1 != 0\n_c_1 == _a_1\n_a_2 == _b_1\n_b_2 == _c_1 % _b_1\n_b_2 != 0\n\n```", "```py\nconstraints = asymfz_gcd.extract_constraints(all_paths[37].get_path_to_root()) \n```", "```py\nconstraints \n```", "```py\n['z3.And(a == _a_0, b == _b_0)',\n 'z3.Not(_a_0 < _b_0)',\n '_b_0 != 0',\n '_c_0 == _a_0',\n '_a_1 == _b_0',\n '_b_1 == _c_0 % _b_0',\n '_b_1 != 0',\n '_c_1 == _a_1',\n '_a_2 == _b_1',\n '_b_2 == _c_1 % _b_1',\n '_b_2 != 0']\n\n```", "```py\nclass SymbolicFuzzer(SymbolicFuzzer):\n    def get_next_path(self):\n        self.last_path -= 1\n        if self.last_path == -1:\n            self.last_path = len(self.paths) - 1\n        return self.paths[self.last_path].get_path_to_root() \n```", "```py\nasymfz_gcd = SymbolicFuzzer(\n    gcd, max_tries=10, max_iter=10, max_depth=10)\ndata = []\nfor i in range(10):\n    r = asymfz_gcd.fuzz()\n    data.append((r['a'].as_long(), r['b'].as_long()))\n    v = gcd(*data[-1])\n    print(r, \"result:\", repr(v)) \n```", "```py\n{'a': 8, 'b': 3} result: 1\n{'a': 1, 'b': 2} result: 1\n{'a': 2, 'b': 5} result: 1\n{'a': 5, 'b': 2} result: 1\n{'a': 3, 'b': 4} result: 1\n{'a': 9, 'b': 9} result: 9\n{'a': 7, 'b': 6} result: 1\n{'a': 5, 'b': 10} result: 5\n{'a': 3, 'b': 1} result: 1\n{'a': 10, 'b': 7} result: 1\n\n```", "```py\nwith VisualizedArcCoverage() as cov:\n    for a, b in data:\n        gcd(a, b) \n```", "```py\ncov.show_coverage(gcd) \n```", "```py\n#  1: def gcd(a: int, b: int) -> int:\n#  2:     if a < b:\n#  3:         c: int = a  # type: ignore\n#  4:         a = b\n#  5:         b = c\n   6: \n#  7:     while b != 0:\n#  8:         c: int = a  # type: ignore\n#  9:         a = b\n# 10:         b = c % b\n  11: \n# 12:     return a\n  13: \n\n```", "```py\nshow_cfg(gcd, arcs=cov.arcs()) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Tuple \n```", "```py\ndef roots(a: float, b: float, c: float) -> Tuple[float, float]:\n    d: float = b * b - 4 * a * c\n    ax: float = 0.5 * d\n    bx: float = 0\n    while (ax - bx) > 0.1:\n        bx = 0.5 * (ax + d / ax)\n        ax = bx\n\n    s: float = bx\n    a2: float = 2 * a\n    ba2: float = b / a2\n\n    return -ba2 + s / a2, -ba2 - s / a2 \n```", "```py\ndef sym_to_float(v):\n    if v is None:\n        return math.inf\n    elif isinstance(v, z3.IntNumRef):\n        return v.as_long()\n    return v.numerator_as_long() / v.denominator_as_long() \n```", "```py\nasymfz_roots = SymbolicFuzzer(\n    roots,\n    max_tries=10,\n    max_iter=10,\n    max_depth=10) \n```", "```py\nwith ExpectError():\n    for i in range(100):\n        r = asymfz_roots.fuzz()\n        print(r)\n        d = [sym_to_float(r[i]) for i in ['a', 'b', 'c']]\n        v = roots(*d)\n        print(d, v) \n```", "```py\n{'a': 11/10, 'b': 0, 'c': -1/2}\n[1.1, 0.0, -0.5] (0.7045454545454545, -0.7045454545454545)\n{'a': 0, 'b': 58617/131072, 'c': -1/2}\n\n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/94617992.py\", line 6, in <module>\n    v = roots(*d)\n        ^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/2299859991.py\", line 11, in roots\n    ba2: float = b / a2\n                 ~~^~~~\nZeroDivisionError: float division by zero (expected)\n\n```", "```py\ndef roots2(a: float, b: float, c: float) -> Tuple[float, float]:\n    d: float = b * b - 4 * a * c\n\n    xa: float = 0.5 * d\n    xb: float = 0\n    while (xa - xb) > 0.1:\n        xb = 0.5 * (xa + d / xa)\n        xa = xb\n\n    s: float = xb\n\n    if a == 0:\n        return -c / b, -c / b  # only one solution\n\n    a2: float = 2 * a\n    ba2: float = b / a2\n    return -ba2 + s / a2, -ba2 - s / a2 \n```", "```py\nasymfz_roots = SymbolicFuzzer(\n    roots2,\n    max_tries=10,\n    max_iter=10,\n    max_depth=10) \n```", "```py\nwith ExpectError():\n    for i in range(1000):\n        r = asymfz_roots.fuzz()\n        d = [sym_to_float(r[i]) for i in ['a', 'b', 'c']]\n        v = roots2(*d)\n        #print(d, v) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/567876003.py\", line 5, in <module>\n    v = roots2(*d)\n        ^^^^^^^^^^\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_16239/714795544.py\", line 13, in roots2\n    return -c / b, -c / b  # only one solution\n           ~~~^~~\nZeroDivisionError: float division by zero (expected)\n\n```", "```py\nimport [math](https://docs.python.org/3/library/math.html) \n```", "```py\ndef roots3(a: float, b: float, c: float) -> Tuple[float, float]:\n    d: float = b * b - 4 * a * c\n\n    xa: float = 0.5 * d\n    xb: float = 0\n    while (xa - xb) > 0.1:\n        xb = 0.5 * (xa + d / xa)\n        xa = xb\n    s: float = xb\n\n    if a == 0:\n        if b == 0:\n            return math.inf, math.inf\n        return -c / b, -c / b  # only one solution\n\n    a2: float = 2 * a\n    ba2: float = b / a2\n    return -ba2 + s / a2, -ba2 - s / a2 \n```", "```py\nasymfz_roots = SymbolicFuzzer(\n    roots3,\n    max_tries=10,\n    max_iter=10,\n    max_depth=10) \n```", "```py\nfor i in range(10):\n    r = asymfz_roots.fuzz()\n    print(r)\n    d = [sym_to_float(r[i]) for i in ['a', 'b', 'c']]\n    v = roots3(*d)\n    print(d, v) \n```", "```py\n{'a': -1, 'b': 0, 'c': 0}\n[-1.0, 0.0, 0.0] (0.0, 0.0)\n{'a': -11/20, 'b': 0, 'c': 1}\n[-0.55, 0.0, 1.0] (-1.409090909090909, 1.409090909090909)\n{'a': -1/40, 'b': 0, 'c': 2}\n[-0.025, 0.0, 2.0] (0.0, 0.0)\n{'a': 0, 'b': -1/4, 'c': 3}\n[0.0, -0.25, 3.0] (12.0, 12.0)\n{'a': 0, 'b': 0, 'c': 4}\n[0.0, 0.0, 4.0] (inf, inf)\n{'a': 0, 'b': -777645/524288, 'c': 5}\n[0.0, -1.4832401275634766, 5.0] (3.370998334715712, 3.370998334715712)\n{'a': -2/91, 'b': 0, 'c': 91/40}\n[-0.02197802197802198, 0.0, 2.275] (0.0, 0.0)\n{'a': 0, 'b': 4/9, 'c': 6}\n[0.0, 0.4444444444444444, 6.0] (-13.5, -13.5)\n{'a': 0, 'b': 0, 'c': 7}\n[0.0, 0.0, 7.0] (inf, inf)\n{'a': -7/6, 'b': -1, 'c': 3/2}\n[-1.1666666666666667, -1.0, 1.5] (-1.7142857142857142, 0.857142857142857)\n\n```", "```py\ni = 0\nwhile i < 10:\n    i += 1 \n```", "```py\nclass SymbolicFuzzer(SymbolicFuzzer):\n    def get_all_paths(self, fenter):\n        path_lst = [PNode(0, fenter)]\n        completed = []\n        for i in range(self.max_iter):\n            new_paths = [PNode(0, fenter)]\n            for path in path_lst:\n                # explore each path once\n                if path.cfgnode.children:\n                    np = path.explore()\n                    for p in np:\n                        if path.idx > self.max_depth:\n                            break\n                        if self.can_be_satisfied(p):\n                            new_paths.append(p)\n                        else:\n                            break\n                else:\n                    completed.append(path)\n            path_lst = new_paths\n        return completed + path_lst \n```", "```py\nAdvancedSymbolicFuzzer = SymbolicFuzzer \n```", "```py\n@incollection{fuzzingbook2025:SymbolicFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Symbolic Fuzzing},\n    year = {2025},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/SymbolicFuzzer.html}},\n    note = {Retrieved 2025-01-22 09:37:42+01:00},\n    url = {https://www.fuzzingbook.org/html/SymbolicFuzzer.html},\n    urldate = {2025-01-22 09:37:42+01:00}\n}\n\n```"]