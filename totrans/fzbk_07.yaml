- en: 'Fuzzing: Breaking Things with Random Inputs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/Fuzzer.html](http://www.fuzzingbook.org/html/Fuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we'll start with one of the simplest test generation techniques.
    The key idea of random text generation, also known as *fuzzing*, is to feed a
    *string of random characters* into a program in the hope to uncover failures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should know fundamentals of software testing; for instance, from the chapter
    ["Introduction to Software Testing"](Intro_Testing.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have a decent understanding of Python; for instance, from the [Python
    tutorial](https://docs.python.org/3/tutorial/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can make these prerequisites explicit. First, we'll import a standard package
    required for working in notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, we explicitly import (and thus require) the earlier chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides two important classes, introduced in [A Fuzzing Architecture](#A-Fuzzing-Architecture):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Fuzzer` as a base class for fuzzers; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runner` as a base class for programs under test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Fuzzer` is a base class for fuzzers, with `RandomFuzzer` as a simple instantiation.
    The `fuzz()` method of `Fuzzer` objects returns a string with a generated input.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RandomFuzzer()` constructor allows a number of keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="254pt" height="191pt" viewBox="0.00 0.00 254.12 190.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 186.5)"><g
    id="node1" class="node"><title>RandomFuzzer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class RandomFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce random inputs."><text text-anchor="start" x="8" y="-43.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">RandomFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="RandomFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, min_length: int = 10, max_length: int
    = 100, char_start: int = 32, char_range: int = 32) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings of `min_length` to `max_length` characters
  prefs: []
  type: TYPE_NORMAL
- en: 'in the range [`char_start`, `char_start` + `char_range`)"><text text-anchor="start"
    x="24.5" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="24.5" y="-8.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>Fuzzer</title>
    <g id="a_node2"><a xlink:href="#" xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="33.88" y="-165.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node2_3"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node2_4"><a
    xlink:href="#" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="24.5" y="-143.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_5"><a xlink:href="#"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="24.5" y="-130.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_6"><a xlink:href="#" xlink:title="run(self,
    runner: Runner = <Runner object>) -> Tuple[subprocess.CompletedProcess, str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="24.5" y="-118" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">run()</text></a></g>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="runs(self, runner: Runner = <PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="24.5"
    y="-105.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>RandomFuzzer->Fuzzer</title></g> <g id="node3"
    class="node"><title>Legend</title> <text text-anchor="start" x="126.88" y="-46.25"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="126.88" y="-36.25" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="132.88" y="-36.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="126.88" y="-26.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="132.88" y="-26.25" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="126.88" y="-16.25" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="132.88" y="-16.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="126.88" y="-7.2" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Runners
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A `Fuzzer` can be paired with a `Runner`, which takes the fuzzed strings as
    input. Its result is a class-specific *status* and an *outcome* (`PASS`, `FAIL`,
    or `UNRESOLVED`). A `PrintRunner` will simply print out the given input and return
    a `PASS` outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A `ProgramRunner` will feed the generated input into an external program. Its
    result is a pair of the program status (a `CompletedProcess` instance) and an
    *outcome* (`PASS`, `FAIL`, or `UNRESOLVED`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="371pt" height="224pt" viewBox="0.00 0.00 371.12 224.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 220)"><g
    id="node1" class="node"><title>ProgramRunner</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ProgramRunner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test a program with inputs."><text text-anchor="start" x="8" y="-56.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProgramRunner</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="ProgramRunner"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, program: Union[str, List[str]]) ->
    None:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize.
  prefs: []
  type: TYPE_NORMAL
- en: '`program` is a program spec as passed to `subprocess.run()`"><text text-anchor="start"
    x="18.5" y="-34.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="run(self, inp: str = '''') ->
    Tuple[subprocess.CompletedProcess, str]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with `inp` as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return test outcome based on result of `subprocess.run()`."><text text-anchor="start"
    x="18.5" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">run()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="run_process(self, inp: str =
    '''') -> subprocess.CompletedProcess:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program with `inp` as input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return result of `subprocess.run()`."><text text-anchor="start" x="18.5" y="-7.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">run_process()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Runner</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Runner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for testing inputs."><text text-anchor="start" x="95.62" y="-199.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">Runner</text> <g id="a_node2_4"><a xlink:href="#" xlink:title="Runner"><g
    id="a_node2_5"><a xlink:href="#" xlink:title="FAIL = ''FAIL''"><text text-anchor="start"
    x="88.5" y="-176" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">FAIL</text></a></g> <g id="a_node2_6"><a xlink:href="#"
    xlink:title="PASS = ''PASS''"><text text-anchor="start" x="88.5" y="-163.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">PASS</text></a></g>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="UNRESOLVED = ''UNRESOLVED''"><text
    text-anchor="start" x="88.5" y="-150.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node2_8"><a xlink:href="#" xlink:title="Runner"><g id="a_node2_9"><a
    xlink:href="#" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize"><text text-anchor="start" x="88.5" y="-130.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_10"><a xlink:href="#"
    xlink:title="run(self, inp: str) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the runner with the given input"><text text-anchor="start" x="88.5" y="-118"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>ProgramRunner->Runner</title></g> <g id="node3"
    class="node"><title>PrintRunner</title> <g id="a_node3"><a xlink:href="#" xlink:title="class
    PrintRunner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple runner, printing the input."><text text-anchor="start" x="141.25" y="-43.7"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">PrintRunner</text> <g id="a_node3_11"><a xlink:href="#" xlink:title="PrintRunner"><g
    id="a_node3_12"><a xlink:href="#" xlink:title="run(self, inp) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: Print the given input"><text text-anchor="start" x="164.5" y="-21.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>PrintRunner->Runner</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="243.88"
    y="-52.62" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="243.88" y="-42.62" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="249.88" y="-42.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="243.88" y="-32.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="249.88" y="-32.62" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="243.88" y="-22.62" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="249.88" y="-22.62" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="243.88" y="-13.57" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: A Testing Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fuzzing was born in a "dark and stormy night in the Fall of 1988" [[Takanen
    *et al*, 2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)].
    Sitting in his apartment in Wisconsin, Madison, professor Barton Miller was connected
    to his university computer via a 1200 baud telephone line. The thunderstorm caused
    noise on the line, and this noise in turn caused the UNIX commands on either end
    to get bad inputs – and crash. The frequent crashes surprised him – surely, programs
    should be more robust than that? As a scientist, he wanted to investigate the
    extent of the problem and its causes. So he crafted a *programming exercise* for
    his students at the University of Wisconsin-Madison – an exercise that would have
    his students create the first fuzzers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the [assignment](http://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf)
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this project is to evaluate the robustness of various UNIX utility
    programs, given an unpredictable input stream. [...] First, you will build a *fuzz
    generator*. This is a program that will output a random character stream. Second,
    you will take the fuzz generator and use it to attack as many UNIX utilities as
    possible, with the goal of trying to break them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This assignment captures the essence of fuzzing: *Create random inputs, and
    see if they break things.* Just let it run long enough, and you''ll see.'
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Fuzzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us try to fulfill this assignment and build a fuzz generator. The idea is
    to produce random characters, adding them to a buffer string variable (`out`),
    and finally returning the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation uses the following Python features and functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`random.randrange(start, end)` – return a random number $[$ `start`, `end`
    $)$'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range(start, end)` – create an iterator (which can be used as a list) with
    integers in the range $[$ `start`, `end` $)$.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for elem in list: body` – execute `body` in a loop with `elem` taking each
    value from `list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for i in range(start, end): body` – execute `body` in a loop with `i` from
    `start` to `end` $-$ 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chr(n)` – return a character with ASCII code `n`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use random numbers, we have to import the respective module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here comes the actual `fuzzer()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With its default arguments, the `fuzzer()` function returns a string of random
    characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Bart Miller coined the term "fuzz" as the name for such random, unstructured
    data. Now imagine that this "fuzz" string was the input to a program expecting
    a specific input format – say, a comma-separated list of values, or an e-mail
    address. Would the program be able to process such an input without any problems?
  prefs: []
  type: TYPE_NORMAL
- en: If the above fuzzing input already is intriguing, consider that fuzzing can
    easily be set up to produce other kinds of input. For instance, we can also have
    `fuzzer()` produce a series of lowercase letters. We use `ord(c)` to return the
    ASCII code of the character `c`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Assume a program expects an identifier as its input. Would it expect such a
    long identifier?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Quiz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which of these produces strings with arbitrary long decimal numbers?
  prefs: []
  type: TYPE_NORMAL
- en: 'Indeed! It is the last one that does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing External Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us see what happens if we actually invoke an external program with fuzzed
    inputs. To this end, let us proceed in two steps. First, we create an *input file*
    with fuzzed test data; then we feed this input file into a program of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Input Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us obtain a temporary file name such that we do not clutter the file system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can now open this file for writing. The Python `open()` function opens a
    file into which we can then write arbitrary contents. It is commonly used in conjunction
    with the `with` statement, which ensures that the file is closed as soon as it
    is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the file was actually created by reading its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Invoking External Programs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have an input file, we can invoke a program on it. For the fun of
    it, let us test the `bc` calculator program, which takes an arithmetic expression
    and evaluates it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke `bc`, let us use the Python `subprocess` module. This is how this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `result`, we can check the program output. In the case of `bc`, this
    is the result of evaluating the arithmetic expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can also check the status. A value of 0 indicates that the program terminated
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Any error messages would be available in `results.stderr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Instead of `bc`, you can actually put in any program you like. Be aware, though,
    that if your program is able to change or even damage your system, there is quite
    a risk that the fuzzed input contains data or commands that do precisely this.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just for the fun of it, imagine you would test a file removal program - say
    `rm -fr FILE`, where `FILE` is a string produced by `fuzzer()`. What is the chance
    of `fuzzer()` (with default arguments) producing a `FILE` argument that results
    in deleting all your files?
  prefs: []
  type: TYPE_NORMAL
- en: The chance is actually higher than you may think. If you remove `/` (the root
    of all files), for instance, your entire file system will be gone. If you remove
    `.` (the current folder), all the files in the current directory will be gone.
  prefs: []
  type: TYPE_NORMAL
- en: The probability of generating a string that is exactly 1 character long is 1/101,
    this is because the length of the string is determined by calling random.randrange(0,
    max_length + 1), where the default value of max_length is 100\. Per the description
    given of random.randrange, that should return a random number in [0, 99 + 1).
    So, we end up with the inclusive range [0, 100] where there are 101 values in
    the interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `/` or `.` to be produced, you need a string length of 1 (chance: 1 out
    of 101) and one of these two characters (chance: 2 out of 32).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The above code block precludes the possibility of removing `~` (your home directory),
    this is because the probability of generating the character '~' is not 1/32; it
    is 0/32\. The characters are created by calling chr(random.randrange(char_start,
    char_start + char_range)), where the default value of char_start is 32 and the
    default value of char_range is 32\. The documentation for chr reads, "[r]eturn
    the string representing a character whose Unicode code point is the integer i."
    The Unicode code point for '~' is 126 and therefore, not in the interval [32,
    64).
  prefs: []
  type: TYPE_NORMAL
- en: If the code were to be changed so that char_range = 95 then the probability
    of obtaining the character '~' would be 1/94 , thus resulting in the probability
    of the event of deleting all files being equal to 0.000332
  prefs: []
  type: TYPE_NORMAL
- en: And all your files in the home directory will be gone
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: However, we can actually deal with any string as long as the *second* character
    is a space – after all, `rm -fr / WHATEVER` will first deal with `/`, and only
    then with whatever follows. The chances for the first character are 2 out of 32
    as the code block above only allows for the probability of obtaining a `/` or
    a `.` but not a `~`.
  prefs: []
  type: TYPE_NORMAL
- en: For the space the probability is 1 out of 32.
  prefs: []
  type: TYPE_NORMAL
- en: We have to include the term for the probability of obtaining at least 2 characters
    which is required for the scenario of obtaining a space as the second character.
    This probability is 99/101 because it is calculated as (1 - probability of obtaining
    a single character or no character at all), so it is equal to 1-(2/101).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the probability calculation for the event of deleting all files
    in the case of having a space for the second character is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[probability of obtaining ''/'' or ''. '' followed by a space] = [the probability
    of obtaining either the ''/'' character or the ''. '' character] *[the probability
    of obtaining space]* [Probability of getting at least 2 characters] = 0.001914'
  prefs: []
  type: TYPE_NORMAL
- en: Diagram of probability of obtaining at least 2 characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Given that fuzz tests are typically run millions of times, you really don't
    want to take this risk. Run your fuzzers in a safe environment that you can reset
    at will, such as a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Long-Running Fuzzing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now feed a large number of inputs into our tested program, to see whether
    it might crash on some. We store all results in the `runs` variable as pairs of
    input data and the actual result. (Note: running this may take a while.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now query `runs` for some statistics. For instance, we can query how
    many runs actually passed -- that is, there were no error messages. We use a *list
    comprehension* here: The form *expression* `for` *element* `in` *list* `if` *condition*
    returns a list of evaluated *expressions* in which each *element* comes from *list*
    if the *condition* was true. (Actually, a list comprehension returns a *list generator*,
    but for our purposes, the generator behaves like a list.) Here, we have the *expression*
    be 1 for all elements where *condition* holds, and we use `sum()` to sum over
    all elements in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Most inputs apparently are invalid – not a big surprise, as it is unlikely that
    a random input contains a valid arithmetic expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the first error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Are there any runs with messages other than `illegal character`, `parse error`,
    or `syntax error`? (Say, something like `crash` or `you found a fatal bug`?) Not
    very many:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe a crash would be indicated by `bc` just crashing. Unfortunately, the
    return code is never nonzero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How about we let the above `bc` test run for some more? While it is running,
    let us take a look on how the state of the art was in 1989.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs Fuzzers Find
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When Miller and his students ran their first fuzzers in 1989, they found an
    alarming result: About **a third of the UNIX utilities** they fuzzed had issues
    – they crashed, hung, or otherwise failed when confronted with fuzzing input [[Miller
    *et al*, 1990](https://doi.org/10.1145/96267.96279)]. This also included the `bc`
    program, above. (The `bc` above is a [modern reimplementation](https://git.gavinhoward.com/gavin/bc)
    whose author is a [staunch believer in fuzzing](https://git.gavinhoward.com/gavin/bc/src/branch/master/tests/fuzzing)!)'
  prefs: []
  type: TYPE_NORMAL
- en: Considering that many of these UNIX utilities were used in scripts that would
    also process network input, this was an alarming result. Programmers quickly built
    and ran their own fuzzers, rushed to fix the reported errors, and learned not
    to trust external inputs anymore.
  prefs: []
  type: TYPE_NORMAL
- en: What kind of problems did Miller's fuzzing experiment find? It turns out that
    the mistakes programmers made in 1990 are still the same mistakes being made today.
  prefs: []
  type: TYPE_NORMAL
- en: Buffer Overflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many programs have built-in maximum lengths for inputs and input elements.
    In languages like C, it is easy to excess these lengths without the program (or
    the programmer) even noticing, triggering so-called **buffer overflows**. The
    following code, for instance, happily copies the `input` string into a `weekday`
    string even if `input` has more than eight characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Ironically, this already fails if `input` is `"Wednesday"` (9 characters); any
    excess characters (here, `'y'` and the following `'\0'` string terminator) are
    simply copied to whatever resides in memory after `weekday`, triggering arbitrary
    behavior; maybe some boolean character variable which would be set from `'n'`
    to `'y'`. With fuzzing, it is very easy to produce arbitrary long inputs and input
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily simulate this buffer overflow behavior in a Python function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: And yes, it quickly crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `with ExpectError()` line in the above code ensures that the error message
    is printed, yet execution continues; this is to differentiate this "expected"
    error from "unexpected" errors in other code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Missing Error Checks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many programming languages do not have exceptions, but instead have functions
    return special **error codes** in exceptional circumstances. The C function `getchar()`,
    for instance, normally returns a character from the standard input; if no input
    is available anymore, it returns the special value `EOF` (end of file). Now assume
    a programmer is scanning the input for the next character, reading in characters
    with `getchar()` until a space character is read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What happens if the input ends prematurely, as would perfectly be feasible with
    fuzzing? Well, `getchar()` returns `EOF`, and keeps on returning `EOF` when called
    again; so the code above simply enters an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we can simulate such missing error checks. Here''s a function that will
    effectively hang if no space is present in the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using the timeout mechanism from our [Introduction to Testing](Intro_Testing.html),
    we can interrupt this function after some time. And yes, it does hang after a
    few fuzzing inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `with ExpectTimeout()` line in the above code ensures that execution of
    the enclosed code is interrupted after two seconds, printing the error message.
  prefs: []
  type: TYPE_NORMAL
- en: Rogue Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With fuzzing, it is easy to generate **uncommon values** in the input, causing
    all kinds of interesting behavior. Consider the following code, again in the C
    language, which first reads a buffer size from the input, and then allocates a
    buffer of the given size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What happens if `size` is very large, exceeding program memory? What happens
    if `size` is less than the number of characters following? What happens if `size`
    is negative? By providing a random number here, fuzzing can create all kinds of
    damages.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can easily simulate such rogue numbers in Python. The function `collapse_if_too_large()`
    fails if the passed value (a string) is too large after having been converted
    to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have `fuzzer()` create a string of digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: If we feed such numbers into `collapse_if_too_large()`, it will very soon fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If we really wanted to allocate that much memory on a system, having it quickly
    fail as above actually would be the better option. In reality, running out of
    memory may dramatically slow systems down, up to the point that they become totally
    unresponsive – and restarting is the only option.
  prefs: []
  type: TYPE_NORMAL
- en: One might argue that these are all problems of bad programming, or of bad programming
    languages. But then, there are thousands of people starting to program every day,
    and all of them make the same mistakes again and again, even today.
  prefs: []
  type: TYPE_NORMAL
- en: Catching Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Miller and his students built their first fuzzer, they could identify errors
    simply because the program would crash or hang – two conditions that are easy
    to identify. If the failures are more subtle, though, we need to come up with
    additional checks.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Checkers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Buffer overflows, as [discussed above](#Buffer-Overflows), are a particular
    instance of a more general problem: In languages like C and C++, a program can
    access arbitrary parts of its memory – even those parts that are uninitialized,
    already freed or simply not part of the data structure you are trying to access.
    This is necessary if you want to write an operating system, and great if you want
    a maximum of performance or control, but pretty bad if you want to avoid mistakes.
    Fortunately, there are tools that help catching such issues at runtime, and they
    are great when combined with fuzzing.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking Memory Accesses
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To catch problematic memory accesses during testing, one can run C programs
    in special *memory-checking* environments; at runtime, these check for each and
    every memory operation whether it accesses valid and initialized memory. A popular
    example is [LLVM Address Sanitizer](https://clang.llvm.org/docs/AddressSanitizer.html)
    which detects a whole set of potentially dangerous memory safety violations. In
    the following example we will compile a rather simple C program with this tool
    and provoke an out-of-bounds read by reading past an allocated portion of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile this C program with address sanitization enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If we run the program with an argument of `99`, it returns `buf[99]`, which
    is 42.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Accessing `buf[110]`, however, results in an out-of-bounds error in AddressSanitizer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you want to find errors in a C program, turning on such checks for fuzzing
    is fairly easy. It will slow down execution by a certain factor depending on the
    tool (for AddressSanitizer it is typically 2$\times$) and also consume more memory,
    but CPU cycles are dead cheap compared to the human effort it takes to find these
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-bounds accesses to memory are a great security risk, as they may let
    attackers access or even modify information that is not meant for them. As a famous
    example, the [HeartBleed bug](https://en.wikipedia.org/wiki/Heartbleed) was a
    security bug in the OpenSSL library, implementing cryptographic protocols that
    provide communications security over a computer network. (If you read this text
    in a browser, it is likely encrypted using these protocols.)
  prefs: []
  type: TYPE_NORMAL
- en: The HeartBleed bug was exploited by sending a specially crafted command to the
    SSL *heartbeat* service. A heartbeat service is used to check if the server on
    the other end is still alive. A client would send the service a string like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: to which the server would reply with `BIRD`, and the client would know the server
    is alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this service could be exploited by asking the server to reply
    with *more* than the requested set of letters. This is very well explained in
    this [XKCD comic](https://xkcd.com/1354/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![XKCD Comic](../Images/6b6685cb7a4fd6e38881d177a59f4484.png)'
  prefs: []
  type: TYPE_IMG
- en: '![XKCD Comic](../Images/4be606ce2f1ba917b9f5b31d3c40a689.png)'
  prefs: []
  type: TYPE_IMG
- en: '![XKCD Comic](../Images/62570bd228b59b31a896243c80a46f78.png)'
  prefs: []
  type: TYPE_IMG
- en: In the OpenSSL implementation, these memory contents could involve cryptographic
    certificates, private keys, and more – and worse, no one would notice that this
    memory just had been accessed. When the HeartBleed bug was discovered, it had
    been around for many years, and none would know whether and which secrets had
    already leaked; the quickly set up [HeartBleed announcement page](http://heartbleed.com/)
    said it all.
  prefs: []
  type: TYPE_NORMAL
- en: But how was HeartBleed discovered? Very simple. Researchers both at the Codenomicon
    company as well as with Google compiled the OpenSSL library with a memory sanitizer,
    and then happily flooded it with fuzzed commands. The memory sanitizer would then
    notice whether an out-of-bounds memory access had occurred – and actually, it
    would very quickly discover this.
  prefs: []
  type: TYPE_NORMAL
- en: A memory checker is just one of many checkers one can run to detect runtime
    errors during fuzzing. In the [chapter on mining function specifications](DynamicInvariants.html),
    we will learn more about how to define generic checkers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re done with `program`, so we clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Information Leaks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Information leaks may not only occur through illegal memory accesses; they
    can also occur within "valid" memory – if this "valid" memory contains sensitive
    information that should not leak out. Let us illustrate this issue in a Python
    program. To start with, let us create some program memory filled with actual data
    and random data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We add more "memory" characters to `secrets`, filled with `"deadbeef"` as marker
    for uninitialized memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We define a service (similar to the heartbeat service discussed above) that
    would take a reply to be sent back, as well as a length. It would store the reply
    to be sent in memory, and then send it back with the given length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This perfectly works for standard strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the length is greater than the length of the reply string, additional
    contents of memory spill out. Note that all of this still occurs within regular
    array bounds, so an address sanitizer would not be triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'How can one detect such issues? The idea is to identify information that should
    not leak out, such as the given secrets, but also uninitialized memory. We can
    simulate such a check in a small Python example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: With such a check, we find that secrets and/or uninitialized memory indeed leak
    out. In the [chapter on information flow](InformationFlow.html), we will discuss
    how to do this automatically, "tainting" sensitive information and values derived
    from them, and ensuring that "tainted" values do not leak out.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, you should always *enable as many automatic checkers as
    possible* during fuzzing. CPU cycles are cheap, and errors are expensive. If you
    only execute the program without an option to actually detect errors, you will
    be missing several opportunities.
  prefs: []
  type: TYPE_NORMAL
- en: Program-Specific Checkers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides generic checkers that apply to *all* programs on a given platform or
    in a given language, you can also devise *specific* checkers that apply to your
    program, or a subsystem. In the [chapter on testing](Intro_Testing.html), we already
    have hinted at techniques of [runtime verification](Intro_Testing.html#Runtime-Verification)
    that check function results at runtime for correctness.
  prefs: []
  type: TYPE_NORMAL
- en: One key idea for detecting errors early is the concept of *assertion* – a predicate
    that checks the input (precondition) and the result (postcondition) of important
    functions. The more assertions you have in your program, the higher your chances
    to detect errors during execution that would go undetected by generic checkers
    – notably during fuzzing. If you worry about the impact of assertions on performance,
    keep in mind that assertions can be turned off in production code (although it
    can be helpful to leave the most critical checks active).
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important uses of assertions for finding errors is *checking
    the integrity of complex data structures.* Let us illustrate the concept using
    a simple example. Suppose we have a mapping of airport codes to airports, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This list of airport codes may be pretty critical: if we have a spelling mistake
    in any of the airport codes, this may impact whatever application we have. We
    therefore introduce a function that checks the list for consistency. The consistency
    condition is called a *representation invariant*, and functions (or methods) that
    check it are therefore typically named `repOK()` for "the representation is ok".'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's have a checker for individual airport codes. The checker fails
    if the code is inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `code_repOK()` to check all elements in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add an invalid element to the list, our check would fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, rather than manipulating the list directly, we''d have a special
    function for adding elements; this could then also check whether the code is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This check also allows us to find out errors in argument lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: For maximum checking, though, the `add_new_airport()` function would also ensure
    the correct representation of the list of airport codes – *before* and *after*
    changing it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This catches the inconsistency introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The more `repOK()` assertions exist in your code, the more errors you will catch
    – even those specific to only your domain and problem. On top, such assertions
    document the *assumptions you made* during programming and thus help other programmers
    to understand your code and prevent errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a final example, let us consider a rather complex data structure – a [red-black
    tree](https://en.wikipedia.org/wiki/Red-black_tree), a self-balancing binary search
    tree. Implementing a red-black tree is not too hard, but getting it correct can
    be a task of several hours even for experienced programmers. A `repOK()` method,
    however, documents all the assumptions and checks them as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Here, `repOK()` is a method that runs on an object of the `RedBlackTree` class.
    It runs five different checks, all of which have their own assertions. Whenever
    an element is added or deleted, all these consistency checks are run automatically.
    If you have an error in any of these, the checkers will find them – if you run
    the tree through sufficiently many fuzzed inputs, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Static Code Checkers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many of the benefits from `repOK()` assertions can also be obtained by using
    *static type checkers* on your code. In Python, for instance, the [MyPy](http://mypy-lang.org)
    static checker can find type errors as soon as types of arguments are properly
    declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: If we now add a key with a non-string type, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'this would be caught by MyPy immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Statically checking more advanced properties such as the airport code consisting
    of exactly three uppercase characters or a tree being acyclic, however, quickly
    reach the limits of static checking. Your `repOK()` assertions will still be needed
    – best in conjunction with a good test generator.
  prefs: []
  type: TYPE_NORMAL
- en: A Fuzzing Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we'd like to reuse some parts of this chapter in the following ones, let
    us define things in a way that are easier to reuse, and in particular easier to
    *extend*. To this end, we introduce a number of *classes* that encapsulate the
    functionality above in a reusable way.
  prefs: []
  type: TYPE_NORMAL
- en: Runner Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first thing we introduce is the notion of a `Runner` – that is, an object
    whose job it is to execute some object with a given input. A runner typically
    is some program or function under test, but we can also have simpler runners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with a base class for runners. A runner essentially provides a
    method `run(input)` that is used to pass `input` (a string) to the runner. `run()`
    returns a pair (`result`, `outcome`). Here, `result` is a runner-specific value
    that gives details on the run; `outcome` is a value that classifies the result
    in three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Runner.PASS` – the test *passed*. The run produced correct results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runner.FAIL` – the test *failed*. The run produced incorrect results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Runner.UNRESOLVED` – the test neither passed nor failed. This happens if the
    run could not take place – for instance, because the input was invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: As a base class, `Runner` merely provides an interface for more complex runners
    that build on it. More specifically, we introduce *subclasses* that *inherit*
    the methods from their superclass in order to add additional methods or to override
    inherited methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one example of such a subclass: `PrintRunner` simply prints out everything
    that is given to it, overriding the inherited `run()` method. This is the default
    runner in many situations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is just the string we passed as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Still, at this point, we have no way to classify program behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The `ProgramRunner` class sends the input to the standard input of a program
    instead. The program is specified when creating a `ProgramRunner` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Here's a variant for binary (i.e., non-textual) input and output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us demonstrate a `ProgramRunner` using the `cat` program – a program that
    copies its input to its output. We see that a standard invocation of `cat` simply
    does the job, with the output of `cat` being the same as its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzer Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now define a *fuzzer* that actually feed data into a consumer. The base
    class for fuzzers provides one central method `fuzz()` that creates some input.
    The `run()` function then sends the fuzz() input to a runner, returning the outcome;
    `runs()` does this for a given number (`trials`) of times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: By default, `Fuzzer` objects do not do much, as their `fuzz()` function is merely
    an abstract placeholder. The subclass `RandomFuzzer`, however, implements the
    functionality of the `fuzzer()` function, above, adding a parameter `min_length`
    to specify a minimum length.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: With `RandomFuzzer`, we can now create a fuzzer whose configuration needs to
    be specified only once when creating the fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We can now send such generated inputs to our previously defined `cat` runner,
    verifying that `cat` actually does copy its (fuzzed) input to its output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Combining a `Fuzzer` with a `Runner`, however, is so common that we can use
    the `run()` method supplied by the `Fuzzer` class for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: With `runs()`, we can repeat a fuzzing run a number of times, obtaining a list
    of results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have all in place to create fuzzers – starting with the simple
    random fuzzers introduced in this chapter, but even far more advanced ones. Stay
    tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomly generating inputs ("fuzzing") is a simple, cost-effective way to quickly
    test arbitrary programs for their robustness.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs fuzzers find are mainly due to errors and deficiencies in *input processing*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To catch errors, have as many *consistency checkers* as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re done, so don''t forget to clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From here, you can explore how to
  prefs: []
  type: TYPE_NORMAL
- en: '[use *mutations* on existing inputs to get more valid inputs](MutationFuzzer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[use *grammars* to specify the input format and thus get many more valid inputs](Grammars.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[reduce *failing inputs* for efficient debugging](Reducer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enjoy the read!
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Books on generating software tests in general are scarce (which is why we wrote
    this book). There are a few notable books on *fuzzing,* though, also based on
    the basic fuzzing techniques introduced in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The book "Fuzzing – Brute Force Vulnerability Discovery" covers a wide range
    of fuzzing domains, including files, Web pages, environment variables, and network
    protocols. The authors bring in lots of experience from fuzzing at Microsoft,
    and include a number of ready-made tools for Windows and UNIX programs. The tools
    have aged somewhat, but the principles remain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book "Fuzzing for Software Security Testing and Quality Assurance" [[Takanen
    *et al*, 2008](http://us.artechhouse.com/Fuzzing-for-Software-Security-Testing-and-Quality-Assurance-Second-Edition-P1930.aspx)],
    now in its second edition 2018, covers a wide range of fuzzing tools and detection
    techniques; its authors bring in plenty of experience from security testing and
    vulnerability discovery. This is arguably one of the most comprehensive and up-to-date
    books on the field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically for this chapter, the seminal work on fuzzing, introducing both
    the term and the approach, is "An Empirical Study of the Reliability of UNIX Utilities"
    [[Miller *et al*, 1990](https://doi.org/10.1145/96267.96279)]. As the foundation
    for the field, this is a must-read for anyone interested in fuzzing and robustness
    testing, with observations as valid today as they were 30 years ago.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the errors found by Miller et al. [[Miller *et al*, 1990](https://doi.org/10.1145/96267.96279)]
    involves the *troff* typesetting system. *Troff* takes as input a text consisting
    of lines; a line beginning with a dot (`.`) includes typesetting commands, as
    in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: which would produce (using `nroff -ms`) the text
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: At the time of Miller et al., *troff* would fail if its input included
  prefs: []
  type: TYPE_NORMAL
- en: The input sequence `\D` (backslash + D) followed by a non-printable character
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A character in the ASCII range 128–255 (i.e., the 8th bit is set) followed by
    a newline character
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single dot (`.`) followed by a newline character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise 1: Simulate Troff'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each of the above, write a Python function `f(s)` that fails if `s` fulfills
    the failure criterion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Run Simulated Troff'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a class `TroffRunner` as subclass of `Runner` that checks for the above
    predicates. Run it with `Fuzzer`. Be sure to have the `Fuzzer` object produce
    the entire range of characters. Count how frequently the individual predicates
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Run Real Troff'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `BinaryProgramRunner`, apply the fuzzer you configured on the real `troff`
    program. Check if you can produce any run whose output code is non-zero, indicating
    a failure or a crash.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Fuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Fuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing: Breaking Things with Random Inputs](https://www.fuzzingbook.org/html/Fuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Fuzzer.html](https://www.fuzzingbook.org/html/Fuzzer.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
