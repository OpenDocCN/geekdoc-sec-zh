- en: Mutation Analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/MutationAnalysis.html](http://www.fuzzingbook.org/html/MutationAnalysis.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In the [chapter on coverage](Coverage.html), we showed how one can identify
    which parts of the program are executed by a program, and hence get a sense of
    the effectiveness of a set of test cases in covering the program structure. However,
    coverage alone may not be the best measure for the effectiveness of a test, as
    one can have great coverage without ever checking a result for correctness. In
    this chapter, we introduce another means for assessing the effectiveness of a
    test suite: After injecting *mutations* – *artificial faults* – into the code,
    we check whether a test suite can detect these artificial faults. The idea is
    that if it fails to detect such mutations, it will also miss real bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You need some understanding of how a program is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have read [the chapter on coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces two methods of running *mutation analysis* on subject
    programs. The first class `MuFunctionAnalyzer` targets individual functions. Given
    a function `gcd` and two test cases evaluate, one can run mutation analysis on
    the test cases as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second class `MuProgramAnalyzer` targets standalone programs with test
    suites. Given a program `gcd` whose source code is provided in `gcd_src` and the
    test suite is provided by `TestGCD`, one can evaluate the mutation score of `TestGCD`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The mutation score thus obtained is a better indicator of the quality of a given
    test suite than pure coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Why Structural Coverage is Not Enough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the problems with [structural coverage](Coverage.html) measures is that
    it fails to check whether the program executions generated by the test suite were
    actually *correct*. That is, an execution that produces a wrong output that is
    unnoticed by the test suite is counted exactly the same as an execution that produces
    the right output for coverage. Indeed, if one deletes the assertions in a typical
    test case, the coverage would not change for the new test suite, but the new test
    suite is much less useful than the original one. As an example, consider this
    "test":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The final assertion here will always pass, no matter what `execute_the_program_as_a_whole()`
    will do. Okay, if `execute_the_program_as_a_whole()` raises an exception, the
    test will fail, but we can also get around that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The problem with these "tests", however, is that `execute_the_program_as_a_whole()`
    may achieve 100% code coverage (or 100% of any other structural coverage metric).
    Yet, this number of 100% does not reflect the ability of the test to discover
    bugs, which actually is 0%.
  prefs: []
  type: TYPE_NORMAL
- en: This is indeed, not an optimal state of affairs. How can we verify that our
    tests are actually useful? One alternative (hinted in the chapter on coverage)
    is to inject bugs into the program, and evaluate the effectiveness of test suites
    in catching these injected bugs. However, that introduces another problem. How
    do we produce these bugs in the first place? Any manual effort is likely to be
    biased by the preconceptions of the developer as to where the bugs are likely
    to occur, and what effect it would have. Further, writing good bugs is likely
    to take a significant amount of time, for a very indirect benefit. Hence, such
    a solution is not sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding Artificial Faults with Mutation Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mutation Analysis offers an alternative solution to assess the effectiveness
    of a test suite. The idea of mutation analysis is to seed *artificial faults*,
    known as *mutations*, into the program code, and to check whether the test suite
    finds them. Such a mutation could, for instance, replace a `+` by a `-` somewhere
    within `execute_the_program_as_a_whole()`. Of course, the above ineffective tests
    would not detect this, as they do not check any of the results. An effective test
    would, however; and the assumption is that the more effective a test is in finding
    *artificial* faults, the more effective it would be in finding *real* faults.
  prefs: []
  type: TYPE_NORMAL
- en: The insight from Mutation Analysis is to consider the probability of insertion
    of a bug from the perspective of a programmer. If one assumes that the attention
    received by each program element in the program is sufficiently similar, one can
    further assume that each token in the program has a similar probability of being
    incorrectly transcribed. Of course, the programmer will correct any mistakes that
    gets detected by the compilers (or other static analysis tools). So the set of
    valid tokens different from the original that make it past the compilation stage
    is considered to be its possible set of *mutations* that represent the *probable
    faults* in the program. A test suite is then judged by its capability to detect
    (and hence prevent) such mutations. The proportion of such mutants detected over
    all *valid* mutants produced is taken as the mutation score. In this chapter,
    we see how one can implement Mutation Analysis in Python programs. The mutation
    score obtained represents the ability of any program analysis tools to prevent
    faults, and can be used to judge static test suites, test generators such as fuzzers,
    and also static and symbolic execution frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: It might be intuitive to consider a slightly different perspective. A test suite
    is a program that can be considered to accept as its input, the program to be
    tested. What is the best way to evaluate such a program (the test suite)? We can
    essentially *fuzz* the test suite by applying small mutations to the input program,
    and verifying that the test suite in question does not produce unexpected behaviors.
    The test suite is supposed to only allow the original through; and hence any mutant
    that is not detected as faulty represents a bug in the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Coverage Adequacy by Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us introduce a more detailed example to illustrate both the problems with
    coverage as well as how mutation analysis works. The `triangle()` program below
    classifies a triangle with edge lengths $a$, $b$, and $c$ into the proper triangle
    category. We want to verify that the program works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here are a few test cases to ensure that the program works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Running them actually causes all tests to pass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, the statement that "all tests pass" has value only if we know that
    our tests are effective. What is the effectiveness of our test suite? As we saw
    in the [chapter on coverage](Coverage.html), one can use structural coverage techniques
    such as statement coverage to obtain a measure of effectiveness of the test case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We add a function `show_coverage()` to visualize the coverage obtained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `strong_oracle()` seems to have adequately covered all possible conditions.
    That is, our set of test cases is reasonably good according to structural coverage.
    However, does the coverage obtained tell the whole story? Consider this test suite
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All that we are checking here is that a triangle with unequal sides is not equilateral.
    What is the coverage obtained?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, there does not seem to be *any* difference in coverage. The `weak_oracle()`
    obtains exactly the same coverage as that of `strong_oracle()`. However, a moment's
    reflection should convince one that the `weak_oracle()` is not as effective as
    `strong_oracle()`. However, *coverage* is unable to distinguish between the two
    test suites. What are we missing in coverage? The problem here is that coverage
    is unable to evaluate the *quality* of our assertions. Indeed, coverage does not
    care about assertions at all. However, as we saw above, assertions are an extremely
    important part of test suite effectiveness. Hence, what we need is a way to evaluate
    the quality of assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Artificial Faults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice that in the [chapter on coverage](Coverage.html), coverage was presented
    as a *proxy* for the likelihood of a test suite to uncover bugs. What if we actually
    try to evaluate the likelihood of a test suite to uncover bugs? All we need is
    to inject bugs into the program, one at a time, and count the number of such bugs
    that our test suite detects. The frequency of detection will provide us with the
    actual likelihood of the test suite to uncover bugs. This technique is called
    *fault injection*. Here is an example for *fault injection*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let us see if our test suites are good enough to catch this fault. We first
    check whether `weak_oracle()` can detect this change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `weak_oracle()` is unable to detect any changes. What about our `strong_oracle()`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Our `strong_oracle()` is able to detect this fault, which is evidence that `strong_oracle()`
    is probably a better test suite.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fault injection* can provide a good measure of effectiveness of a test suite,
    provided we have a list of possible faults. The problem is that collecting such
    a set of *unbiased* faults is rather expensive. It is difficult to create good
    faults that are reasonably hard to detect, and it is a manual process. Given that
    it is a manual process, the generated faults will be biased by the preconceptions
    of the developer who creates it. Even when such curated faults are available,
    they are unlikely to be exhaustive, and likely to miss important classes of bugs,
    and parts of the program. Hence, *fault injection* is an insufficient replacement
    for coverage. Can we do better?'
  prefs: []
  type: TYPE_NORMAL
- en: Mutation Analysis provides an alternative to a curated set of faults. The key
    insight is that, if one assumes that the programmer understands the program in
    question, the majority of errors made are very likely small transcription errors
    (a few tokens). A compiler will likely catch most of these errors. Hence, the
    majority of residual faults in a program is likely to be due to small (single
    token) variations at certain points in the structure of the program from the correct
    program (This particular assumption is called the *Competent Programmer Hypothesis*
    or the *Finite Neighborhood Hypothesis*).
  prefs: []
  type: TYPE_NORMAL
- en: What about the larger faults composed of multiple smaller faults? The key insight
    here is that, for a majority of such complex faults, test cases that detect a
    single smaller fault in isolation is very likely to detect the larger complex
    fault that contains it. (This assumption is called the *Coupling Effect*.)
  prefs: []
  type: TYPE_NORMAL
- en: How can we use these assumptions in practice? The idea is to simply generate
    *all* possible *valid* variants of the program that differs from the original
    by a small change (such as a single token change) (Such variants are called *mutants*).
    Next, the given test suite is applied to each variant thus generated. Any mutant
    detected by the test suite is said to have been *killed* by the test suite. The
    effectiveness of a test suite is given by the proportion of mutants killed to
    the valid mutants generated.
  prefs: []
  type: TYPE_NORMAL
- en: We next implement a simple mutation analysis framework and use it to evaluate
    our test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating Python Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manipulate a Python program, we work on the *abstract syntax tree* (AST)
    representation – which is the internal representation compilers and interpreters
    work on after reading in the program text.
  prefs: []
  type: TYPE_NORMAL
- en: Briefly speaking, we convert the program into a tree, and then *change parts
    of this tree* – for instance, by changing `+` operators into `-` or vice versa,
    or actual statements into `pass` statements that do nothing. The resulting mutated
    tree can then be processed further; it can be passed on to the Python interpreter
    for execution, or we can *unparse* it back into a textual form.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by importing the AST manipulation modules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can get the source of a Python function using `inspect.getsource()`. (Note
    that this does not work for functions defined in other notebooks.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To view these in a visually pleasing form, our function `print_content(s, suffix)`
    formats and highlights the string `s` as if it were a file with ending `suffix`.
    We can thus view (and highlight) the source as if it were a Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Parsing this gives us an abstract syntax tree (AST) – a representation of the
    program in tree form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What does this AST look like? The helper functions `ast.dump()` (textual output)
    and `showast.show_ast()` (graphical output with [showast](https://github.com/hchasestevens/show_ast))
    allow us to inspect the structure of the tree. We see that the function starts
    as a `FunctionDef` with name and arguments, followed by a body, which is a list
    of statements; in this case, the body contains only an `If`, which itself contains
    other nodes of type `If`, `Compare`, `Name`, `Str`, and `Return`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Too much text for you? This graphical representation may make things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1791pt" height="476pt"
    viewBox="0.00 0.00 1791.38 476.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 472)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="115.88" y="-445.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="49.25" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"triangle"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="124.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="start" x="495"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">If</text></g> <g id="edge9" class="edge"><title>0--9</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="40.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="112.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge5" class="edge"><title>2--5</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="start" x="184.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge7" class="edge"><title>2--7</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="53.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="125.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge6" class="edge"><title>5--6</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="197.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge8" class="edge"><title>7--8</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="start" x="348.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge10"
    class="edge"><title>9--10</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="start" x="656" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge18"
    class="edge"><title>9--18</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="start" x="1187" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge33"
    class="edge"><title>9--33</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="start" x="252.75" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge11"
    class="edge"><title>10--11</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="341.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="396.75"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>10--15</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="197.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="269.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="341.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge16" class="edge"><title>15--16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="413.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge17" class="edge"><title>15--17</title></g>
    <g id="node20" class="node"><title>19</title> <text text-anchor="start" x="564.38"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge19" class="edge"><title>18--19</title></g>
    <g id="node28" class="node"><title>27</title> <text text-anchor="start" x="674.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge27" class="edge"><title>18--27</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="799.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge30" class="edge"><title>18--30</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="start" x="468.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="557.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Eq</text></g>
    <g id="edge23" class="edge"><title>19--23</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="start" x="612.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge24"
    class="edge"><title>19--24</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="413.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge21" class="edge"><title>20--21</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="485.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge22" class="edge"><title>20--22</title></g> <g id="node26" class="node"><title>25</title>
    <text text-anchor="middle" x="557.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"c"</text></g> <g id="edge25" class="edge"><title>24--25</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="629.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge26" class="edge"><title>24--26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="start" x="693.25" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge28"
    class="edge"><title>27--28</title></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="736.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Equilateral"</text></g> <g id="edge29" class="edge"><title>28--29</title></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="start" x="815.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge31" class="edge"><title>30--31</title></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="869.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge32" class="edge"><title>31--32</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1102.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge34"
    class="edge"><title>33--34</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1209.5" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge42"
    class="edge"><title>33--42</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="start" x="1521" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge45"
    class="edge"><title>33--45</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="start" x="1022.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge35"
    class="edge"><title>34--35</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="middle" x="1111.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge38" class="edge"><title>34--38</title></g>
    <g id="node40" class="node"><title>39</title> <text text-anchor="start" x="1166.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge39" class="edge"><title>34--39</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="967.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge36" class="edge"><title>35--36</title></g> <g id="node38" class="node"><title>37</title>
    <text text-anchor="middle" x="1039.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge37" class="edge"><title>35--37</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1111.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge40" class="edge"><title>39--40</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="middle" x="1183.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge41" class="edge"><title>39--41</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1242.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node45" class="node"><title>44</title> <text text-anchor="middle" x="1281.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge44" class="edge"><title>43--44</title></g> <g id="node47" class="node"><title>46</title>
    <text text-anchor="start" x="1436.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge46"
    class="edge"><title>45--46</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="start" x="1569.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge54"
    class="edge"><title>45--54</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="start" x="1690.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge57"
    class="edge"><title>45--57</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1362.75" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge47"
    class="edge"><title>46--47</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1451.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge50" class="edge"><title>46--50</title></g>
    <g id="node52" class="node"><title>51</title> <text text-anchor="start" x="1506.75"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge51" class="edge"><title>46--51</title></g>
    <g id="node49" class="node"><title>48</title> <text text-anchor="middle" x="1307.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge48" class="edge"><title>47--48</title></g> <g id="node50" class="node"><title>49</title>
    <text text-anchor="middle" x="1379.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge49" class="edge"><title>47--49</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="middle" x="1451.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge52" class="edge"><title>51--52</title></g> <g id="node54" class="node"><title>53</title>
    <text text-anchor="middle" x="1523.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge53" class="edge"><title>51--53</title></g>
    <g id="node56" class="node"><title>55</title> <text text-anchor="start" x="1582.25"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge55" class="edge"><title>54--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="middle" x="1621.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Isosceles"</text></g>
    <g id="edge56" class="edge"><title>55--56</title></g> <g id="node59" class="node"><title>58</title>
    <text text-anchor="start" x="1697.25" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge58"
    class="edge"><title>57--58</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="middle" x="1738.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Scalene"</text></g> <g id="edge59" class="edge"><title>58--59</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: The function `ast.unparse()` converts such a tree back into the more familiar
    textual Python code representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: A Simple Mutator for Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now go and mutate the `triangle()` program. A simple way to produce valid
    mutated version of this program is to replace some of its statements by `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: The `MuFunctionAnalyzer` is the main class responsible for mutation analysis
    of the test suite. It accepts the function to be tested. It normalizes the source
    code given by parsing and unparsing it once, using the functions discussed above.
    This is required to ensure that later `diff`s between the original and mutant
    are not derailed by differences in whitespace, comments, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `get_mutation_count()` fetches the number of possible mutations available.
    We will see later how this can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Mutator` provides the base class for implementing individual mutations.
    It accepts a list of locations to mutate. It assumes that the method `mutable_visit()`
    is invoked on all nodes of interest as determined by the subclass. When the `Mutator`
    is invoked without a list of locations to mutate, it simply loops through all
    possible mutation points and retains a count in `self.count`. If it is invoked
    with a specific list of locations to mutate, the `mutable_visit()` method calls
    the `mutation_visit()` which performs the mutation on the node. Note that a single
    location can produce multiple mutations. (Hence the hashmap).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `StmtDeletionMutator` simply hooks into all the statement processing visitors.
    It performs mutation by replacing the given statement with `pass`. As you can
    see, it visits all kinds of statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual mutation consists of replacing the node with a `pass` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For `triangle()`, this visitor produces five mutations – namely, replacing
    the five `return` statements with `pass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We need a way to obtain the individual mutants. For this, we convert our `MuFunctionAnalyzer`
    to an *iterable*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `PMIterator`, which is the *iterator* class for `MuFunctionAnalyzer` is
    defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `next()` method returns the corresponding `Mutant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `Mutant` class contains logic for generating mutants when given the locations
    to mutate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: These names are a bit generic yet. Let's see whether we can get more insights
    into the mutations produced.
  prefs: []
  type: TYPE_NORMAL
- en: The `generate_mutant()` simply calls the `mutator()` method, and passes the
    mutator a copy of the AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `src()` method returns the mutated source.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how one can obtain the mutants, and visualize the difference from the
    original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this `diff` output, lines prefixed with `+` are added, whereas lines prefixed
    with `-` are deleted. We see that each of the five mutants indeed replaces a return
    statement with a `pass` statement.
  prefs: []
  type: TYPE_NORMAL
- en: We add the `diff()` method to `Mutant` so that it can be called directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now ready to implement the actual evaluation. We define our mutant as
    a *context manager* that verifies whether all assertions given succeed. The idea
    is that we can write code such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: and while `mutant` is active (i.e., the code block under `with:`), the original
    function is replaced by the mutated function.
  prefs: []
  type: TYPE_NORMAL
- en: The `__enter__()` function is called when the `with` block is entered. It creates
    the mutant as a Python function and places it in the global namespace, such that
    the `assert` statement executes the mutated function rather than the original.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `__exit__()` function checks whether an exception has occurred (i.e., the
    assertion failed, or some other error was raised); if so, it marks the mutation
    as `detected`. Finally, it restores the original function definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `finish()` method simply invokes the method on the mutant, checks if the
    mutant was discovered, and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The mutation score – the ratio of mutants detected by the test suite - is computed
    by `score()`. A score of 1.0 means that all mutants were discovered; a score of
    0.1 means that only 10% of mutants were detected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here is how we use our framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Only one out of five mutations resulted in a failing assertion. Hence, the `weak_oracle()`
    test suite gets a mutation score of 20%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Since we are modifying the global namespace, we do not have to refer to the
    function directly within the for loop of mutant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: That is, we were able to achieve `100%` mutation score with the `strong_oracle()`
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another example. `gcd()` computes the greatest common divisor of two
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Here's a test for it. How effective is it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We see that our `TestGCD` test suite is able to obtain a mutation score of 42%.
  prefs: []
  type: TYPE_NORMAL
- en: Mutator for Modules and Test Suites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider the `triangle()` program we discussed previously. As we discussed,
    a simple way to produce valid mutated version of this program is to replace some
    of its statements by `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: For demonstration purposes, we would like to proceed as though the program was
    in a different file. We can do that by producing a `Module` object in Python,
    and attaching the function to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We attach the `triangle()` function to the `shape` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We can now invoke triangle through the module `shape`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We want to test the `triangle()` function. For that, we define a `StrongShapeTest`
    class as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We define a helper function `suite()` that looks through a given class and identifies
    the test functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The tests in `TestTriangle` class can be invoked with different test runners.
    The simplest is to directly invoke the `run()` method of the `TestCase`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `TextTestRunner` class provides ability to control the verbosity of execution.
    It also allows one to return on the *first* failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program under coverage is accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The coverage obtained is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How much coverage does it obtain?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The `MuProgramAnalyzer` is the main class responsible for mutation analysis
    of the test suite. It accepts the name of the module to be tested, and its source
    code. It normalizes the source code given by parsing and unparsing it once. This
    is required to ensure that later `diff`s between the original and mutant are not
    derailed by differences in whitespace, comments, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We now extend the `Mutator` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `AdvStmtDeletionMutator` simply hooks into all the statement processing
    visitors. It performs mutation by replacing the given statement with `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Aagin, we can obtain the number of mutations produced for `triangle()` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We need a way to obtain the individual mutants. For this, we convert our `MuProgramAnalyzer`
    to an *iterable*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The `AdvPMIterator`, which is the *iterator* class for `MuProgramAnalyzer` is
    defined as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The `next()` method returns the corresponding `Mutant`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The `Mutant` class contains logic for generating mutants when given the locations
    to mutate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The `generate_mutant()` simply calls the `mutator()` method, and passes the
    mutator a copy of the AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The `src()` method returns the mutated source.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we visualize mutants as difference from the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We add the `diff()` method to `Mutant` so that it can be called directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to implement the actual evaluation. For doing that, we require
    the ability to accept the module where the test suite is defined, and invoke the
    test method on it. The method `getitem` accepts the test module, fixes the import
    entries on the test module to correctly point to the mutant module, and passes
    it to the test runner `MutantTestRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The `MutantTestRunner` simply calls all `test_` methods on the test module,
    checks if the mutant was discovered, and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: The mutation score is computed by `score()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Here is how we use our framework.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `WeakShape` test suite resulted in only `20%` mutation score.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, we were able to achieve `100%` mutation score with `StrongShapeTest`
    test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Here is another example, `gcd()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: We see that our `TestGCD` test suite is able to obtain `42%` mutation score.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem of Equivalent Mutants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems with mutation analysis is that not all mutants generated
    need to be faulty. For example, consider the `new_gcd()` program below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This program can be mutated to produce the following mutant.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: While other mutants are faulty compared to the original, `mutant 1` is indistinguishable
    from the original in terms of its semantics because it removes an inconsequential
    assignment. This means that `mutant 1` does not represent a fault. These kinds
    of mutants that do not represent a fault are called *Equivalent mutants*. The
    problem with equivalent mutants is that it becomes very difficult to judge the
    mutation score in the presence of equivalent mutants. For example, with a mutation
    score of 70%, anywhere from 0 to 30% of the mutants may be equivalent. Hence,
    without knowing the actual number of equivalent mutants, it is impossible to judge
    how much the tests can be improved. We discuss two methods to deal with equivalent
    mutants.
  prefs: []
  type: TYPE_NORMAL
- en: Statistical Estimation of Number of Equivalent Mutants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the number of mutants that are alive is small enough, one may rely on simply
    inspecting them manually. However, if the number of mutants are sufficiently large
    (say > 1000), one may choose a smaller number of mutants from the alive mutants
    randomly and manually evaluate them to see whether they represent faults. The
    sample size determination is governed by the following formula for a binomial
    distribution (approximated by a normal distribution):'
  prefs: []
  type: TYPE_NORMAL
- en: $$ n \ge \hat{p}(1-\hat{p})\bigg(\frac{Z_{\frac{\alpha}{2}}}{\Delta}\bigg)^2
    $$
  prefs: []
  type: TYPE_NORMAL
- en: 'where $n$ is the number of samples, $p$ is the parameter for the probability
    distribution, $\alpha$ is the accuracy desired, $\Delta$ the precision. For an
    accuracy of $95\%$, $Z_{0.95}=1.96$. we have the following values (the maximum
    value of $\hat{p}(1-\hat{p}) = 0.25$) and $Z$ is the critical value for normal
    distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ n \ge 0.25\bigg(\frac{1.96}{\Delta}\bigg)^2 $$
  prefs: []
  type: TYPE_NORMAL
- en: For $\Delta = 0.01$, (that is for a maximum error of 1%), we need to evaluate
    $9604$ mutants for equivalence. If one relaxes the constraint to $\Delta = 0.1$
    (that is an error of $10\%$), then one needs to evaluate only $96$ mutants for
    equivalence.
  prefs: []
  type: TYPE_NORMAL
- en: Statistical Estimation of the Number of Immortals by Chao's Estimator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the idea of sampling only a limited number of mutants is appealing, it
    is still limited in that manual analysis is necessary. If computing power is cheap,
    another way to estimate the number of true mutants (and hence the number of equivalent
    mutants) is by means of Chao''s estimator. As we will see in the chapter on [when
    to stop fuzzing](WhenToStopFuzzing.html), the formula is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ \hat S_\text{Chao1} = \begin{cases} S(n) + \frac{f_1^2}{2f_2} & \text{if
    $f_2>0$}\\ S(n) + \frac{f_1(f_1-1)}{2} & \text{otherwise} \end{cases} $$
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to compute the result of the complete test matrix $T \times
    M$ of each test against each mutant. The variable $f_1$ represents the number
    of mutants that were killed exactly once, and the variable $f_2$ represents the
    number of variables that were killed exactly twice. $S(n)$ is the total number
    of mutants killed. Here, $\hat{S}_{Chao1}$ provides the estimate of the true number
    of mutants. If $M$ is the total mutants generated, then $M - \hat{S}_{Chao1}$
    represents the number of **immortal** mutants. Note that these **immortal** mutants
    are somewhat different from the traditional equivalent mutants in that the **mortality**
    depends on the oracle used to distinguish variant behavior. That is, if one uses
    a fuzzer that relies on errors thrown to detect killing, it will not detect mutants
    that produce different output but does not throw an error. Hence, the *Chao1*
    estimate will essentially be the asymptote value of mutants the fuzzer can detect
    if it is given an infinite amount of time. The **immortal** mutant estimate will
    approach true **equivalent** mutant estimate when the oracle used is sufficiently
    strong. For more details see the chapter on [when to stop fuzzing](WhenToStopFuzzing.html).
    A comprehensive guide to species discovery in testing is the paper by Boehme [[Böhme
    *et al*, 2018](https://doi.org/10.1145/3210309)].
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned why structural coverage is insufficient to evaluate the quality
    of test suites.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned how to use Mutation Analysis for evaluating test suite quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned the limitations of Mutation Analysis -- Equivalent and Redundant
    mutants, and how to estimate them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While naive fuzzing generates poor quality oracles, techniques such as [symbolic](SymbolicFuzzer.html)
    and [concolic](ConcolicFuzzer.html) can enhance the quality oracles used in fuzzing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dynamic invariants](DynamicInvariants.html) can also be of great help in improving
    the quality of oracles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter on [when to stop fuzzing](WhenToStopFuzzing.html) provides a detailed
    overview of the Chao estimator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of Mutation Analysis was first introduced by Lipton et al. [Lipton
    *et al*, 1971]. An excellent survey of mutation analysis research was published
    by Jia et al. [Jia *et al*, 2011]. The chapter on Mutation Analysis by Papadakis
    et al [Papadakis *et al*, 2019] is another excellent overview of the current trends
    in mutation analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Arithmetic Expression Mutators'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our simple statement deletion mutation is only one of the ways in which a program
    could be mutated. Another category of mutants is *expression mutation* where arithmetic
    operators such as `{+,-,*,/}` etc. are replaced for one another. For example,
    given an expression such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: One can mutate it to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to find out which node types we want to mutate. We get these
    via the ast functions and find that the node type is named BinOp
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: To mutate the tree, you thus need to change the `op` attribute (which has one
    of the values `Add`, `Sub`, `Mult`, and `Div`)
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: To mutate the tree, we need to change the `op` attribute (which has one of the
    values `Add`, `Sub`, `Mult`, and `Div`). Write a class `BinOpMutator` that does
    the necessary mutations, and then create a class `MuBinOpAnalyzer` as subclass
    of `MuFunctionAnalyzer` which makes use of `BinOpMutator`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Optimizing Mutation Analysis'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our technique for mutation analysis is somewhat inefficient in that we run the
    tests even on mutants that have mutations in code not covered by the test case.
    Test cases have no possibility of detecting errors on portions of code they do
    not cover. Hence, one of the simplest optimizations is to first recover the coverage
    information from the given test case, and only run the test case on mutants where
    the mutations lie in the code being covered by the test case. Can you modify the
    `MuFunctionAnalyzer` to incorporate recovering coverage as the first step?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Byte Code Mutator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen how to mutate the AST given the source. One of the deficiencies
    with this approach is that the Python bytecode is targeted by other languages
    too. In such cases, the source may not be readily converted to a Python AST, and
    it is desirable to mutate the bytecode instead. Can you implement a bytecode mutator
    for Python function that mutates the bytecode instead of fetching the source and
    then mutating it?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Estimating Residual Defect Density'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The defect density of a program is the number of defects in a program that that
    were detected before release divided by the program size. The residual defect
    density is the percentage of defects that escaped detection. While estimation
    of the real residual defect density is difficult, mutation analysis can provide
    an upper bound. The number of mutants that remain undetected is a plausible upper
    bound on the number of defects that remain within the program. However, this upper
    bound may be too wide. The reason is that some remaining faults can interact with
    each other, and if present together, can be detected by the available test suite.
    Hence, a tighter bound is the number of mutants that can exist *together* in a
    given program without being detected by the given test suite. This can be accomplished
    by starting with the complete set of mutations possible, and applying delta-debugging
    from [the chapter on reducing](Reducer.html) to determine the minimum number of
    mutations that need to be removed to make the mutant pass undetected by the test
    suite. Can you produce a new `RDDEstimator` by extending the `MuFunctionAnalyzer`
    that estimates the residual defect density upper bound using this technique?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationAnalysis.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:06+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/MutationAnalysis.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Mutation Analysis](https://www.fuzzingbook.org/html/MutationAnalysis.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/MutationAnalysis.html](https://www.fuzzingbook.org/html/MutationAnalysis.html).
    Retrieved 2023-11-11 18:18:06+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
