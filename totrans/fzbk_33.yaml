- en: Testing Compilers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/PythonFuzzer.html](http://www.fuzzingbook.org/html/PythonFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we will make use of [grammars and grammar-based testing](Grammars.html)
    to systematically generate *program code* – for instance, to test a compiler or
    an interpreter. Not very surprisingly, we use *Python* and the *Python interpreter*
    as our domain.
  prefs: []
  type: TYPE_NORMAL
- en: We chose Python not only because the rest of the book is also based on Python.
    Most importantly, Python brings lots of built-in infrastructure we can leverage,
    especially
  prefs: []
  type: TYPE_NORMAL
- en: '*parsers* that convert Python code into an abstract syntax tree (AST) representation
    and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*unparsers* that take an AST and convert it back into Python code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows us to leverage grammars that operate on ASTs rather than concrete
    syntax, greatly reducing complexity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You must read the chapter on [Fuzzing with Grammars](Grammars.html) to understand
    how grammars and grammar-based testing work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides a `PythonFuzzer` class that allows producing arbitrary
    Python code elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, `PythonFuzzer` produces a *function definition* – that is, a list
    of statements as above. You can pass a `start_symbol` argument to state which
    Python element you''d like to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here is a list of all possible start symbols. Their names reflect the nonterminals
    from the [Python `ast` module documentation](https://docs.python.org/3/library/ast.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like more control over Python code generation, here is what is happening
    behind the scenes. The EBNF grammar `PYTHON_AST_GRAMMAR` can parse and produce
    *abstract syntax trees* for Python. To produce a Python module without `PythonFuzzer`,
    you would take these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1:** Create a non-EBNF grammar suitable for `ISLaSolver` (or any other
    grammar fuzzer):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2:** Feed the resulting grammar into a grammar fuzzer such as ISLa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3:** Have the grammar fuzzer produce a string. This string represents
    an AST.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 4:** Convert the AST into an actual Python AST data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 5:** Finally, convert the AST structure back into readable Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The chapter has many more applications, including parsing and mutating Python
    code, evolutionary fuzzing, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the details on the `PythonFuzzer` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PythonFuzzer(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str,
    List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str]
    = None, **kw_params) -> None`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce Python code. Parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start_symbol`: The grammatical entity to be generated (default: `<FunctionDef>`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constraint` an ISLa constraint (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional keyword parameters are passed to the `ISLaSolver` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="248pt" height="152pt" viewBox="0.00 0.00 248.12 152.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 148.25)"><g
    id="node1" class="node"><title>PythonFuzzer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class PythonFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce Python code."><text text-anchor="start" x="8" y="-43.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">PythonFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="PythonFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, start_symbol: Optional[str] = None,
    *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]]
    = None, constraint: Optional[str] = None, **kw_params) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce Python code. Parameters are:'
  prefs: []
  type: TYPE_NORMAL
- en: '* `start_symbol`: The grammatical entity to be generated (default: `<FunctionDef>`)'
  prefs: []
  type: TYPE_NORMAL
- en: '* `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`);
    and'
  prefs: []
  type: TYPE_NORMAL
- en: '* `constraint` an ISLa constraint (if any).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional keyword parameters are passed to the `ISLaSolver` superclass."><text
    text-anchor="start" x="21.5" y="-21.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a Python code string."><text text-anchor="start" x="21.5" y="-8.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">fuzz()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>ISLaSolver</title>
    <g id="a_node2"><a xlink:href="isla.solver.ipynb" xlink:title="class ISLaSolver:'
  prefs: []
  type: TYPE_NORMAL
- en: The solver class for ISLa formulas/constraints. Its top-level methods are
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.solve`
  prefs: []
  type: TYPE_NORMAL
- en: Use to generate solutions for an ISLa constraint.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.check`
  prefs: []
  type: TYPE_NORMAL
- en: Use to check if an ISLa constraint is satisfied for a given input.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.parse`
  prefs: []
  type: TYPE_NORMAL
- en: Use to parse and validate an input.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.repair`
  prefs: []
  type: TYPE_NORMAL
- en: Use to repair an input such that it satisfies a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.mutate`
  prefs: []
  type: TYPE_NORMAL
- en: 'Use to mutate an input such that the result satisfies a constraint."><text
    text-anchor="start" x="18.88" y="-127.45" font-family="Patua One, Helvetica, sans-serif"
    font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text> <g id="a_node2_3"><a
    xlink:href="#" xlink:title="ISLaSolver"><g id="a_node2_4"><a xlink:href="isla.solver.ipynb"
    xlink:title="__init__(self, grammar: Union[Dict[str, List[str]], str], formula:
    Union[isla.language.Formula, str, NoneType] = None, structural_predicates: Set[isla.language.StructuralPredicate]
    = frozenset({StructuralPredicate(name=''nth'', arity=3, eval_fun=<function is_nth>),
    StructuralPredicate(name=''inside'', arity=2, eval_fun=<function in_tree>), StructuralPredicate(name=''same_position'',
    arity=2, eval_fun=<function is_same_position>), StructuralPredicate(name=''consecutive'',
    arity=2, eval_fun=<function consecutive>), StructuralPredicate(name=''different_position'',
    arity=2, eval_fun=<function is_different_position>), StructuralPredicate(name=''before'',
    arity=2, eval_fun=<function is_before>), StructuralPredicate(name=''level'', arity=4,
    eval_fun=<function level_check>), StructuralPredicate(name=''direct_child'', arity=2,
    eval_fun=<function is_direct_child>), StructuralPredicate(name=''after'', arity=2,
    eval_fun=<function is_after>)}), semantic_predicates: Set[isla.language.SemanticPredicate]
    = frozenset({SemanticPredicate(count, 3)}), max_number_free_instantiations: int
    = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results:
    int = 5, enforce_unique_trees_in_queue: bool = False, debug: bool = False, cost_computer:
    Optional[ForwardRef(''CostComputer'')] = None, timeout_seconds: Optional[int]
    = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate,
    ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Dict[str, List[str]]],
    isla.fuzzer.GrammarFuzzer] = <function SolverDefaults.<lambda>>, tree_insertion_methods:
    Optional[int] = None, activate_unsat_support: bool = False, grammar_unwinding_threshold:
    int = 4, initial_tree: isla.helpers.Maybe[isla.derivation_tree.DerivationTree]
    = Maybe(a=None), enable_optimized_z3_queries: bool = True, start_symbol: Optional[str]
    = None):'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of :class:`~isla.solver.ISLaSolver` accepts a large number of
  prefs: []
  type: TYPE_NORMAL
- en: parameters. However, all but the first one, :code:`grammar`, are *optional.*
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to construct an ISLa solver is by only providing it with a
  prefs: []
  type: TYPE_NORMAL
- en: grammar only; it then works like a grammar fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import random'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.seed(1)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import string'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> LANG_GRAMMAR = {'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<start>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<stmt>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<stmt>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<assgn> ; <stmt>&quot;,
    &quot;<assgn>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<assgn>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<var> := <rhs>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<rhs>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<var>&quot;, &quot;<digit>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<var>&quot;: list(string.ascii_lowercase),'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<digit>&quot;: list(string.digits)'
  prefs: []
  type: TYPE_NORMAL
- en: '... }'
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from isla.solver import ISLaSolver'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> solver = ISLaSolver(LANG_GRAMMAR)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> str(solver.solve())'
  prefs: []
  type: TYPE_NORMAL
- en: '''d := 9'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> str(solver.solve())'
  prefs: []
  type: TYPE_NORMAL
- en: '''v := n ; s := r'''
  prefs: []
  type: TYPE_NORMAL
- en: ':param grammar: The underlying grammar; either, as a &quot;Fuzzing Book&quot;
    dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: or in BNF syntax.
  prefs: []
  type: TYPE_NORMAL
- en: ':param formula: The formula to solve; either a string or a readily parsed'
  prefs: []
  type: TYPE_NORMAL
- en: formula. If no formula is given, a default `true` constraint is assumed, and
  prefs: []
  type: TYPE_NORMAL
- en: the solver falls back to a grammar fuzzer. The number of produced solutions
  prefs: []
  type: TYPE_NORMAL
- en: will then be bound by `max_number_free_instantiations`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param structural_predicates: Structural predicates to use when parsing a'
  prefs: []
  type: TYPE_NORMAL
- en: formula.
  prefs: []
  type: TYPE_NORMAL
- en: ':param semantic_predicates: Semantic predicates to use when parsing a formula.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_free_instantiations: Number of times that nonterminals that'
  prefs: []
  type: TYPE_NORMAL
- en: are not bound by any formula should be expanded by a coverage-based fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_smt_instantiations: Number of solutions of SMT formulas that'
  prefs: []
  type: TYPE_NORMAL
- en: should be produced.
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_tree_insertion_results: The maximum number of results when'
  prefs: []
  type: TYPE_NORMAL
- en: solving existential quantifiers by tree insertion.
  prefs: []
  type: TYPE_NORMAL
- en: ':param enforce_unique_trees_in_queue: If true, states with the same tree as
    an'
  prefs: []
  type: TYPE_NORMAL
- en: already existing tree in the queue are discarded, irrespectively of the
  prefs: []
  type: TYPE_NORMAL
- en: constraint.
  prefs: []
  type: TYPE_NORMAL
- en: ':param debug: If true, debug information about the evolution of states is'
  prefs: []
  type: TYPE_NORMAL
- en: collected, notably in the field state_tree. The root of the tree is in the
  prefs: []
  type: TYPE_NORMAL
- en: field state_tree_root. The field costs stores the computed cost values for
  prefs: []
  type: TYPE_NORMAL
- en: all new nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ':param cost_computer: The `CostComputer` class for computing the cost relevant'
  prefs: []
  type: TYPE_NORMAL
- en: to placing states in ISLa's queue.
  prefs: []
  type: TYPE_NORMAL
- en: ':param timeout_seconds: Number of seconds after which the solver will terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param global_fuzzer: If set to True, only one coverage-guided grammar fuzzer'
  prefs: []
  type: TYPE_NORMAL
- en: object is used to finish off unconstrained open derivation trees throughout
  prefs: []
  type: TYPE_NORMAL
- en: the whole generation time. This may be beneficial for some targets; e.g., we
  prefs: []
  type: TYPE_NORMAL
- en: experienced that CSV works significantly faster. However, the achieved k-path
  prefs: []
  type: TYPE_NORMAL
- en: coverage can be lower with that setting.
  prefs: []
  type: TYPE_NORMAL
- en: ':param predicates_unique_in_int_arg: This is needed in certain cases for'
  prefs: []
  type: TYPE_NORMAL
- en: instantiating universal integer quantifiers. The supplied predicates should
  prefs: []
  type: TYPE_NORMAL
- en: have exactly one integer argument, and hold for exactly one integer value
  prefs: []
  type: TYPE_NORMAL
- en: once all other parameters are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: ':param fuzzer_factory: Constructor of the fuzzer to use for instantiating'
  prefs: []
  type: TYPE_NORMAL
- en: '&quot;free&quot; nonterminals.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param tree_insertion_methods: Combination of methods to use for existential'
  prefs: []
  type: TYPE_NORMAL
- en: 'quantifier elimination by tree insertion. Full selection: `DIRECT_EMBEDDING
    &amp;'
  prefs: []
  type: TYPE_NORMAL
- en: SELF_EMBEDDING &amp; CONTEXT_ADDITION`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param activate_unsat_support: Set to True if you assume that a formula might'
  prefs: []
  type: TYPE_NORMAL
- en: be unsatisfiable. This triggers additional tests for unsatisfiability that
  prefs: []
  type: TYPE_NORMAL
- en: reduce input generation performance, but might ensure termination (with a
  prefs: []
  type: TYPE_NORMAL
- en: negative solver result) for unsatisfiable problems for which the solver could
  prefs: []
  type: TYPE_NORMAL
- en: otherwise diverge.
  prefs: []
  type: TYPE_NORMAL
- en: ':param grammar_unwinding_threshold: When querying the SMT solver, ISLa passes
    a'
  prefs: []
  type: TYPE_NORMAL
- en: regular expression for the syntax of the involved nonterminals. If this
  prefs: []
  type: TYPE_NORMAL
- en: syntax is not regular, we unwind the respective part in the reference grammar
  prefs: []
  type: TYPE_NORMAL
- en: up to a depth of `grammar_unwinding_threshold`. If this is too shallow, it can
  prefs: []
  type: TYPE_NORMAL
- en: happen that an equation etc. cannot be solved; if it is too deep, it can
  prefs: []
  type: TYPE_NORMAL
- en: negatively impact performance (and quite tremendously so).
  prefs: []
  type: TYPE_NORMAL
- en: ':param initial_tree: An initial input tree for the queue, if the solver shall'
  prefs: []
  type: TYPE_NORMAL
- en: not start from the tree `(<start>, None)`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param enable_optimized_z3_queries: Enables preprocessing of Z3 queries (mainly'
  prefs: []
  type: TYPE_NORMAL
- en: numeric problems concerning things like length). This can improve performance
  prefs: []
  type: TYPE_NORMAL
- en: significantly; however, it might happen that certain problems cannot be solved
  prefs: []
  type: TYPE_NORMAL
- en: anymore. In that case, this option can/should be deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: ':param start_symbol: This is an alternative to `initial_tree` for starting
    with'
  prefs: []
  type: TYPE_NORMAL
- en: a start symbol different form `<start>`. If `start_symbol` is provided, a tree
  prefs: []
  type: TYPE_NORMAL
- en: consisting of a single root node with the value of `start_symbol` is chosen
    as
  prefs: []
  type: TYPE_NORMAL
- en: initial tree."><text text-anchor="start" x="21.5" y="-105.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g></a></g></a></g></g> <g id="edge1"
    class="edge"><title>PythonFuzzer->ISLaSolver</title></g> <g id="node3" class="node"><title>Legend</title>
    <text text-anchor="start" x="120.88" y="-46.25" font-family="Patua One, Helvetica,
    sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
    <text text-anchor="start" x="120.88" y="-36.25" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="126.88" y="-36.25"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="8.00">public_method()</text> <text text-anchor="start" x="120.88" y="-26.25"
    font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text> <text
    text-anchor="start" x="126.88" y="-26.25" font-family="'Fira Mono', 'Source Code
    Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text text-anchor="start"
    x="120.88" y="-16.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="126.88" y="-16.25" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="120.88" y="-7.2" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: A Grammar for Concrete Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To *produce* code, it is fairly easy to write a grammar with *concrete* syntax.
    If we want to produce, say, arithmetic expressions, we can easily create a concrete
    grammar which does precisely that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We use the [Fuzzingbook format for grammars](https://www.fuzzingbook.org/html/Grammars.html),
    in which grammars are represented as dictionaries from symbols to lists of expansion
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We can use this grammar to produce syntactically valid arithmetic expressions.
    We use the [ISLa solver](FuzzingWithConstraints.html) as our generator, as it
    is the most powerful; but we could also use any other of our grammar fuzzers such
    as [GrammarFuzzer](GrammarFuzzer.html) at this point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some concrete inputs produced from the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We could extend the grammar further to also produce assignments and other statements,
    and piece by piece cover the entire syntax of the programming language. However,
    this would be a not-so-great idea. Why?
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that when testing *compilers*, you not only want to be able to
    *produce* code, but also to *parse* code, such that you can mutate and manipulate
    it at will. And this is where our "concrete" syntax will give us problems. While
    we can easily parse code (or expressions) that exactly adheres to the syntax...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '... a single space will already suffice to make it fail...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '... as does the absence of spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, spaces are optional in most programming languages. We *could* update
    our grammar such that it can handle optional spaces at all times (introducing
    a `<space>` nonterminal). But then, there are other features like *comments*...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '... or *continuation lines* ...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: that our grammar would have to cover.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top, there are language features that cannot be even represented properly
    in a context-free grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: In the C programming language, for instance, the parser needs to know whether
    an identifier has been defined as a *type*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, *indentation* levels cannot be represented by a context-free grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this reason, it is often a good idea to make use of a dedicated *parser*
    (or *preprocessor*) to turn input into a more *abstract* representation - typically
    a *tree* structure. In programming languages, such a tree is called an *abstract
    syntax tree* (AST); it is the data structure that compilers operate on.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Syntax Trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract Syntax Trees (ASTs) that represent program code are among the most
    complex data structures in the world (if not *the* most complex data structures)
    - notably because they reflect all the complexity of the programming language
    and its features. The good news is that in Python, working with ASTs is particularly
    easy - one can work with them using standard language features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate ASTs using an example. Here is a piece of code that we''d
    like to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us obtain the source code of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We make use of the [Python AST module](https://docs.python.org/3/library/ast.html)
    to convert this code string to an AST and back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'With `ast.parse()`, we can parse the `main()` source into an AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what this tree looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="369pt" height="332pt"
    viewBox="0.00 0.00 368.62 332.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 328)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="83.38" y="-301.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="32.75" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"main"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="128.75"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">arguments</text></g>
    <g id="edge2" class="edge"><title>0--2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="start" x="202.25" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Expr</text></g> <g id="edge3"
    class="edge"><title>0--3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="start" x="202.25" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Call</text></g> <g id="edge4"
    class="edge"><title>3--4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="start" x="159.25" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge5"
    class="edge"><title>4--5</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="start" x="242.75" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge8"
    class="edge"><title>4--8</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="93.75" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"print"</text></g> <g id="edge6" class="edge"><title>5--6</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="175.75"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge7" class="edge"><title>5--7</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="290.75" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"Hello, world!"</text></g> <g id="edge9" class="edge"><title>8--9</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: We see how the function definition has become a `FunctionDef` node, whose third
    child is an `Expr` node, which in turn becomes a `Call` – of the `"print"` function
    with an argument of `"Hello, world!"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these AST nodes comes as a *constructor* – that is, we can invoke `FunctionDef()`
    to obtain a function definition node, or `Call()` to obtain a call node. These
    constructors take the AST *children* as arguments, but also lots of *optional*
    arguments (which we did not use so far). The *dump* of the AST into a string reveals
    all the arguments for each constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The [Python ast documentation](https://docs.python.org/3/library/ast.html) lists
    all these constructors, which make up the abstract syntax. There are more than
    100 individual constructors! (We said that ASTs are complex, right?)
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing about the above string representation is that we can take it
    *as is* and turn it into a tree again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take this tree and compile it into executable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We can also *unparse* the tree (= turn it into source code again). (Note how
    the comment got lost during parsing.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Hence, we can
  prefs: []
  type: TYPE_NORMAL
- en: '*Parse* concrete code into ASTs (with `ast.parse()`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Generate* new ASTs and *mutate* existing ones'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Unparse* ASTs to obtain concrete code again (with `ast.unparse()`)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To *generate* and *mutate* ASTs (step #2, above), we need means to produce
    *correct* ASTs, invoking all constructors with the correct arguments. The plan
    is thus to have a *grammar* for ASTs, which produces (and parses) ASTs as we like.'
  prefs: []
  type: TYPE_NORMAL
- en: A Grammar for ASTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming language grammars are among the most complicated formal grammars
    around, and ASTs reflect much of this complexity. We will use the [abstract AST
    grammar](https://docs.python.org/3/library/ast.html) as specified in the Python
    documentation as base, and build a formal context-free grammar step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start with simple constants – strings and integers. Again, we use the
    `fuzzingbook` syntax for grammars, as it allows for easier extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we use *extended Backus-Naur form* in our grammars (here: `<string>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`<elem>+` stands for one or more instances of `<elem>`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<elem>*` stands for zero or more instances of `<elem>`;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<elem>?` stands for one or zero instances of `<elem>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A call to `is_valid_grammar()` ensures our grammar is free of common mistakes.
    Don't write grammars without it!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create an AST from this expression and turn it into Python code (well,
    a literal):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do this a number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Our grammar can also *parse* ASTs obtained from concrete code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now come up with a quiz question: *Does our grammar support negative
    numbers?* For this, let''s first find out if the `Constant()` constructor also
    take a *negative* number as an argument? It turns out it can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: But what happens if we parse a negative number, say `-1`? One might assume that
    this simply results in a `Constant(-1)`, right? Try it out yourself!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Quiz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we parse a negative number, do we obtain
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that parsing `-1` yields a unary minus `USub()` applied to a
    positive value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As unary operators are not part of our grammar (yet), it cannot handle negative
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the next sections, we will gradually expand our grammar with more and more
    Python features, eventually covering (almost) the entire language.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Composites"><summary>Composites</summary>
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add composite constants – lists, dictionaries, tuples, etc. Here is
    how these are represented in an AST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Let us encode these into a grammar, again using the definitions from the [abstract
    AST grammar](https://docs.python.org/3/library/ast.html). All these structures
    also take *contexts* in which identifiers are used – `Load()` if they are used
    for evaluation, `Store()` if they appear on the left-hand side of an assignment
    (yes, in Python, you can have a tuple on the left-hand side of an assignment,
    say `(x, y) = (1, 2)`), and `Del()` if they are used as operands in a `del` statement.
    Right now, we only use `Load()` and `Del()` interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You may encounter a number of uncommon expressions here. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`()` is an empty tuple.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(1,)` is a tuple with one element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{}` is an empty dictionary; `{1}` is a set with one element.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An empty set is denoted by `set()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fact that we use `set()` to represent empty sets is actually a feature of
    our `PYTHON_AST_COMPOSITES_GRAMMAR` grammar. If we invoke the `Set()` AST constructor
    without any elements, we obtain this beautiful expression...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '... which indeed evaluates into an empty set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Technically speaking, all of this is correct, but we'd like to stick to (somewhat)
    more readable code. If you want to confuse your programmer friends, always use
    `{*()}` instead of `set()`.</details> <details id="Excursion:-Expressions"><summary>Expressions</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Let us extend our grammar with *expressions*. The Python parser already takes
    care of precedence rules, so we can treat all unary and binary operators in a
    similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Not all of these expressions are *type-correct*. For instance, `set() * set()`
    raises a type error at runtime. They *can* be properly parsed, though.
  prefs: []
  type: TYPE_NORMAL
- en: How good is our grammar at this point? Let us create 20 expressions and check
    how many of these
  prefs: []
  type: TYPE_NORMAL
- en: parse without `SyntaxError`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: evaluate without `TypeError`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We're not doing too bad here. It is possible, in principle, to use ISLa constraints
    such that the resulting code will be properly typed - but this would take hundreds
    to thousands of rules. We will leave this exercise to the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you should *not* repeat this experiment once *identifiers* come into
    play. There is a remote chance that the fuzzer synthesizes a call like `os.remove("/")`
    – and away goes your file system!</details> <details id="Excursion:-Names-and-Function-Calls"><summary>Names
    and Function Calls</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Let us add some *identifiers* such that we can call *functions*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]</details> <details id="Excursion:-Attributes-and-Subscripts"><summary>Attributes
    and Subscripts</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: Let us add attributes and subscripts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]</details> <details id="Excursion:-Variable-Assignments"><summary>Variable
    Assignments</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: Now for variable assignments. These make things more complex, as we have a restricted
    set of expressions on the left hand side of an assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]</details> <details id="Excursion:-Statements"><summary>Statements</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: Now for statements. There's quite a lot of these.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see if we can also *parse* code properly. Here is a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: It seems our grammar can also parse non-trivial code properly. We are doing
    well!</details> <details id="Excursion:-Function-Definitions"><summary>Function
    Definitions</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Now for function definitions. Not too many surprises here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python 3.12 and later, function definitions also have a `type_param` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'In Python 3.13 and later, several `<FunctionDef>` and `<arguments>` attributes
    are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]</details> <details id="Excursion:-Modules"><summary>Modules</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: We close with *modules* – sequences of definitions. After all the other definitions,
    this is now fairly straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have covered (almost) all AST elements of Python. There would
    be a few more Python elements to consider (marked as `FIXME`, above), but we'll
    leave these to the reader. Let us define `PYTHON_AST_GRAMMAR` as the official
    grammar coming out of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Here are a few (very weird) examples of Python functions we can produce. All
    of these are valid, but only *syntactically* – very few of the code samples produced
    this way will actually result in something meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: A Class for Fuzzing Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For convenience, let us introduce a class `PythonFuzzer` that makes use of the
    above grammar in order to produce Python code. This will be fairly easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: By default, the `PythonFuzzer` will produce a *function definition* - that is,
    a function header and body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing a start symbol as parameter, you can have `PythonFuzzer` produce
    arbitrary Python elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of all possible start symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the Python Fuzzer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When fuzzing, you may be interested in *specific* properties of the produced
    output. How can we influence the code that `PythonFuzzer` produces? We explore
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By adjusting the *grammar* to our needs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By adding *constraints* that customize the output for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting the Grammar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A simple way to adjust output generation is to *adapt the grammar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume you''d like to have function definitions without decorators.
    To achieve this, you can *alter the rule that produces function definitions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: As any AST rule, it comes in *abstract syntax*, so we first have to identify
    the element we'd like to adjust. In our case, this is `decorator_list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since decorator_list is a list, we can alter the rule to produce empty lists
    only. To create a new adapted grammar, we do not alter the existing `PYTHON_AST_GRAMMAR`.
    Instead, we use the `extend_grammar()` function to create a new grammar with a
    new, adapted rule for `<FunctionDef>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we''re not done yet. We also need to ensure that our grammar is *valid*,
    as any misspelled nonterminal identifier will result in problems during production.
    For this, we use the `is_valid_grammar()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that with our change, our grammar has an *orphaned rule*: The `<returns>`
    rule is no longer used. This is because `<returns>` is part of the `<type_annotation>`
    we just have deleted. (`<type_annotation>` is still used when defining types for
    variables.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we need to delete the `<returns>` rule from our grammar. Fortunately,
    we have a function `trim_grammar()`, which deletes all orphaned rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: With this, our grammar becomes valid...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '... and we can use it for fuzzing - now without decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Adjusting the grammar is straightforward once you understood the grammar structure,
    but the AST grammar is complex; also, your changes and extensions tie you closely
    to the grammar structure. Carefully study how the individual rules are defined,
    above.
  prefs: []
  type: TYPE_NORMAL
- en: Using Constraints for Customizing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more elegant alternative to altering the grammar is to make use of *constraints*
    that tune the grammar to your needs. Since `PythonFuzzer` is derived from `ISLaSolver`,
    we can pass a `constraint` argument constraining the grammar, as discussed in
    the chapter on [fuzzing with constraints](FuzzingWithConstraints.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to have a function definition with 10 characters in each identifier,
    we make use of an ISLa constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: We can also constrain individual children – say, the actual identifier of the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we want to test how the compiler handles large numbers. Let us define
    a constraint such that the function body (`<nonempty_stmt_list>`) contains at
    least one integer (`<integer>`) with a value of at least 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Assume we'd like to test compilers with non-trivial functions. Here's how to
    define a constraint such that the function body has exactly *three* statements
    (`<stmt>`). Note that this can take more than a minute to resolve, but the result
    definitely is a nontrivial function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, if we want the decorator list to be empty, as in our grammar-altering
    example, we can constrain the decorator list to be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Mutating Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When producing code for compilers (or actually, producing inputs in general),
    it is often a good idea to not just create *everything* from scratch, but rather
    to *mutate* existing inputs. This way, one can achieve a better balance between
    *common* inputs (the ones to mutate) and *uncommon inputs* (the new parts added
    via mutation).
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To *mutate* inputs, we first need to be able to *parse* them. This is where
    a grammar is really put to test - can it really parse all possible code? This
    is why relying on an *existing* parser that is tried and proven (in our case the
    Python parser) and operating on an *abstraction* (in our case the AST) is really
    handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have seen how to parse code into an AST, using `ast.parse()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Our grammar is able to parse this (non_trivial) string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: To mutate the input, we first have to parse it into a *derivation tree* structure.
    This is (again) a tree representation of the code, but this time, using the elements
    of *our* grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us inspect what a derivation tree looks like. Alas, the string representation
    is very long and not that useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can *visualize* the derivation tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="2150pt" height="1228pt" viewBox="0.00 0.00 2150.25 1228.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 1224.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="1188.5"
    y="-1206.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="1188.5"
    y="-1156.7" font-family="Times,serif" font-size="14.00"><mod></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="1188.5" y="-1106.45" font-family="Times,serif" font-size="14.00"><Module></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="995.5" y="-1056.2" font-family="Times,serif" font-size="14.00">Module(body=</text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="1117.5" y="-1056.2" font-family="Times,serif" font-size="14.00"><nonempty_stmt_list></text></g>
    <g id="edge4" class="edge"><title>2->4</title></g> <g id="node201" class="node"><title>200</title>
    <text text-anchor="middle" x="1259.5" y="-1056.2" font-family="Times,serif" font-size="14.00"><type_ignore_param></text></g>
    <g id="edge200" class="edge"><title>2->200</title></g> <g id="node207" class="node"><title>206</title>
    <text text-anchor="middle" x="1354.5" y="-1056.2" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge206" class="edge"><title>2->206</title></g> <g id="node6"
    class="node"><title>5</title> <text text-anchor="middle" x="1061.5" y="-1005.95"
    font-family="Times,serif" font-size="14.00">[ (91)</text></g> <g id="edge5" class="edge"><title>4->5</title></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="1117.5"
    y="-1005.95" font-family="Times,serif" font-size="14.00"><stmts></text></g> <g
    id="edge6" class="edge"><title>4->6</title></g> <g id="node200" class="node"><title>199</title>
    <text text-anchor="middle" x="1173.5" y="-1005.95" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge199" class="edge"><title>4->199</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="1117.5" y="-955.7"
    font-family="Times,serif" font-size="14.00"><stmt></text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="1117.5"
    y="-905.45" font-family="Times,serif" font-size="14.00"><FunctionDef></text></g>
    <g id="edge8" class="edge"><title>7->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="61.5" y="-855.2" font-family="Times,serif" font-size="14.00">FunctionDef(name=</text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="167.5" y="-855.2" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge10" class="edge"><title>8->10</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="681.5" y="-855.2" font-family="Times,serif" font-size="14.00">,
    args=</text></g> <g id="edge23" class="edge"><title>8->23</title></g> <g id="node25"
    class="node"><title>24</title> <text text-anchor="middle" x="755.5" y="-855.2"
    font-family="Times,serif" font-size="14.00"><arguments></text></g> <g id="edge24"
    class="edge"><title>8->24</title></g> <g id="node82" class="node"><title>81</title>
    <text text-anchor="middle" x="1066.5" y="-855.2" font-family="Times,serif" font-size="14.00">,
    body=</text></g> <g id="edge81" class="edge"><title>8->81</title></g> <g id="node83"
    class="node"><title>82</title> <text text-anchor="middle" x="1168.5" y="-855.2"
    font-family="Times,serif" font-size="14.00"><nonempty_stmt_list></text></g> <g
    id="edge82" class="edge"><title>8->82</title></g> <g id="node191" class="node"><title>190</title>
    <text text-anchor="middle" x="1315.5" y="-855.2" font-family="Times,serif" font-size="14.00"><decorator_list_param></text></g>
    <g id="edge190" class="edge"><title>8->190</title></g> <g id="node197" class="node"><title>196</title>
    <text text-anchor="middle" x="1432.5" y="-855.2" font-family="Times,serif" font-size="14.00"><returns-1></text></g>
    <g id="edge196" class="edge"><title>8->196</title></g> <g id="node198" class="node"><title>197</title>
    <text text-anchor="middle" x="1537.5" y="-855.2" font-family="Times,serif" font-size="14.00"><type_comment-3></text></g>
    <g id="edge197" class="edge"><title>8->197</title></g> <g id="node199" class="node"><title>198</title>
    <text text-anchor="middle" x="1625.5" y="-855.2" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge198" class="edge"><title>8->198</title></g> <g id="node12"
    class="node"><title>11</title> <text text-anchor="middle" x="75.5" y="-804.95"
    font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge11" class="edge"><title>10->11</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="121.5"
    y="-804.95" font-family="Times,serif" font-size="14.00"><id></text></g> <g id="edge12"
    class="edge"><title>10->12</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="167.5" y="-804.95" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge22" class="edge"><title>10->22</title></g> <g id="node14"
    class="node"><title>13</title> <text text-anchor="middle" x="28.5" y="-754.7"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge13"
    class="edge"><title>12->13</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="121.5" y="-754.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge15" class="edge"><title>12->15</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="26.5" y="-704.45" font-family="Times,serif" font-size="14.00">s
    (115)</text></g> <g id="edge14" class="edge"><title>13->14</title></g> <g id="node17"
    class="node"><title>16</title> <text text-anchor="middle" x="103.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge16"
    class="edge"><title>15->16</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="207.5" y="-704.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge18" class="edge"><title>15->18</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="103.5" y="-654.2" font-family="Times,serif" font-size="14.00">u
    (117)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="189.5" y="-654.2"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge19"
    class="edge"><title>18->19</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="293.5" y="-654.2" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge21" class="edge"><title>18->21</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="189.5" y="-603.95" font-family="Times,serif" font-size="14.00">m
    (109)</text></g> <g id="edge20" class="edge"><title>19->20</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="230.5" y="-804.95"
    font-family="Times,serif" font-size="14.00">arguments(</text></g> <g id="edge25"
    class="edge"><title>24->25</title></g> <g id="node27" class="node"><title>26</title>
    <text text-anchor="middle" x="340.5" y="-804.95" font-family="Times,serif" font-size="14.00"><posonlyargs_param></text></g>
    <g id="edge26" class="edge"><title>24->26</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="middle" x="435.5" y="-804.95" font-family="Times,serif" font-size="14.00">args=</text></g>
    <g id="edge33" class="edge"><title>24->33</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="middle" x="497.5" y="-804.95" font-family="Times,serif" font-size="14.00"><arg_list></text></g>
    <g id="edge34" class="edge"><title>24->34</title></g> <g id="node61" class="node"><title>60</title>
    <text text-anchor="middle" x="575.5" y="-804.95" font-family="Times,serif" font-size="14.00"><vararg-1></text></g>
    <g id="edge60" class="edge"><title>24->60</title></g> <g id="node62" class="node"><title>61</title>
    <text text-anchor="middle" x="685.5" y="-804.95" font-family="Times,serif" font-size="14.00"><kwonlyargs_param></text></g>
    <g id="edge61" class="edge"><title>24->61</title></g> <g id="node68" class="node"><title>67</title>
    <text text-anchor="middle" x="825.5" y="-804.95" font-family="Times,serif" font-size="14.00"><kw_defaults_param></text></g>
    <g id="edge67" class="edge"><title>24->67</title></g> <g id="node74" class="node"><title>73</title>
    <text text-anchor="middle" x="936.5" y="-804.95" font-family="Times,serif" font-size="14.00"><kwarg-1></text></g>
    <g id="edge73" class="edge"><title>24->73</title></g> <g id="node75" class="node"><title>74</title>
    <text text-anchor="middle" x="1035.5" y="-804.95" font-family="Times,serif" font-size="14.00"><defaults_param></text></g>
    <g id="edge74" class="edge"><title>24->74</title></g> <g id="node81" class="node"><title>80</title>
    <text text-anchor="middle" x="1119.5" y="-804.95" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge80" class="edge"><title>24->80</title></g> <g id="node28"
    class="node"><title>27</title> <text text-anchor="middle" x="258.5" y="-754.7"
    font-family="Times,serif" font-size="14.00">posonlyargs=</text></g> <g id="edge27"
    class="edge"><title>26->27</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="341.5" y="-754.7" font-family="Times,serif" font-size="14.00"><arg_list></text></g>
    <g id="edge28" class="edge"><title>26->28</title></g> <g id="node33" class="node"><title>32</title>
    <text text-anchor="middle" x="391.5" y="-754.7" font-family="Times,serif" font-size="14.00">,</text></g>
    <g id="edge32" class="edge"><title>26->32</title></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="286.5" y="-704.45" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge29" class="edge"><title>28->29</title></g> <g id="node31"
    class="node"><title>30</title> <text text-anchor="middle" x="345.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><args-1></text></g> <g id="edge30"
    class="edge"><title>28->30</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="404.5" y="-704.45" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge31" class="edge"><title>28->31</title></g> <g id="node36"
    class="node"><title>35</title> <text text-anchor="middle" x="435.5" y="-754.7"
    font-family="Times,serif" font-size="14.00">[ (91)</text></g> <g id="edge35" class="edge"><title>34->35</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="494.5"
    y="-754.7" font-family="Times,serif" font-size="14.00"><args-1></text></g> <g
    id="edge36" class="edge"><title>34->36</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="middle" x="553.5" y="-754.7" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge59" class="edge"><title>34->59</title></g> <g id="node38"
    class="node"><title>37</title> <text text-anchor="middle" x="494.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><args></text></g> <g id="edge37" class="edge"><title>36->37</title></g>
    <g id="node39" class="node"><title>38</title> <text text-anchor="middle" x="408.5"
    y="-654.2" font-family="Times,serif" font-size="14.00"><arg></text></g> <g id="edge38"
    class="edge"><title>37->38</title></g> <g id="node49" class="node"><title>48</title>
    <text text-anchor="middle" x="494.5" y="-654.2" font-family="Times,serif" font-size="14.00">,</text></g>
    <g id="edge48" class="edge"><title>37->48</title></g> <g id="node50" class="node"><title>49</title>
    <text text-anchor="middle" x="559.5" y="-654.2" font-family="Times,serif" font-size="14.00"><arg></text></g>
    <g id="edge49" class="edge"><title>37->49</title></g> <g id="node40" class="node"><title>39</title>
    <text text-anchor="middle" x="301.5" y="-603.95" font-family="Times,serif" font-size="14.00">arg(arg=</text></g>
    <g id="edge39" class="edge"><title>38->39</title></g> <g id="node41" class="node"><title>40</title>
    <text text-anchor="middle" x="375.5" y="-603.95" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge40" class="edge"><title>38->40</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="middle" x="441.5" y="-603.95" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge47" class="edge"><title>38->47</title></g> <g id="node42"
    class="node"><title>41</title> <text text-anchor="middle" x="329.5" y="-553.7"
    font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge41" class="edge"><title>40->41</title></g>
    <g id="node43" class="node"><title>42</title> <text text-anchor="middle" x="375.5"
    y="-553.7" font-family="Times,serif" font-size="14.00"><id></text></g> <g id="edge42"
    class="edge"><title>40->42</title></g> <g id="node47" class="node"><title>46</title>
    <text text-anchor="middle" x="421.5" y="-553.7" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge46" class="edge"><title>40->46</title></g> <g id="node44"
    class="node"><title>43</title> <text text-anchor="middle" x="329.5" y="-503.45"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge43"
    class="edge"><title>42->43</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="middle" x="421.5" y="-503.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge45" class="edge"><title>42->45</title></g> <g id="node45" class="node"><title>44</title>
    <text text-anchor="middle" x="329.5" y="-453.2" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge44" class="edge"><title>43->44</title></g> <g id="node51"
    class="node"><title>50</title> <text text-anchor="middle" x="498.5" y="-603.95"
    font-family="Times,serif" font-size="14.00">arg(arg=</text></g> <g id="edge50"
    class="edge"><title>49->50</title></g> <g id="node52" class="node"><title>51</title>
    <text text-anchor="middle" x="572.5" y="-603.95" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge51" class="edge"><title>49->51</title></g> <g id="node59" class="node"><title>58</title>
    <text text-anchor="middle" x="638.5" y="-603.95" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge58" class="edge"><title>49->58</title></g> <g id="node53"
    class="node"><title>52</title> <text text-anchor="middle" x="526.5" y="-553.7"
    font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge52" class="edge"><title>51->52</title></g>
    <g id="node54" class="node"><title>53</title> <text text-anchor="middle" x="572.5"
    y="-553.7" font-family="Times,serif" font-size="14.00"><id></text></g> <g id="edge53"
    class="edge"><title>51->53</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="middle" x="618.5" y="-553.7" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge57" class="edge"><title>51->57</title></g> <g id="node55"
    class="node"><title>54</title> <text text-anchor="middle" x="543.5" y="-503.45"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge54"
    class="edge"><title>53->54</title></g> <g id="node57" class="node"><title>56</title>
    <text text-anchor="middle" x="635.5" y="-503.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge56" class="edge"><title>53->56</title></g> <g id="node56" class="node"><title>55</title>
    <text text-anchor="middle" x="543.5" y="-453.2" font-family="Times,serif" font-size="14.00">b
    (98)</text></g> <g id="edge55" class="edge"><title>54->55</title></g> <g id="node63"
    class="node"><title>62</title> <text text-anchor="middle" x="626.5" y="-754.7"
    font-family="Times,serif" font-size="14.00">, kwonlyargs=</text></g> <g id="edge62"
    class="edge"><title>61->62</title></g> <g id="node64" class="node"><title>63</title>
    <text text-anchor="middle" x="712.5" y="-754.7" font-family="Times,serif" font-size="14.00"><arg_list></text></g>
    <g id="edge63" class="edge"><title>61->63</title></g> <g id="node65" class="node"><title>64</title>
    <text text-anchor="middle" x="653.5" y="-704.45" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge64" class="edge"><title>63->64</title></g> <g id="node66"
    class="node"><title>65</title> <text text-anchor="middle" x="712.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><args-1></text></g> <g id="edge65"
    class="edge"><title>63->65</title></g> <g id="node67" class="node"><title>66</title>
    <text text-anchor="middle" x="771.5" y="-704.45" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge66" class="edge"><title>63->66</title></g> <g id="node69"
    class="node"><title>68</title> <text text-anchor="middle" x="799.5" y="-754.7"
    font-family="Times,serif" font-size="14.00">, kw_defaults=</text></g> <g id="edge68"
    class="edge"><title>67->68</title></g> <g id="node70" class="node"><title>69</title>
    <text text-anchor="middle" x="890.5" y="-754.7" font-family="Times,serif" font-size="14.00"><expr_list></text></g>
    <g id="edge69" class="edge"><title>67->69</title></g> <g id="node71" class="node"><title>70</title>
    <text text-anchor="middle" x="826.5" y="-704.45" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge70" class="edge"><title>69->70</title></g> <g id="node72"
    class="node"><title>71</title> <text text-anchor="middle" x="888.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><exprs-1></text></g> <g id="edge71"
    class="edge"><title>69->71</title></g> <g id="node73" class="node"><title>72</title>
    <text text-anchor="middle" x="950.5" y="-704.45" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge72" class="edge"><title>69->72</title></g> <g id="node76"
    class="node"><title>75</title> <text text-anchor="middle" x="982.5" y="-754.7"
    font-family="Times,serif" font-size="14.00">, defaults=</text></g> <g id="edge75"
    class="edge"><title>74->75</title></g> <g id="node77" class="node"><title>76</title>
    <text text-anchor="middle" x="1061.5" y="-754.7" font-family="Times,serif" font-size="14.00"><expr_list></text></g>
    <g id="edge76" class="edge"><title>74->76</title></g> <g id="node78" class="node"><title>77</title>
    <text text-anchor="middle" x="999.5" y="-704.45" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge77" class="edge"><title>76->77</title></g> <g id="node79"
    class="node"><title>78</title> <text text-anchor="middle" x="1061.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><exprs-1></text></g> <g id="edge78"
    class="edge"><title>76->78</title></g> <g id="node80" class="node"><title>79</title>
    <text text-anchor="middle" x="1123.5" y="-704.45" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge79" class="edge"><title>76->79</title></g> <g id="node84"
    class="node"><title>83</title> <text text-anchor="middle" x="1168.5" y="-804.95"
    font-family="Times,serif" font-size="14.00">[ (91)</text></g> <g id="edge83" class="edge"><title>82->83</title></g>
    <g id="node85" class="node"><title>84</title> <text text-anchor="middle" x="1224.5"
    y="-804.95" font-family="Times,serif" font-size="14.00"><stmts></text></g> <g
    id="edge84" class="edge"><title>82->84</title></g> <g id="node190" class="node"><title>189</title>
    <text text-anchor="middle" x="1280.5" y="-804.95" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge189" class="edge"><title>82->189</title></g> <g id="node86"
    class="node"><title>85</title> <text text-anchor="middle" x="1183.5" y="-754.7"
    font-family="Times,serif" font-size="14.00"><stmt></text></g> <g id="edge85" class="edge"><title>84->85</title></g>
    <g id="node155" class="node"><title>154</title> <text text-anchor="middle" x="1225.5"
    y="-754.7" font-family="Times,serif" font-size="14.00">,</text></g> <g id="edge154"
    class="edge"><title>84->154</title></g> <g id="node156" class="node"><title>155</title>
    <text text-anchor="middle" x="1302.5" y="-754.7" font-family="Times,serif" font-size="14.00"><stmts></text></g>
    <g id="edge155" class="edge"><title>84->155</title></g> <g id="node87" class="node"><title>86</title>
    <text text-anchor="middle" x="1183.5" y="-704.45" font-family="Times,serif" font-size="14.00"><Assign></text></g>
    <g id="edge86" class="edge"><title>85->86</title></g> <g id="node88" class="node"><title>87</title>
    <text text-anchor="middle" x="873.5" y="-654.2" font-family="Times,serif" font-size="14.00">Assign(targets=</text></g>
    <g id="edge87" class="edge"><title>86->87</title></g> <g id="node89" class="node"><title>88</title>
    <text text-anchor="middle" x="1008.5" y="-654.2" font-family="Times,serif" font-size="14.00"><nonempty_lhs_expr_list></text></g>
    <g id="edge88" class="edge"><title>86->88</title></g> <g id="node122" class="node"><title>121</title>
    <text text-anchor="middle" x="1122.5" y="-654.2" font-family="Times,serif" font-size="14.00">,
    value=</text></g> <g id="edge121" class="edge"><title>86->121</title></g> <g id="node123"
    class="node"><title>122</title> <text text-anchor="middle" x="1183.5" y="-654.2"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge122"
    class="edge"><title>86->122</title></g> <g id="node153" class="node"><title>152</title>
    <text text-anchor="middle" x="1276.5" y="-654.2" font-family="Times,serif" font-size="14.00"><type_comment-1></text></g>
    <g id="edge152" class="edge"><title>86->152</title></g> <g id="node154" class="node"><title>153</title>
    <text text-anchor="middle" x="1364.5" y="-654.2" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge153" class="edge"><title>86->153</title></g> <g id="node90"
    class="node"><title>89</title> <text text-anchor="middle" x="906.5" y="-603.95"
    font-family="Times,serif" font-size="14.00">[ (91)</text></g> <g id="edge89" class="edge"><title>88->89</title></g>
    <g id="node91" class="node"><title>90</title> <text text-anchor="middle" x="974.5"
    y="-603.95" font-family="Times,serif" font-size="14.00"><lhs_exprs></text></g>
    <g id="edge90" class="edge"><title>88->90</title></g> <g id="node121" class="node"><title>120</title>
    <text text-anchor="middle" x="1042.5" y="-603.95" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge120" class="edge"><title>88->120</title></g> <g id="node92"
    class="node"><title>91</title> <text text-anchor="middle" x="864.5" y="-553.7"
    font-family="Times,serif" font-size="14.00"><lhs_expr></text></g> <g id="edge91"
    class="edge"><title>90->91</title></g> <g id="node93" class="node"><title>92</title>
    <text text-anchor="middle" x="859.5" y="-503.45" font-family="Times,serif" font-size="14.00"><lhs_Name></text></g>
    <g id="edge92" class="edge"><title>91->92</title></g> <g id="node94" class="node"><title>93</title>
    <text text-anchor="middle" x="736.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text></g>
    <g id="edge93" class="edge"><title>92->93</title></g> <g id="node95" class="node"><title>94</title>
    <text text-anchor="middle" x="815.5" y="-453.2" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge94" class="edge"><title>92->94</title></g> <g id="node120" class="node"><title>119</title>
    <text text-anchor="middle" x="903.5" y="-453.2" font-family="Times,serif" font-size="14.00">,
    ctx=Store())</text></g> <g id="edge119" class="edge"><title>92->119</title></g>
    <g id="node96" class="node"><title>95</title> <text text-anchor="middle" x="769.5"
    y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge95"
    class="edge"><title>94->95</title></g> <g id="node97" class="node"><title>96</title>
    <text text-anchor="middle" x="815.5" y="-402.95" font-family="Times,serif" font-size="14.00"><id></text></g>
    <g id="edge96" class="edge"><title>94->96</title></g> <g id="node119" class="node"><title>118</title>
    <text text-anchor="middle" x="861.5" y="-402.95" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge118" class="edge"><title>94->118</title></g> <g id="node98"
    class="node"><title>97</title> <text text-anchor="middle" x="742.5" y="-352.7"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge97"
    class="edge"><title>96->97</title></g> <g id="node100" class="node"><title>99</title>
    <text text-anchor="middle" x="834.5" y="-352.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge99" class="edge"><title>96->99</title></g> <g id="node99" class="node"><title>98</title>
    <text text-anchor="middle" x="742.5" y="-302.45" font-family="Times,serif" font-size="14.00">t
    (116)</text></g> <g id="edge98" class="edge"><title>97->98</title></g> <g id="node101"
    class="node"><title>100</title> <text text-anchor="middle" x="826.5" y="-302.45"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge100"
    class="edge"><title>99->100</title></g> <g id="node103" class="node"><title>102</title>
    <text text-anchor="middle" x="930.5" y="-302.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge102" class="edge"><title>99->102</title></g> <g id="node102" class="node"><title>101</title>
    <text text-anchor="middle" x="826.5" y="-252.2" font-family="Times,serif" font-size="14.00">h
    (104)</text></g> <g id="edge101" class="edge"><title>100->101</title></g> <g id="node104"
    class="node"><title>103</title> <text text-anchor="middle" x="917.5" y="-252.2"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge103"
    class="edge"><title>102->103</title></g> <g id="node106" class="node"><title>105</title>
    <text text-anchor="middle" x="1021.5" y="-252.2" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge105" class="edge"><title>102->105</title></g> <g id="node105" class="node"><title>104</title>
    <text text-anchor="middle" x="917.5" y="-201.95" font-family="Times,serif" font-size="14.00">e
    (101)</text></g> <g id="edge104" class="edge"><title>103->104</title></g> <g id="node107"
    class="node"><title>106</title> <text text-anchor="middle" x="1008.5" y="-201.95"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge106"
    class="edge"><title>105->106</title></g> <g id="node109" class="node"><title>108</title>
    <text text-anchor="middle" x="1112.5" y="-201.95" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge108" class="edge"><title>105->108</title></g> <g id="node108" class="node"><title>107</title>
    <text text-anchor="middle" x="1008.5" y="-151.7" font-family="Times,serif" font-size="14.00">_
    (95)</text></g> <g id="edge107" class="edge"><title>106->107</title></g> <g id="node110"
    class="node"><title>109</title> <text text-anchor="middle" x="1098.5" y="-151.7"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge109"
    class="edge"><title>108->109</title></g> <g id="node112" class="node"><title>111</title>
    <text text-anchor="middle" x="1202.5" y="-151.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge111" class="edge"><title>108->111</title></g> <g id="node111" class="node"><title>110</title>
    <text text-anchor="middle" x="1098.5" y="-101.45" font-family="Times,serif" font-size="14.00">s
    (115)</text></g> <g id="edge110" class="edge"><title>109->110</title></g> <g id="node113"
    class="node"><title>112</title> <text text-anchor="middle" x="1188.5" y="-101.45"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge112"
    class="edge"><title>111->112</title></g> <g id="node115" class="node"><title>114</title>
    <text text-anchor="middle" x="1292.5" y="-101.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge114" class="edge"><title>111->114</title></g> <g id="node114" class="node"><title>113</title>
    <text text-anchor="middle" x="1188.5" y="-51.2" font-family="Times,serif" font-size="14.00">u
    (117)</text></g> <g id="edge113" class="edge"><title>112->113</title></g> <g id="node116"
    class="node"><title>115</title> <text text-anchor="middle" x="1279.5" y="-51.2"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge115"
    class="edge"><title>114->115</title></g> <g id="node118" class="node"><title>117</title>
    <text text-anchor="middle" x="1383.5" y="-51.2" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge117" class="edge"><title>114->117</title></g> <g id="node117" class="node"><title>116</title>
    <text text-anchor="middle" x="1279.5" y="-0.95" font-family="Times,serif" font-size="14.00">m
    (109)</text></g> <g id="edge116" class="edge"><title>115->116</title></g> <g id="node124"
    class="node"><title>123</title> <text text-anchor="middle" x="1183.5" y="-603.95"
    font-family="Times,serif" font-size="14.00"><BinOp></text></g> <g id="edge123"
    class="edge"><title>122->123</title></g> <g id="node125" class="node"><title>124</title>
    <text text-anchor="middle" x="995.5" y="-553.7" font-family="Times,serif" font-size="14.00">BinOp(left=</text></g>
    <g id="edge124" class="edge"><title>123->124</title></g> <g id="node126" class="node"><title>125</title>
    <text text-anchor="middle" x="1067.5" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge125" class="edge"><title>123->125</title></g> <g id="node137" class="node"><title>136</title>
    <text text-anchor="middle" x="1120.5" y="-553.7" font-family="Times,serif" font-size="14.00">,
    op=</text></g> <g id="edge136" class="edge"><title>123->136</title></g> <g id="node138"
    class="node"><title>137</title> <text text-anchor="middle" x="1183.5" y="-553.7"
    font-family="Times,serif" font-size="14.00"><operator></text></g> <g id="edge137"
    class="edge"><title>123->137</title></g> <g id="node140" class="node"><title>139</title>
    <text text-anchor="middle" x="1252.5" y="-553.7" font-family="Times,serif" font-size="14.00">,
    right=</text></g> <g id="edge139" class="edge"><title>123->139</title></g> <g
    id="node141" class="node"><title>140</title> <text text-anchor="middle" x="1311.5"
    y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge140"
    class="edge"><title>123->140</title></g> <g id="node152" class="node"><title>151</title>
    <text text-anchor="middle" x="1365.5" y="-553.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge151" class="edge"><title>123->151</title></g> <g id="node127"
    class="node"><title>126</title> <text text-anchor="middle" x="1066.5" y="-503.45"
    font-family="Times,serif" font-size="14.00"><Name></text></g> <g id="edge126"
    class="edge"><title>125->126</title></g> <g id="node128" class="node"><title>127</title>
    <text text-anchor="middle" x="986.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text></g>
    <g id="edge127" class="edge"><title>126->127</title></g> <g id="node129" class="node"><title>128</title>
    <text text-anchor="middle" x="1065.5" y="-453.2" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge128" class="edge"><title>126->128</title></g> <g id="node136" class="node"><title>135</title>
    <text text-anchor="middle" x="1152.5" y="-453.2" font-family="Times,serif" font-size="14.00">,
    ctx=Load())</text></g> <g id="edge135" class="edge"><title>126->135</title></g>
    <g id="node130" class="node"><title>129</title> <text text-anchor="middle" x="1019.5"
    y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge129"
    class="edge"><title>128->129</title></g> <g id="node131" class="node"><title>130</title>
    <text text-anchor="middle" x="1065.5" y="-402.95" font-family="Times,serif" font-size="14.00"><id></text></g>
    <g id="edge130" class="edge"><title>128->130</title></g> <g id="node135" class="node"><title>134</title>
    <text text-anchor="middle" x="1111.5" y="-402.95" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge134" class="edge"><title>128->134</title></g> <g id="node132"
    class="node"><title>131</title> <text text-anchor="middle" x="1047.5" y="-352.7"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge131"
    class="edge"><title>130->131</title></g> <g id="node134" class="node"><title>133</title>
    <text text-anchor="middle" x="1139.5" y="-352.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge133" class="edge"><title>130->133</title></g> <g id="node133" class="node"><title>132</title>
    <text text-anchor="middle" x="1047.5" y="-302.45" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge132" class="edge"><title>131->132</title></g> <g id="node139"
    class="node"><title>138</title> <text text-anchor="middle" x="1183.5" y="-503.45"
    font-family="Times,serif" font-size="14.00">Add()</text></g> <g id="edge138" class="edge"><title>137->138</title></g>
    <g id="node142" class="node"><title>141</title> <text text-anchor="middle" x="1312.5"
    y="-503.45" font-family="Times,serif" font-size="14.00"><Name></text></g> <g id="edge141"
    class="edge"><title>140->141</title></g> <g id="node143" class="node"><title>142</title>
    <text text-anchor="middle" x="1235.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text></g>
    <g id="edge142" class="edge"><title>141->142</title></g> <g id="node144" class="node"><title>143</title>
    <text text-anchor="middle" x="1314.5" y="-453.2" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge143" class="edge"><title>141->143</title></g> <g id="node151" class="node"><title>150</title>
    <text text-anchor="middle" x="1401.5" y="-453.2" font-family="Times,serif" font-size="14.00">,
    ctx=Load())</text></g> <g id="edge150" class="edge"><title>141->150</title></g>
    <g id="node145" class="node"><title>144</title> <text text-anchor="middle" x="1268.5"
    y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge144"
    class="edge"><title>143->144</title></g> <g id="node146" class="node"><title>145</title>
    <text text-anchor="middle" x="1314.5" y="-402.95" font-family="Times,serif" font-size="14.00"><id></text></g>
    <g id="edge145" class="edge"><title>143->145</title></g> <g id="node150" class="node"><title>149</title>
    <text text-anchor="middle" x="1360.5" y="-402.95" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge149" class="edge"><title>143->149</title></g> <g id="node147"
    class="node"><title>146</title> <text text-anchor="middle" x="1282.5" y="-352.7"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge146"
    class="edge"><title>145->146</title></g> <g id="node149" class="node"><title>148</title>
    <text text-anchor="middle" x="1374.5" y="-352.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge148" class="edge"><title>145->148</title></g> <g id="node148" class="node"><title>147</title>
    <text text-anchor="middle" x="1282.5" y="-302.45" font-family="Times,serif" font-size="14.00">b
    (98)</text></g> <g id="edge147" class="edge"><title>146->147</title></g> <g id="node157"
    class="node"><title>156</title> <text text-anchor="middle" x="1379.5" y="-704.45"
    font-family="Times,serif" font-size="14.00"><stmt></text></g> <g id="edge156"
    class="edge"><title>155->156</title></g> <g id="node158" class="node"><title>157</title>
    <text text-anchor="middle" x="1455.5" y="-654.2" font-family="Times,serif" font-size="14.00"><Return></text></g>
    <g id="edge157" class="edge"><title>156->157</title></g> <g id="node159" class="node"><title>158</title>
    <text text-anchor="middle" x="1385.5" y="-603.95" font-family="Times,serif" font-size="14.00">Return(value=</text></g>
    <g id="edge158" class="edge"><title>157->158</title></g> <g id="node160" class="node"><title>159</title>
    <text text-anchor="middle" x="1463.5" y="-603.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge159" class="edge"><title>157->159</title></g> <g id="node189" class="node"><title>188</title>
    <text text-anchor="middle" x="1517.5" y="-603.95" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge188" class="edge"><title>157->188</title></g> <g id="node161"
    class="node"><title>160</title> <text text-anchor="middle" x="1478.5" y="-553.7"
    font-family="Times,serif" font-size="14.00"><Name></text></g> <g id="edge160"
    class="edge"><title>159->160</title></g> <g id="node162" class="node"><title>161</title>
    <text text-anchor="middle" x="1408.5" y="-503.45" font-family="Times,serif" font-size="14.00">Name(id=</text></g>
    <g id="edge161" class="edge"><title>160->161</title></g> <g id="node163" class="node"><title>162</title>
    <text text-anchor="middle" x="1487.5" y="-503.45" font-family="Times,serif" font-size="14.00"><identifier></text></g>
    <g id="edge162" class="edge"><title>160->162</title></g> <g id="node188" class="node"><title>187</title>
    <text text-anchor="middle" x="1574.5" y="-503.45" font-family="Times,serif" font-size="14.00">,
    ctx=Load())</text></g> <g id="edge187" class="edge"><title>160->187</title></g>
    <g id="node164" class="node"><title>163</title> <text text-anchor="middle" x="1470.5"
    y="-453.2" font-family="Times,serif" font-size="14.00">' (39)</text></g> <g id="edge163"
    class="edge"><title>162->163</title></g> <g id="node165" class="node"><title>164</title>
    <text text-anchor="middle" x="1516.5" y="-453.2" font-family="Times,serif" font-size="14.00"><id></text></g>
    <g id="edge164" class="edge"><title>162->164</title></g> <g id="node187" class="node"><title>186</title>
    <text text-anchor="middle" x="1562.5" y="-453.2" font-family="Times,serif" font-size="14.00">'
    (39)</text></g> <g id="edge186" class="edge"><title>162->186</title></g> <g id="node166"
    class="node"><title>165</title> <text text-anchor="middle" x="1456.5" y="-402.95"
    font-family="Times,serif" font-size="14.00"><id_start></text></g> <g id="edge165"
    class="edge"><title>164->165</title></g> <g id="node168" class="node"><title>167</title>
    <text text-anchor="middle" x="1548.5" y="-402.95" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge167" class="edge"><title>164->167</title></g> <g id="node167" class="node"><title>166</title>
    <text text-anchor="middle" x="1456.5" y="-352.7" font-family="Times,serif" font-size="14.00">t
    (116)</text></g> <g id="edge166" class="edge"><title>165->166</title></g> <g id="node169"
    class="node"><title>168</title> <text text-anchor="middle" x="1540.5" y="-352.7"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge168"
    class="edge"><title>167->168</title></g> <g id="node171" class="node"><title>170</title>
    <text text-anchor="middle" x="1644.5" y="-352.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge170" class="edge"><title>167->170</title></g> <g id="node170" class="node"><title>169</title>
    <text text-anchor="middle" x="1540.5" y="-302.45" font-family="Times,serif" font-size="14.00">h
    (104)</text></g> <g id="edge169" class="edge"><title>168->169</title></g> <g id="node172"
    class="node"><title>171</title> <text text-anchor="middle" x="1631.5" y="-302.45"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge171"
    class="edge"><title>170->171</title></g> <g id="node174" class="node"><title>173</title>
    <text text-anchor="middle" x="1735.5" y="-302.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge173" class="edge"><title>170->173</title></g> <g id="node173" class="node"><title>172</title>
    <text text-anchor="middle" x="1631.5" y="-252.2" font-family="Times,serif" font-size="14.00">e
    (101)</text></g> <g id="edge172" class="edge"><title>171->172</title></g> <g id="node175"
    class="node"><title>174</title> <text text-anchor="middle" x="1722.5" y="-252.2"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge174"
    class="edge"><title>173->174</title></g> <g id="node177" class="node"><title>176</title>
    <text text-anchor="middle" x="1826.5" y="-252.2" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge176" class="edge"><title>173->176</title></g> <g id="node176" class="node"><title>175</title>
    <text text-anchor="middle" x="1722.5" y="-201.95" font-family="Times,serif" font-size="14.00">_
    (95)</text></g> <g id="edge175" class="edge"><title>174->175</title></g> <g id="node178"
    class="node"><title>177</title> <text text-anchor="middle" x="1811.5" y="-201.95"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge177"
    class="edge"><title>176->177</title></g> <g id="node180" class="node"><title>179</title>
    <text text-anchor="middle" x="1915.5" y="-201.95" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge179" class="edge"><title>176->179</title></g> <g id="node179" class="node"><title>178</title>
    <text text-anchor="middle" x="1811.5" y="-151.7" font-family="Times,serif" font-size="14.00">s
    (115)</text></g> <g id="edge178" class="edge"><title>177->178</title></g> <g id="node181"
    class="node"><title>180</title> <text text-anchor="middle" x="1901.5" y="-151.7"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge180"
    class="edge"><title>179->180</title></g> <g id="node183" class="node"><title>182</title>
    <text text-anchor="middle" x="2005.5" y="-151.7" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge182" class="edge"><title>179->182</title></g> <g id="node182" class="node"><title>181</title>
    <text text-anchor="middle" x="1901.5" y="-101.45" font-family="Times,serif" font-size="14.00">u
    (117)</text></g> <g id="edge181" class="edge"><title>180->181</title></g> <g id="node184"
    class="node"><title>183</title> <text text-anchor="middle" x="1992.5" y="-101.45"
    font-family="Times,serif" font-size="14.00"><id_continue></text></g> <g id="edge183"
    class="edge"><title>182->183</title></g> <g id="node186" class="node"><title>185</title>
    <text text-anchor="middle" x="2096.5" y="-101.45" font-family="Times,serif" font-size="14.00"><id_continue-1></text></g>
    <g id="edge185" class="edge"><title>182->185</title></g> <g id="node185" class="node"><title>184</title>
    <text text-anchor="middle" x="1992.5" y="-51.2" font-family="Times,serif" font-size="14.00">m
    (109)</text></g> <g id="edge184" class="edge"><title>183->184</title></g> <g id="node192"
    class="node"><title>191</title> <text text-anchor="middle" x="1358.5" y="-804.95"
    font-family="Times,serif" font-size="14.00">, decorator_list=</text></g> <g id="edge191"
    class="edge"><title>190->191</title></g> <g id="node193" class="node"><title>192</title>
    <text text-anchor="middle" x="1453.5" y="-804.95" font-family="Times,serif" font-size="14.00"><expr_list></text></g>
    <g id="edge192" class="edge"><title>190->192</title></g> <g id="node194" class="node"><title>193</title>
    <text text-anchor="middle" x="1391.5" y="-754.7" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge193" class="edge"><title>192->193</title></g> <g id="node195"
    class="node"><title>194</title> <text text-anchor="middle" x="1453.5" y="-754.7"
    font-family="Times,serif" font-size="14.00"><exprs-1></text></g> <g id="edge194"
    class="edge"><title>192->194</title></g> <g id="node196" class="node"><title>195</title>
    <text text-anchor="middle" x="1515.5" y="-754.7" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge195" class="edge"><title>192->195</title></g> <g id="node202"
    class="node"><title>201</title> <text text-anchor="middle" x="1254.5" y="-1005.95"
    font-family="Times,serif" font-size="14.00">, type_ignores=</text></g> <g id="edge201"
    class="edge"><title>200->201</title></g> <g id="node203" class="node"><title>202</title>
    <text text-anchor="middle" x="1367.5" y="-1005.95" font-family="Times,serif" font-size="14.00"><type_ignore_list></text></g>
    <g id="edge202" class="edge"><title>200->202</title></g> <g id="node204" class="node"><title>203</title>
    <text text-anchor="middle" x="1285.5" y="-955.7" font-family="Times,serif" font-size="14.00">[
    (91)</text></g> <g id="edge203" class="edge"><title>202->203</title></g> <g id="node205"
    class="node"><title>204</title> <text text-anchor="middle" x="1367.5" y="-955.7"
    font-family="Times,serif" font-size="14.00"><type_ignores-1></text></g> <g id="edge204"
    class="edge"><title>202->204</title></g> <g id="node206" class="node"><title>205</title>
    <text text-anchor="middle" x="1449.5" y="-955.7" font-family="Times,serif" font-size="14.00">]
    (93)</text></g> <g id="edge205" class="edge"><title>202->205</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: We see that a derivation tree consists of *nonterminal* nodes whose children
    make up an *expansion* from the grammar. For instance, at the very top, we see
    that a `<start>` nonterminal expands into a `<mod>` nonterminal, which again expands
    into a `<Module>` nonterminal. This comes right from the grammar rules
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: The child of `<mod>` is a `<Module>`, which expands into the nodes
  prefs: []
  type: TYPE_NORMAL
- en: '`(body=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<nonempty_stmt_list>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`, type_ignores=`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<type_ignore_list>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, nodes like `(body=` or `, type_ignores=` are called *terminal* nodes (because
    they have no more elements to expand). The nonterminals like `<nonempty_stmt_list>`
    get expanded further below – notably, `<nonempty_stmt_list>` expands into a `<FunctionDef>`
    node that represents the `sum()` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the structure exactly follows the `<Module>` definition in our grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'If we traverse the tree depth-first, left to right, and only collect the terminal
    symbols, we obtain the original string we parsed. Applying the `str()` function
    to the derivation tree gets us exactly that string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'And again, we can convert this string into an AST and thus obtain our original
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Mutating Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With derivation trees, we can have a *structured* representation of our input.
    In our case, we already have that with ASTs, so why bother introducing a new one?
    The answer is simple: Derivation trees also allow us to *synthesize* new inputs,
    because we have a *grammar* that describes their structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most notably, we can mutate inputs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the input into a derivation tree, as shown above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Randomly choose some node `<symbol>` in the derivation tree to be mutated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the grammar to produce a new expansion for `<symbol>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the children of `<symbol>` by the expansion just generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process as often as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a decent programming task, and if you'd like a blueprint, have a look
    at the `FragmentMutator` in this tutorial on [greybox fuzzing with grammars](https://www.fuzzingbook.org/html/GreyboxGrammarFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, ISLa already provides us with functionality that does exactly this.
    The `ISLaSolver.mutate()` method takes an input and mutates it according to the
    rules in the grammar. The input to mutate can be given as a derivation tree, or
    as a string; its output is a derivation tree (which can again be converted into
    a string).
  prefs: []
  type: TYPE_NORMAL
- en: Let us apply `mutate()` on our `sum()` function. The `min_mutations` and `max_mutations`
    parameters define how many mutation steps should be performed; we set both to
    1 in order to have exactly one mutation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Toy with the above to see the effect of a mutation. Note if one of the top-level
    nodes (like `<FunctionDef>` or `<Module>`) is selected for mutation, then `sum()`
    will be replaced by something entirely different. Otherwise, though, the code
    will still be pretty similar to the original `sum()` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the more we increase the number of mutations, the more different
    the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: By toying with the `mutate()` parameters, we can control how *common* and how
    *uncommon* our input should be.
  prefs: []
  type: TYPE_NORMAL
- en: How Effective is Mutation?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Does mutating existing code help us in finding bugs? Let us assume we have
    a buggy compiler that generates bad code for an expression of the form `<elem>
    * (<elem> + <elem>)`. The code in `has_distributive_law()` checks an AST for the
    presence of this bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand how this works, a visualization of the AST comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="342pt" height="332pt"
    viewBox="0.00 0.00 342.00 332.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 328)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="113.5" y="-301.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">Expr</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="start" x="109.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge1"
    class="edge"><title>0--1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="start" x="8" y="-157.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">Constant</text></g> <g id="edge2" class="edge"><title>1--2</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="130"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Add</text></g>
    <g id="edge4" class="edge"><title>1--4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="start" x="184.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge5"
    class="edge"><title>1--5</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="35" y="-84.95" font-family="Courier,monospace" font-size="14.00"
    fill="#008040">1</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="start" x="88" y="-85.95"
    font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g>
    <g id="edge6" class="edge"><title>5--6</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="207" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Mult</text></g> <g id="edge8" class="edge"><title>5--8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="start" x="260"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge9" class="edge"><title>5--9</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="121"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">2</text></g>
    <g id="edge7" class="edge"><title>6--7</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="293" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">3</text></g> <g id="edge10" class="edge"><title>9--10</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: How many attempts does it take for each until we find a mutation that triggers
    the bug in `has_distributive_law()`? Let us write a function that computes this
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'If we pass an input that already exhibits the bug, we do not need any mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: However, the further we are away from the bug, the more mutations (and the more
    time) it takes to find it. Notably, mutating `2 + 2` until we have a distributive
    law still is much faster than mutating `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: We conclude that mutating existing code can indeed be helpful, especially if
    it is syntactically *close to inputs that trigger bugs*. If you want to have a
    good chance in finding bugs, focus on *inputs that have triggered bugs before*
    – sometimes a simple mutation of these already helps finding a new bug.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One interesting application of mutating inputs is to use mutations for *evolutionary
    fuzzing*. The idea is to have a population of inputs, to apply *mutations* on
    them, and to check whether they improve on a particular goal (mostly code coverage).
    Those inputs that *do* improve are being retained ("survival of the fittest")
    as the next generation, and evolved further. By repeating this process often enough,
    we may obtain inputs that cover large parts of code and thus improve chances to
    uncover bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume we have a buggy compiler that generates bad code for an expression
    of the form `<elem> * (<elem> + <elem>)`. The function `has_distributive_law()`,
    above, checks an AST for the presence of this bug.
  prefs: []
  type: TYPE_NORMAL
- en: Our aim is to detect this bug via fuzzing. But if we simply generate random
    inputs from scratch, it may take a long time until we generate the exact copmbination
    of operators that triggers the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To have our fuzzers guided by coverage, we first need to *measure* code coverage.
    We make use of the [Coverage module from the Fuzzing Book](https://www.fuzzingbook.org/html/Coverage.html),
    which is particularly easy to use. It simply uses a `with` clause to obtain coverage
    from the code in the `with` body. Here is how to obtain coverage for our `has_distributive_law()`
    code, above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The `coverage()` method tells us which lines in the code actually have been
    reached. This includes lines from `has_distributive_law()`, but also lines from
    other functions called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'Which are the lines executed? With a bit of code inspection, we can easily
    visualize the covered lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, a `#` indicates that the code has been executed (covered).
    We see that our input "1 * 2" satisfies the conditions in Lines 4 and 5, but does
    not satisfy the conditions in later lines.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now use coverage as a *fitness function* to guide evolution. The higher
    the fitness (the coverage), the higher the chances of an input to be retained
    for further evolution. Our `ast_fitness()` function simply counts the number of
    lines covered in `has_distributive_law()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the fitness of a number of given inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's set up a fitness function that takes derivation trees. Essentially,
    our `tree_fitness()` function is based on the `ast_fitness()` function, above;
    however, we also add a small component `1 / len(code_str)` to give extra fitness
    to shorter inputs. Otherwise, our inputs may grow and keep on growing, making
    mutations inefficient.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Evolving Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now make use of our fitness function to implement a simple evolutionary
    fuzzing algorithm. We start with *evolution* – that is, taking a population and
    adding offspring via mutations. Our initial population consists of a single candidate
    – in our case, `sum_tree` reflecting the `sum()` function, above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Our `evolve()` function adds two new children to each population member.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: As we can evolve all these, too, we get an exponential growth.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Survival of the Fittest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No population can expand forever and still survive. Let us thus limit the population
    to a certain size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'The `select()` function implements survival of the fittest: It limits the population
    to at most `POPULATION_SIZE` elements, sorting them by their fitness (highest
    to lowest). Members with low fitness beyond `POPULATION_SIZE` do not survive.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the following call to trim our `sum_population` to the fittest members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: Evolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We now have everything in place:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a *population* (say, `sum_population`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can evolve the population (using `evolve()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can have only the fittest survive (using `select()`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us repeat this process over several generations. We track whenever we have
    found a new "best" candidate and log them. If we find a candidate that triggers
    the bug, we stop. Note that this may take a long time, and not necessarily yield
    a perfect result.
  prefs: []
  type: TYPE_NORMAL
- en: 'As common in search-based approaches, we stop and restart the search if we
    have not found a sufficient solution after a number of generations (here: `GENERATIONS`).
    Other than that, we keep searching until we have a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Success! We found a piece of code that triggers the bug. Check for occurrences
    of the distributive law.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: You may note that not all of the code is required to trigger the bug. We could
    run our evolutionary fuzzer a bit longer to see whether it can be further reduced,
    or use a dedicated input reduction technique such as [Delta Debugging](https://www.fuzzingbook.org/html/Reducer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Chances of Evolutionary Fuzzing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Could the bug in `distributive_law()` have been found without evolutionary guidance
    - i.e., simply by applying one mutation to `sum()`?
  prefs: []
  type: TYPE_NORMAL
- en: When producing an expression (`<expr>`), we calculate how big the chances are
    to
  prefs: []
  type: TYPE_NORMAL
- en: Produce a binary operator, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a `*`, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce another binary operator as one child, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Produce a `+`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do a few queries on our grammar to compute the chances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: On average, it would take about 19000 (non-evolutionary) runs until we have
    an expression that triggers the distributive law. So it is definitely better to
    make use of additional information (say, coverage) in order to guide mutations
    towards a goal.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating and processing complex inputs such as program code,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: try to rely on existing infrastructure to *parse* inputs into some *abstract
    syntax*, and then
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: have your grammars *process that abstract syntax* rather than the concrete syntax.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifically, program code is normally converted into *abstract syntax trees*
    before being compiled or interpreted, and you can (and should) make use of such
    conversions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once program code is turned into an AST, it is fairly easy to generate, mutate,
    and evolve despite its complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The seminal work on compiler testing is *Csmith* [[Yang *et al*, 2011](https://doi.org/10.1145/1993498.1993532)],
    a generator of C programs. Csmith has been used to thoroughly test compilers such
    as Clang or GCC; beyond producing code that is syntactically correct, it also
    aims at *semantic* correctness as well as avoiding undefined and unspecified behaviors.
    This is a must read for anyone in the field in compiler testing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-24 21:37:28+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/PythonFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Testing Compilers](https://www.fuzzingbook.org/html/PythonFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/PythonFuzzer.html](https://www.fuzzingbook.org/html/PythonFuzzer.html).
    Retrieved 2024-11-24 21:37:28+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
