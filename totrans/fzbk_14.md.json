["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('Jc8Whz0W41o') \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import List, Dict, Union, Any, Tuple, Optional \n```", "```py\nimport [Fuzzer](Fuzzer.html) \n```", "```py\n>>> from [fuzzingbook.Grammars](Grammars.html) import <identifier> \n```", "```py\n>>> US_PHONE_GRAMMAR: Grammar = {\n>>>     \"<start>\": [\"<phone-number>\"],\n>>>     \"<phone-number>\": [\"(<area>)<exchange>-<line>\"],\n>>>     \"<area>\": [\"<lead-digit><digit><digit>\"],\n>>>     \"<exchange>\": [\"<lead-digit><digit><digit>\"],\n>>>     \"<line>\": [\"<digit><digit><digit><digit>\"],\n>>>     \"<lead-digit>\": [\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n>>>     \"<digit>\": [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n>>> }\n>>> \n>>> assert is_valid_grammar(US_PHONE_GRAMMAR) \n```", "```py\n>>> [simple_grammar_fuzzer(US_PHONE_GRAMMAR) for i in range(5)]\n['(692)449-5179',\n '(519)230-7422',\n '(613)761-0853',\n '(979)881-3858',\n '(810)914-5475'] \n```", "```py\n<start> ::= <digit><digit>\n<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```", "```py\n<start>  ::= <integer>\n<integer> ::= <digit> | <digit><integer>\n<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```", "```py\n<start>   ::= <number>\n<number>  ::= <integer> | +<integer> | -<integer>\n<integer> ::= <digit> | <digit><integer>\n<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import quiz \n```", "```py\n<start>   ::= <expr>\n<expr>    ::= <term> + <expr> | <term> - <expr> | <term>\n<term>    ::= <term> * <factor> | <term> / <factor> | <factor>\n<factor>  ::= +<factor> | -<factor> | (<expr>) | <integer> | <integer>.<integer>\n<integer> ::= <digit><integer> | <digit>\n<digit>   ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n```", "```py\nDIGIT_GRAMMAR = {\n    \"<start>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n} \n```", "```py\nSimpleGrammar = Dict[str, List[str]] \n```", "```py\nOption = Dict[str, Any] \n```", "```py\nExpansion = Union[str, Tuple[str, Option]] \n```", "```py\nGrammar = Dict[str, List[Expansion]] \n```", "```py\nEXPR_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<expr>\"],\n\n    \"<expr>\":\n        [\"<term> + <expr>\", \"<term> - <expr>\", \"<term>\"],\n\n    \"<term>\":\n        [\"<factor> * <term>\", \"<factor> / <term>\", \"<factor>\"],\n\n    \"<factor>\":\n        [\"+<factor>\",\n         \"-<factor>\",\n         \"(<expr>)\",\n         \"<integer>.<integer>\",\n         \"<integer>\"],\n\n    \"<integer>\":\n        [\"<digit><integer>\", \"<digit>\"],\n\n    \"<digit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n} \n```", "```py\nEXPR_GRAMMAR[\"<digit>\"] \n```", "```py\n['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n```", "```py\n\"<identifier>\" in EXPR_GRAMMAR \n```", "```py\nFalse\n\n```", "```py\nSTART_SYMBOL = \"<start>\" \n```", "```py\nimport [re](https://docs.python.org/3/library/re.html) \n```", "```py\nRE_NONTERMINAL = re.compile(r'(<[^<> ]*>)') \n```", "```py\ndef nonterminals(expansion):\n    # In later chapters, we allow expansions to be tuples,\n    # with the expansion being the first element\n    if isinstance(expansion, tuple):\n        expansion = expansion[0]\n\n    return RE_NONTERMINAL.findall(expansion) \n```", "```py\nassert nonterminals(\"<term> * <factor>\") == [\"<term>\", \"<factor>\"]\nassert nonterminals(\"<digit><integer>\") == [\"<digit>\", \"<integer>\"]\nassert nonterminals(\"1 < 3 > 2\") == []\nassert nonterminals(\"1 <3> 2\") == [\"<3>\"]\nassert nonterminals(\"1 + 2\") == []\nassert nonterminals((\"<1>\", {'option': 'value'})) == [\"<1>\"] \n```", "```py\ndef is_nonterminal(s):\n    return RE_NONTERMINAL.match(s) \n```", "```py\nassert is_nonterminal(\"<abc>\")\nassert is_nonterminal(\"<symbol-1>\")\nassert not is_nonterminal(\"+\") \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nclass ExpansionError(Exception):\n    pass \n```", "```py\ndef simple_grammar_fuzzer(grammar: Grammar, \n                          start_symbol: str = START_SYMBOL,\n                          max_nonterminals: int = 10,\n                          max_expansion_trials: int = 100,\n                          log: bool = False) -> str:\n  \"\"\"Produce a string from `grammar`.\n `start_symbol`: use a start symbol other than `<start>` (default).\n `max_nonterminals`: the maximum number of nonterminals \n still left for expansion\n `max_expansion_trials`: maximum # of attempts to produce a string\n `log`: print expansion progress if True\"\"\"\n\n    term = start_symbol\n    expansion_trials = 0\n\n    while len(nonterminals(term)) > 0:\n        symbol_to_expand = random.choice(nonterminals(term))\n        expansions = grammar[symbol_to_expand]\n        expansion = random.choice(expansions)\n        # In later chapters, we allow expansions to be tuples,\n        # with the expansion being the first element\n        if isinstance(expansion, tuple):\n            expansion = expansion[0]\n\n        new_term = term.replace(symbol_to_expand, expansion, 1)\n\n        if len(nonterminals(new_term)) < max_nonterminals:\n            term = new_term\n            if log:\n                print(\"%-40s\" % (symbol_to_expand + \" -> \" + expansion), term)\n            expansion_trials = 0\n        else:\n            expansion_trials += 1\n            if expansion_trials >= max_expansion_trials:\n                raise ExpansionError(\"Cannot expand \" + repr(term))\n\n    return term \n```", "```py\nsimple_grammar_fuzzer(grammar=EXPR_GRAMMAR, max_nonterminals=3, log=True) \n```", "```py\n<start> -> <expr>                        <expr>\n<expr> -> <term> + <expr>                <term> + <expr>\n<term> -> <factor>                       <factor> + <expr>\n<factor> -> <integer>                    <integer> + <expr>\n<integer> -> <digit>                     <digit> + <expr>\n<digit> -> 6                             6 + <expr>\n<expr> -> <term> - <expr>                6 + <term> - <expr>\n<expr> -> <term>                         6 + <term> - <term>\n<term> -> <factor>                       6 + <factor> - <term>\n<factor> -> -<factor>                    6 + -<factor> - <term>\n<term> -> <factor>                       6 + -<factor> - <factor>\n<factor> -> (<expr>)                     6 + -(<expr>) - <factor>\n<factor> -> (<expr>)                     6 + -(<expr>) - (<expr>)\n<expr> -> <term>                         6 + -(<term>) - (<expr>)\n<expr> -> <term>                         6 + -(<term>) - (<term>)\n<term> -> <factor>                       6 + -(<factor>) - (<term>)\n<factor> -> +<factor>                    6 + -(+<factor>) - (<term>)\n<factor> -> +<factor>                    6 + -(++<factor>) - (<term>)\n<term> -> <factor>                       6 + -(++<factor>) - (<factor>)\n<factor> -> (<expr>)                     6 + -(++(<expr>)) - (<factor>)\n<factor> -> <integer>                    6 + -(++(<expr>)) - (<integer>)\n<expr> -> <term>                         6 + -(++(<term>)) - (<integer>)\n<integer> -> <digit>                     6 + -(++(<term>)) - (<digit>)\n<digit> -> 9                             6 + -(++(<term>)) - (9)\n<term> -> <factor> * <term>              6 + -(++(<factor> * <term>)) - (9)\n<term> -> <factor>                       6 + -(++(<factor> * <factor>)) - (9)\n<factor> -> <integer>                    6 + -(++(<integer> * <factor>)) - (9)\n<integer> -> <digit>                     6 + -(++(<digit> * <factor>)) - (9)\n<digit> -> 2                             6 + -(++(2 * <factor>)) - (9)\n<factor> -> +<factor>                    6 + -(++(2 * +<factor>)) - (9)\n<factor> -> -<factor>                    6 + -(++(2 * +-<factor>)) - (9)\n<factor> -> -<factor>                    6 + -(++(2 * +--<factor>)) - (9)\n<factor> -> -<factor>                    6 + -(++(2 * +---<factor>)) - (9)\n<factor> -> -<factor>                    6 + -(++(2 * +----<factor>)) - (9)\n<factor> -> <integer>.<integer>          6 + -(++(2 * +----<integer>.<integer>)) - (9)\n<integer> -> <digit>                     6 + -(++(2 * +----<digit>.<integer>)) - (9)\n<integer> -> <digit>                     6 + -(++(2 * +----<digit>.<digit>)) - (9)\n<digit> -> 1                             6 + -(++(2 * +----1.<digit>)) - (9)\n<digit> -> 7                             6 + -(++(2 * +----1.7)) - (9)\n\n```", "```py\n'6 + -(++(2 * +----1.7)) - (9)'\n\n```", "```py\nfor i in range(10):\n    print(simple_grammar_fuzzer(grammar=EXPR_GRAMMAR, max_nonterminals=5)) \n```", "```py\n7 / +48.5\n-5.9 / 9 - 4 * +-(-+++((1 + (+7 - (-1 * (++-+7.7 - -+-4.0))))) * +--4 - -(6) + 64)\n8.2 - 27 - -9 / +((+9 * --2 + --+-+-((-1 * +(8 - 5 - 6)) * (-((-+(((+(4))))) - ++4) / +(-+---((5.6 - --(3 * -1.8 * +(6 * +-(((-(-6) * ---+6)) / +--(+-+-7 * (-0 * (+(((((2)) + 8 - 3 - ++9.0 + ---(--+7 / (1 / +++6.37) + (1) / 482) / +++-+0)))) * -+5 + 7.513)))) - (+1 / ++((-84)))))))) * ++5 / +-(--2 - -++-9.0)))) / 5 * --++090\n1 - -3 * 7 - 28 / 9\n(+9) * +-5 * ++-926.2 - (+9.03 / -+(-(-6) / 2 * +(-+--(8) / -(+1.0) - 5 + 4)) * 3.5)\n8 + -(9.6 - 3 - -+-4 * +77)\n-(((((++((((+((++++-((+-37))))))))))))) / ++(-(+++(+6)) * -++-(+(++(---6 * (((7)) * (1) / (-7.6 * 535338) + +256) * 0) * 0))) - 4 + +1\n5.43\n(9 / -405 / -23 - +-((+-(2 * (13))))) + +6 - +8 - 934\n-++2 - (--+715769550) / 8 / (1)\n\n```", "```py\nfrom [RailroadDiagrams](RailroadDiagrams.html) import NonTerminal, Terminal, Choice, HorizontalChoice, Sequence\nfrom [RailroadDiagrams](RailroadDiagrams.html) import show_diagram \n```", "```py\nfrom [IPython.display](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html) import SVG \n```", "```py\ndef syntax_diagram_symbol(symbol: str) -> Any:\n    if is_nonterminal(symbol):\n        return NonTerminal(symbol[1:-1])\n    else:\n        return Terminal(symbol) \n```", "```py\nSVG(show_diagram(syntax_diagram_symbol('<term>'))) \n```", "```py\ndef syntax_diagram_expr(expansion: Expansion) -> Any:\n    # In later chapters, we allow expansions to be tuples,\n    # with the expansion being the first element\n    if isinstance(expansion, tuple):\n        expansion = expansion[0]\n\n    symbols = [sym for sym in re.split(RE_NONTERMINAL, expansion) if sym != \"\"]\n    if len(symbols) == 0:\n        symbols = [\"\"]  # special case: empty expansion\n\n    return Sequence(*[syntax_diagram_symbol(sym) for sym in symbols]) \n```", "```py\nSVG(show_diagram(syntax_diagram_expr(EXPR_GRAMMAR['<term>'][0]))) \n```", "```py\nfrom [itertools](https://docs.python.org/3/library/itertools.html) import zip_longest \n```", "```py\ndef syntax_diagram_alt(alt: List[Expansion]) -> Any:\n    max_len = 5\n    alt_len = len(alt)\n    if alt_len > max_len:\n        iter_len = alt_len // max_len\n        alts = list(zip_longest(*[alt[i::iter_len] for i in range(iter_len)]))\n        exprs = [[syntax_diagram_expr(expr) for expr in alt\n                  if expr is not None] for alt in alts]\n        choices = [Choice(len(expr) // 2, *expr) for expr in exprs]\n        return HorizontalChoice(*choices)\n    else:\n        return Choice(alt_len // 2, *[syntax_diagram_expr(expr) for expr in alt]) \n```", "```py\nSVG(show_diagram(syntax_diagram_alt(EXPR_GRAMMAR['<digit>']))) \n```", "```py\ndef syntax_diagram(grammar: Grammar) -> None:\n    from [IPython.display](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html) import SVG, display\n\n    for key in grammar:\n        print(\"%s\" % key[1:-1])\n        display(SVG(show_diagram(syntax_diagram_alt(grammar[key])))) \n```", "```py\nsyntax_diagram(EXPR_GRAMMAR) \n```", "```py\nstart\n\n```", "```py\nexpr\n\n```", "```py\nterm\n\n```", "```py\nfactor\n\n```", "```py\ninteger\n\n```", "```py\ndigit\n\n```", "```py\nCGI_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<string>\"],\n\n    \"<string>\":\n        [\"<letter>\", \"<letter><string>\"],\n\n    \"<letter>\":\n        [\"<plus>\", \"<percent>\", \"<other>\"],\n\n    \"<plus>\":\n        [\"+\"],\n\n    \"<percent>\":\n        [\"%<hexdigit><hexdigit>\"],\n\n    \"<hexdigit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n            \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"],\n\n    \"<other>\":  # Actually, could be _all_ letters\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"a\", \"b\", \"c\", \"d\", \"e\", \"-\", \"_\"],\n} \n```", "```py\nsyntax_diagram(CGI_GRAMMAR) \n```", "```py\nstart\n\n```", "```py\nstring\n\n```", "```py\nletter\n\n```", "```py\nplus\n\n```", "```py\npercent\n\n```", "```py\nhexdigit\n\n```", "```py\nother\n\n```", "```py\nfor i in range(10):\n    print(simple_grammar_fuzzer(grammar=CGI_GRAMMAR, max_nonterminals=10)) \n```", "```py\n+%9a\n+++%ce+\n+_\n+%c6c\n++\n+%cd+5\n1%ee\n%b9%d5\n%96\n%57d%42\n\n```", "```py\nURL_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<url>\"],\n    \"<url>\":\n        [\"<scheme>://<authority><path><query>\"],\n    \"<scheme>\":\n        [\"http\", \"https\", \"ftp\", \"ftps\"],\n    \"<authority>\":\n        [\"<host>\", \"<host>:<port>\", \"<userinfo>@<host>\", \"<userinfo>@<host>:<port>\"],\n    \"<host>\":  # Just a few\n        [\"cispa.saarland\", \"www.google.com\", \"fuzzingbook.com\"],\n    \"<port>\":\n        [\"80\", \"8080\", \"<nat>\"],\n    \"<nat>\":\n        [\"<digit>\", \"<digit><digit>\"],\n    \"<digit>\":\n        [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n    \"<userinfo>\":  # Just one\n        [\"user:password\"],\n    \"<path>\":  # Just a few\n        [\"\", \"/\", \"/<id>\"],\n    \"<id>\":  # Just a few\n        [\"abc\", \"def\", \"x<digit><digit>\"],\n    \"<query>\":\n        [\"\", \"?<params>\"],\n    \"<params>\":\n        [\"<param>\", \"<param>&<params>\"],\n    \"<param>\":  # Just a few\n        [\"<id>=<id>\", \"<id>=<nat>\"],\n} \n```", "```py\nsyntax_diagram(URL_GRAMMAR) \n```", "```py\nstart\n\n```", "```py\nurl\n\n```", "```py\nscheme\n\n```", "```py\nauthority\n\n```", "```py\nhost\n\n```", "```py\nport\n\n```", "```py\nnat\n\n```", "```py\ndigit\n\n```", "```py\nuserinfo\n\n```", "```py\npath\n\n```", "```py\nid\n\n```", "```py\nquery\n\n```", "```py\nparams\n\n```", "```py\nparam\n\n```", "```py\nfor i in range(10):\n    print(simple_grammar_fuzzer(grammar=URL_GRAMMAR, max_nonterminals=10)) \n```", "```py\nhttps://user:password@cispa.saarland:80/\nhttp://fuzzingbook.com?def=56&x89=3&x46=48&def=def\nftp://cispa.saarland/?x71=5&x35=90&def=abc\nhttps://cispa.saarland:80/def?def=7&x23=abc\nhttps://fuzzingbook.com:80/\nhttps://fuzzingbook.com:80/abc?def=abc&abc=x14&def=abc&abc=2&def=38\nftps://fuzzingbook.com/x87\nhttps://user:password@fuzzingbook.com:6?def=54&x44=abc\nhttp://fuzzingbook.com:80?x33=25&def=8\nhttp://fuzzingbook.com:8080/def\n\n```", "```py\nTITLE_GRAMMAR: Grammar = {\n    \"<start>\": [\"<title>\"],\n    \"<title>\": [\"<topic>: <subtopic>\"],\n    \"<topic>\": [\"Generating Software Tests\", \"<fuzzing-prefix>Fuzzing\", \"The Fuzzing Book\"],\n    \"<fuzzing-prefix>\": [\"\", \"The Art of \", \"The Joy of \"],\n    \"<subtopic>\": [\"<subtopic-main>\",\n                   \"<subtopic-prefix><subtopic-main>\",\n                   \"<subtopic-main><subtopic-suffix>\"],\n    \"<subtopic-main>\": [\"Breaking Software\",\n                        \"Generating Software Tests\",\n                        \"Principles, Techniques and Tools\"],\n    \"<subtopic-prefix>\": [\"\", \"Tools and Techniques for \"],\n    \"<subtopic-suffix>\": [\" for <reader-property> and <reader-property>\",\n                          \" for <software-property> and <software-property>\"],\n    \"<reader-property>\": [\"Fun\", \"Profit\"],\n    \"<software-property>\": [\"Robustness\", \"Reliability\", \"Security\"],\n} \n```", "```py\nsyntax_diagram(TITLE_GRAMMAR) \n```", "```py\nstart\n\n```", "```py\ntitle\n\n```", "```py\ntopic\n\n```", "```py\nfuzzing-prefix\n\n```", "```py\nsubtopic\n\n```", "```py\nsubtopic-main\n\n```", "```py\nsubtopic-prefix\n\n```", "```py\nsubtopic-suffix\n\n```", "```py\nreader-property\n\n```", "```py\nsoftware-property\n\n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Set \n```", "```py\ntitles: Set[str] = set()\nwhile len(titles) < 10:\n    titles.add(simple_grammar_fuzzer(\n        grammar=TITLE_GRAMMAR, max_nonterminals=10))\ntitles \n```", "```py\n{'Fuzzing: Generating Software Tests',\n 'Fuzzing: Principles, Techniques and Tools',\n 'Generating Software Tests: Breaking Software',\n 'Generating Software Tests: Breaking Software for Robustness and Robustness',\n 'Generating Software Tests: Principles, Techniques and Tools',\n 'Generating Software Tests: Principles, Techniques and Tools for Profit and Fun',\n 'Generating Software Tests: Tools and Techniques for Principles, Techniques and Tools',\n 'The Fuzzing Book: Breaking Software',\n 'The Fuzzing Book: Generating Software Tests for Profit and Profit',\n 'The Fuzzing Book: Generating Software Tests for Robustness and Robustness'}\n\n```", "```py\nfrom [MutationFuzzer](MutationFuzzer.html) import MutationFuzzer  # minor dependency \n```", "```py\nnumber_of_seeds = 10\nseeds = [\n    simple_grammar_fuzzer(\n        grammar=URL_GRAMMAR,\n        max_nonterminals=10) for i in range(number_of_seeds)]\nseeds \n```", "```py\n['ftps://user:password@www.google.com:80',\n 'http://cispa.saarland/',\n 'ftp://www.google.com:42/',\n 'ftps://user:password@fuzzingbook.com:39?abc=abc',\n 'https://www.google.com?x33=1&x06=1',\n 'http://www.google.com:02/',\n 'https://user:password@www.google.com/',\n 'ftp://cispa.saarland:8080/?abc=abc&def=def&abc=5',\n 'http://www.google.com:80/def?def=abc',\n 'http://user:password@cispa.saarland/']\n\n```", "```py\nm = MutationFuzzer(seeds) \n```", "```py\n[m.fuzz() for i in range(20)] \n```", "```py\n['ftps://user:password@www.google.com:80',\n 'http://cispa.saarland/',\n 'ftp://www.google.com:42/',\n 'ftps://user:password@fuzzingbook.com:39?abc=abc',\n 'https://www.google.com?x33=1&x06=1',\n 'http://www.google.com:02/',\n 'https://user:password@www.google.com/',\n 'ftp://cispa.saarland:8080/?abc=abc&def=def&abc=5',\n 'http://www.google.com:80/def?def=abc',\n 'http://user:password@cispa.saarland/',\n 'Eh4tp:www.coogle.com:80/def?d%f=abc',\n 'ftps://}ser:passwod@fuzzingbook.com:9?abc=abc',\n 'uftp//cispa.sRaarland:808&0?abc=abc&def=defabc=5',\n 'http://user:paswor9d@cispar.saarland/v',\n 'ftp://Www.g\\x7fogle.cAom:42/',\n 'hht://userC:qassMword@cispy.csaarland/',\n 'httx://ww.googlecom:80defde`f=ac',\n 'htt://cispq.waarlnd/',\n 'htFtp\\t://cmspa./saarna(md/',\n 'ft:/www.google.com:42\\x0f']\n\n```", "```py\nsimple_nonterminal_grammar: Grammar = {\n    \"<start>\": [\"<nonterminal>\"],\n    \"<nonterminal>\": [\"<left-angle><identifier><right-angle>\"],\n    \"<left-angle>\": [\"<\"],\n    \"<right-angle>\": [\">\"],\n    \"<identifier>\": [\"id\"]  # for now\n} \n```", "```py\nimport [copy](https://docs.python.org/3/library/copy.html) \n```", "```py\nnonterminal_grammar = copy.deepcopy(simple_nonterminal_grammar)\nnonterminal_grammar[\"<identifier>\"] = [\"<idchar>\", \"<identifier><idchar>\"]\nnonterminal_grammar[\"<idchar>\"] = ['a', 'b', 'c', 'd']  # for now \n```", "```py\nnonterminal_grammar \n```", "```py\n{'<start>': ['<nonterminal>'],\n '<nonterminal>': ['<left-angle><identifier><right-angle>'],\n '<left-angle>': ['<'],\n '<right-angle>': ['>'],\n '<identifier>': ['<idchar>', '<identifier><idchar>'],\n '<idchar>': ['a', 'b', 'c', 'd']}\n\n```", "```py\ndef extend_grammar(grammar: Grammar, extension: Grammar = {}) -> Grammar:\n  \"\"\"Create a copy of `grammar`, updated with `extension`.\"\"\"\n    new_grammar = copy.deepcopy(grammar)\n    new_grammar.update(extension)\n    return new_grammar \n```", "```py\nnonterminal_grammar = extend_grammar(simple_nonterminal_grammar,\n                                     {\n                                         \"<identifier>\": [\"<idchar>\", \"<identifier><idchar>\"],\n                                         # for now\n                                         \"<idchar>\": ['a', 'b', 'c', 'd']\n                                     }\n                                     ) \n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\ndef srange(characters: str) -> List[Expansion]:\n  \"\"\"Construct a list with all characters in the string\"\"\"\n    return [c for c in characters] \n```", "```py\nstring.ascii_letters \n```", "```py\n'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\n```", "```py\nsrange(string.ascii_letters)[:10] \n```", "```py\n['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n```", "```py\nnonterminal_grammar = extend_grammar(nonterminal_grammar,\n                                     {\n                                         \"<idchar>\": (srange(string.ascii_letters) + \n                                                      srange(string.digits) + \n                                                      srange(\"-_\"))\n                                     }\n                                     ) \n```", "```py\n[simple_grammar_fuzzer(nonterminal_grammar, \"<identifier>\") for i in range(10)] \n```", "```py\n['b', 'd', 'V9', 'x4c', 'YdiEWj', 'c', 'xd', '7', 'vIU', 'QhKD']\n\n```", "```py\ndef crange(character_start: str, character_end: str) -> List[Expansion]:\n    return [chr(i)\n            for i in range(ord(character_start), ord(character_end) + 1)] \n```", "```py\ncrange('0', '9') \n```", "```py\n['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n```", "```py\nassert crange('a', 'z') == srange(string.ascii_lowercase) \n```", "```py\nnonterminal_grammar[\"<identifier>\"] \n```", "```py\n['<idchar>', '<identifier><idchar>']\n\n```", "```py\n<identifier> = <idchar>+\n```", "```py\nnonterminal_ebnf_grammar = extend_grammar(nonterminal_grammar,\n                                          {\n                                              \"<identifier>\": [\"<idchar>+\"]\n                                          }\n                                          ) \n```", "```py\nEXPR_EBNF_GRAMMAR: Grammar = {\n    \"<start>\":\n        [\"<expr>\"],\n\n    \"<expr>\":\n        [\"<term> + <expr>\", \"<term> - <expr>\", \"<term>\"],\n\n    \"<term>\":\n        [\"<factor> * <term>\", \"<factor> / <term>\", \"<factor>\"],\n\n    \"<factor>\":\n        [\"<sign>?<factor>\", \"(<expr>)\", \"<integer>(.<integer>)?\"],\n\n    \"<sign>\":\n        [\"+\", \"-\"],\n\n    \"<integer>\":\n        [\"<digit>+\"],\n\n    \"<digit>\":\n        srange(string.digits)\n} \n```", "```py\ndef new_symbol(grammar: Grammar, symbol_name: str = \"<symbol>\") -> str:\n  \"\"\"Return a new symbol for `grammar` based on `symbol_name`\"\"\"\n    if symbol_name not in grammar:\n        return symbol_name\n\n    count = 1\n    while True:\n        tentative_symbol_name = symbol_name[:-1] + \"-\" + repr(count) + \">\"\n        if tentative_symbol_name not in grammar:\n            return tentative_symbol_name\n        count += 1 \n```", "```py\nassert new_symbol(EXPR_EBNF_GRAMMAR, '<expr>') == '<expr-1>' \n```", "```py\nRE_PARENTHESIZED_EXPR = re.compile(r'\\([^()]*\\)[?+*]') \n```", "```py\ndef parenthesized_expressions(expansion: Expansion) -> List[str]:\n    # In later chapters, we allow expansions to be tuples,\n    # with the expansion being the first element\n    if isinstance(expansion, tuple):\n        expansion = expansion[0]\n\n    return re.findall(RE_PARENTHESIZED_EXPR, expansion) \n```", "```py\nassert parenthesized_expressions(\"(<foo>)* (<foo><bar>)+ (+<foo>)? <integer>(.<integer>)?\") == [\n    '(<foo>)*', '(<foo><bar>)+', '(+<foo>)?', '(.<integer>)?'] \n```", "```py\ndef convert_ebnf_parentheses(ebnf_grammar: Grammar) -> Grammar:\n  \"\"\"Convert a grammar in extended BNF to BNF\"\"\"\n    grammar = extend_grammar(ebnf_grammar)\n    for nonterminal in ebnf_grammar:\n        expansions = ebnf_grammar[nonterminal]\n\n        for i in range(len(expansions)):\n            expansion = expansions[i]\n            if not isinstance(expansion, str):\n                expansion = expansion[0]\n\n            while True:\n                parenthesized_exprs = parenthesized_expressions(expansion)\n                if len(parenthesized_exprs) == 0:\n                    break\n\n                for expr in parenthesized_exprs:\n                    operator = expr[-1:]\n                    contents = expr[1:-2]\n\n                    new_sym = new_symbol(grammar)\n\n                    exp = grammar[nonterminal][i]\n                    opts = None\n                    if isinstance(exp, tuple):\n                        (exp, opts) = exp\n                    assert isinstance(exp, str)\n\n                    expansion = exp.replace(expr, new_sym + operator, 1)\n                    if opts:\n                        grammar[nonterminal][i] = (expansion, opts)\n                    else:\n                        grammar[nonterminal][i] = expansion\n\n                    grammar[new_sym] = [contents]\n\n    return grammar \n```", "```py\nconvert_ebnf_parentheses({\"<number>\": [\"<integer>(.<integer>)?\"]}) \n```", "```py\n{'<number>': ['<integer><symbol>?'], '<symbol>': ['.<integer>']}\n\n```", "```py\nconvert_ebnf_parentheses({\"<foo>\": [\"((<foo>)?)+\"]}) \n```", "```py\n{'<foo>': ['<symbol-1>+'], '<symbol>': ['<foo>'], '<symbol-1>': ['<symbol>?']}\n\n```", "```py\nRE_EXTENDED_NONTERMINAL = re.compile(r'(<[^<> ]*>[?+*])') \n```", "```py\ndef extended_nonterminals(expansion: Expansion) -> List[str]:\n    # In later chapters, we allow expansions to be tuples,\n    # with the expansion being the first element\n    if isinstance(expansion, tuple):\n        expansion = expansion[0]\n\n    return re.findall(RE_EXTENDED_NONTERMINAL, expansion) \n```", "```py\nassert extended_nonterminals(\n    \"<foo>* <bar>+ <elem>? <none>\") == ['<foo>*', '<bar>+', '<elem>?'] \n```", "```py\ndef convert_ebnf_operators(ebnf_grammar: Grammar) -> Grammar:\n  \"\"\"Convert a grammar in extended BNF to BNF\"\"\"\n    grammar = extend_grammar(ebnf_grammar)\n    for nonterminal in ebnf_grammar:\n        expansions = ebnf_grammar[nonterminal]\n\n        for i in range(len(expansions)):\n            expansion = expansions[i]\n            extended_symbols = extended_nonterminals(expansion)\n\n            for extended_symbol in extended_symbols:\n                operator = extended_symbol[-1:]\n                original_symbol = extended_symbol[:-1]\n                assert original_symbol in ebnf_grammar, \\\n                    f\"{original_symbol} is not defined in grammar\"\n\n                new_sym = new_symbol(grammar, original_symbol)\n\n                exp = grammar[nonterminal][i]\n                opts = None\n                if isinstance(exp, tuple):\n                    (exp, opts) = exp\n                assert isinstance(exp, str)\n\n                new_exp = exp.replace(extended_symbol, new_sym, 1)\n                if opts:\n                    grammar[nonterminal][i] = (new_exp, opts)\n                else:\n                    grammar[nonterminal][i] = new_exp\n\n                if operator == '?':\n                    grammar[new_sym] = [\"\", original_symbol]\n                elif operator == '*':\n                    grammar[new_sym] = [\"\", original_symbol + new_sym]\n                elif operator == '+':\n                    grammar[new_sym] = [\n                        original_symbol, original_symbol + new_sym]\n\n    return grammar \n```", "```py\nconvert_ebnf_operators({\"<integer>\": [\"<digit>+\"], \"<digit>\": [\"0\"]}) \n```", "```py\n{'<integer>': ['<digit-1>'],\n '<digit>': ['0'],\n '<digit-1>': ['<digit>', '<digit><digit-1>']}\n\n```", "```py\ndef convert_ebnf_grammar(ebnf_grammar: Grammar) -> Grammar:\n    return convert_ebnf_operators(convert_ebnf_parentheses(ebnf_grammar)) \n```", "```py\nconvert_ebnf_grammar({\"<authority>\": [\"(<userinfo>@)?<host>(:<port>)?\"]}) \n```", "```py\n{'<authority>': ['<symbol-2><host><symbol-1-1>'],\n '<symbol>': ['<userinfo>@'],\n '<symbol-1>': [':<port>'],\n '<symbol-2>': ['', '<symbol>'],\n '<symbol-1-1>': ['', '<symbol-1>']}\n\n```", "```py\nexpr_grammar = convert_ebnf_grammar(EXPR_EBNF_GRAMMAR)\nexpr_grammar \n```", "```py\n{'<start>': ['<expr>'],\n '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],\n '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],\n '<factor>': ['<sign-1><factor>', '(<expr>)', '<integer><symbol-1>'],\n '<sign>': ['+', '-'],\n '<integer>': ['<digit-1>'],\n '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<symbol>': ['.<integer>'],\n '<sign-1>': ['', '<sign>'],\n '<symbol-1>': ['', '<symbol>'],\n '<digit-1>': ['<digit>', '<digit><digit-1>']}\n\n```", "```py\n\"<expr>\":\n        [(\"<term> + <expr>\", opts(min_depth=10)),\n         (\"<term> - <expr>\", opts(max_depth=2)),\n         \"<term>\"] \n```", "```py\ndef opts(**kwargs: Any) -> Dict[str, Any]:\n    return kwargs \n```", "```py\nopts(min_depth=10) \n```", "```py\n{'min_depth': 10}\n\n```", "```py\ndef exp_string(expansion: Expansion) -> str:\n  \"\"\"Return the string to be expanded\"\"\"\n    if isinstance(expansion, str):\n        return expansion\n    return expansion[0] \n```", "```py\nexp_string((\"<term> + <expr>\", opts(min_depth=10))) \n```", "```py\n'<term> + <expr>'\n\n```", "```py\ndef exp_opts(expansion: Expansion) -> Dict[str, Any]:\n  \"\"\"Return the options of an expansion.  If options are not defined, return {}\"\"\"\n    if isinstance(expansion, str):\n        return {}\n    return expansion[1] \n```", "```py\ndef exp_opt(expansion: Expansion, attribute: str) -> Any:\n  \"\"\"Return the given attribution of an expansion.\n If attribute is not defined, return None\"\"\"\n    return exp_opts(expansion).get(attribute, None) \n```", "```py\nexp_opts((\"<term> + <expr>\", opts(min_depth=10))) \n```", "```py\n{'min_depth': 10}\n\n```", "```py\nexp_opt((\"<term> - <expr>\", opts(max_depth=2)), 'max_depth') \n```", "```py\n2\n\n```", "```py\ndef set_opts(grammar: Grammar, symbol: str, expansion: Expansion, \n             opts: Option = {}) -> None:\n  \"\"\"Set the options of the given expansion of grammar[symbol] to opts\"\"\"\n    expansions = grammar[symbol]\n    for i, exp in enumerate(expansions):\n        if exp_string(exp) != exp_string(expansion):\n            continue\n\n        new_opts = exp_opts(exp)\n        if opts == {} or new_opts == {}:\n            new_opts = opts\n        else:\n            for key in opts:\n                new_opts[key] = opts[key]\n\n        if new_opts == {}:\n            grammar[symbol][i] = exp_string(exp)\n        else:\n            grammar[symbol][i] = (exp_string(exp), new_opts)\n\n        return\n\n    raise KeyError(\n        \"no expansion \" +\n        repr(symbol) +\n        \" -> \" +\n        repr(\n            exp_string(expansion))) \n```", "```py\nimport [sys](https://docs.python.org/3/library/sys.html) \n```", "```py\ndef def_used_nonterminals(grammar: Grammar, start_symbol: \n                          str = START_SYMBOL) -> Tuple[Optional[Set[str]], \n                                                       Optional[Set[str]]]:\n  \"\"\"Return a pair (`defined_nonterminals`, `used_nonterminals`) in `grammar`.\n In case of error, return (`None`, `None`).\"\"\"\n\n    defined_nonterminals = set()\n    used_nonterminals = {start_symbol}\n\n    for defined_nonterminal in grammar:\n        defined_nonterminals.add(defined_nonterminal)\n        expansions = grammar[defined_nonterminal]\n        if not isinstance(expansions, list):\n            print(repr(defined_nonterminal) + \": expansion is not a list\",\n                  file=sys.stderr)\n            return None, None\n\n        if len(expansions) == 0:\n            print(repr(defined_nonterminal) + \": expansion list empty\",\n                  file=sys.stderr)\n            return None, None\n\n        for expansion in expansions:\n            if isinstance(expansion, tuple):\n                expansion = expansion[0]\n            if not isinstance(expansion, str):\n                print(repr(defined_nonterminal) + \": \"\n                      + repr(expansion) + \": not a string\",\n                      file=sys.stderr)\n                return None, None\n\n            for used_nonterminal in nonterminals(expansion):\n                used_nonterminals.add(used_nonterminal)\n\n    return defined_nonterminals, used_nonterminals \n```", "```py\ndef reachable_nonterminals(grammar: Grammar,\n                           start_symbol: str = START_SYMBOL) -> Set[str]:\n    reachable = set()\n\n    def _find_reachable_nonterminals(grammar, symbol):\n        nonlocal reachable\n        reachable.add(symbol)\n        for expansion in grammar.get(symbol, []):\n            for nonterminal in nonterminals(expansion):\n                if nonterminal not in reachable:\n                    _find_reachable_nonterminals(grammar, nonterminal)\n\n    _find_reachable_nonterminals(grammar, start_symbol)\n    return reachable \n```", "```py\ndef unreachable_nonterminals(grammar: Grammar,\n                             start_symbol=START_SYMBOL) -> Set[str]:\n    return grammar.keys() - reachable_nonterminals(grammar, start_symbol) \n```", "```py\ndef opts_used(grammar: Grammar) -> Set[str]:\n    used_opts = set()\n    for symbol in grammar:\n        for expansion in grammar[symbol]:\n            used_opts |= set(exp_opts(expansion).keys())\n    return used_opts \n```", "```py\ndef is_valid_grammar(grammar: Grammar,\n                     start_symbol: str = START_SYMBOL, \n                     supported_opts: Set[str] = set()) -> bool:\n  \"\"\"Check if the given `grammar` is valid.\n `start_symbol`: optional start symbol (default: `<start>`)\n `supported_opts`: options supported (default: none)\"\"\"\n\n    defined_nonterminals, used_nonterminals = \\\n        def_used_nonterminals(grammar, start_symbol)\n    if defined_nonterminals is None or used_nonterminals is None:\n        return False\n\n    # Do not complain about '<start>' being not used,\n    # even if start_symbol is different\n    if START_SYMBOL in grammar:\n        used_nonterminals.add(START_SYMBOL)\n\n    for unused_nonterminal in defined_nonterminals - used_nonterminals:\n        print(repr(unused_nonterminal) + \": defined, but not used. Consider applying trim_grammar() on the grammar\",\n              file=sys.stderr)\n    for undefined_nonterminal in used_nonterminals - defined_nonterminals:\n        print(repr(undefined_nonterminal) + \": used, but not defined\",\n              file=sys.stderr)\n\n    # Symbols must be reachable either from <start> or given start symbol\n    unreachable = unreachable_nonterminals(grammar, start_symbol)\n    msg_start_symbol = start_symbol\n\n    if START_SYMBOL in grammar:\n        unreachable = unreachable - \\\n            reachable_nonterminals(grammar, START_SYMBOL)\n        if start_symbol != START_SYMBOL:\n            msg_start_symbol += \" or \" + START_SYMBOL\n\n    for unreachable_nonterminal in unreachable:\n        print(repr(unreachable_nonterminal) + \": unreachable from \" + msg_start_symbol + \". Consider applying trim_grammar() on the grammar\",\n              file=sys.stderr)\n\n    used_but_not_supported_opts = set()\n    if len(supported_opts) > 0:\n        used_but_not_supported_opts = opts_used(\n            grammar).difference(supported_opts)\n        for opt in used_but_not_supported_opts:\n            print(\n                \"warning: option \" +\n                repr(opt) +\n                \" is not supported\",\n                file=sys.stderr)\n\n    return used_nonterminals == defined_nonterminals and len(unreachable) == 0 \n```", "```py\ndef trim_grammar(grammar: Grammar, start_symbol=START_SYMBOL) -> Grammar:\n  \"\"\"Create a copy of `grammar` where all unused and unreachable nonterminals are removed.\"\"\"\n    new_grammar = extend_grammar(grammar)\n    defined_nonterminals, used_nonterminals = \\\n        def_used_nonterminals(grammar, start_symbol)\n    if defined_nonterminals is None or used_nonterminals is None:\n        return new_grammar\n\n    unused = defined_nonterminals - used_nonterminals\n    unreachable = unreachable_nonterminals(grammar, start_symbol)\n    for nonterminal in unused | unreachable:\n        del new_grammar[nonterminal]\n\n    return new_grammar \n```", "```py\nassert is_valid_grammar(EXPR_GRAMMAR)\nassert is_valid_grammar(CGI_GRAMMAR)\nassert is_valid_grammar(URL_GRAMMAR) \n```", "```py\nassert is_valid_grammar(EXPR_EBNF_GRAMMAR) \n```", "```py\nassert not is_valid_grammar({\"<start>\": [\"<x>\"], \"<y>\": [\"1\"]}) \n```", "```py\n'<y>': defined, but not used. Consider applying trim_grammar() on the grammar\n'<x>': used, but not defined\n'<y>': unreachable from <start>. Consider applying trim_grammar() on the grammar\n\n```", "```py\nassert not is_valid_grammar({\"<start>\": \"123\"}) \n```", "```py\n'<start>': expansion is not a list\n\n```", "```py\nassert not is_valid_grammar({\"<start>\": []}) \n```", "```py\n'<start>': expansion list empty\n\n```", "```py\nassert not is_valid_grammar({\"<start>\": [1, 2, 3]}) \n```", "```py\n'<start>': 1: not a string\n\n```", "```py\n<options> ::= <option>*\n<option> ::= -h | --version | -v | -d | -i | --global-config <filename>\n```", "```py\n<call-sequence> ::= <call>*\n<call> ::= urlparse(<url>) | urlsplit(<url>)\n```", "```py\n<term>: 50% <factor> * <term> |  30% <factor> / <term> | 20% <factor>\n<integer>: <digit>+ { <integer> >= 100 }\n```", "```py\n/regex/\n```", "```py\n<integer> ::= /[+-]?[0-9]+/\n```", "```py\n{\n    \"<start>\": [\"<s1>\"],\n    \"<s1>\": [ \"<s2>\", \"<s1><s2>\" ],\n    \"<s2>\": crange('0', '9')\n} \n```", "```py\n{\n    \"<integer>\": [\"<s1><s3>\"],\n    \"<s1>\": [ \"\", \"<s2>\" ],\n    \"<s2>\": srange(\"+-\"),\n    \"<s3>\": [ \"<s4>\", \"<s4><s3>\" ],\n    \"<s4>\": crange('0', '9')\n} \n```", "```py\ndef expression_grammar_fn():\n    start = \"<expr>\"\n    expr = \"<term> + <expr>\" | \"<term> - <expr>\"\n    term = \"<factor> * <term>\" | \"<factor> / <term>\" | \"<factor>\"\n    factor = \"+<factor>\" | \"-<factor>\" | \"(<expr>)\" | \"<integer>.<integer>\" | \"<integer>\"\n    integer = \"<digit><integer>\" | \"<digit>\"\n    digit = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' \n```", "```py\nwith ExpectError():\n    expression_grammar_fn() \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_8783/1271268731.py\", line 2, in <module>\n    expression_grammar_fn()\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_8783/3029408019.py\", line 3, in expression_grammar_fn\n    expr = \"<term> + <expr>\" | \"<term> - <expr>\"\n           ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\nTypeError: unsupported operand type(s) for |: 'str' and 'str' (expected)\n\n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html)\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nsource = inspect.getsource(expression_grammar_fn)\nsource \n```", "```py\n'def expression_grammar_fn():\\n    start = \"<expr>\"\\n    expr = \"<term> + <expr>\" | \"<term> - <expr>\"\\n    term = \"<factor> * <term>\" | \"<factor> / <term>\" | \"<factor>\"\\n    factor = \"+<factor>\" | \"-<factor>\" | \"(<expr>)\" | \"<integer>.<integer>\" | \"<integer>\"\\n    integer = \"<digit><integer>\" | \"<digit>\"\\n    digit = \\'0\\' | \\'1\\' | \\'2\\' | \\'3\\' | \\'4\\' | \\'5\\' | \\'6\\' | \\'7\\' | \\'8\\' | \\'9\\'\\n'\n\n```", "```py\ntree = ast.parse(source) \n```", "```py\ndef get_alternatives(op, to_expr=lambda o: o.s):\n    if isinstance(op, ast.BinOp) and isinstance(op.op, ast.BitOr):\n        return get_alternatives(op.left, to_expr) + [to_expr(op.right)]\n    return [to_expr(op)] \n```", "```py\ndef funct_parser(tree, to_expr=lambda o: o.s):\n    return {assign.targets[0].id: get_alternatives(assign.value, to_expr)\n            for assign in tree.body[0].body} \n```", "```py\ngrammar = funct_parser(tree)\nfor symbol in grammar:\n    print(symbol, \"::=\", grammar[symbol]) \n```", "```py\nstart ::= ['<expr>']\nexpr ::= ['<term> + <expr>', '<term> - <expr>']\nterm ::= ['<factor> * <term>', '<factor> / <term>', '<factor>']\nfactor ::= ['+<factor>', '-<factor>', '(<expr>)', '<integer>.<integer>', '<integer>']\ninteger ::= ['<digit><integer>', '<digit>']\ndigit ::= ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']\n\n```", "```py\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_8783/1939255217.py:1: DeprecationWarning: Attribute s is deprecated and will be removed in Python 3.14; use value instead\n  def funct_parser(tree, to_expr=lambda o: o.s):\n\n```", "```py\ndef define_name(o):\n    return o.id if isinstance(o, ast.Name) else o.s \n```", "```py\ndef define_expr(op):\n    if isinstance(op, ast.BinOp) and isinstance(op.op, ast.Add):\n        return (*define_expr(op.left), define_name(op.right))\n    return (define_name(op),) \n```", "```py\ndef define_ex_grammar(fn):\n    return define_grammar(fn, define_expr) \n```", "```py\n@define_ex_grammar\ndef expression_grammar():\n    start   = expr\n    expr    = (term + '+' + expr\n            |  term + '-' + expr)\n    term    = (factor + '*' + term\n            |  factor + '/' + term\n            |  factor)\n    factor  = ('+' + factor\n            |  '-' + factor\n            |  '(' + expr + ')'\n            |  integer + '.' + integer\n            |  integer)\n    integer = (digit + integer\n            |  digit)\n    digit   = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\nfor symbol in expression_grammar:\n    print(symbol, \"::=\", expression_grammar[symbol]) \n```", "```py\ndef identifier_grammar_fn():\n    identifier = idchar * (1,) \n```", "```py\n@incollection{fuzzingbook2024:Grammars,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Fuzzing with Grammars},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/Grammars.html}},\n    note = {Retrieved 2024-06-30 18:31:28+02:00},\n    url = {https://www.fuzzingbook.org/html/Grammars.html},\n    urldate = {2024-06-30 18:31:28+02:00}\n}\n\n```"]