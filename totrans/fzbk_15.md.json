["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('Ohl8TLcLl3A') \n```", "```py\n>>> from [fuzzingbook.GrammarFuzzer](GrammarFuzzer.html) import <identifier> \n```", "```py\n>>> from [Grammars](Grammars.html) import US_PHONE_GRAMMAR\n>>> phone_fuzzer = GrammarFuzzer(US_PHONE_GRAMMAR)\n>>> phone_fuzzer.fuzz()\n'(771)306-0659' \n```", "```py\n>>> area_fuzzer = GrammarFuzzer(US_PHONE_GRAMMAR, start_symbol='<area>')\n>>> area_fuzzer.fuzz()\n'409' \n```", "```py\nProduce strings from `grammar`, starting with `start_symbol`.\nIf `min_nonterminals` or `max_nonterminals` is given, use them as limits \nfor the number of nonterminals produced.  \nIf `disp` is set, display the intermediate derivation trees.\nIf `log` is set, show intermediate steps as text on standard output. \n```", "```py\n>>> display_tree(phone_fuzzer.derivation_tree) \n```", "```py\n>>> phone_fuzzer.derivation_tree\n('<start>',\n [('<phone-number>',\n   [('(', []),\n    ('<area>',\n     [('<lead-digit>', [('7', [])]),\n      ('<digit>', [('7', [])]),\n      ('<digit>', [('1', [])])]),\n    (')', []),\n    ('<exchange>',\n     [('<lead-digit>', [('3', [])]),\n      ('<digit>', [('0', [])]),\n      ('<digit>', [('6', [])])]),\n    ('-', []),\n    ('<line>',\n     [('<digit>', [('0', [])]),\n      ('<digit>', [('6', [])]),\n      ('<digit>', [('5', [])]),\n      ('<digit>', [('9', [])])])])]) \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import quiz \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Tuple, List, Optional, Any, Union, Set, Callable, Dict \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import unicode_escape \n```", "```py\nfrom [Grammars](Grammars.html) import EXPR_EBNF_GRAMMAR, convert_ebnf_grammar, Grammar, Expansion\nfrom [Grammars](Grammars.html) import simple_grammar_fuzzer, is_valid_grammar, exp_string \n```", "```py\nexpr_grammar = convert_ebnf_grammar(EXPR_EBNF_GRAMMAR)\nexpr_grammar \n```", "```py\n{'<start>': ['<expr>'],\n '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],\n '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],\n '<factor>': ['<sign-1><factor>', '(<expr>)', '<integer><symbol-1>'],\n '<sign>': ['+', '-'],\n '<integer>': ['<digit-1>'],\n '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<symbol>': ['.<integer>'],\n '<sign-1>': ['', '<sign>'],\n '<symbol-1>': ['', '<symbol>'],\n '<digit-1>': ['<digit>', '<digit><digit-1>']}\n\n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectTimeout \n```", "```py\nwith ExpectTimeout(1):\n    simple_grammar_fuzzer(grammar=expr_grammar, max_nonterminals=3) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_9136/3259437052.py\", line 2, in <module>\n    simple_grammar_fuzzer(grammar=expr_grammar, max_nonterminals=3)\n  File \"Grammars.ipynb\", line 87, in simple_grammar_fuzzer\n    symbol_to_expand = random.choice(nonterminals(term))\n                                     ^^^^^^^^^^^^^^^^^^\n  File \"Grammars.ipynb\", line 61, in nonterminals\n    return RE_NONTERMINAL.findall(expansion)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"Timeout.ipynb\", line 43, in timeout_handler\n    raise TimeoutError()\nTimeoutError (expected)\n\n```", "```py\nexpr_grammar['<factor>'] \n```", "```py\n['<sign-1><factor>', '(<expr>)', '<integer><symbol-1>']\n\n```", "```py\nfrom [Grammars](Grammars.html) import simple_grammar_fuzzer \n```", "```py\nfrom [Grammars](Grammars.html) import START_SYMBOL, EXPR_GRAMMAR, URL_GRAMMAR, CGI_GRAMMAR \n```", "```py\nfrom [Grammars](Grammars.html) import RE_NONTERMINAL, nonterminals, is_nonterminal \n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\ntrials = 50\nxs = []\nys = []\nfor i in range(trials):\n    with Timer() as t:\n        s = simple_grammar_fuzzer(EXPR_GRAMMAR, max_nonterminals=15)\n    xs.append(len(s))\n    ys.append(t.elapsed_time())\n    print(i, end=\" \")\nprint() \n```", "```py\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \n\n```", "```py\naverage_time = sum(ys) / trials\nprint(\"Average time:\", average_time) \n```", "```py\nAverage time: 0.10001757324207575\n\n```", "```py\n%matplotlib inline\n\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt\nplt.scatter(xs, ys)\nplt.title('Time required for generating an output'); \n```", "```py\n(SYMBOL_NAME, CHILDREN) \n```", "```py\nDerivationTree = Tuple[str, Optional[List[Any]]] \n```", "```py\nderivation_tree: DerivationTree = (\"<start>\",\n                   [(\"<expr>\",\n                     [(\"<expr>\", None),\n                      (\" + \", []),\n                         (\"<term>\", None)]\n                     )]) \n```", "```py\nfrom [graphviz](https://graphviz.readthedocs.io/) import Digraph \n```", "```py\nfrom [IPython.display](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html) import display \n```", "```py\nimport [re](https://docs.python.org/3/library/re.html)\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\ndef dot_escape(s: str, show_ascii=None) -> str:\n  \"\"\"Return s in a form suitable for dot.\n If `show_ascii` is True or length of `s` is 1, also append ascii value.\"\"\"\n    escaped_s = ''\n    if show_ascii is None:\n        show_ascii = (len(s) == 1)  # Default: Single chars only\n\n    if show_ascii and s == '\\n':\n        return '\\\\\\\\n (10)'\n\n    s = s.replace('\\n', '\\\\n')\n    for c in s:\n        if re.match('[,<>\\\\\\\\\"]', c):\n            escaped_s += '\\\\' + c\n        elif c in string.printable and 31 < ord(c) < 127:\n            escaped_s += c\n        else:\n            escaped_s += '\\\\\\\\x' + format(ord(c), '02x')\n\n        if show_ascii:\n            escaped_s += f' ({ord(c)})'\n\n    return escaped_s \n```", "```py\nassert dot_escape(\"hello\") == \"hello\" \n```", "```py\nassert dot_escape(\"<hello>, world\") == \"\\\\<hello\\\\>\\\\, world\" \n```", "```py\nassert dot_escape(\"\\\\n\") == \"\\\\\\\\n\" \n```", "```py\nassert dot_escape(\"\\n\", show_ascii=False) == \"\\\\\\\\n\" \n```", "```py\nassert dot_escape(\"\\n\", show_ascii=True) == \"\\\\\\\\n (10)\" \n```", "```py\nassert dot_escape(\"\\n\", show_ascii=True) == \"\\\\\\\\n (10)\" \n```", "```py\nassert dot_escape('\\x01', show_ascii=False) == \"\\\\\\\\x01\" \n```", "```py\nassert dot_escape('\\x01') == \"\\\\\\\\x01 (1)\" \n```", "```py\ndef extract_node(node, id):\n    symbol, children, *annotation = node\n    return symbol, children, ''.join(str(a) for a in annotation) \n```", "```py\ndef default_node_attr(dot, nid, symbol, ann):\n    dot.node(repr(nid), dot_escape(symbol)) \n```", "```py\ndef default_edge_attr(dot, start_node, stop_node):\n    dot.edge(repr(start_node), repr(stop_node)) \n```", "```py\ndef default_graph_attr(dot):\n    dot.attr('node', shape='plain') \n```", "```py\ndef display_tree(derivation_tree: DerivationTree,\n                 log: bool = False,\n                 extract_node: Callable = extract_node,\n                 node_attr: Callable = default_node_attr,\n                 edge_attr: Callable = default_edge_attr,\n                 graph_attr: Callable = default_graph_attr) -> Any:\n\n    # If we import display_tree, we also have to import its functions\n    from [graphviz](https://graphviz.readthedocs.io/) import Digraph\n\n    counter = 0\n\n    def traverse_tree(dot, tree, id=0):\n        (symbol, children, annotation) = extract_node(tree, id)\n        node_attr(dot, id, symbol, annotation)\n\n        if children:\n            for child in children:\n                nonlocal counter\n                counter += 1\n                child_id = counter\n                edge_attr(dot, id, child_id)\n                traverse_tree(dot, child, child_id)\n\n    dot = Digraph(comment=\"Derivation Tree\")\n    graph_attr(dot)\n    traverse_tree(dot, derivation_tree)\n    if log:\n        print(dot)\n    return dot \n```", "```py\ndisplay_tree(derivation_tree) \n```", "```py\nderivation_tree \n```", "```py\n('<start>', [('<expr>', [('<expr>', None), (' + ', []), ('<term>', None)])])\n\n```", "```py\ndef display_annotated_tree(tree: DerivationTree,\n                           a_nodes: Dict[int, str],\n                           a_edges: Dict[Tuple[int, int], str],\n                           log: bool = False):\n    def graph_attr(dot):\n        dot.attr('node', shape='plain')\n        dot.graph_attr['rankdir'] = 'LR'\n\n    def annotate_node(dot, nid, symbol, ann):\n        if nid in a_nodes:\n            dot.node(repr(nid), \n                     \"%s (%s)\" % (dot_escape(unicode_escape(symbol)),\n                                  a_nodes[nid]))\n        else:\n            dot.node(repr(nid), dot_escape(unicode_escape(symbol)))\n\n    def annotate_edge(dot, start_node, stop_node):\n        if (start_node, stop_node) in a_edges:\n            dot.edge(repr(start_node), repr(stop_node),\n                     a_edges[(start_node, stop_node)])\n        else:\n            dot.edge(repr(start_node), repr(stop_node))\n\n    return display_tree(tree, log=log,\n                        node_attr=annotate_node,\n                        edge_attr=annotate_edge,\n                        graph_attr=graph_attr) \n```", "```py\ndisplay_annotated_tree(derivation_tree, {3: 'plus'}, {(1, 3): 'op'}, log=False) \n```", "```py\ndef all_terminals(tree: DerivationTree) -> str:\n    (symbol, children) = tree\n    if children is None:\n        # This is a nonterminal symbol not expanded yet\n        return symbol\n\n    if len(children) == 0:\n        # This is a terminal symbol\n        return symbol\n\n    # This is an expanded symbol:\n    # Concatenate all terminal symbols from all children\n    return ''.join([all_terminals(c) for c in children]) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'<expr> + <term>'\n\n```", "```py\ndef tree_to_string(tree: DerivationTree) -> str:\n    symbol, children, *_ = tree\n    if children:\n        return ''.join(tree_to_string(c) for c in children)\n    else:\n        return '' if is_nonterminal(symbol) else symbol \n```", "```py\ntree_to_string(derivation_tree) \n```", "```py\n' + '\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\nclass GrammarFuzzer(Fuzzer):\n  \"\"\"Produce strings from grammars efficiently, using derivation trees.\"\"\"\n\n    def __init__(self,\n                 grammar: Grammar,\n                 start_symbol: str = START_SYMBOL,\n                 min_nonterminals: int = 0,\n                 max_nonterminals: int = 10,\n                 disp: bool = False,\n                 log: Union[bool, int] = False) -> None:\n  \"\"\"Produce strings from `grammar`, starting with `start_symbol`.\n If `min_nonterminals` or `max_nonterminals` is given, use them as limits \n for the number of nonterminals produced. \n If `disp` is set, display the intermediate derivation trees.\n If `log` is set, show intermediate steps as text on standard output.\"\"\"\n\n        self.grammar = grammar\n        self.start_symbol = start_symbol\n        self.min_nonterminals = min_nonterminals\n        self.max_nonterminals = max_nonterminals\n        self.disp = disp\n        self.log = log\n        self.check_grammar()  # Invokes is_valid_grammar() \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def new_method(self, args):\n        pass \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def check_grammar(self) -> None:\n  \"\"\"Check the grammar passed\"\"\"\n        assert self.start_symbol in self.grammar\n        assert is_valid_grammar(\n            self.grammar,\n            start_symbol=self.start_symbol,\n            supported_opts=self.supported_opts())\n\n    def supported_opts(self) -> Set[str]:\n  \"\"\"Set of supported options. To be overloaded in subclasses.\"\"\"\n        return set()  # We don't support specific options \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def init_tree(self) -> DerivationTree:\n        return (self.start_symbol, None) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR)\ndisplay_tree(f.init_tree()) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def choose_node_expansion(self, node: DerivationTree,\n                              children_alternatives: List[List[DerivationTree]]) -> int:\n  \"\"\"Return index of expansion in `children_alternatives` to be selected.\n 'children_alternatives`: a list of possible children for `node`.\n Defaults to random. To be overloaded in subclasses.\"\"\"\n        return random.randrange(0, len(children_alternatives)) \n```", "```py\ndef expansion_to_children(expansion: Expansion) -> List[DerivationTree]:\n    # print(\"Converting \" + repr(expansion))\n    # strings contains all substrings -- both terminals and nonterminals such\n    # that ''.join(strings) == expansion\n\n    expansion = exp_string(expansion)\n    assert isinstance(expansion, str)\n\n    if expansion == \"\":  # Special case: epsilon expansion\n        return [(\"\", [])]\n\n    strings = re.split(RE_NONTERMINAL, expansion)\n    return [(s, None) if is_nonterminal(s) else (s, [])\n            for s in strings if len(s) > 0] \n```", "```py\nexpansion_to_children(\"<term> + <expr>\") \n```", "```py\n[('<term>', None), (' + ', []), ('<expr>', None)]\n\n```", "```py\nexpansion_to_children(\"\") \n```", "```py\n[('', [])]\n\n```", "```py\nexpansion_to_children((\"+<term>\", {\"extra_data\": 1234})) \n```", "```py\n[('+', []), ('<term>', None)]\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expansion_to_children(self, expansion: Expansion) -> List[DerivationTree]:\n        return expansion_to_children(expansion) \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node_randomly(self, node: DerivationTree) -> DerivationTree:\n  \"\"\"Choose a random expansion for `node` and return it\"\"\"\n        (symbol, children) = node\n        assert children is None\n\n        if self.log:\n            print(\"Expanding\", all_terminals(node), \"randomly\")\n\n        # Fetch the possible expansions from grammar...\n        expansions = self.grammar[symbol]\n        children_alternatives: List[List[DerivationTree]] = [\n            self.expansion_to_children(expansion) for expansion in expansions\n        ]\n\n        # ... and select a random expansion\n        index = self.choose_node_expansion(node, children_alternatives)\n        chosen_children = children_alternatives[index]\n\n        # Process children (for subclasses)\n        chosen_children = self.process_chosen_children(chosen_children,\n                                                       expansions[index])\n\n        # Return with new children\n        return (symbol, chosen_children) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node(self, node: DerivationTree) -> DerivationTree:\n        return self.expand_node_randomly(node) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def process_chosen_children(self,\n                                chosen_children: List[DerivationTree],\n                                expansion: Expansion) -> List[DerivationTree]:\n  \"\"\"Process children after selection.  By default, does nothing.\"\"\"\n        return chosen_children \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR, log=True)\n\nprint(\"Before expand_node_randomly():\")\nexpr_tree = (\"<integer>\", None)\ndisplay_tree(expr_tree) \n```", "```py\nBefore expand_node_randomly():\n\n```", "```py\nprint(\"After expand_node_randomly():\")\nexpr_tree = f.expand_node_randomly(expr_tree)\ndisplay_tree(expr_tree) \n```", "```py\nAfter expand_node_randomly():\nExpanding <integer> randomly\n\n```", "```py\ndigit_subtree = expr_tree[1][0]\ndisplay_tree(digit_subtree) \n```", "```py\nprint(\"After expanding the <digit> subtree:\")\ndigit_subtree = f.expand_node_randomly(digit_subtree)\ndisplay_tree(digit_subtree) \n```", "```py\nAfter expanding the <digit> subtree:\nExpanding <digit> randomly\n\n```", "```py\ndisplay_tree(expr_tree) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def possible_expansions(self, node: DerivationTree) -> int:\n        (symbol, children) = node\n        if children is None:\n            return 1\n\n        return sum(self.possible_expansions(c) for c in children) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR)\nprint(f.possible_expansions(derivation_tree)) \n```", "```py\n2\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def any_possible_expansions(self, node: DerivationTree) -> bool:\n        (symbol, children) = node\n        if children is None:\n            return True\n\n        return any(self.any_possible_expansions(c) for c in children) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR)\nf.any_possible_expansions(derivation_tree) \n```", "```py\nTrue\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def choose_tree_expansion(self,\n                              tree: DerivationTree,\n                              children: List[DerivationTree]) -> int:\n  \"\"\"Return index of subtree in `children` to be selected for expansion.\n Defaults to random.\"\"\"\n        return random.randrange(0, len(children))\n\n    def expand_tree_once(self, tree: DerivationTree) -> DerivationTree:\n  \"\"\"Choose an unexpanded symbol in tree; expand it.\n Can be overloaded in subclasses.\"\"\"\n        (symbol, children) = tree\n        if children is None:\n            # Expand this node\n            return self.expand_node(tree)\n\n        # Find all children with possible expansions\n        expandable_children = [\n            c for c in children if self.any_possible_expansions(c)]\n\n        # `index_map` translates an index in `expandable_children`\n        # back into the original index in `children`\n        index_map = [i for (i, c) in enumerate(children)\n                     if c in expandable_children]\n\n        # Select a random child\n        child_to_be_expanded = \\\n            self.choose_tree_expansion(tree, expandable_children)\n\n        # Expand in place\n        children[index_map[child_to_be_expanded]] = \\\n            self.expand_tree_once(expandable_children[child_to_be_expanded])\n\n        return tree \n```", "```py\nderivation_tree = (\"<start>\",\n                   [(\"<expr>\",\n                     [(\"<expr>\", None),\n                      (\" + \", []),\n                         (\"<term>\", None)]\n                     )])\ndisplay_tree(derivation_tree) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR, log=True)\nderivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <expr> randomly\n\n```", "```py\nderivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <term> randomly\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def symbol_cost(self, symbol: str, seen: Set[str] = set()) \\\n            -> Union[int, float]:\n        expansions = self.grammar[symbol]\n        return min(self.expansion_cost(e, seen | {symbol}) for e in expansions)\n\n    def expansion_cost(self, expansion: Expansion,\n                       seen: Set[str] = set()) -> Union[int, float]:\n        symbols = nonterminals(expansion)\n        if len(symbols) == 0:\n            return 1  # no symbol\n\n        if any(s in seen for s in symbols):\n            return float('inf')\n\n        # the value of a expansion is the sum of all expandable variables\n        # inside + 1\n        return sum(self.symbol_cost(s, seen) for s in symbols) + 1 \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR)\nassert f.symbol_cost(\"<digit>\") == 1 \n```", "```py\nassert f.symbol_cost(\"<expr>\") == 5 \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node_by_cost(self, node: DerivationTree, \n                            choose: Callable = min) -> DerivationTree:\n        (symbol, children) = node\n        assert children is None\n\n        # Fetch the possible expansions from grammar...\n        expansions = self.grammar[symbol]\n\n        children_alternatives_with_cost = [(self.expansion_to_children(expansion),\n                                            self.expansion_cost(expansion, {symbol}),\n                                            expansion)\n                                           for expansion in expansions]\n\n        costs = [cost for (child, cost, expansion)\n                 in children_alternatives_with_cost]\n        chosen_cost = choose(costs)\n        children_with_chosen_cost = [child for (child, child_cost, _) \n                                     in children_alternatives_with_cost\n                                     if child_cost == chosen_cost]\n        expansion_with_chosen_cost = [expansion for (_, child_cost, expansion)\n                                      in children_alternatives_with_cost\n                                      if child_cost == chosen_cost]\n\n        index = self.choose_node_expansion(node, children_with_chosen_cost)\n\n        chosen_children = children_with_chosen_cost[index]\n        chosen_expansion = expansion_with_chosen_cost[index]\n        chosen_children = self.process_chosen_children(\n            chosen_children, chosen_expansion)\n\n        # Return with a new list\n        return (symbol, chosen_children) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node_min_cost(self, node: DerivationTree) -> DerivationTree:\n        if self.log:\n            print(\"Expanding\", all_terminals(node), \"at minimum cost\")\n\n        return self.expand_node_by_cost(node, min) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node(self, node: DerivationTree) -> DerivationTree:\n        return self.expand_node_min_cost(node) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR, log=True)\ndisplay_tree(derivation_tree) \n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <term> at minimum cost\n\n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <factor> at minimum cost\n\n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <term> at minimum cost\n\n```", "```py\nwhile f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree) \n```", "```py\nExpanding <integer> at minimum cost\nExpanding <digit> at minimum cost\nExpanding <factor> at minimum cost\nExpanding <integer> at minimum cost\nExpanding <factor> at minimum cost\nExpanding <integer> at minimum cost\nExpanding <digit> at minimum cost\nExpanding <digit> at minimum cost\n\n```", "```py\ndisplay_tree(derivation_tree) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node_max_cost(self, node: DerivationTree) -> DerivationTree:\n        if self.log:\n            print(\"Expanding\", all_terminals(node), \"at maximum cost\")\n\n        return self.expand_node_by_cost(node, max) \n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def expand_node(self, node: DerivationTree) -> DerivationTree:\n        return self.expand_node_max_cost(node) \n```", "```py\nderivation_tree = (\"<start>\",\n                   [(\"<expr>\",\n                     [(\"<expr>\", None),\n                      (\" + \", []),\n                         (\"<term>\", None)]\n                     )]) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR, log=True)\ndisplay_tree(derivation_tree) \n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <term> at maximum cost\n\n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <factor> at maximum cost\n\n```", "```py\nif f.any_possible_expansions(derivation_tree):\n    derivation_tree = f.expand_tree_once(derivation_tree)\ndisplay_tree(derivation_tree) \n```", "```py\nExpanding <expr> at maximum cost\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def log_tree(self, tree: DerivationTree) -> None:\n  \"\"\"Output a tree if self.log is set; if self.display is also set, show the tree structure\"\"\"\n        if self.log:\n            print(\"Tree:\", all_terminals(tree))\n            if self.disp:\n                display(display_tree(tree))\n            # print(self.possible_expansions(tree), \"possible expansion(s) left\")\n\n    def expand_tree_with_strategy(self, tree: DerivationTree,\n                                  expand_node_method: Callable,\n                                  limit: Optional[int] = None):\n  \"\"\"Expand tree using `expand_node_method` as node expansion function\n until the number of possible expansions reaches `limit`.\"\"\"\n        self.expand_node = expand_node_method\n        while ((limit is None\n                or self.possible_expansions(tree) < limit)\n               and self.any_possible_expansions(tree)):\n            tree = self.expand_tree_once(tree)\n            self.log_tree(tree)\n        return tree\n\n    def expand_tree(self, tree: DerivationTree) -> DerivationTree:\n  \"\"\"Expand `tree` in a three-phase strategy until all expansions are complete.\"\"\"\n        self.log_tree(tree)\n        tree = self.expand_tree_with_strategy(\n            tree, self.expand_node_max_cost, self.min_nonterminals)\n        tree = self.expand_tree_with_strategy(\n            tree, self.expand_node_randomly, self.max_nonterminals)\n        tree = self.expand_tree_with_strategy(\n            tree, self.expand_node_min_cost)\n\n        assert self.possible_expansions(tree) == 0\n\n        return tree \n```", "```py\ninitial_derivation_tree: DerivationTree = (\"<start>\",\n                   [(\"<expr>\",\n                     [(\"<expr>\", None),\n                      (\" + \", []),\n                         (\"<term>\", None)]\n                     )]) \n```", "```py\ndisplay_tree(initial_derivation_tree) \n```", "```py\nf = GrammarFuzzer(\n    EXPR_GRAMMAR,\n    min_nonterminals=3,\n    max_nonterminals=5,\n    log=True)\nderivation_tree = f.expand_tree(initial_derivation_tree) \n```", "```py\nTree: <expr> + <term>\nExpanding <expr> at maximum cost\nTree: <term> + <expr> + <term>\nExpanding <expr> randomly\nTree: <term> + <term> + <term>\nExpanding <term> randomly\nTree: <factor> / <term> + <term> + <term>\nExpanding <term> randomly\nTree: <factor> / <factor> + <term> + <term>\nExpanding <factor> randomly\nTree: <integer> / <factor> + <term> + <term>\nExpanding <term> randomly\nTree: <integer> / <factor> + <factor> * <term> + <term>\nExpanding <factor> at minimum cost\nTree: <integer> / <integer> + <factor> * <term> + <term>\nExpanding <integer> at minimum cost\nTree: <integer> / <digit> + <factor> * <term> + <term>\nExpanding <factor> at minimum cost\nTree: <integer> / <digit> + <integer> * <term> + <term>\nExpanding <integer> at minimum cost\nTree: <digit> / <digit> + <integer> * <term> + <term>\nExpanding <term> at minimum cost\nTree: <digit> / <digit> + <integer> * <term> + <factor>\nExpanding <digit> at minimum cost\nTree: <digit> / 5 + <integer> * <term> + <factor>\nExpanding <factor> at minimum cost\nTree: <digit> / 5 + <integer> * <term> + <integer>\nExpanding <integer> at minimum cost\nTree: <digit> / 5 + <integer> * <term> + <digit>\nExpanding <integer> at minimum cost\nTree: <digit> / 5 + <digit> * <term> + <digit>\nExpanding <digit> at minimum cost\nTree: 7 / 5 + <digit> * <term> + <digit>\nExpanding <digit> at minimum cost\nTree: 7 / 5 + <digit> * <term> + 0\nExpanding <term> at minimum cost\nTree: 7 / 5 + <digit> * <factor> + 0\nExpanding <factor> at minimum cost\nTree: 7 / 5 + <digit> * <integer> + 0\nExpanding <integer> at minimum cost\nTree: 7 / 5 + <digit> * <digit> + 0\nExpanding <digit> at minimum cost\nTree: 7 / 5 + 4 * <digit> + 0\nExpanding <digit> at minimum cost\nTree: 7 / 5 + 4 * 2 + 0\n\n```", "```py\ndisplay_tree(derivation_tree) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'7 / 5 + 4 * 2 + 0'\n\n```", "```py\nclass GrammarFuzzer(GrammarFuzzer):\n    def fuzz_tree(self) -> DerivationTree:\n  \"\"\"Produce a derivation tree from the grammar.\"\"\"\n        tree = self.init_tree()\n        # print(tree)\n\n        # Expand all nonterminals\n        tree = self.expand_tree(tree)\n        if self.log:\n            print(repr(all_terminals(tree)))\n        if self.disp:\n            display(display_tree(tree))\n        return tree\n\n    def fuzz(self) -> str:\n  \"\"\"Produce a string from the grammar.\"\"\"\n        self.derivation_tree = self.fuzz_tree()\n        return all_terminals(self.derivation_tree) \n```", "```py\nf = GrammarFuzzer(EXPR_GRAMMAR)\nf.fuzz() \n```", "```py\n'18.3 * 21.95 / 0'\n\n```", "```py\ndisplay_tree(f.derivation_tree) \n```", "```py\nf = GrammarFuzzer(URL_GRAMMAR)\nf.fuzz() \n```", "```py\n'ftp://user:password@www.google.com:53/def?abc=def'\n\n```", "```py\ndisplay_tree(f.derivation_tree) \n```", "```py\nf = GrammarFuzzer(CGI_GRAMMAR, min_nonterminals=3, max_nonterminals=5)\nf.fuzz() \n```", "```py\n'e+d+'\n\n```", "```py\ndisplay_tree(f.derivation_tree) \n```", "```py\ntrials = 50\nxs = []\nys = []\nf = GrammarFuzzer(EXPR_GRAMMAR, max_nonterminals=20)\nfor i in range(trials):\n    with Timer() as t:\n        s = f.fuzz()\n    xs.append(len(s))\n    ys.append(t.elapsed_time())\n    print(i, end=\" \")\nprint() \n```", "```py\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \n\n```", "```py\naverage_time = sum(ys) / trials\nprint(\"Average time:\", average_time) \n```", "```py\nAverage time: 0.0263434316823259\n\n```", "```py\n%matplotlib inline\n\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt\nplt.scatter(xs, ys)\nplt.title('Time required for generating an output'); \n```", "```py\nf = GrammarFuzzer(expr_grammar, max_nonterminals=10)\nf.fuzz() \n```", "```py\n'(9 + 7) * 7 * 2 * 5 + 7 * 2 / 6'\n\n```", "```py\nclass ExerciseGrammarFuzzer(GrammarFuzzer):\n    def expand_node_randomly(self, node: DerivationTree) -> DerivationTree:\n        if self.log:\n            print(\"Expanding\", all_terminals(node), \"randomly by cost\")\n\n        return self.expand_node_by_cost(node, random.choice) \n```", "```py\n@incollection{fuzzingbook2023:GrammarFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Efficient Grammar Fuzzing},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/GrammarFuzzer.html}},\n    note = {Retrieved 2023-11-11 18:18:06+01:00},\n    url = {https://www.fuzzingbook.org/html/GrammarFuzzer.html},\n    urldate = {2023-11-11 18:18:06+01:00}\n}\n\n```"]