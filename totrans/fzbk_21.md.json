["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('JOv1xGVdXAU') \n```", "```py\n>>> from [fuzzingbook.Reducer](Reducer.html) import <identifier> \n```", "```py\n>>> !python -c 'x = 1 + 2 * 3 / 0'\nTraceback (most recent call last):\n  File \"<string>\", line 1, in <module>\nZeroDivisionError: division by zero \n```", "```py\n>>> from [Fuzzer](Fuzzer.html) import ProgramRunner\n>>> import [subprocess](https://docs.python.org/3/library/subprocess.html)\n>>> class ZeroDivisionRunner(ProgramRunner):\n>>>     \"\"\"Make outcome 'FAIL' if ZeroDivisionError occurs\"\"\"\n>>> \n>>>     def run(self, inp: str = \"\") -> Tuple[subprocess.CompletedProcess, Outcome]:\n>>>         process, outcome = super().run(inp)\n>>>         if process.stderr.find('ZeroDivisionError') >= 0:\n>>>             outcome = 'FAIL'\n>>>         return process, outcome \n```", "```py\n>>> python_input = \"x = 1 + 2 * 3 / 0\"\n>>> python_runner = ZeroDivisionRunner(\"python\")\n>>> process, outcome = python_runner.run(python_input)\n>>> outcome\n'FAIL' \n```", "```py\n>>> dd = DeltaDebuggingReducer(python_runner)\n>>> dd.reduce(python_input)\n'3/0' \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import quiz \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Tuple, List, Sequence, Any, Optional \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nfrom [Fuzzer](Fuzzer.html) import RandomFuzzer, Runner, Outcome \n```", "```py\nimport [re](https://docs.python.org/3/library/re.html) \n```", "```py\nclass MysteryRunner(Runner):\n    def run(self, inp: str) -> Tuple[str, Outcome]:\n        x = inp.find(chr(0o17 + 0o31))\n        y = inp.find(chr(0o27 + 0o22))\n        if x >= 0 and y >= 0 and x < y:\n            return (inp, Runner.FAIL)\n        else:\n            return (inp, Runner.PASS) \n```", "```py\nmystery = MysteryRunner()\nrandom_fuzzer = RandomFuzzer()\nwhile True:\n    inp = random_fuzzer.fuzz()\n    result, outcome = mystery.run(inp)\n    if outcome == mystery.FAIL:\n        break \n```", "```py\nfailing_input = result\nfailing_input \n```", "```py\n' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#'\n\n```", "```py\nfailing_input \n```", "```py\n' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#'\n\n```", "```py\nhalf_length = len(failing_input) // 2   # // is integer division\nfirst_half = failing_input[:half_length]\nmystery.run(first_half) \n```", "```py\n(\" 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':\", 'PASS')\n\n```", "```py\nsecond_half = failing_input[half_length:]\nmystery.run(second_half) \n```", "```py\n('\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#', 'PASS')\n\n```", "```py\nquarter_length = len(failing_input) // 4\ninput_without_first_quarter = failing_input[quarter_length:]\nmystery.run(input_without_first_quarter) \n```", "```py\n('50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#',\n 'FAIL')\n\n```", "```py\ninput_without_first_and_second_quarter = failing_input[quarter_length * 2:]\nmystery.run(input_without_first_and_second_quarter) \n```", "```py\n('\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#', 'PASS')\n\n```", "```py\nsecond_half \n```", "```py\n'\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#'\n\n```", "```py\ninput_without_first_and_second_quarter \n```", "```py\n'\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#'\n\n```", "```py\ninput_without_first_and_third_quarter = failing_input[quarter_length:\n                                                      quarter_length * 2] + failing_input[quarter_length * 3:]\nmystery.run(input_without_first_and_third_quarter) \n```", "```py\n(\"50#7*8=$&&=$9!%6(4=&69':<7+1<2!4$>92+$1<(3%&5''>#\", 'PASS')\n\n```", "```py\ninput_without_first_and_fourth_quarter = failing_input[quarter_length:quarter_length * 3]\nmystery.run(input_without_first_and_fourth_quarter) \n```", "```py\n('50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+', 'FAIL')\n\n```", "```py\nclass Reducer:\n  \"\"\"Base class for reducers.\"\"\"\n\n    def __init__(self, runner: Runner, log_test: bool = False) -> None:\n  \"\"\"Attach reducer to the given `runner`\"\"\"\n        self.runner = runner\n        self.log_test = log_test\n        self.reset()\n\n    def reset(self) -> None:\n  \"\"\"Reset the test counter to zero. To be extended in subclasses.\"\"\"\n        self.tests = 0\n\n    def test(self, inp: str) -> Outcome:\n  \"\"\"Test with input `inp`. Return outcome.\n To be extended in subclasses.\"\"\"\n\n        result, outcome = self.runner.run(inp)\n        self.tests += 1\n        if self.log_test:\n            print(\"Test #%d\" % self.tests, repr(inp), repr(len(inp)), outcome)\n        return outcome\n\n    def reduce(self, inp: str) -> str:\n  \"\"\"Reduce input `inp`. Return reduced input.\n To be defined in subclasses.\"\"\"\n\n        self.reset()\n        # Default: Don't reduce\n        return inp \n```", "```py\nclass CachingReducer(Reducer):\n  \"\"\"A reducer that also caches test outcomes\"\"\"\n\n    def reset(self):\n        super().reset()\n        self.cache = {}\n\n    def test(self, inp):\n        if inp in self.cache:\n            return self.cache[inp]\n\n        outcome = super().test(inp)\n        self.cache[inp] = outcome\n        return outcome \n```", "```py\nclass DeltaDebuggingReducer(CachingReducer):\n  \"\"\"Reduce inputs using delta debugging.\"\"\"\n\n    def reduce(self, inp: str) -> str:\n  \"\"\"Reduce input `inp` using delta debugging. Return reduced input.\"\"\"\n\n        self.reset()\n        assert self.test(inp) != Runner.PASS\n\n        n = 2     # Initial granularity\n        while len(inp) >= 2:\n            start = 0.0\n            subset_length = len(inp) / n\n            some_complement_is_failing = False\n\n            while start < len(inp):\n                complement = inp[:int(start)] + \\\n                    inp[int(start + subset_length):]\n\n                if self.test(complement) == Runner.FAIL:\n                    inp = complement\n                    n = max(n - 1, 2)\n                    some_complement_is_failing = True\n                    break\n\n                start += subset_length\n\n            if not some_complement_is_failing:\n                if n == len(inp):\n                    break\n                n = min(n * 2, len(inp))\n\n        return inp \n```", "```py\ndd_reducer = DeltaDebuggingReducer(mystery, log_test=True)\ndd_reducer.reduce(failing_input) \n```", "```py\nTest #1 ' 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#' 97 FAIL\nTest #2 '\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#' 49 PASS\nTest #3 \" 7:,>((/$$-/->.;.=;(.%!:50#7*8=$&&=$9!%6(4=&69':\" 48 PASS\nTest #4 '50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+<7+1<2!4$>92+$1<(3%&5\\'\\'>#' 73 FAIL\nTest #5 \"50#7*8=$&&=$9!%6(4=&69':<7+1<2!4$>92+$1<(3%&5''>#\" 49 PASS\nTest #6 '50#7*8=$&&=$9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+' 48 FAIL\nTest #7 '\\'<3+0-3.24#7=!&60)2/+\";+' 24 PASS\nTest #8 \"50#7*8=$&&=$9!%6(4=&69':\" 24 PASS\nTest #9 '9!%6(4=&69\\':\\'<3+0-3.24#7=!&60)2/+\";+' 36 FAIL\nTest #10 '9!%6(4=&69\\':=!&60)2/+\";+' 24 FAIL\nTest #11 '=!&60)2/+\";+' 12 PASS\nTest #12 \"9!%6(4=&69':\" 12 PASS\nTest #13 '=&69\\':=!&60)2/+\";+' 18 PASS\nTest #14 '9!%6(4=!&60)2/+\";+' 18 FAIL\nTest #15 '9!%6(42/+\";+' 12 PASS\nTest #16 '9!%6(4=!&60)' 12 FAIL\nTest #17 '=!&60)' 6 PASS\nTest #18 '9!%6(4' 6 PASS\nTest #19 '6(4=!&60)' 9 FAIL\nTest #20 '6(460)' 6 FAIL\nTest #21 '60)' 3 PASS\nTest #22 '6(4' 3 PASS\nTest #23 '(460)' 5 FAIL\nTest #24 '460)' 4 PASS\nTest #25 '(0)' 3 FAIL\nTest #26 '0)' 2 PASS\nTest #27 '(' 1 PASS\nTest #28 '()' 2 FAIL\nTest #29 ')' 1 PASS\n\n```", "```py\n'()'\n\n```", "```py\nwith ExpectError():\n    dd_reducer.reduce(\"I am a passing input\") \n```", "```py\nTest #1 'I am a passing input' 20 PASS\n\n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_29923/3080932113.py\", line 2, in <module>\n    dd_reducer.reduce(\"I am a passing input\")\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_29923/2870451724.py\", line 8, in reduce\n    assert self.test(inp) != Runner.PASS\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\nexpr_input = \"1 + (2 * 3)\"\ndd_reducer = DeltaDebuggingReducer(mystery, log_test=True)\ndd_reducer.reduce(expr_input) \n```", "```py\nTest #1 '1 + (2 * 3)' 11 FAIL\nTest #2 '2 * 3)' 6 PASS\nTest #3 '1 + (' 5 PASS\nTest #4 '+ (2 * 3)' 9 FAIL\nTest #5 '+ ( 3)' 6 FAIL\nTest #6 ' 3)' 3 PASS\nTest #7 '+ (' 3 PASS\nTest #8 ' ( 3)' 5 FAIL\nTest #9 '( 3)' 4 FAIL\nTest #10 '3)' 2 PASS\nTest #11 '( ' 2 PASS\nTest #12 '(3)' 3 FAIL\nTest #13 '()' 2 FAIL\nTest #14 ')' 1 PASS\nTest #15 '(' 1 PASS\n\n```", "```py\n'()'\n\n```", "```py\nfrom [Grammars](Grammars.html) import EXPR_GRAMMAR \n```", "```py\nfrom [Parser](Parser.html) import EarleyParser, Parser  # minor dependency \n```", "```py\nclass EvalMysteryRunner(MysteryRunner):\n    def __init__(self) -> None:\n        self.parser = EarleyParser(EXPR_GRAMMAR)\n\n    def run(self, inp: str) -> Tuple[str, Outcome]:\n        try:\n            tree, *_ = self.parser.parse(inp)\n        except SyntaxError:\n            return (inp, Runner.UNRESOLVED)\n\n        return super().run(inp) \n```", "```py\neval_mystery = EvalMysteryRunner() \n```", "```py\ndd_reducer = DeltaDebuggingReducer(eval_mystery, log_test=True)\ndd_reducer.reduce(expr_input) \n```", "```py\nTest #1 '1 + (2 * 3)' 11 FAIL\nTest #2 '2 * 3)' 6 UNRESOLVED\nTest #3 '1 + (' 5 UNRESOLVED\nTest #4 '+ (2 * 3)' 9 UNRESOLVED\nTest #5 '1 2 * 3)' 8 UNRESOLVED\nTest #6 '1 + ( 3)' 8 UNRESOLVED\nTest #7 '1 + (2 *' 8 UNRESOLVED\nTest #8 ' + (2 * 3)' 10 UNRESOLVED\nTest #9 '1+ (2 * 3)' 10 UNRESOLVED\nTest #10 '1 (2 * 3)' 9 UNRESOLVED\nTest #11 '1 + 2 * 3)' 10 UNRESOLVED\nTest #12 '1 + ( * 3)' 10 UNRESOLVED\nTest #13 '1 + (2 3)' 9 UNRESOLVED\nTest #14 '1 + (2 *3)' 10 UNRESOLVED\nTest #15 '1 + (2 * ' 9 UNRESOLVED\nTest #16 '1  (2 * 3)' 10 UNRESOLVED\nTest #17 '1 +(2 * 3)' 10 UNRESOLVED\nTest #18 '1 + (2* 3)' 10 UNRESOLVED\nTest #19 '1 + (2  3)' 10 UNRESOLVED\nTest #20 '1 + (2 * )' 10 UNRESOLVED\nTest #21 '1 + (2 * 3' 10 UNRESOLVED\n\n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\nfrom [Grammars](Grammars.html) import Grammar\nfrom [GrammarFuzzer](GrammarFuzzer.html) import all_terminals, expansion_to_children, display_tree \n```", "```py\nderivation_tree, *_ = EarleyParser(EXPR_GRAMMAR).parse(expr_input)\ndisplay_tree(derivation_tree) \n```", "```py\nimport [copy](https://docs.python.org/3/library/copy.html) \n```", "```py\nnew_derivation_tree = copy.deepcopy(derivation_tree)\n# We really should have some query language\nsub_expr_tree = new_derivation_tree[1][0][1][2]\ndisplay_tree(sub_expr_tree) \n```", "```py\nnew_derivation_tree[1][0] = sub_expr_tree\ndisplay_tree(new_derivation_tree) \n```", "```py\nall_terminals(new_derivation_tree) \n```", "```py\n'(2 * 3)'\n\n```", "```py\n<term> ::= <term> * <factor> \n```", "```py\n<term> ::= <factor>\n```", "```py\nterm_tree = new_derivation_tree[1][0][1][0][1][0][1][1][1][0]\ndisplay_tree(term_tree) \n```", "```py\nshorter_term_tree = term_tree[1][2]\ndisplay_tree(shorter_term_tree) \n```", "```py\nnew_derivation_tree[1][0][1][0][1][0][1][1][1][0] = shorter_term_tree\ndisplay_tree(new_derivation_tree) \n```", "```py\nall_terminals(new_derivation_tree) \n```", "```py\n'(3)'\n\n```", "```py\nclass GrammarReducer(CachingReducer):\n  \"\"\"Reduce inputs using grammars\"\"\"\n\n    def __init__(self, runner: Runner, parser: Parser, *,\n                 log_test: bool = False, log_reduce: bool = False):\n  \"\"\"Constructor.\n `runner` is the runner to be used.\n `parser` is the parser to be used.\n `log_test` - if set, show tests and results.\n `log_reduce` - if set, show reduction steps.\n \"\"\"\n\n        super().__init__(runner, log_test=log_test)\n        self.parser = parser\n        self.grammar = parser.grammar()\n        self.start_symbol = parser.start_symbol()\n        self.log_reduce = log_reduce\n        self.try_all_combinations = False \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import DerivationTree \n```", "```py\ndef tree_list_to_string(q: List[DerivationTree]) -> str:\n    return \"[\" + \", \".join([all_terminals(tree) for tree in q]) + \"]\" \n```", "```py\ntree_list_to_string([derivation_tree, derivation_tree]) \n```", "```py\n'[1 + (2 * 3), 1 + (2 * 3)]'\n\n```", "```py\ndef possible_combinations(list_of_lists: List[List[Any]]) -> List[List[Any]]:\n    if len(list_of_lists) == 0:\n        return []\n\n    ret = []\n    for e in list_of_lists[0]:\n        if len(list_of_lists) == 1:\n            ret.append([e])\n        else:\n            for c in possible_combinations(list_of_lists[1:]):\n                new_combo = [e] + c\n                ret.append(new_combo)\n\n    return ret \n```", "```py\npossible_combinations([[1, 2], ['a', 'b']]) \n```", "```py\n[[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]\n\n```", "```py\ndef number_of_nodes(tree: DerivationTree) -> int:\n    (symbol, children) = tree\n    if children is None:\n        return 1\n\n    return 1 + sum([number_of_nodes(c) for c in children]) \n```", "```py\nnumber_of_nodes(derivation_tree) \n```", "```py\n25\n\n```", "```py\ndef max_height(tree: DerivationTree) -> int:\n    (symbol, children) = tree\n    if children is None or len(children) == 0:\n        return 1\n\n    return 1 + max([max_height(c) for c in children]) \n```", "```py\nmax_height(derivation_tree) \n```", "```py\n12\n\n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def subtrees_with_symbol(self, tree: DerivationTree,\n                             symbol: str, depth: int = -1,\n                             ignore_root: bool = True) -> List[DerivationTree]:\n  \"\"\"Find all subtrees in `tree` whose root is `symbol`.\n If `ignore_root` is true, ignore the root note of `tree`.\"\"\"\n\n        ret = []\n        (child_symbol, children) = tree\n        if depth <= 0 and not ignore_root and child_symbol == symbol:\n            ret.append(tree)\n\n        # Search across all children\n        if depth != 0 and children is not None:\n            for c in children:\n                ret += self.subtrees_with_symbol(c,\n                                                 symbol,\n                                                 depth=depth - 1,\n                                                 ignore_root=False)\n\n        return ret \n```", "```py\ngrammar_reducer = GrammarReducer(\n    mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_reduce=True) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\n[all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(\n    derivation_tree, \"<term>\")] \n```", "```py\n['1', '(2 * 3)', '2 * 3', '3']\n\n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def alternate_reductions(self, tree: DerivationTree, symbol: str, \n                             depth: int = -1):\n        reductions = []\n\n        expansions = self.grammar.get(symbol, [])\n        expansions.sort(\n            key=lambda expansion: len(\n                expansion_to_children(expansion)))\n\n        for expansion in expansions:\n            expansion_children = expansion_to_children(expansion)\n\n            match = True\n            new_children_reductions = []\n            for (alt_symbol, _) in expansion_children:\n                child_reductions = self.subtrees_with_symbol(\n                    tree, alt_symbol, depth=depth)\n                if len(child_reductions) == 0:\n                    match = False   # Child not found; cannot apply rule\n                    break\n\n                new_children_reductions.append(child_reductions)\n\n            if not match:\n                continue  # Try next alternative\n\n            # Use the first suitable combination\n            for new_children in possible_combinations(new_children_reductions):\n                new_tree = (symbol, new_children)\n                if number_of_nodes(new_tree) < number_of_nodes(tree):\n                    reductions.append(new_tree)\n                    if not self.try_all_combinations:\n                        break\n\n        # Sort by number of nodes\n        reductions.sort(key=number_of_nodes)\n\n        return reductions \n```", "```py\ngrammar_reducer = GrammarReducer(\n    mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_reduce=True) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\ngrammar_reducer.try_all_combinations = True\nprint([all_terminals(t)\n       for t in grammar_reducer.alternate_reductions(derivation_tree, \"<term>\")]) \n```", "```py\n['1', '2', '3', '1 * 1', '1 * 3', '2 * 1', '2 * 3', '3 * 1', '3 * 3', '(2 * 3)', '1 * 2 * 3', '2 * 2 * 3', '3 * 2 * 3', '1 * (2 * 3)', '(2 * 3) * 1', '(2 * 3) * 3', '2 * (2 * 3)', '3 * (2 * 3)']\n\n```", "```py\ngrammar_reducer.try_all_combinations = False\n[all_terminals(t) for t in grammar_reducer.alternate_reductions(\n    derivation_tree, \"<term>\")] \n```", "```py\n['1', '1 * 1']\n\n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def symbol_reductions(self, tree: DerivationTree, symbol: str, \n                          depth: int = -1):\n  \"\"\"Find all expansion alternatives for the given symbol\"\"\"\n        reductions = (self.subtrees_with_symbol(tree, symbol, depth=depth)\n                      + self.alternate_reductions(tree, symbol, depth=depth))\n\n        # Filter duplicates\n        unique_reductions = []\n        for r in reductions:\n            if r not in unique_reductions:\n                unique_reductions.append(r)\n\n        return unique_reductions \n```", "```py\ngrammar_reducer = GrammarReducer(\n    mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_reduce=True) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\nreductions = grammar_reducer.symbol_reductions(derivation_tree, \"<expr>\")\ntree_list_to_string([r for r in reductions]) \n```", "```py\n'[1 + (2 * 3), (2 * 3), 2 * 3, 1]'\n\n```", "```py\nreductions = grammar_reducer.symbol_reductions(derivation_tree, \"<term>\")\ntree_list_to_string([r for r in reductions]) \n```", "```py\n'[1, (2 * 3), 2 * 3, 3, 1 * 1]'\n\n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def reduce_subtree(self, tree: DerivationTree,\n                       subtree: DerivationTree, depth: int = -1):\n        symbol, children = subtree\n        if children is None or len(children) == 0:\n            return False\n\n        if self.log_reduce:\n            print(\"Reducing\", all_terminals(subtree), \"with depth\", depth)\n\n        reduced = False\n        while True:\n            reduced_child = False\n            for i, child in enumerate(children):\n                if child is None:\n                    continue\n\n                (child_symbol, _) = child\n                for reduction in self.symbol_reductions(\n                        child, child_symbol, depth):\n                    if number_of_nodes(reduction) >= number_of_nodes(child):\n                        continue\n\n                    # Try this reduction\n                    if self.log_reduce:\n                        print(\n                            \"Replacing\",\n                            all_terminals(\n                                children[i]),\n                            \"by\",\n                            all_terminals(reduction))\n                    children[i] = reduction\n                    if self.test(all_terminals(tree)) == Runner.FAIL:\n                        # Success\n                        if self.log_reduce:\n                            print(\"New tree:\", all_terminals(tree))\n                        reduced = reduced_child = True\n                        break\n                    else:\n                        # Didn't work out - restore\n                        children[i] = child\n\n            if not reduced_child:\n                if self.log_reduce:\n                    print(\"Tried all alternatives for\", all_terminals(subtree))\n                break\n\n        # Run recursively\n        for c in children:\n            if self.reduce_subtree(tree, c, depth):\n                reduced = True\n\n        return reduced \n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def reduce_tree(self, tree):\n        return self.reduce_subtree(tree, tree) \n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def parse(self, inp):\n        tree, *_ = self.parser.parse(inp)\n        if self.log_reduce:\n            print(all_terminals(tree))\n        return tree \n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def reduce(self, inp):\n        tree = self.parse(inp)\n        self.reduce_tree(tree)\n        return all_terminals(tree) \n```", "```py\nexpr_input \n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\ngrammar_reducer = GrammarReducer(\n    eval_mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_test=True)\ngrammar_reducer.reduce(expr_input) \n```", "```py\nTest #1 '(2 * 3)' 7 FAIL\nTest #2 '2 * 3' 5 PASS\nTest #3 '3' 1 PASS\nTest #4 '2' 1 PASS\nTest #5 '(3)' 3 FAIL\n\n```", "```py\n'(3)'\n\n```", "```py\ngrammar_reducer = GrammarReducer(\n    mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_reduce=True) \n```", "```py\nall_terminals(derivation_tree) \n```", "```py\n'1 + (2 * 3)'\n\n```", "```py\ndisplay_tree(derivation_tree) \n```", "```py\n[all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(\n    derivation_tree, \"<term>\", depth=1)] \n```", "```py\n[]\n\n```", "```py\n[all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(\n    derivation_tree, \"<term>\", depth=2)] \n```", "```py\n['1']\n\n```", "```py\n[all_terminals(t) for t in grammar_reducer.subtrees_with_symbol(\n    derivation_tree, \"<term>\", depth=3)] \n```", "```py\n['(2 * 3)']\n\n```", "```py\nclass GrammarReducer(GrammarReducer):\n    def reduce_tree(self, tree):\n        depth = 0\n        while depth < max_height(tree):\n            reduced = self.reduce_subtree(tree, tree, depth)\n            if reduced:\n                depth = 0    # Start with new tree\n            else:\n                depth += 1   # Extend search for subtrees\n        return tree \n```", "```py\ngrammar_reducer = GrammarReducer(\n    mystery,\n    EarleyParser(EXPR_GRAMMAR),\n    log_test=True)\ngrammar_reducer.reduce(expr_input) \n```", "```py\nTest #1 '(2 * 3)' 7 FAIL\nTest #2 '(3)' 3 FAIL\nTest #3 '3' 1 PASS\n\n```", "```py\n'(3)'\n\n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer \n```", "```py\nlong_expr_input = GrammarFuzzer(EXPR_GRAMMAR, min_nonterminals=100).fuzz()\nlong_expr_input \n```", "```py\n'++---((-2 / 3 / 3 - -+1 / 5 - 2) * ++6 / +8 * 4 / 9 / 2 * 8 + ++(5) * 3 / 8 * 0 + 3 * 3 + 4 / 0 / 6 + 9) * ++++(+--9 * -3 * 7 / 4 + --(4) / 3 - 0 / 3 + 5 + 0) * (1 * 6 - 1 / 9 * 5 - 9 / 0 + 7) * ++(8 - 1) * +1 * 7 * 0 + ((1 + 4) / 4 * 8 * 9 * 4 + 4 / (4) * 1 - (4) * 8 * 5 + 1 + 4) / (+(2 - 1 - 9) * 5 + 3 + 6 - 2) * +3 * (3 - 7 + 8) / 4 - -(9 * 4 - 1 * 0 + 5) / (5 / 9 * 5 + 2) * 7 + ((7 - 5 + 3) / 1 * 8 - 8 - 9) * --+1 * 4 / 4 - 4 / 7 * 4 - 3 / 6 * 1 - 2 - 7 - 8'\n\n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\ngrammar_reducer = GrammarReducer(eval_mystery, EarleyParser(EXPR_GRAMMAR))\nwith Timer() as grammar_time:\n    print(grammar_reducer.reduce(long_expr_input)) \n```", "```py\n(9)\n\n```", "```py\ngrammar_reducer.tests \n```", "```py\n10\n\n```", "```py\ngrammar_time.elapsed_time() \n```", "```py\n0.0751019999734126\n\n```", "```py\ndd_reducer = DeltaDebuggingReducer(eval_mystery)\nwith Timer() as dd_time:\n    print(dd_reducer.reduce(long_expr_input)) \n```", "```py\n((2 - 1 - 2) * 8 + (5) - (4)) / ((2) * 3) * (9) / 3 / 1 - 8\n\n```", "```py\ndd_reducer.tests \n```", "```py\n900\n\n```", "```py\ndd_time.elapsed_time() \n```", "```py\n1.6051183340023272\n\n```", "```py\nwith DeltaDebugger() as dd:\n    fun(args...)\ndd \n```", "```py\n<number> ::= <float> | <integer> | <not-a-number>\n<float> ::= <digits>.<digits>\n<integer> ::= <digits>\n<not-a-number> ::= NaN\n<digits> ::= [0-9]+\n```", "```py\n@incollection{fuzzingbook2023:Reducer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Reducing Failure-Inducing Inputs},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/Reducer.html}},\n    note = {Retrieved 2023-11-11 18:18:06+01:00},\n    url = {https://www.fuzzingbook.org/html/Reducer.html},\n    urldate = {2023-11-11 18:18:06+01:00}\n}\n\n```"]