["```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\n>>> from [fuzzingbook.ClassDiagram](ClassDiagram.html) import <identifier> \n```", "```py\n>>> display_class_hierarchy(D_Class, abstract_classes=[A_Class]) \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\ndef class_hierarchy(cls: Type) -> List[Type]:\n    superclasses = cls.mro()\n    hierarchy = []\n    last_superclass_name = \"\"\n\n    for superclass in superclasses:\n        if superclass.__name__ != last_superclass_name:\n            hierarchy.append(superclass)\n            last_superclass_name = superclass.__name__\n\n    return hierarchy \n```", "```py\nclass A_Class:\n  \"\"\"A Class which does A thing right.\n Comes with a longer docstring.\"\"\"\n\n    def foo(self) -> None:\n  \"\"\"The Adventures of the glorious Foo\"\"\"\n        pass\n\n    def quux(self) -> None:\n  \"\"\"A method that is not used.\"\"\"\n        pass \n```", "```py\nclass A_Class(A_Class):\n    # We define another function in a separate cell.\n\n    def second(self) -> None:\n        pass \n```", "```py\nclass B_Class(A_Class):\n  \"\"\"A subclass inheriting some methods.\"\"\"\n\n    VAR = \"A variable\"\n\n    def foo(self) -> None:\n  \"\"\"A WW2 foo fighter.\"\"\"\n        pass\n\n    def bar(self, qux: Any = None, bartender: int = 42) -> None:\n  \"\"\"A qux walks into a bar.\n `bartender` is an optional attribute.\"\"\"\n        pass \n```", "```py\nSomeType = List[Optional[Union[str, int]]] \n```", "```py\nclass C_Class:\n  \"\"\"A class injecting some method\"\"\"\n\n    def qux(self, arg: SomeType) -> SomeType:\n        return arg \n```", "```py\nclass D_Class(B_Class, C_Class):\n  \"\"\"A subclass inheriting from multiple superclasses.\n Comes with a fairly long, but meaningless documentation.\"\"\"\n\n    def foo(self) -> None:\n        B_Class.foo(self) \n```", "```py\nclass D_Class(D_Class):\n    pass  # An incremental addiiton that should not impact D's semantics \n```", "```py\nclass_hierarchy(D_Class) \n```", "```py\n[__main__.D_Class,\n __main__.B_Class,\n __main__.A_Class,\n __main__.C_Class,\n object]\n\n```", "```py\nD_Class.__bases__ \n```", "```py\n(__main__.D_Class,)\n\n```", "```py\ndef class_tree(cls: Type, lowest: Optional[Type] = None) -> List[Tuple[Type, List]]:\n    ret = []\n    for base in cls.__bases__:\n        if base.__name__ == cls.__name__:\n            if not lowest:\n                lowest = cls\n            ret += class_tree(base, lowest)\n        else:\n            if lowest:\n                cls = lowest\n            ret.append((cls, class_tree(base)))\n\n    return ret \n```", "```py\nclass_tree(D_Class) \n```", "```py\n[(__main__.D_Class, [(__main__.B_Class, [(__main__.A_Class, [])])]),\n (__main__.D_Class, [(__main__.C_Class, [])])]\n\n```", "```py\nclass_tree(D_Class)[0][0] \n```", "```py\n__main__.D_Class\n\n```", "```py\nassert class_tree(D_Class)[0][0] == D_Class \n```", "```py\ndef class_set(classes: Union[Type, List[Type]]) -> Set[Type]:\n    if not isinstance(classes, list):\n        classes = [classes]\n\n    ret = set()\n\n    def traverse_tree(tree: List[Tuple[Type, List]]) -> None:\n        for (cls, subtrees) in tree:\n            ret.add(cls)\n            for subtree in subtrees:\n                traverse_tree(subtrees)\n\n    for cls in classes:\n        traverse_tree(class_tree(cls))\n\n    return ret \n```", "```py\nclass_set(D_Class) \n```", "```py\n{__main__.A_Class, __main__.B_Class, __main__.C_Class, __main__.D_Class}\n\n```", "```py\nassert A_Class in class_set(D_Class) \n```", "```py\nassert B_Class in class_set(D_Class) \n```", "```py\nassert C_Class in class_set(D_Class) \n```", "```py\nassert D_Class in class_set(D_Class) \n```", "```py\nclass_set([B_Class, C_Class]) \n```", "```py\n{__main__.A_Class, __main__.B_Class, __main__.C_Class}\n\n```", "```py\nA_Class.__doc__ \n```", "```py\nA_Class.__bases__[0].__doc__ \n```", "```py\n'A Class which does A thing right.\\n    Comes with a longer docstring.'\n\n```", "```py\nA_Class.__bases__[0].__name__ \n```", "```py\n'A_Class'\n\n```", "```py\nD_Class.foo \n```", "```py\n<function __main__.D_Class.foo(self) -> None>\n\n```", "```py\nD_Class.foo.__doc__ \n```", "```py\nA_Class.foo.__doc__ \n```", "```py\n'The Adventures of the glorious Foo'\n\n```", "```py\ndef docstring(obj: Any) -> str:\n    doc = inspect.getdoc(obj)\n    return doc if doc else \"\" \n```", "```py\ndocstring(A_Class) \n```", "```py\n'A Class which does A thing right.\\nComes with a longer docstring.'\n\n```", "```py\ndocstring(D_Class.foo) \n```", "```py\n'A WW2 foo fighter.'\n\n```", "```py\ndef unknown() -> None:\n    pass \n```", "```py\ndocstring(unknown) \n```", "```py\n''\n\n```", "```py\nimport [html](https://docs.python.org/3/library/html.html) \n```", "```py\nimport [re](https://docs.python.org/3/library/re.html) \n```", "```py\ndef escape(text: str) -> str:\n    text = html.escape(text)\n    assert '<' not in text\n    assert '>' not in text\n    text = text.replace('{', '&#x7b;')\n    text = text.replace('|', '&#x7c;')\n    text = text.replace('}', '&#x7d;')\n    return text \n```", "```py\nescape(\"f(foo={})\") \n```", "```py\n'f(foo=&#x7b;&#x7d;)'\n\n```", "```py\ndef escape_doc(docstring: str) -> str:\n    DOC_INDENT = 0\n    docstring = \"&#x0a;\".join(\n        ' ' * DOC_INDENT + escape(line).strip()\n        for line in docstring.split('\\n')\n    )\n    return docstring \n```", "```py\nprint(escape_doc(\"'Hello\\n {You|Me}'\")) \n```", "```py\n&#x27;Hello&#x0a;&#x7b;You&#x7c;Me&#x7d;&#x27;\n\n```", "```py\ninspect.getmembers(D_Class) \n```", "```py\n[('VAR', 'A variable'),\n ('__class__', type),\n ('__delattr__', <slot wrapper '__delattr__' of 'object' objects>),\n ('__dict__', mappingproxy({'__module__': '__main__', '__doc__': None})),\n ('__dir__', <method '__dir__' of 'object' objects>),\n ('__doc__', None),\n ('__eq__', <slot wrapper '__eq__' of 'object' objects>),\n ('__format__', <method '__format__' of 'object' objects>),\n ('__ge__', <slot wrapper '__ge__' of 'object' objects>),\n ('__getattribute__', <slot wrapper '__getattribute__' of 'object' objects>),\n ('__getstate__', <method '__getstate__' of 'object' objects>),\n ('__gt__', <slot wrapper '__gt__' of 'object' objects>),\n ('__hash__', <slot wrapper '__hash__' of 'object' objects>),\n ('__init__', <slot wrapper '__init__' of 'object' objects>),\n ('__init_subclass__', <function D_Class.__init_subclass__>),\n ('__le__', <slot wrapper '__le__' of 'object' objects>),\n ('__lt__', <slot wrapper '__lt__' of 'object' objects>),\n ('__module__', '__main__'),\n ('__ne__', <slot wrapper '__ne__' of 'object' objects>),\n ('__new__', <function object.__new__(*args, **kwargs)>),\n ('__reduce__', <method '__reduce__' of 'object' objects>),\n ('__reduce_ex__', <method '__reduce_ex__' of 'object' objects>),\n ('__repr__', <slot wrapper '__repr__' of 'object' objects>),\n ('__setattr__', <slot wrapper '__setattr__' of 'object' objects>),\n ('__sizeof__', <method '__sizeof__' of 'object' objects>),\n ('__str__', <slot wrapper '__str__' of 'object' objects>),\n ('__subclasshook__', <function D_Class.__subclasshook__>),\n ('__weakref__', <attribute '__weakref__' of 'A_Class' objects>),\n ('bar',\n  <function __main__.B_Class.bar(self, qux: Any = None, bartender: int = 42) -> None>),\n ('foo', <function __main__.D_Class.foo(self) -> None>),\n ('quux', <function __main__.A_Class.quux(self) -> None>),\n ('qux',\n  <function __main__.C_Class.qux(self, arg: List[Union[int, str, NoneType]]) -> List[Union[int, str, NoneType]]>),\n ('second', <function __main__.A_Class.second(self) -> None>)]\n\n```", "```py\ndef class_items(cls: Type, pred: Callable) -> List[Tuple[str, Any]]:\n    def _class_items(cls: Type) -> List:\n        all_items = inspect.getmembers(cls, pred)\n        for base in cls.__bases__:\n            all_items += _class_items(base)\n\n        return all_items\n\n    unique_items = []\n    items_seen = set()\n    for (name, item) in _class_items(cls):\n        if name not in items_seen:\n            unique_items.append((name, item))\n            items_seen.add(name)\n\n    return unique_items \n```", "```py\ndef class_methods(cls: Type) -> List[Tuple[str, Callable]]:\n    return class_items(cls, inspect.isfunction) \n```", "```py\ndef defined_in(name: str, cls: Type) -> bool:\n    if not hasattr(cls, name):\n        return False\n\n    defining_classes = []\n\n    def search_superclasses(name: str, cls: Type) -> None:\n        if not hasattr(cls, name):\n            return\n\n        for base in cls.__bases__:\n            if hasattr(base, name):\n                defining_classes.append(base)\n                search_superclasses(name, base)\n\n    search_superclasses(name, cls)\n\n    if any(cls.__name__ != c.__name__ for c in defining_classes):\n        return False  # Already defined in superclass\n\n    return True \n```", "```py\nassert not defined_in('VAR', A_Class) \n```", "```py\nassert defined_in('VAR', B_Class) \n```", "```py\nassert not defined_in('VAR', C_Class) \n```", "```py\nassert not defined_in('VAR', D_Class) \n```", "```py\ndef class_vars(cls: Type) -> List[Any]:\n    def is_var(item: Any) -> bool:\n        return not callable(item)\n\n    return [item for item in class_items(cls, is_var) \n            if not item[0].startswith('__') and defined_in(item[0], cls)] \n```", "```py\nclass_methods(D_Class) \n```", "```py\n[('bar',\n  <function __main__.B_Class.bar(self, qux: Any = None, bartender: int = 42) -> None>),\n ('foo', <function __main__.D_Class.foo(self) -> None>),\n ('quux', <function __main__.A_Class.quux(self) -> None>),\n ('qux',\n  <function __main__.C_Class.qux(self, arg: List[Union[int, str, NoneType]]) -> List[Union[int, str, NoneType]]>),\n ('second', <function __main__.A_Class.second(self) -> None>)]\n\n```", "```py\nclass_vars(B_Class) \n```", "```py\n[('VAR', 'A variable')]\n\n```", "```py\ndef public_class_methods(cls: Type) -> List[Tuple[str, Callable]]:\n    return [(name, method) for (name, method) in class_methods(cls) \n            if method.__qualname__.startswith(cls.__name__)] \n```", "```py\ndef doc_class_methods(cls: Type) -> List[Tuple[str, Callable]]:\n    return [(name, method) for (name, method) in public_class_methods(cls) \n            if docstring(method) is not None] \n```", "```py\npublic_class_methods(D_Class) \n```", "```py\n[('foo', <function __main__.D_Class.foo(self) -> None>)]\n\n```", "```py\ndoc_class_methods(D_Class) \n```", "```py\n[('foo', <function __main__.D_Class.foo(self) -> None>)]\n\n```", "```py\ndef overloaded_class_methods(classes: Union[Type, List[Type]]) -> Set[str]:\n    all_methods: Dict[str, Set[Callable]] = {}\n    for cls in class_set(classes):\n        for (name, method) in class_methods(cls):\n            if method.__qualname__.startswith(cls.__name__):\n                all_methods.setdefault(name, set())\n                all_methods[name].add(cls)\n\n    return set(name for name in all_methods if len(all_methods[name]) >= 2) \n```", "```py\noverloaded_class_methods(D_Class) \n```", "```py\n{'foo'}\n\n```", "```py\nfrom [inspect](https://docs.python.org/3/library/inspect.html) import signature \n```", "```py\nimport [warnings](https://docs.python.org/3/library/warnings.html) \n```", "```py\nimport [os](https://docs.python.org/3/library/os.html) \n```", "```py\ndef display_class_hierarchy(classes: Union[Type, List[Type]], *,\n                            public_methods: Optional[List] = None,\n                            abstract_classes: Optional[List] = None,\n                            include_methods: bool = True,\n                            include_class_vars: bool = True,\n                            include_legend: bool = True,\n                            local_defs_only: bool = True,\n                            types: Dict[str, Any] = {},\n                            project: str = 'fuzzingbook',\n                            log: bool = False) -> Any:\n  \"\"\"Visualize a class hierarchy.\n`classes` is a Python class (or a list of classes) to be visualized.\n`public_methods`, if given, is a list of methods to be shown as \"public\" (bold).\n (Default: all methods with a docstring)\n`abstract_classes`, if given, is a list of classes to be shown as \"abstract\" (cursive).\n (Default: all classes with an abstract method)\n`include_methods`: if set (default), include all methods\n`include_legend`: if set (default), include a legend\n`local_defs_only`: if set (default), hide details of imported classes\n`types`: type names with definitions, to be used in docs\n \"\"\"\n    from [graphviz](https://graphviz.readthedocs.io/) import Digraph\n\n    if project == 'debuggingbook':\n        CLASS_FONT = 'Raleway, Helvetica, Arial, sans-serif'\n        CLASS_COLOR = '#6A0DAD'  # HTML 'purple'\n    else:\n        CLASS_FONT = 'Patua One, Helvetica, sans-serif'\n        CLASS_COLOR = '#B03A2E'\n\n    METHOD_FONT = \"'Fira Mono', 'Source Code Pro', 'Courier', monospace\"\n    METHOD_COLOR = 'black'\n\n    if isinstance(classes, list):\n        starting_class = classes[0]\n    else:\n        starting_class = classes\n        classes = [starting_class]\n\n    title = starting_class.__name__ + \" class hierarchy\"\n\n    dot = Digraph(comment=title)\n    dot.attr('node', shape='record', fontname=CLASS_FONT)\n    dot.attr('graph', rankdir='BT', tooltip=title)\n    dot.attr('edge', arrowhead='empty')\n\n    # Hack to force rendering as HTML, allowing hovers and links in Jupyter\n    dot._repr_html_ = dot._repr_image_svg_xml\n\n    edges = set()\n    overloaded_methods: Set[str] = set()\n\n    drawn_classes = set()\n\n    def method_string(method_name: str, public: bool, overloaded: bool,\n                      fontsize: float = 10.0) -> str:\n        method_string = f'<font face=\"{METHOD_FONT}\" point-size=\"{str(fontsize)}\">'\n\n        if overloaded:\n            name = f'<i>{method_name}()</i>'\n        else:\n            name = f'{method_name}()'\n\n        if public:\n            method_string += f'<b>{name}</b>'\n        else:\n            method_string += f'<font color=\"{METHOD_COLOR}\">' \\\n                             f'{name}</font>'\n\n        method_string += '</font>'\n        return method_string\n\n    def var_string(var_name: str, fontsize: int = 10) -> str:\n        var_string = f'<font face=\"{METHOD_FONT}\" point-size=\"{str(fontsize)}\">'\n        var_string += f'{var_name}'\n        var_string += '</font>'\n        return var_string\n\n    def is_overloaded(method_name: str, f: Any) -> bool:\n        return (method_name in overloaded_methods or\n                (docstring(f) is not None and \"in subclasses\" in docstring(f)))\n\n    def is_abstract(cls: Type) -> bool:\n        if not abstract_classes:\n            return inspect.isabstract(cls)\n\n        return (cls in abstract_classes or\n                any(c.__name__ == cls.__name__ for c in abstract_classes))\n\n    def is_public(method_name: str, f: Any) -> bool:\n        if public_methods:\n            return (method_name in public_methods or\n                    f in public_methods or\n                    any(f.__qualname__ == m.__qualname__\n                        for m in public_methods))\n\n        return bool(docstring(f))\n\n    def frame_module(frameinfo: Any) -> str:\n        return os.path.splitext(os.path.basename(frameinfo.frame.f_code.co_filename))[0]\n\n    def callers() -> List[str]:\n        frames = inspect.getouterframes(inspect.currentframe())\n        return [frame_module(frameinfo) for frameinfo in frames]\n\n    def is_local_class(cls: Type) -> bool:\n        return cls.__module__ == '__main__' or cls.__module__ in callers()\n\n    def class_vars_string(cls: Type, url: str) -> str:\n        cls_vars = class_vars(cls)\n        if len(cls_vars) == 0:\n            return \"\"\n\n        vars_string = f'<table border=\"0\" cellpadding=\"0\" ' \\\n                      f'cellspacing=\"0\" ' \\\n                      f'align=\"left\" tooltip=\"{cls.__name__}\" href=\"#\">'\n\n        for (name, var) in cls_vars:\n            if log:\n                print(f\"    Drawing {name}\")\n\n            var_doc = escape(f\"{name} = {repr(var)}\")\n            tooltip = f' tooltip=\"{var_doc}\"'\n            href = f' href=\"{url}\"'\n            vars_string += f'<tr><td align=\"left\" border=\"0\"' \\\n                           f'{tooltip}{href}>'\n\n            vars_string += var_string(name)\n            vars_string += '</td></tr>'\n\n        vars_string += '</table>'\n        return vars_string\n\n    def class_methods_string(cls: Type, url: str) -> str:\n        methods = public_class_methods(cls)\n        # return \"<br/>\".join([name + \"()\" for (name, f) in methods])\n        methods_string = f'<table border=\"0\" cellpadding=\"0\" ' \\\n                         f'cellspacing=\"0\" ' \\\n                         f'align=\"left\" tooltip=\"{cls.__name__}\" href=\"#\">'\n\n        public_methods_only = local_defs_only and not is_local_class(cls)\n\n        methods_seen = False\n        for public in [True, False]:\n            for (name, f) in methods:\n                if public != is_public(name, f):\n                    continue\n\n                if public_methods_only and not public:\n                    continue\n\n                if log:\n                    print(f\"    Drawing {name}()\")\n\n                if is_public(name, f) and not docstring(f):\n                    warnings.warn(f\"{f.__qualname__}() is listed as public,\"\n                                  f\" but has no docstring\")\n\n                overloaded = is_overloaded(name, f)\n\n                sig = str(inspect.signature(f))\n                # replace 'List[Union[...]]' by the actual type def\n                for tp in types:\n                    tp_def = str(types[tp]).replace('typing.', '')\n                    sig = sig.replace(tp_def, tp)\n                sig = sig.replace('__main__.', '')\n\n                method_doc = escape(name + sig)\n                if docstring(f):\n                    method_doc += \":&#x0a;\" + escape_doc(docstring(f))\n\n                if log:\n                    print(f\"    Method doc: {method_doc}\")\n\n                # Tooltips are only shown if a href is present, too\n                tooltip = f' tooltip=\"{method_doc}\"'\n                href = f' href=\"{url}\"'\n                methods_string += f'<tr><td align=\"left\" border=\"0\"' \\\n                                  f'{tooltip}{href}>'\n\n                methods_string += method_string(name, public, overloaded)\n\n                methods_string += '</td></tr>'\n                methods_seen = True\n\n        if not methods_seen:\n            return \"\"\n\n        methods_string += '</table>'\n        return methods_string\n\n    def display_class_node(cls: Type) -> None:\n        name = cls.__name__\n\n        if name in drawn_classes:\n            return\n        drawn_classes.add(name)\n\n        if log:\n            print(f\"Drawing class {name}\")\n\n        if cls.__module__ == '__main__':\n            url = '#'\n        else:\n            url = cls.__module__ + '.ipynb'\n\n        if is_abstract(cls):\n            formatted_class_name = f'<i>{cls.__name__}</i>'\n        else:\n            formatted_class_name = cls.__name__\n\n        if include_methods or include_class_vars:\n            vars = class_vars_string(cls, url)\n            methods = class_methods_string(cls, url)\n            spec = '<{<b><font color=\"' + CLASS_COLOR + '\">' + \\\n                formatted_class_name + '</font></b>'\n            if include_class_vars and vars:\n                spec += '|' + vars\n            if include_methods and methods:\n                spec += '|' + methods\n            spec += '}>'\n        else:\n            spec = '<' + formatted_class_name + '>'\n\n        class_doc = escape('class ' + cls.__name__)\n        if docstring(cls):\n            class_doc += ':&#x0a;' + escape_doc(docstring(cls))\n        else:\n            warnings.warn(f\"Class {cls.__name__} has no docstring\")\n\n        dot.node(name, spec, tooltip=class_doc, href=url)\n\n    def display_class_trees(trees: List[Tuple[Type, List]]) -> None:\n        for tree in trees:\n            (cls, subtrees) = tree\n            display_class_node(cls)\n\n            for subtree in subtrees:\n                (subcls, _) = subtree\n\n                if (cls.__name__, subcls.__name__) not in edges:\n                    dot.edge(cls.__name__, subcls.__name__)\n                    edges.add((cls.__name__, subcls.__name__))\n\n            display_class_trees(subtrees)\n\n    def display_legend() -> None:\n        fontsize = 8.0\n\n        label = f'<b><font color=\"{CLASS_COLOR}\">Legend</font></b><br align=\"left\"/>' \n\n        for item in [\n            method_string(\"public_method\",\n                          public=True, overloaded=False, fontsize=fontsize),\n            method_string(\"private_method\",\n                          public=False, overloaded=False, fontsize=fontsize),\n            method_string(\"overloaded_method\",\n                          public=False, overloaded=True, fontsize=fontsize)\n        ]:\n            label += '&bull;&nbsp;' + item + '<br align=\"left\"/>'\n\n        label += f'<font face=\"Helvetica\" point-size=\"{str(fontsize  +  1)}\">' \\\n                 'Hover over names to see doc' \\\n                 '</font><br align=\"left\"/>'\n\n        dot.node('Legend', label=f'<{label}>', shape='plain', fontsize=str(fontsize + 2))\n\n    for cls in classes:\n        tree = class_tree(cls)\n        overloaded_methods = overloaded_class_methods(cls)\n        display_class_trees(tree)\n\n    if include_legend:\n        display_legend()\n\n    return dot \n```", "```py\ndisplay_class_hierarchy(D_Class, types={'SomeType': SomeType},\n                        project='debuggingbook', log=True) \n```", "```py\nDrawing class D_Class\n    Drawing foo()\n    Method doc: foo(self) -&gt; None:&#x0a;A WW2 foo fighter.\nDrawing class B_Class\n    Drawing VAR\n    Drawing bar()\n    Method doc: bar(self, qux: Any = None, bartender: int = 42) -&gt; None:&#x0a;A qux walks into a bar.&#x0a;`bartender` is an optional attribute.\n    Drawing foo()\n    Method doc: foo(self) -&gt; None:&#x0a;A WW2 foo fighter.\nDrawing class A_Class\n    Drawing foo()\n    Method doc: foo(self) -&gt; None:&#x0a;The Adventures of the glorious Foo\n    Drawing quux()\n    Method doc: quux(self) -&gt; None:&#x0a;A method that is not used.\n    Drawing second()\n    Method doc: second(self) -&gt; None\nDrawing class C_Class\n    Drawing qux()\n    Method doc: qux(self, arg: SomeType) -&gt; SomeType\n\n```", "```py\ndisplay_class_hierarchy(D_Class, types={'SomeType': SomeType},\n                        project='fuzzingbook') \n```", "```py\ndisplay_class_hierarchy([A_Class, B_Class],\n                        abstract_classes=[A_Class],\n                        public_methods=[\n                            A_Class.quux,\n                        ],\n                        log=True) \n```", "```py\nDrawing class A_Class\n    Drawing quux()\n    Method doc: quux(self) -&gt; None:&#x0a;A method that is not used.\n    Drawing foo()\n    Method doc: foo(self) -&gt; None:&#x0a;The Adventures of the glorious Foo\n    Drawing second()\n    Method doc: second(self) -&gt; None\nDrawing class B_Class\n    Drawing VAR\n    Drawing bar()\n    Method doc: bar(self, qux: Any = None, bartender: int = 42) -&gt; None:&#x0a;A qux walks into a bar.&#x0a;`bartender` is an optional attribute.\n    Drawing foo()\n    Method doc: foo(self) -&gt; None:&#x0a;A WW2 foo fighter.\n\n```", "```py\n@incollection{fuzzingbook2024:ClassDiagram,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Class Diagrams},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/ClassDiagram.html}},\n    note = {Retrieved 2024-06-30 18:45:02+02:00},\n    url = {https://www.fuzzingbook.org/html/ClassDiagram.html},\n    urldate = {2024-06-30 18:45:02+02:00}\n}\n\n```"]