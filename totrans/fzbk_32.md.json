["```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nimport [APIFuzzer](APIFuzzer.html) \n```", "```py\n>>> from [fuzzingbook.Carver](Carver.html) import <identifier> \n```", "```py\n>>> with CallCarver() as carver:\n>>>     y = my_sqrt(2)\n>>>     y = my_sqrt(4) \n```", "```py\n>>> carver.called_functions()\n['my_sqrt', '__exit__'] \n```", "```py\n>>> carver.arguments('my_sqrt')\n[[('x', 2)], [('x', 4)]] \n```", "```py\n>>> my_sqrt_miner = CallGrammarMiner(carver)\n>>> my_sqrt_grammar = my_sqrt_miner.mine_call_grammar()\n>>> my_sqrt_grammar\n{'<start>': ['<call>'],\n '<call>': ['<my_sqrt>'],\n '<my_sqrt-x>': ['2', '4'],\n '<my_sqrt>': ['my_sqrt(<my_sqrt-x>)']} \n```", "```py\n>>> fuzzer = GrammarCoverageFuzzer(my_sqrt_grammar)\n>>> fuzzer.fuzz()\n'my_sqrt(4)' \n```", "```py\n>>> eval(fuzzer.fuzz())\n1.414213562373095 \n```", "```py\nimport [urllib.parse](https://docs.python.org/3/library/urllib.parse.html) \n```", "```py\ndef webbrowser(url):\n  \"\"\"Download the http/https resource given by the URL\"\"\"\n    import [requests](http://docs.python-requests.org/en/master/)  # Only import if needed\n\n    r = requests.get(url)\n    return r.text \n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\nwith Timer() as webbrowser_timer:\n    fuzzingbook_contents = webbrowser(\n        \"http://www.fuzzingbook.org/html/Fuzzer.html\")\n\nprint(\"Downloaded %d bytes in %.2f seconds\" %\n      (len(fuzzingbook_contents), webbrowser_timer.elapsed_time())) \n```", "```py\nDownloaded 474839 bytes in 0.48 seconds\n\n```", "```py\nfuzzingbook_contents[:100] \n```", "```py\n'\\n<!-- A html document -->\\n<!-- \\nwith standard nbconvert css layout\\nwith standard nbconvert input/out'\n\n```", "```py\nfrom [IPython.display](https://ipython.readthedocs.io/en/stable/api/generated/IPython.display.html) import HTML, display\nHTML(fuzzingbook_contents) \n```", "```py\nfrom [urllib.parse](https://docs.python.org/3/library/urllib.parse.html) import urlparse \n```", "```py\nurlparse('https://www.fuzzingbook.com/html/Carver.html') \n```", "```py\nParseResult(scheme='https', netloc='www.fuzzingbook.com', path='/html/Carver.html', params='', query='', fragment='')\n\n```", "```py\nruns = 1000\nwith Timer() as urlparse_timer:\n    for i in range(runs):\n        urlparse('https://www.fuzzingbook.com/html/Carver.html')\n\navg_urlparse_time = urlparse_timer.elapsed_time() / 1000\navg_urlparse_time \n```", "```py\n1.4512089546769858e-06\n\n```", "```py\nwebbrowser_timer.elapsed_time() \n```", "```py\n0.48406379198422655\n\n```", "```py\nwebbrowser_timer.elapsed_time() / avg_urlparse_time \n```", "```py\n333558.98916153726\n\n```", "```py\nwith Carver() as carver:\n    function_to_be_traced()\nc = carver.calls() \n```", "```py\nimport [sys](https://docs.python.org/3/library/sys.html) \n```", "```py\nclass Carver:\n    def __init__(self, log=False):\n        self._log = log\n        self.reset()\n\n    def reset(self):\n        self._calls = {}\n\n    # Start of `with` block\n    def __enter__(self):\n        self.original_trace_function = sys.gettrace()\n        sys.settrace(self.traceit)\n        return self\n\n    # End of `with` block\n    def __exit__(self, exc_type, exc_value, tb):\n        sys.settrace(self.original_trace_function) \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\ndef get_qualified_name(code):\n  \"\"\"Return the fully qualified name of the current function\"\"\"\n    name = code.co_name\n    module = inspect.getmodule(code)\n    if module is not None:\n        name = module.__name__ + \".\" + name\n    return name \n```", "```py\ndef get_arguments(frame):\n  \"\"\"Return call arguments in the given frame\"\"\"\n    # When called, all arguments are local variables\n    local_variables = frame.f_locals.copy()\n    arguments = [(var, frame.f_locals[var])\n                 for var in local_variables]\n    arguments.reverse()  # Want same order as call\n    return arguments \n```", "```py\nclass CallCarver(Carver):\n    def add_call(self, function_name, arguments):\n  \"\"\"Add given call to list of calls\"\"\"\n        if function_name not in self._calls:\n            self._calls[function_name] = []\n        self._calls[function_name].append(arguments)\n\n    # Tracking function: Record all calls and all args\n    def traceit(self, frame, event, arg):\n        if event != \"call\":\n            return None\n\n        code = frame.f_code\n        function_name = code.co_name\n        qualified_name = get_qualified_name(code)\n        arguments = get_arguments(frame)\n\n        self.add_call(function_name, arguments)\n        if qualified_name != function_name:\n            self.add_call(qualified_name, arguments)\n\n        if self._log:\n            print(simple_call_string(function_name, arguments))\n\n        return None \n```", "```py\nclass CallCarver(CallCarver):\n    def calls(self):\n  \"\"\"Return a dictionary of all calls traced.\"\"\"\n        return self._calls\n\n    def arguments(self, function_name):\n  \"\"\"Return a list of all arguments of the given function\n as (VAR, VALUE) pairs.\n Raises an exception if the function was not traced.\"\"\"\n        return self._calls[function_name]\n\n    def called_functions(self, qualified=False):\n  \"\"\"Return all functions called.\"\"\"\n        if qualified:\n            return [function_name for function_name in self._calls.keys()\n                    if function_name.find('.') >= 0]\n        else:\n            return [function_name for function_name in self._calls.keys()\n                    if function_name.find('.') < 0] \n```", "```py\nfrom [Intro_Testing](Intro_Testing.html) import my_sqrt \n```", "```py\nwith CallCarver() as sqrt_carver:\n    my_sqrt(2)\n    my_sqrt(4) \n```", "```py\nsqrt_carver.calls() \n```", "```py\n{'my_sqrt': [[('x', 2)], [('x', 4)]],\n 'Intro_Testing.my_sqrt': [[('x', 2)], [('x', 4)]],\n '__exit__': [[('tb', None),\n   ('exc_value', None),\n   ('exc_type', None),\n   ('self', <__main__.CallCarver at 0x164d98e20>)]]}\n\n```", "```py\nsqrt_carver.called_functions() \n```", "```py\n['my_sqrt', '__exit__']\n\n```", "```py\nsqrt_carver.arguments(\"my_sqrt\") \n```", "```py\n[[('x', 2)], [('x', 4)]]\n\n```", "```py\ndef simple_call_string(function_name, argument_list):\n  \"\"\"Return function_name(arg[0], arg[1], ...) as a string\"\"\"\n    return function_name + \"(\" + \\\n        \", \".join([var + \"=\" + repr(value)\n                   for (var, value) in argument_list]) + \")\" \n```", "```py\nfor function_name in sqrt_carver.called_functions():\n    for argument_list in sqrt_carver.arguments(function_name):\n        print(simple_call_string(function_name, argument_list)) \n```", "```py\nmy_sqrt(x=2)\nmy_sqrt(x=4)\n__exit__(tb=None, exc_value=None, exc_type=None, self=<__main__.CallCarver object at 0x164d98e20>)\n\n```", "```py\neval(\"my_sqrt(x=2)\") \n```", "```py\n1.414213562373095\n\n```", "```py\nwith CallCarver() as webbrowser_carver:\n    webbrowser(\"https://www.fuzzingbook.org\") \n```", "```py\nfunction_list = webbrowser_carver.called_functions(qualified=True)\nlen(function_list) \n```", "```py\n361\n\n```", "```py\nprint(function_list[:50]) \n```", "```py\n['requests.api.get', 'requests.api.request', 'requests.sessions.__init__', 'requests.utils.default_headers', 'requests.utils.default_user_agent', 'requests.structures.__init__', 'collections.abc.update', 'abc.__instancecheck__', 'requests.structures.__setitem__', 'requests.hooks.default_hooks', 'requests.hooks.<dictcomp>', 'requests.cookies.cookiejar_from_dict', 'http.cookiejar.__init__', 'threading.RLock', 'http.cookiejar.__iter__', 'requests.cookies.<listcomp>', 'http.cookiejar.deepvalues', 'http.cookiejar.vals_sorted_by_key', 'requests.adapters.__init__', 'urllib3.util.retry.__init__', 'urllib3.util.retry.<listcomp>', 'requests.adapters.init_poolmanager', 'urllib3.poolmanager.__init__', 'urllib3.request.__init__', 'urllib3._collections.__init__', 'requests.sessions.mount', 'requests.sessions.<listcomp>', 'requests.sessions.__enter__', 'requests.sessions.request', 'requests.models.__init__', 'requests.sessions.prepare_request', 'requests.cookies.merge_cookies', 'requests.cookies.update', 'requests.utils.get_netrc_auth', 'collections.abc.get', 'os.__getitem__', 'os.encode', 'requests.utils.<genexpr>', 'posixpath.expanduser', 'posixpath._get_sep', 'collections.abc.__contains__', 'os.decode', 'genericpath.exists', 'urllib.parse.urlparse', 'urllib.parse._coerce_args', 'urllib.parse.urlsplit', 'urllib.parse._splitnetloc', 'urllib.parse._checknetloc', 'urllib.parse._noop', 'netrc.__init__']\n\n```", "```py\nurlparse_argument_list = webbrowser_carver.arguments(\"urllib.parse.urlparse\")\nurlparse_argument_list \n```", "```py\n[[('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')],\n [('allow_fragments', True),\n  ('scheme', ''),\n  ('url', 'https://www.fuzzingbook.org/')]]\n\n```", "```py\nurlparse_call = simple_call_string(\"urlparse\", urlparse_argument_list[0])\nurlparse_call \n```", "```py\n\"urlparse(allow_fragments=True, scheme='', url='https://www.fuzzingbook.org')\"\n\n```", "```py\neval(urlparse_call) \n```", "```py\nParseResult(scheme='https', netloc='www.fuzzingbook.org', path='', params='', query='', fragment='')\n\n```", "```py\nemail_parse_argument_list = webbrowser_carver.arguments(\"email.parser.parse\") \n```", "```py\nemail_parse_call = simple_call_string(\n    \"email.parser.Parser.parse\",\n    email_parse_argument_list[0])\nemail_parse_call \n```", "```py\n'email.parser.Parser.parse(headersonly=False, fp=<_io.StringIO object at 0x165160040>, self=<email.parser.Parser object at 0x164d9a3b0>)'\n\n```", "```py\nimport [pickle](https://docs.python.org/3/library/pickle.html) \n```", "```py\nemail_parse_argument_list \n```", "```py\n[[('headersonly', False),\n  ('fp', <_io.StringIO at 0x165160040>),\n  ('self', <email.parser.Parser at 0x164d9a3b0>)]]\n\n```", "```py\nparser_object = email_parse_argument_list[0][2][1]\nparser_object \n```", "```py\n<email.parser.Parser at 0x164d9a3b0>\n\n```", "```py\npickled = pickle.dumps(parser_object)\npickled \n```", "```py\nb'\\x80\\x04\\x95w\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x0cemail.parser\\x94\\x8c\\x06Parser\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x06_class\\x94\\x8c\\x0bhttp.client\\x94\\x8c\\x0bHTTPMessage\\x94\\x93\\x94\\x8c\\x06policy\\x94\\x8c\\x11email._policybase\\x94\\x8c\\x08Compat32\\x94\\x93\\x94)\\x81\\x94ub.'\n\n```", "```py\nunpickled_parser_object = pickle.loads(pickled)\nunpickled_parser_object \n```", "```py\n<email.parser.Parser at 0x1653cc430>\n\n```", "```py\ndef call_value(value):\n    value_as_string = repr(value)\n    if value_as_string.find('<') >= 0:\n        # Complex object\n        value_as_string = \"pickle.loads(\" + repr(pickle.dumps(value)) + \")\"\n    return value_as_string \n```", "```py\ndef call_string(function_name, argument_list):\n  \"\"\"Return function_name(arg[0], arg[1], ...) as a string, pickling complex objects\"\"\"\n    if len(argument_list) > 0:\n        (first_var, first_value) = argument_list[0]\n        if first_var == \"self\":\n            # Make this a method call\n            method_name = function_name.split(\".\")[-1]\n            function_name = call_value(first_value) + \".\" + method_name\n            argument_list = argument_list[1:]\n\n    return function_name + \"(\" + \\\n        \", \".join([var + \"=\" + call_value(value)\n                   for (var, value) in argument_list]) + \")\" \n```", "```py\ncall = call_string(\"email.parser.Parser.parse\", email_parse_argument_list[0])\nprint(call) \n```", "```py\nemail.parser.Parser.parse(headersonly=False, fp=pickle.loads(b'\\x80\\x04\\x95\\xc4\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x03_io\\x94\\x8c\\x08StringIO\\x94\\x93\\x94)\\x81\\x94(X\\x9b\\x02\\x00\\x00Connection: keep-alive\\r\\nContent-Length: 51336\\r\\nServer: GitHub.com\\r\\nContent-Type: text/html; charset=utf-8\\r\\nLast-Modified: Sat, 09 Nov 2024 16:09:36 GMT\\r\\nAccess-Control-Allow-Origin: *\\r\\nETag: W/\"672f8940-4620a\"\\r\\nexpires: Sat, 09 Nov 2024 17:02:19 GMT\\r\\nCache-Control: max-age=600\\r\\nContent-Encoding: gzip\\r\\nx-proxy-cache: MISS\\r\\nX-GitHub-Request-Id: 4FED:361A70:4094950:424934E:672F9343\\r\\nAccept-Ranges: bytes\\r\\nAge: 0\\r\\nDate: Sat, 09 Nov 2024 16:52:20 GMT\\r\\nVia: 1.1 varnish\\r\\nX-Served-By: cache-fra-eddf8230152-FRA\\r\\nX-Cache: MISS\\r\\nX-Cache-Hits: 0\\r\\nX-Timer: S1731171140.907105,VS0,VE105\\r\\nVary: Accept-Encoding\\r\\nX-Fastly-Request-ID: ca9f40b3c3e14ac63fadb8002a5b3b2d5be59d1b\\r\\n\\r\\n\\x94\\x8c\\x01\\n\\x94M\\x9b\\x02Nt\\x94b.'), self=pickle.loads(b'\\x80\\x04\\x95w\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x0cemail.parser\\x94\\x8c\\x06Parser\\x94\\x93\\x94)\\x81\\x94}\\x94(\\x8c\\x06_class\\x94\\x8c\\x0bhttp.client\\x94\\x8c\\x0bHTTPMessage\\x94\\x93\\x94\\x8c\\x06policy\\x94\\x8c\\x11email._policybase\\x94\\x8c\\x08Compat32\\x94\\x93\\x94)\\x81\\x94ub.'))\n\n```", "```py\nimport [email](https://docs.python.org/3/library/email.html) \n```", "```py\neval(call) \n```", "```py\n<http.client.HTTPMessage at 0x1653cd720>\n\n```", "```py\nimport [traceback](https://docs.python.org/3/library/traceback.html) \n```", "```py\nimport [enum](https://docs.python.org/3/library/enum.html)\nimport [socket](https://docs.python.org/3/library/socket.html) \n```", "```py\nall_functions = set(webbrowser_carver.called_functions(qualified=True))\ncall_success = set()\nrun_success = set() \n```", "```py\nexceptions_seen = set()\n\nfor function_name in webbrowser_carver.called_functions(qualified=True):\n    for argument_list in webbrowser_carver.arguments(function_name):\n        try:\n            call = call_string(function_name, argument_list)\n            call_success.add(function_name)\n\n            result = eval(call)\n            run_success.add(function_name)\n\n        except Exception as exc:\n            exceptions_seen.add(repr(exc))\n            # print(\"->\", call, file=sys.stderr)\n            # traceback.print_exc()\n            # print(\"\", file=sys.stderr)\n            continue \n```", "```py\nprint(\"%d/%d calls (%.2f%%) successfully created and %d/%d calls (%.2f%%) successfully ran\" % (\n    len(call_success), len(all_functions), len(\n        call_success) * 100 / len(all_functions),\n    len(run_success), len(all_functions), len(run_success) * 100 / len(all_functions))) \n```", "```py\n240/361 calls (66.48%) successfully created and 49/361 calls (13.57%) successfully ran\n\n```", "```py\nfor i in range(10):\n    print(list(exceptions_seen)[i]) \n```", "```py\nNameError(\"name 'logging' is not defined\")\nTypeError(\"cannot pickle 'SSLSocket' object\")\nAttributeError(\"module 'enum' has no attribute '__call__'\")\nAttributeError(\"'NoneType' object has no attribute 'readline'\")\nNameError(\"name 'codecs' is not defined\")\nSyntaxError('invalid syntax', ('<string>', 1, 17, \"requests.models.<genexpr>(.0=pickle.loads(b'\\\\x80\\\\x04\\\\x95\\\\x1b\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x8c\\\\x08builtins\\\\x94\\\\x8c\\\\x04iter\\\\x94\\\\x93\\\\x94]\\\\x94\\\\x85\\\\x94R\\\\x94.'))\", 1, 18))\nSyntaxError('invalid syntax', ('<string>', 1, 18, \"urllib3.util.url.<genexpr>(.0=pickle.loads(b'\\\\x80\\\\x04\\\\x95\\\\x1c\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x8c\\\\x08builtins\\\\x94\\\\x8c\\\\x04iter\\\\x94\\\\x93\\\\x94\\\\x8c\\\\x00\\\\x94\\\\x85\\\\x94R\\\\x94.'))\", 1, 19))\nAttributeError(\"module 'email.parser' has no attribute 'parsestr'\")\nSyntaxError('invalid syntax', ('<string>', 1, 16, \"requests.utils.<genexpr>(f='.netrc', .0=pickle.loads(b'\\\\x80\\\\x04\\\\x950\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x00\\\\x8c\\\\x08builtins\\\\x94\\\\x8c\\\\x04iter\\\\x94\\\\x93\\\\x94\\\\x8c\\\\x06.netrc\\\\x94\\\\x8c\\\\x06_netrc\\\\x94\\\\x86\\\\x94\\\\x85\\\\x94R\\\\x94K\\\\x01b.'))\", 1, 17))\nAttributeError(\"module 'email.message' has no attribute 'get'\")\n\n```", "```py\nimport [math](https://docs.python.org/3/library/math.html) \n```", "```py\ndef power(x, y):\n    return math.pow(x, y) \n```", "```py\nwith CallCarver() as power_carver:\n    z = power(1, 2)\n    z = power(3, 4) \n```", "```py\npower_carver.arguments(\"power\") \n```", "```py\n[[('y', 2), ('x', 1)], [('y', 4), ('x', 3)]]\n\n```", "```py\nfrom [Grammars](Grammars.html) import START_SYMBOL, is_valid_grammar, new_symbol\nfrom [Grammars](Grammars.html) import extend_grammar, Grammar \n```", "```py\nPOWER_GRAMMAR: Grammar = {\n    \"<start>\": [\"power(<x>, <y>)\"],\n    \"<x>\": [\"1\", \"3\"],\n    \"<y>\": [\"2\", \"4\"]\n}\n\nassert is_valid_grammar(POWER_GRAMMAR) \n```", "```py\nfrom [GrammarCoverageFuzzer](GrammarCoverageFuzzer.html) import GrammarCoverageFuzzer \n```", "```py\npower_fuzzer = GrammarCoverageFuzzer(POWER_GRAMMAR)\n[power_fuzzer.fuzz() for i in range(5)] \n```", "```py\n['power(1, 2)', 'power(3, 4)', 'power(1, 2)', 'power(3, 4)', 'power(3, 4)']\n\n```", "```py\nclass CallGrammarMiner:\n    def __init__(self, carver, log=False):\n        self.carver = carver\n        self.log = log \n```", "```py\nimport [copy](https://docs.python.org/3/library/copy.html) \n```", "```py\nclass CallGrammarMiner(CallGrammarMiner):\n    CALL_SYMBOL = \"<call>\"\n\n    def initial_grammar(self):\n        return extend_grammar(\n            {START_SYMBOL: [self.CALL_SYMBOL],\n                self.CALL_SYMBOL: []\n             }) \n```", "```py\nm = CallGrammarMiner(power_carver)\ninitial_grammar = m.initial_grammar()\ninitial_grammar \n```", "```py\n{'<start>': ['<call>'], '<call>': []}\n\n```", "```py\narguments = power_carver.arguments(\"power\")\narguments \n```", "```py\n[[('y', 2), ('x', 1)], [('y', 4), ('x', 3)]]\n\n```", "```py\nclass CallGrammarMiner(CallGrammarMiner):\n    def var_symbol(self, function_name, var, grammar):\n        return new_symbol(grammar, \"<\" + function_name + \"-\" + var + \">\")\n\n    def mine_arguments_grammar(self, function_name, arguments, grammar):\n        var_grammar = {}\n\n        variables = {}\n        for argument_list in arguments:\n            for (var, value) in argument_list:\n                value_string = call_value(value)\n                if self.log:\n                    print(var, \"=\", value_string)\n\n                if value_string.find(\"<\") >= 0:\n                    var_grammar[\"<langle>\"] = [\"<\"]\n                    value_string = value_string.replace(\"<\", \"<langle>\")\n\n                if var not in variables:\n                    variables[var] = set()\n                variables[var].add(value_string)\n\n        var_symbols = []\n        for var in variables:\n            var_symbol = self.var_symbol(function_name, var, grammar)\n            var_symbols.append(var_symbol)\n            var_grammar[var_symbol] = list(variables[var])\n\n        return var_grammar, var_symbols \n```", "```py\nm = CallGrammarMiner(power_carver)\nvar_grammar, var_symbols = m.mine_arguments_grammar(\n    \"power\", arguments, initial_grammar) \n```", "```py\nvar_grammar \n```", "```py\n{'<power-y>': ['2', '4'], '<power-x>': ['3', '1']}\n\n```", "```py\nvar_symbols \n```", "```py\n['<power-y>', '<power-x>']\n\n```", "```py\nclass CallGrammarMiner(CallGrammarMiner):\n    def function_symbol(self, function_name, grammar):\n        return new_symbol(grammar, \"<\" + function_name + \">\")\n\n    def mine_function_grammar(self, function_name, grammar):\n        arguments = self.carver.arguments(function_name)\n\n        if self.log:\n            print(function_name, arguments)\n\n        var_grammar, var_symbols = self.mine_arguments_grammar(\n            function_name, arguments, grammar)\n\n        function_grammar = var_grammar\n        function_symbol = self.function_symbol(function_name, grammar)\n\n        if len(var_symbols) > 0 and var_symbols[0].find(\"-self\") >= 0:\n            # Method call\n            function_grammar[function_symbol] = [\n                var_symbols[0] + \".\" + function_name + \"(\" + \", \".join(var_symbols[1:]) + \")\"]\n        else:\n            function_grammar[function_symbol] = [\n                function_name + \"(\" + \", \".join(var_symbols) + \")\"]\n\n        if self.log:\n            print(function_symbol, \"::=\", function_grammar[function_symbol])\n\n        return function_grammar, function_symbol \n```", "```py\nm = CallGrammarMiner(power_carver)\nfunction_grammar, function_symbol = m.mine_function_grammar(\n    \"power\", initial_grammar)\nfunction_grammar \n```", "```py\n{'<power-y>': ['2', '4'],\n '<power-x>': ['3', '1'],\n '<power>': ['power(<power-y>, <power-x>)']}\n\n```", "```py\nfunction_symbol \n```", "```py\n'<power>'\n\n```", "```py\npower_carver.called_functions() \n```", "```py\n['power', '__exit__']\n\n```", "```py\nclass CallGrammarMiner(CallGrammarMiner):\n    def mine_call_grammar(self, function_list=None, qualified=False):\n        grammar = self.initial_grammar()\n        fn_list = function_list\n        if function_list is None:\n            fn_list = self.carver.called_functions(qualified=qualified)\n\n        for function_name in fn_list:\n            if function_list is None and (function_name.startswith(\"_\") or function_name.startswith(\"<\")):\n                continue  # Internal function\n\n            # Ignore errors with mined functions\n            try:\n                function_grammar, function_symbol = self.mine_function_grammar(\n                    function_name, grammar)\n            except:\n                if function_list is not None:\n                    raise\n\n            if function_symbol not in grammar[self.CALL_SYMBOL]:\n                grammar[self.CALL_SYMBOL].append(function_symbol)\n            grammar.update(function_grammar)\n\n        assert is_valid_grammar(grammar)\n        return grammar \n```", "```py\nm = CallGrammarMiner(power_carver)\npower_grammar = m.mine_call_grammar()\npower_grammar \n```", "```py\n{'<start>': ['<call>'],\n '<call>': ['<power>'],\n '<power-y>': ['2', '4'],\n '<power-x>': ['3', '1'],\n '<power>': ['power(<power-y>, <power-x>)']}\n\n```", "```py\npower_fuzzer = GrammarCoverageFuzzer(power_grammar)\n[power_fuzzer.fuzz() for i in range(5)] \n```", "```py\n['power(4, 3)', 'power(2, 1)', 'power(4, 3)', 'power(4, 3)', 'power(2, 3)']\n\n```", "```py\nwith CallCarver() as webbrowser_carver:\n    webbrowser(\"https://www.fuzzingbook.org\") \n```", "```py\nm = CallGrammarMiner(webbrowser_carver)\nwebbrowser_grammar = m.mine_call_grammar() \n```", "```py\ncall_list = webbrowser_grammar['<call>']\nlen(call_list) \n```", "```py\n136\n\n```", "```py\nprint(call_list[:20]) \n```", "```py\n['<webbrowser>', '<default_headers>', '<default_user_agent>', '<update>', '<default_hooks>', '<cookiejar_from_dict>', '<RLock>', '<deepvalues>', '<vals_sorted_by_key>', '<init_poolmanager>', '<mount>', '<prepare_request>', '<merge_cookies>', '<get_netrc_auth>', '<encode>', '<expanduser>', '<decode>', '<exists>', '<urlparse>', '<urlsplit>']\n\n```", "```py\nwebbrowser_grammar[\"<urlparse>\"] \n```", "```py\n['urlparse(<urlparse-allow_fragments>, <urlparse-scheme>, <urlparse-url>)']\n\n```", "```py\nwebbrowser_grammar[\"<urlparse-url>\"] \n```", "```py\n[\"'https://www.fuzzingbook.org'\", \"'https://www.fuzzingbook.org/'\"]\n\n```", "```py\nurlparse_fuzzer = GrammarCoverageFuzzer(\n    webbrowser_grammar, start_symbol=\"<urlparse>\")\nfor i in range(5):\n    print(urlparse_fuzzer.fuzz()) \n```", "```py\nurlparse(True, '', 'https://www.fuzzingbook.org')\nurlparse(True, '', 'https://www.fuzzingbook.org/')\nurlparse(True, '', 'https://www.fuzzingbook.org')\nurlparse(True, '', 'https://www.fuzzingbook.org')\nurlparse(True, '', 'https://www.fuzzingbook.org')\n\n```", "```py\nfrom [urllib.parse](https://docs.python.org/3/library/urllib.parse.html) import urlsplit \n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\nwith Timer() as urlsplit_timer:\n    urlsplit('http://www.fuzzingbook.org/', 'http', True)\nurlsplit_timer.elapsed_time() \n```", "```py\n1.2375006917864084e-05\n\n```", "```py\nwith Timer() as webbrowser_timer:\n    webbrowser(\"http://www.fuzzingbook.org\")\nwebbrowser_timer.elapsed_time() \n```", "```py\n0.31702329200925305\n\n```", "```py\nwebbrowser_timer.elapsed_time() / urlsplit_timer.elapsed_time() \n```", "```py\n25618.029477754102\n\n```", "```py\nclass ResultCarver(CallCarver):\n    def traceit(self, frame, event, arg):\n        if event == \"return\":\n            if self._log:\n                print(\"Result:\", arg)\n\n        super().traceit(frame, event, arg)\n        # Need to return traceit function such that it is invoked for return\n        # events\n        return self.traceit \n```", "```py\nwith ResultCarver(log=True) as result_carver:\n    my_sqrt(2) \n```", "```py\nmy_sqrt(x=2)\nResult: 1.414213562373095\n__exit__(tb=None, exc_value=None, exc_type=None, self=<__main__.ResultCarver object at 0x1653ccf10>)\n\n```", "```py\nclass ResultCarver(CallCarver):\n    def result(self, function_name, argument):\n  \"\"\"Returns the result recorded for function_name(argument\"\"\" \n```", "```py\n@incollection{fuzzingbook2023:Carver,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Carving Unit Tests},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/Carver.html}},\n    note = {Retrieved 2023-11-11 18:18:05+01:00},\n    url = {https://www.fuzzingbook.org/html/Carver.html},\n    urldate = {2023-11-11 18:18:05+01:00}\n}\n\n```"]