<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Grammar Coverage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Grammar Coverage</h1>
<blockquote>原文：<a href="http://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html">http://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html</a></blockquote>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p><a href="GrammarFuzzer.html">Producing inputs from grammars</a> gives all possible expansions of a rule the same likelihood.  For producing a comprehensive test suite, however, it makes more sense to maximize <em>variety</em> – for instance, by not repeating the same expansions over and over again.  In this chapter, we explore how to systematically <em>cover</em> elements of a grammar such that we maximize variety and do not miss out individual elements.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">'GGb3e5p0HC8'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

        

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p><strong>Prerequisites</strong></p>
<ul>
<li>You should have read the <a href="Grammars.html">chapter on grammars</a>.</li>
<li>You should have read the <a href="GrammarFuzzer.html">chapter on efficient grammar fuzzing</a>.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><div class="synopsis"><h2 id="Synopsis">Synopsis</h2><!-- Automatically generated. Do not edit. -->

<p>To <a href="Importing.html">use the code provided in this chapter</a>, write</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="GrammarCoverageFuzzer.html" class="import" target="_blank">fuzzingbook.GrammarCoverageFuzzer</a></span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
<p>and then make use of the following features.</p>
<p>This chapter introduces <code>GrammarCoverageFuzzer</code>, an efficient grammar fuzzer extending <code>GrammarFuzzer</code> from the <a href="GrammarFuzzer.html">chapter on efficient grammar fuzzing</a>.  It strives to <em>cover all expansions at least once,</em> thus ensuring coverage of functionality.</p>
<p>In the following example, for instance, we use <code>GrammarCoverageFuzzer</code> to produce an expression. We see that the resulting expression covers all digits and all operators in a single expression.</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
<span class="s1">'-(2 + 3) * 4.5 / 6 - 2.0 / +8 + 7 + 3'</span>
</pre></div>
<p>After fuzzing, the <code>expansion_coverage()</code> method returns a mapping of grammar expansions covered.</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
<span class="p">{</span><span class="s1">'&lt;digit&gt; -&gt; 0'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 1'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 2'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 3'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 4'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 5'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 6'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 7'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 8'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt; -&gt; 9'</span><span class="p">,</span>
 <span class="s1">'&lt;expr&gt; -&gt; &lt;term&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;expr&gt; -&gt; &lt;term&gt; + &lt;expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;expr&gt; -&gt; &lt;term&gt; - &lt;expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;factor&gt; -&gt; (&lt;expr&gt;)'</span><span class="p">,</span>
 <span class="s1">'&lt;factor&gt; -&gt; +&lt;factor&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;factor&gt; -&gt; -&lt;factor&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;factor&gt; -&gt; &lt;integer&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;factor&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;integer&gt; -&gt; &lt;digit&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;start&gt; -&gt; &lt;expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;term&gt; -&gt; &lt;factor&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;term&gt; -&gt; &lt;factor&gt; * &lt;term&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;term&gt; -&gt; &lt;factor&gt; / &lt;term&gt;'</span><span class="p">}</span>
</pre></div>
<p>Subsequent calls to <code>fuzz()</code> will go for further coverage (i.e., covering the other area code digits, for example); a call to <code>reset()</code> clears the recorded coverage, starting anew.</p>
<p>Since such coverage in inputs also yields higher code coverage, <code>GrammarCoverageFuzzer</code> is a recommended extension to <code>GrammarFuzzer</code>.</p>
<p>

<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="346pt" height="582pt" viewbox="0.00 0.00 345.75 582.00" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 578)">
<g id="a_graph0"><a xlink:title="GrammarCoverageFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-578 341.75,-578 341.75,4 -4,4"/>
</a>
</g>
<!-- GrammarCoverageFuzzer -->
<g id="node1" class="node">
<title>GrammarCoverageFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class GrammarCoverageFuzzer:&#10;Produce from grammars, aiming for coverage of all expansions.">
<polygon fill="none" stroke="black" points="27.38,-0.5 27.38,-85.5 200.88,-85.5 200.88,-0.5 27.38,-0.5"/>
<text text-anchor="start" x="35.38" y="-69.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="27.38,-59.5 200.88,-59.5"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="GrammarCoverageFuzzer">
<g id="a_node1_1"><a xlink:href="#" xlink:title="_new_child_coverage(self, children: List[DerivationTree], max_depth: Union[int, float]) -&gt; Set[str]">
<text text-anchor="start" x="45.12" y="-46" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">_new_child_coverage()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; int:&#10;Choose an expansion of `node` among `children_alternatives`.&#10;Return `n` such that expanding `children_alternatives[n]`&#10;yields the highest additional coverage.">
<text text-anchor="start" x="45.12" y="-34.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
<g id="a_node1_3"><a xlink:href="#" xlink:title="new_child_coverage(self, symbol: str, children: List[DerivationTree], max_depth: Union[int, float] = inf) -&gt; Set[str]:&#10;Return new coverage that would be obtained&#10;by expanding (`symbol`, `children`)">
<text text-anchor="start" x="45.12" y="-20.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">new_child_coverage()</text>
</a>
</g>
<g id="a_node1_4"><a xlink:href="#" xlink:title="new_coverages(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; Optional[List[Set[str]]]:&#10;Return coverage to be obtained for each child at minimum depth">
<text text-anchor="start" x="45.12" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">new_coverages()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- SimpleGrammarCoverageFuzzer -->
<g id="node2" class="node">
<title>SimpleGrammarCoverageFuzzer</title>
<g id="a_node2"><a xlink:href="#" xlink:title="class SimpleGrammarCoverageFuzzer:&#10;When choosing expansions, prefer expansions not covered.">
<polygon fill="none" stroke="black" points="6.75,-122.5 6.75,-194.75 221.5,-194.75 221.5,-122.5 6.75,-122.5"/>
<text text-anchor="start" x="14.75" y="-178.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="6.75,-168.75 221.5,-168.75"/>
<g id="a_node2_5"><a xlink:href="#" xlink:title="SimpleGrammarCoverageFuzzer">
<g id="a_node2_6"><a xlink:href="#" xlink:title="choose_covered_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; int:&#10;Return index of expansion in _covered_ `children_alternatives`&#10;to be selected.&#10;To be overloaded in subclasses.">
<text text-anchor="start" x="15.12" y="-156.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_covered_node_expansion()</text>
</a>
</g>
<g id="a_node2_7"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; int:&#10;Return index of expansion in `children_alternatives` to be selected.&#10;Picks uncovered expansions, if any.">
<text text-anchor="start" x="15.12" y="-143.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
<g id="a_node2_8"><a xlink:href="#" xlink:title="choose_uncovered_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; int:&#10;Return index of expansion in _uncovered_ `children_alternatives`&#10;to be selected.&#10;To be overloaded in subclasses.">
<text text-anchor="start" x="15.12" y="-130.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_uncovered_node_expansion()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;SimpleGrammarCoverageFuzzer -->
<g id="edge1" class="edge">
<title>GrammarCoverageFuzzer-&gt;SimpleGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-85.99C114.12,-94.06 114.12,-102.57 114.12,-110.79"/>
<polygon fill="none" stroke="black" points="110.63,-110.63 114.13,-120.63 117.63,-110.63 110.63,-110.63"/>
</g>
<!-- TrackingGrammarCoverageFuzzer -->
<g id="node3" class="node">
<title>TrackingGrammarCoverageFuzzer</title>
<g id="a_node3"><a xlink:href="#" xlink:title="class TrackingGrammarCoverageFuzzer:&#10;Track grammar coverage during production">
<polygon fill="none" stroke="black" points="0,-231.75 0,-367.75 228.25,-367.75 228.25,-231.75 0,-231.75"/>
<text text-anchor="start" x="8" y="-351.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="0,-341.75 228.25,-341.75"/>
<g id="a_node3_9"><a xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer">
<g id="a_node3_10"><a xlink:href="#" xlink:title="__init__(self, *args, **kwargs) -&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="30.12" y="-329.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node3_11"><a xlink:href="#" xlink:title="expansion_coverage(self) -&gt; Set[str]:&#10;Return the set of covered expansions as strings SYMBOL -&gt; EXPANSION">
<text text-anchor="start" x="30.12" y="-316.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">expansion_coverage()</text>
</a>
</g>
<g id="a_node3_12"><a xlink:href="#" xlink:title="max_expansion_coverage(self, symbol: Optional[str] = None, max_depth: Union[int, float] = inf) -&gt; Set[str]:&#10;Return set of all expansions in a grammar&#10;starting with `symbol` (default: start symbol).&#10;If `max_depth` is given, expand only to that depth.">
<text text-anchor="start" x="30.12" y="-303.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">max_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_13"><a xlink:href="#" xlink:title="missing_expansion_coverage(self) -&gt; Set[str]:&#10;Return expansions not covered yet">
<text text-anchor="start" x="30.12" y="-291" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">missing_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_14"><a xlink:href="#" xlink:title="reset_coverage(self) -&gt; None:&#10;Clear coverage info tracked so far">
<text text-anchor="start" x="30.12" y="-278.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">reset_coverage()</text>
</a>
</g>
<g id="a_node3_15"><a xlink:href="#" xlink:title="_max_expansion_coverage(self, symbol: str, max_depth: Union[int, float]) -&gt; Set[str]">
<text text-anchor="start" x="30.12" y="-264.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">_max_expansion_coverage()</text>
</a>
</g>
<g id="a_node3_16"><a xlink:href="#" xlink:title="add_coverage(self, symbol: str, new_child: Union[str, Tuple[str, Dict[str, Any]], List[DerivationTree]]) -&gt; None">
<text text-anchor="start" x="30.12" y="-251.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_coverage()</text>
</a>
</g>
<g id="a_node3_17"><a xlink:href="#" xlink:title="choose_node_expansion(self, node: DerivationTree, children_alternatives: List[List[DerivationTree]]) -&gt; int:&#10;Return index of expansion in `children_alternatives` to be selected.&#10;'children_alternatives`: a list of possible children for `node`.&#10;Defaults to random. To be overloaded in subclasses.">
<text text-anchor="start" x="30.12" y="-240" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_node_expansion()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- SimpleGrammarCoverageFuzzer&#45;&gt;TrackingGrammarCoverageFuzzer -->
<g id="edge2" class="edge">
<title>SimpleGrammarCoverageFuzzer-&gt;TrackingGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-195.09C114.12,-202.82 114.12,-211.29 114.12,-219.95"/>
<polygon fill="none" stroke="black" points="110.63,-219.89 114.13,-229.89 117.63,-219.89 110.63,-219.89"/>
</g>
<!-- GrammarFuzzer -->
<g id="node4" class="node">
<title>GrammarFuzzer</title>
<g id="a_node4"><a xlink:href="GrammarFuzzer.html" xlink:title="class GrammarFuzzer:&#10;Produce strings from grammars efficiently, using derivation trees.">
<polygon fill="none" stroke="black" points="56.25,-404.75 56.25,-477 172,-477 172,-404.75 56.25,-404.75"/>
<text text-anchor="start" x="64.25" y="-460.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
<polyline fill="none" stroke="black" points="56.25,-451 172,-451"/>
<g id="a_node4_18"><a xlink:href="#" xlink:title="GrammarFuzzer">
<g id="a_node4_19"><a xlink:href="GrammarFuzzer.html" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol: str = '&lt;start&gt;', min_nonterminals: int = 0, max_nonterminals: int = 10, disp: bool = False, log: Union[bool, int] = False) -&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="81.12" y="-438.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node4_20"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self) -&gt; str:&#10;Produce a string from the grammar.">
<text text-anchor="start" x="81.12" y="-425.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz()</text>
</a>
</g>
<g id="a_node4_21"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="81.12" y="-413" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">fuzz_tree()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- TrackingGrammarCoverageFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge3" class="edge">
<title>TrackingGrammarCoverageFuzzer-&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M114.12,-367.87C114.12,-376.36 114.12,-384.91 114.12,-393"/>
<polygon fill="none" stroke="black" points="110.63,-392.94 114.13,-402.94 117.63,-392.94 110.63,-392.94"/>
</g>
<!-- Fuzzer -->
<g id="node5" class="node">
<title>Fuzzer</title>
<g id="a_node5"><a xlink:href="Fuzzer.html" xlink:title="class Fuzzer:&#10;Base class for fuzzers.">
<polygon fill="none" stroke="black" points="85.5,-514 85.5,-573.5 142.75,-573.5 142.75,-514 85.5,-514"/>
<text text-anchor="start" x="93.5" y="-557.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
<polyline fill="none" stroke="black" points="85.5,-547.5 142.75,-547.5"/>
<g id="a_node5_22"><a xlink:href="#" xlink:title="Fuzzer">
<g id="a_node5_23"><a xlink:href="Fuzzer.html" xlink:title="run(self, runner: Fuzzer.Runner = &lt;Fuzzer.Runner object&gt;) -&gt; Tuple[subprocess.CompletedProcess, str]:&#10;Run `runner` with fuzz input">
<text text-anchor="start" x="96.12" y="-535" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">run()</text>
</a>
</g>
<g id="a_node5_24"><a xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = &lt;Fuzzer.PrintRunner object&gt;, trials: int = 10) -&gt; List[Tuple[subprocess.CompletedProcess, str]]:&#10;Run `runner` with fuzz input, `trials` times">
<text text-anchor="start" x="96.12" y="-522.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">runs()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Fuzzer -->
<g id="edge4" class="edge">
<title>GrammarFuzzer-&gt;Fuzzer</title>
<path fill="none" stroke="black" d="M114.12,-477.44C114.12,-485.54 114.12,-494.19 114.12,-502.47"/>
<polygon fill="none" stroke="black" points="110.63,-502.31 114.13,-512.31 117.63,-502.31 110.63,-502.31"/>
</g>
<!-- Legend -->
<g id="node6" class="node">
<title>Legend</title>
<text text-anchor="start" x="218.5" y="-59" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="218.5" y="-49" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-49" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="218.5" y="-39" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-39" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="218.5" y="-29" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="224.5" y="-29" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="218.5" y="-19.95" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</p>
</div>
</div>
</div>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Covering-Grammar-Elements">Covering Grammar Elements</h2><p>The aim of test generation is to cover all functionality of a program – hopefully including the failing functionality, of course.  This functionality, however, is tied to the <em>structure of the input</em>: If we fail to produce certain input elements, then the associated code and functionality will not be triggered either, nixing our chances to find a bug in there.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As an example, consider our expression grammar <code>EXPR_GRAMMAR</code> from the <a href="Grammars.html">chapter on grammars.</a>:</p>
<ul>
<li>If we do not produce negative numbers, then negative numbers will not be tested.</li>
<li>If we do not produce floating-point numbers, then floating-point numbers will not be tested.</li>
</ul>
<p>Our aim must thus be to <em>cover all possible expansions</em> – and not only by chance, but <em>by design</em>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>One way to maximize such variety is to <em>track</em> the expansions that occur during grammar production: If we already have seen some expansion, we can prefer other possible expansion candidates out of the set of possible expansions.  Consider the following rule in our expression grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils.setup</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">quiz</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Fuzzer.html" class="import" target="_blank">Fuzzer</a></span> <span class="kn">import</span> <span class="n">Fuzzer</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/typing.html" class="import" target="_blank">typing</a></span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Optional</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">START_SYMBOL</span>
<span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">Grammar</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">"&lt;factor&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['+&lt;factor&gt;', '-&lt;factor&gt;', '(&lt;expr&gt;)', '&lt;integer&gt;.&lt;integer&gt;', '&lt;integer&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us assume we have already produced an <code>&lt;integer&gt;</code> in the first expansion of <code>&lt;factor&gt;</code>.  As it comes to expand the next factor, we would mark the <code>&lt;integer&gt;</code> expansion as already covered, and choose one of the yet uncovered alternatives such as <code>-&lt;factor&gt;</code> (a negative number) or <code>&lt;integer&gt;.&lt;integer&gt;</code> (a floating-point number).  Only when we have covered all alternatives would we go back and reconsider expansions covered before.</p>
</div>
</div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

    

    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    </p><div class="quiz_question">Which expansions of <code>EXPR_GRAMMAR</code> does the expression <code>1 + 2</code> cover?</div>
    
    <p>
    </p><div class="quiz_options" title="Check all that apply.">

        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-1"><code>&lt;start&gt; -&gt; &lt;expr&gt;</code></label><br/>

        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-2"><code>&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;</code></label><br/>

        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-3"><code>&lt;integer&gt; -&gt; &lt;digit&gt;</code></label><br/>

        <input type="checkbox" name="f7be2e54-d3ed-11ef-b013-6298cf1a5790" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4" onclick="clear_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4-label" for="f7be2e54-d3ed-11ef-b013-6298cf1a5790-4"><code>&lt;factor&gt; -&gt; +&lt;factor&gt;</code></label><br/>

    </div>
    
    <input id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('f7be2e54-d3ed-11ef-b013-6298cf1a5790', 10, 1, '')"/>
    <span class="quiz_hint" id="f7be2e54-d3ed-11ef-b013-6298cf1a5790-hint"/>
    </div>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Indeed! The expression has expansions from <code>&lt;start&gt;</code> and into individual digits.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Tracking-Grammar-Coverage">Tracking Grammar Coverage</h3><p>This concept of <em>grammar coverage</em> is easy to implement.  We introduce a class <code>TrackingGrammarCoverageFuzzer</code> that keeps track of the current grammar coverage achieved:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">Expansion</span>
<span class="kn">from</span> <span class="nn"><a href="GrammarFuzzer.html" class="import" target="_blank">GrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">GrammarFuzzer</span><span class="p">,</span> <span class="n">all_terminals</span><span class="p">,</span> <span class="n">nonterminals</span><span class="p">,</span> \
    <span class="n">display_tree</span><span class="p">,</span> <span class="n">DerivationTree</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/random.html" class="import" target="_blank">random</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Track grammar coverage during production"""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># invoke superclass __init__(), passing all arguments</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Keeping-Track-of-Expansions">Keeping Track of Expansions</h4><p>In the set <code>covered_expansions</code>, we store individual expansions seen.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Return the set of covered expansions as strings SYMBOL -&gt; EXPANSION"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span>

    <span class="k">def</span> <span class="nf">reset_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Clear coverage info tracked so far"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We save them the expansions as strings "<em>symbol</em> -&gt; <em>expansion</em>", using the function <code>expansion_key()</code> to generate a string representation for the (<em>symbol</em>, <em>expansion</em>) pair.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                  <span class="n">expansion</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span>
                                   <span class="n">DerivationTree</span><span class="p">,</span> 
                                   <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Convert (symbol, `expansion`) into a key "SYMBOL -&gt; EXPRESSION". </span>
<span class="sd">      `expansion` can be an expansion string, a derivation tree,</span>
<span class="sd">         or a list of derivation trees."""</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="c1"># Expansion or single derivation tree</span>
        <span class="n">expansion</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">expansion</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Derivation tree</span>
        <span class="n">children</span> <span class="o">=</span> <span class="n">expansion</span>
        <span class="n">expansion</span> <span class="o">=</span> <span class="n">all_terminals</span><span class="p">((</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>

    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">symbol</span> <span class="o">+</span> <span class="s2">" -&gt; "</span> <span class="o">+</span> <span class="n">expansion</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here's an example:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expansion_key</span><span class="p">(</span><span class="n">START_SYMBOL</span><span class="p">,</span> <span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="n">START_SYMBOL</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'&lt;start&gt; -&gt; &lt;expr&gt;'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Instead of <em>expansion</em>, we can also pass a list of children as argument, which will then automatically be converted into a string.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">"&lt;expr&gt;"</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="p">(</span><span class="s2">" + "</span><span class="p">,</span> <span class="p">[]),</span> <span class="p">(</span><span class="s2">"&lt;term&gt;"</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
<span class="n">expansion_key</span><span class="p">(</span><span class="s2">"&lt;expr&gt;"</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'&lt;expr&gt; -&gt; &lt;expr&gt; + &lt;term&gt;'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Computing-Possible-Expansions">Computing Possible Expansions</h4><p>We can compute the set of possible expansions in a grammar by enumerating all expansions.  The method <code>max_expansion_coverage()</code> traverses the grammar recursively starting from the given symbol (by default: the grammar start symbol) and accumulates all expansions in the set <code>expansions</code>.  With the <code>max_depth</code> parameter (default: $\infty$), we can control how deep the grammar exploration should go; we will need this later in the chapter.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">_max_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> 
                                <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">max_depth</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

        <span class="n">expansions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]:</span>
            <span class="n">expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">expansion</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">nonterminals</span><span class="p">(</span><span class="n">expansion</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nonterminal</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">:</span>
                    <span class="n">expansions</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_expansion_coverage</span><span class="p">(</span>
                        <span class="n">nonterminal</span><span class="p">,</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">expansions</span>

    <span class="k">def</span> <span class="nf">max_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">))</span> \
            <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Return set of all expansions in a grammar </span>
<span class="sd">           starting with `symbol` (default: start symbol).</span>
<span class="sd">           If `max_depth` is given, expand only to that depth."""</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_symbol</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_expansion_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">symbol</span> <span class="o">==</span> <span class="n">START_SYMBOL</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_symbols_seen</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cov</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can use <code>max_expansion_coverage()</code> to compute all the expansions within the expression grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">expr_fuzzer</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0',
 '&lt;digit&gt; -&gt; 1',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 3',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 5',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8',
 '&lt;digit&gt; -&gt; 9',
 '&lt;expr&gt; -&gt; &lt;term&gt;',
 '&lt;expr&gt; -&gt; &lt;term&gt; + &lt;expr&gt;',
 '&lt;expr&gt; -&gt; &lt;term&gt; - &lt;expr&gt;',
 '&lt;factor&gt; -&gt; (&lt;expr&gt;)',
 '&lt;factor&gt; -&gt; +&lt;factor&gt;',
 '&lt;factor&gt; -&gt; -&lt;factor&gt;',
 '&lt;factor&gt; -&gt; &lt;integer&gt;',
 '&lt;factor&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;',
 '&lt;integer&gt; -&gt; &lt;digit&gt;',
 '&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;',
 '&lt;start&gt; -&gt; &lt;expr&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt; * &lt;term&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt; / &lt;term&gt;'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Tracking-Expansions-while-Fuzzing">Tracking Expansions while Fuzzing</h4><p>During expansion, we can keep track of expansions seen.  To do so, we hook into the method <code>choose_node_expansion()</code>, expanding a single node in our <a href="GrammarFuzzer.html">Grammar fuzzer</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">add_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                     <span class="n">new_child</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Expansion</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">new_child</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Now covered:"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> 
                              <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">index</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">index</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The method <code>missing_expansion_coverage()</code> is a helper method that returns the expansions that still have to be covered:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">missing_expansion_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Return expansions not covered yet"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Putting-Things-Together">Putting Things Together</h4><p>Let us show how tracking works.  To keep things simple, let us focus on <code>&lt;digit&gt;</code> expansions only.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span>
    <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 9
Tree: 9
'9'
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'9'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 0
Tree: 0
'0'
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'0'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 5
Tree: 5
'5'
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'5'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here's the set of covered expansions so far:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0', '&lt;digit&gt; -&gt; 5', '&lt;digit&gt; -&gt; 9'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is the set of all expansions we can cover:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0',
 '&lt;digit&gt; -&gt; 1',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 3',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 5',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8',
 '&lt;digit&gt; -&gt; 9'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is the missing coverage:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 1',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 3',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>On average, how many characters do we have to produce until all expansions are covered?</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">average_length_until_full_coverage</span><span class="p">(</span><span class="n">fuzzer</span><span class="p">:</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">trials</span> <span class="o">=</span> <span class="mi">50</span>

    <span class="nb">sum</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
        <span class="c1"># print(trial, end=" ")</span>
        <span class="n">fuzzer</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
            <span class="nb">sum</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">sum</span> <span class="o">/</span> <span class="n">trials</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">digit_fuzzer</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">digit_fuzzer</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>28.4
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>For full expressions, this takes a bit longer:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_fuzzer</span> <span class="o">=</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">expr_fuzzer</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>138.12
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Covering-Grammar-Expansions">Covering Grammar Expansions</h3><p>Let us now not only track coverage, but actually <em>produce</em> coverage.  The idea is as follows:</p>
<ol>
<li>We determine children yet uncovered (in <code>uncovered_children</code>)</li>
<li>If all children are covered, we fall back to the original method (i.e., choosing one expansion randomly)</li>
<li>Otherwise, we select a child from the uncovered children and mark it as covered.</li>
</ol>
<p>To this end, we introduce a new fuzzer <code>SimpleGrammarCoverageFuzzer</code> that implements this strategy in the <code>choose_node_expansion()</code> method – the method <a href="GrammarFuzzer.html">the <code>GrammarFuzzer</code> superclass uses to select the child to be expanded</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""When choosing expansions, prefer expansions not covered."""</span>

    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return index of expansion in `children_alternatives` to be selected.</span>
<span class="sd">           Picks uncovered expansions, if any."""</span>

        <span class="c1"># Prefer uncovered expansions</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">uncovered_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                              <span class="k">if</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
                              <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">]</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">uncovered_children</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uncovered_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># All expansions covered - use superclass method</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_covered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="c1"># Select from uncovered nodes</span>
        <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_uncovered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">uncovered_children</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index_map</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The two methods <code>choose_covered_node_expansion()</code> and <code>choose_uncovered_node_expansion()</code> are provided for subclasses to hook in:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_uncovered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                        <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                                        <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return index of expansion in _uncovered_ `children_alternatives`</span>
<span class="sd">           to be selected.</span>
<span class="sd">           To be overloaded in subclasses."""</span>
        <span class="k">return</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">choose_covered_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                      <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                                      <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return index of expansion in _covered_ `children_alternatives`</span>
<span class="sd">           to be selected.</span>
<span class="sd">           To be overloaded in subclasses."""</span>
        <span class="k">return</span> <span class="n">TrackingGrammarCoverageFuzzer</span><span class="o">.</span><span class="n">choose_node_expansion</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>By returning the set of expansions covered so far, we can invoke the fuzzer multiple times, each time adding to the grammar coverage.  Using the <code>EXPR_GRAMMAR</code> grammar to produce digits, for instance, the fuzzer produces one digit after the other:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;digit&gt;"</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'5'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'2'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'1'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here's the set of covered expansions so far:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 1', '&lt;digit&gt; -&gt; 2', '&lt;digit&gt; -&gt; 5'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us fuzz some more. We see that with each iteration, we cover another expansion:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">7</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">(),</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0 9 7 4 8 3 6 
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>At the end, all expansions are covered:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>set()
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us apply this on a more complex grammar – e.g., the full expression grammar.  We see that after a few iterations, we cover each and every digit, operator, and expansion:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>+(0.31 / (5) / 9 + 4 * 6 / 3 - 8 - 7) * -2
+++2 / 87360
((4) * 0 - 1) / -9.6 + 7 / 6 + 1 * 8 + 7 * 8
++++26 / -64.45
(8 / 1 / 6 + 9 + 7 + 8) * 1.1 / 0 * 1
7.7
++(3.5 / 3) - (-4 + 3) / (8 / 0) / -4 * 2 / 1
+(90 / --(28 * 8 / 5 + 5 / (5 / 8))) - +9.36 / 2.5 * (5 * (7 * 6 * 5) / 8)
9.11 / 7.28
1 / (9 - 5 * 6) / 6 / 7 / 7 + 1 + 1 - 7 * -3
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Again, all expansions are covered:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>set()
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that our strategy is much more effective in achieving coverage than the random approach:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>52.28
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Deep-Foresight">Deep Foresight</h2><p>Selecting expansions for individual rules is a good start; however, it is not sufficient, as the following example shows.  We apply our coverage fuzzer on the CGI grammar from the <a href="Grammars.html">chapter on grammars</a>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CGI_GRAMMAR</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;start&gt;': ['&lt;string&gt;'],
 '&lt;string&gt;': ['&lt;letter&gt;', '&lt;letter&gt;&lt;string&gt;'],
 '&lt;letter&gt;': ['&lt;plus&gt;', '&lt;percent&gt;', '&lt;other&gt;'],
 '&lt;plus&gt;': ['+'],
 '&lt;percent&gt;': ['%&lt;hexdigit&gt;&lt;hexdigit&gt;'],
 '&lt;hexdigit&gt;': ['0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'a',
  'b',
  'c',
  'd',
  'e',
  'f'],
 '&lt;other&gt;': ['0', '1', '2', '3', '4', '5', 'a', 'b', 'c', 'd', 'e', '-', '_']}
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>c
+%a6++
+-
+
++
%18%b7
+e
_
d2+%e3
%d0
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>After 10 iterations, we still have a number of expansions uncovered:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">missing_expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;hexdigit&gt; -&gt; 2',
 '&lt;hexdigit&gt; -&gt; 4',
 '&lt;hexdigit&gt; -&gt; 5',
 '&lt;hexdigit&gt; -&gt; 9',
 '&lt;hexdigit&gt; -&gt; c',
 '&lt;hexdigit&gt; -&gt; f',
 '&lt;other&gt; -&gt; 0',
 '&lt;other&gt; -&gt; 1',
 '&lt;other&gt; -&gt; 3',
 '&lt;other&gt; -&gt; 4',
 '&lt;other&gt; -&gt; 5',
 '&lt;other&gt; -&gt; a',
 '&lt;other&gt; -&gt; b'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Why is that so?  The problem is that in the CGI grammar, the largest number of variations to be covered occurs in the <code>hexdigit</code> rule.  However, we first need to <em>reach</em> this expansion.  When expanding a <code>&lt;letter&gt;</code> symbol, we have the choice between three possible expansions:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CGI_GRAMMAR</span><span class="p">[</span><span class="s2">"&lt;letter&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;plus&gt;', '&lt;percent&gt;', '&lt;other&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If all three expansions are covered already, then <code>choose_node_expansion()</code> above will choose one randomly – even if there may be more expansions to cover when choosing <code>&lt;percent&gt;</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>What we need is a better strategy that will pick <code>&lt;percent&gt;</code> if there are more uncovered expansions following – even if <code>&lt;percent&gt;</code> is covered.  Such a strategy was first discussed by W. Burkhardt [<a href="https://doi.org/10.1007/BF02235512">Burkhardt <em>et al</em>, 1967</a>] under the name of "Shortest Path Selection":</p>
<blockquote><p>This version selects, from several alternatives for development, that syntactic unit under which there is still an unused unit available, starting with the shortest path.</p>
</blockquote>
<p>This is what we will implement in the next steps.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Determining-Maximum-per-Symbol-Coverage">Determining Maximum per-Symbol Coverage</h3><p>To address this problem, we introduce a new class <code>GrammarCoverageFuzzer</code> that builds on <code>SimpleGrammarCoverageFuzzer</code>, but with a <em>better strategy</em>.  First, we need to compute the <em>maximum set of expansions</em> that can be reached from a particular symbol, as we already have implemented in <code>max_expansion_coverage()</code>.  The idea is to later compute the <em>intersection</em> of this set and the expansions already covered, such that we can favor those expansions with a non-empty intersection.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The first step – computing the maximum set of expansions that can be reached from a symbol – is already implemented.  By passing a <code>symbol</code> parameter to <code>max_expansion_coverage()</code>, we can compute the possible expansions for every symbol:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="s1">'&lt;integer&gt;'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0',
 '&lt;digit&gt; -&gt; 1',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 3',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 5',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8',
 '&lt;digit&gt; -&gt; 9',
 '&lt;integer&gt; -&gt; &lt;digit&gt;',
 '&lt;integer&gt; -&gt; &lt;digit&gt;&lt;integer&gt;'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that by expanding <code>&lt;integer&gt;</code>, we can cover a total of 12 productions.</p>
</div>
</div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

    

    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    </p><div class="quiz_question">How many productions would <code>f.max_expansion_coverage('&lt;digit&gt;')</code> return?</div>
    
    <p>
    </p><div class="quiz_options" title="Pick a choice.">

        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-1" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-1-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-1">10</label><br/>

        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-2" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-2-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-2">11</label><br/>

        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-3" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-3-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-3">12</label><br/>

        <input type="radio" name="f8753e00-d3ed-11ef-b013-6298cf1a5790" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-4" onclick="clear_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790')"/>
        <label id="f8753e00-d3ed-11ef-b013-6298cf1a5790-4-label" for="f8753e00-d3ed-11ef-b013-6298cf1a5790-4">13</label><br/>

    </div>
    
    <input id="f8753e00-d3ed-11ef-b013-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('f8753e00-d3ed-11ef-b013-6298cf1a5790', 2, 0, '100 / 100')"/>
    <span class="quiz_hint" id="f8753e00-d3ed-11ef-b013-6298cf1a5790-hint"/>
    </div>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Indeed. Here are all the possible expansions for <code>&lt;digit&gt;</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="s1">'&lt;digit&gt;'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0',
 '&lt;digit&gt; -&gt; 1',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 3',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 5',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8',
 '&lt;digit&gt; -&gt; 9'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Determining-yet-Uncovered-Children">Determining yet Uncovered Children</h3><p>We can now start to implement <code>GrammarCoverageFuzzer</code>.  Our idea is to determine the <em>missing coverage</em> for each child.</p>
<p>Given a list of children, we can use <code>max_expansion_coverage()</code> to compute the maximum coverage for each child. From this, we <em>subtract</em> the coverage already seen (<code>expansion_coverage()</code>). This results in the coverage we can still obtain.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Produce from grammars, aiming for coverage of all expansions."""</span>

    <span class="k">def</span> <span class="nf">new_child_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                           <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                           <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span>
                           <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">"""Return new coverage that would be obtained </span>
<span class="sd">           by expanding (`symbol`, `children`)"""</span>

        <span class="n">new_cov</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new_child_coverage</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>
        <span class="n">new_cov</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
        <span class="n">new_cov</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>   <span class="c1"># -= is set subtraction</span>
        <span class="k">return</span> <span class="n">new_cov</span>

    <span class="k">def</span> <span class="nf">_new_child_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span>
                            <span class="n">max_depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="n">new_cov</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c_symbol</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c_symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">:</span>
                <span class="n">new_cov</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">(</span><span class="n">c_symbol</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_cov</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us illustrate <code>new_child_coverage()</code>.  We again start fuzzing, choosing expansions randomly.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Tree: &lt;digit&gt;
Expanding &lt;digit&gt; randomly
Now covered: &lt;digit&gt; -&gt; 2
Tree: 2
'2'
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'2'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is our current coverage:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 2'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we want to expand <code>&lt;digit&gt;</code> into <code>0</code>, that would yield us new coverage:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="p">[(</span><span class="s1">'0'</span><span class="p">,</span> <span class="p">[])])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;digit&gt; -&gt; 0'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we want to expand <code>&lt;digit&gt;</code> into <code>2</code> again, that would yield us <em>no</em> new coverage:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="p">[(</span><span class="s1">'2'</span><span class="p">,</span> <span class="p">[])])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>set()
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>When we go through the individual expansion possibilities for <code>&lt;digit&gt;</code>, we see that all expansions offer additional coverage, <em>except</em> for the <code>2</code> we have already covered.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">"&lt;digit&gt;"</span><span class="p">]:</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_to_children</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0 {'&lt;digit&gt; -&gt; 0'}
1 {'&lt;digit&gt; -&gt; 1'}
2 set()
3 {'&lt;digit&gt; -&gt; 3'}
4 {'&lt;digit&gt; -&gt; 4'}
5 {'&lt;digit&gt; -&gt; 5'}
6 {'&lt;digit&gt; -&gt; 6'}
7 {'&lt;digit&gt; -&gt; 7'}
8 {'&lt;digit&gt; -&gt; 8'}
9 {'&lt;digit&gt; -&gt; 9'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This means that whenever choosing an expansion, we can make use of <code>new_child_coverage()</code> and choose among the expansions that offer the greatest new (unseen) coverage.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Adaptive-Lookahead">Adaptive Lookahead</h3></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>When choosing a child, we do not look out for the maximum overall coverage to be obtained, as this would have expansions with many uncovered possibilities totally dominate other expansions.  Instead, we aim for a <em>breadth-first</em> strategy, first covering all expansions up to a given depth, and only then looking for a greater depth.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The method <code>new_coverages()</code> is at the heart of this strategy: Starting with a maximum depth (<code>max_depth</code>) of zero, it increases the depth until it finds at least one uncovered expansion.</p>
</div>
</div>
</div>
</div>

<details id="Excursion:-Implementing-new_coverage()">
<summary>Implementing <code>new_coverage()</code></summary>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">new_coverages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                      <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> \
            <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">"""Return coverage to be obtained for each child at minimum depth"""</span>

        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="k">for</span> <span class="n">max_depth</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)):</span>
            <span class="n">new_coverages</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">new_child_coverage</span><span class="p">(</span>
                    <span class="n">symbol</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children_alternatives</span><span class="p">]</span>
            <span class="n">max_new_coverage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_coverage</span><span class="p">)</span>
                                   <span class="k">for</span> <span class="n">new_coverage</span> <span class="ow">in</span> <span class="n">new_coverages</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">max_new_coverage</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Uncovered node found</span>
                <span class="k">return</span> <span class="n">new_coverages</span>

        <span class="c1"># All covered</span>
        <span class="k">return</span> <span class="kc">None</span>
</pre></div>

</div>
</div></div>
</div>
</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="All-Together">All Together</h3><p>We can now define <code>choose_node_expansion()</code> to make use of this strategy:</p>
<ol>
<li>We determine the possible coverages to be obtained (using <code>new_coverages()</code>)</li>
<li>We (randomly) select among the children which sport the maximum coverage (using <code>choose_uncovered_node_expansion()</code>).</li>
</ol>
</div>
</div>
</div>
</div>

<details id="Excursion:-Implementing-choose_node_expansion()">
<summary>Implementing <code>choose_node_expansion()</code></summary>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_node_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">children_alternatives</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Choose an expansion of `node` among `children_alternatives`.</span>
<span class="sd">           Return `n` such that expanding `children_alternatives[n]`</span>
<span class="sd">           yields the highest additional coverage."""</span>

        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">new_coverages</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_coverages</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_coverages</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># All expansions covered - use superclass method</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_covered_node_expansion</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">children_alternatives</span><span class="p">)</span>

        <span class="n">max_new_coverage</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span> <span class="k">for</span> <span class="n">cov</span> <span class="ow">in</span> <span class="n">new_coverages</span><span class="p">)</span>

        <span class="n">children_with_max_new_coverage</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                                          <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coverages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">max_new_coverage</span><span class="p">]</span>
        <span class="n">index_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children_alternatives</span><span class="p">)</span>
                     <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_coverages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="n">max_new_coverage</span><span class="p">]</span>

        <span class="c1"># Select a random expansion</span>
        <span class="n">new_children_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_uncovered_node_expansion</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">children_with_max_new_coverage</span><span class="p">)</span>
        <span class="n">new_children</span> <span class="o">=</span> <span class="n">children_with_max_new_coverage</span><span class="p">[</span><span class="n">new_children_index</span><span class="p">]</span>

        <span class="c1"># Save the expansion as covered</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">expansion_key</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">new_children</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Now covered:"</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">index_map</span><span class="p">[</span><span class="n">new_children_index</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With this, our <code>GrammarCoverageFuzzer</code> is now complete!  Let us apply it on a series of examples.  On expressions, it quickly covers all digits and operators:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'-4.02 / (1) * +3 + 5.9 / 7 * 8 - 6'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>set()
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>On average, it is again faster than the simple strategy:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>50.74
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>On the CGI grammar, it takes but a few iterations to cover all letters and digits:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">min_nonterminals</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">()</span> <span class="o">-</span> <span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>%18%d03
%c3%94%7f+cd
%a6%b5%e2%5e%4c-54e01a2
%5eb%7cb_ec%a0+
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This improvement can also be seen in comparing the random, expansion-only, and deep foresight strategies on the CGI grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">TrackingGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>211.34
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">SimpleGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>68.64
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">average_length_until_full_coverage</span><span class="p">(</span><span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>40.38
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Coverage-in-Context">Coverage in Context</h2><p>Sometimes, grammar elements are used in more than just one place.  In our expression grammar, for instance, the <code>&lt;integer&gt;</code> symbol is used for integer numbers as well as for floating point numbers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">EXPR_GRAMMAR</span><span class="p">[</span><span class="s2">"&lt;factor&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['+&lt;factor&gt;', '-&lt;factor&gt;', '(&lt;expr&gt;)', '&lt;integer&gt;.&lt;integer&gt;', '&lt;integer&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our coverage production, as defined above, will ensure that all <code>&lt;integer&gt;</code> expansions (i.e., all <code>&lt;digit&gt;</code> expansions) are covered.  However, the individual digits would be <em>distributed</em> across all occurrences of <code>&lt;integer&gt;</code> in the grammar.  If our coverage-based fuzzer produces, say, <code>1234.56</code>  and <code>7890</code>, we would have full coverage of all digit expansions.  However, <code>&lt;integer&gt;.&lt;integer&gt;</code> and <code>&lt;integer&gt;</code> in the <code>&lt;factor&gt;</code> expansions above would individually cover only a fraction of the digits.  If floating-point numbers and whole numbers have different functions that read them in, we would like each of these functions to be tested with all digits; maybe we would also like the whole and fractional part of a floating-point number to be tested with all digits each.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Ignoring the context in which a symbol is used (in our case, the various uses of <code>&lt;integer&gt;</code> and <code>&lt;digit&gt;</code> in the <code>&lt;factor&gt;</code> context) can be useful if we can assume that all occurrences of this symbol are treated alike anyway.  If not, though, one way to ensure that an occurrence of a symbol is systematically covered independently of other occurrences is to assign the occurrence to a new symbol which is a <em>duplicate</em> of the old symbol.  We will first show how to <em>manually</em> create such duplicates, and then a dedicated function which does it automatically.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Extending-Grammars-for-Context-Coverage-Manually">Extending Grammars for Context Coverage Manually</h3><p>As stated above, one simple way to achieve coverage in context is by <em>duplicating</em> symbols as well as the rules they reference to.  For instance, we could replace <code>&lt;integer&gt;.&lt;integer&gt;</code> by <code>&lt;integer-1&gt;.&lt;integer-2&gt;</code> and give <code>&lt;integer-1&gt;</code> and <code>&lt;integer-2&gt;</code> the same definitions as the original <code>&lt;integer&gt;</code>.  This would mean that not only all expansions of <code>&lt;integer&gt;</code>, but also all expansions of <code>&lt;integer-1&gt;</code> and <code>&lt;integer-2&gt;</code> would be covered.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us illustrate this with actual code:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                  <span class="p">{</span>
                                      <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span> <span class="s2">"&lt;integer-1&gt;.&lt;integer-2&gt;"</span><span class="p">,</span> <span class="s2">"&lt;integer&gt;"</span><span class="p">],</span>
                                      <span class="s2">"&lt;integer-1&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digit-1&gt;&lt;integer-1&gt;"</span><span class="p">,</span> <span class="s2">"&lt;digit-1&gt;"</span><span class="p">],</span>
                                      <span class="s2">"&lt;integer-2&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digit-2&gt;&lt;integer-2&gt;"</span><span class="p">,</span> <span class="s2">"&lt;digit-2&gt;"</span><span class="p">],</span>
                                      <span class="s2">"&lt;digit-1&gt;"</span><span class="p">:</span>
                                      <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"3"</span><span class="p">,</span> <span class="s2">"4"</span><span class="p">,</span>
                                          <span class="s2">"5"</span><span class="p">,</span> <span class="s2">"6"</span><span class="p">,</span> <span class="s2">"7"</span><span class="p">,</span> <span class="s2">"8"</span><span class="p">,</span> <span class="s2">"9"</span><span class="p">],</span>
                                      <span class="s2">"&lt;digit-2&gt;"</span><span class="p">:</span>
                                      <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"3"</span><span class="p">,</span> <span class="s2">"4"</span><span class="p">,</span>
                                          <span class="s2">"5"</span><span class="p">,</span> <span class="s2">"6"</span><span class="p">,</span> <span class="s2">"7"</span><span class="p">,</span> <span class="s2">"8"</span><span class="p">,</span> <span class="s2">"9"</span><span class="p">]</span>
                                  <span class="p">}</span>
                                  <span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we now run our coverage-based fuzzer on the extended grammar, we will cover all digits both of regular integers, and all digits in the whole and fraction part of floating-point numbers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;factor&gt;"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>-(43.76 / 8.0 * 5.5 / 6.9 * 6 / 4 + +03)
(90.1 - 1 * 7.3 * 9 + 5 / 8 / 7)
2.8
1.2
10.4
2
4386
7
0
08929.4302
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see how our "foresighted" coverage fuzzer specifically generates floating-point numbers that cover all digits both in the whole and fractional parts.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Extending-Grammars-for-Context-Coverage-Programmatically">Extending Grammars for Context Coverage Programmatically</h3><p>If we want to enhance coverage in context, manually adapting our grammars may not be the perfect choice, since any change to the grammar will have to be replicated in all duplicates.  Instead, we introduce a function that will do the duplication for us.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The function <code>duplicate_context()</code> takes a grammar, a symbol in the grammar, and an expansion of this symbol (<code>None</code> or not given: all expansions of symbol),  and it changes the expansion to refer to a duplicate of all originally referenced rules.  The idea is that we invoke it as</p>
<div class="highlight"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"&lt;integer&gt;.&lt;integer&gt;"</span><span class="p">)</span>
</pre></div>
<p>and get a similar result as with our manual changes, above.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here is the code:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">new_symbol</span><span class="p">,</span> <span class="n">unreachable_nonterminals</span>
<span class="kn">from</span> <span class="nn"><a href="GrammarFuzzer.html" class="import" target="_blank">GrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">expansion_to_children</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> 
                      <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                      <span class="n">expansion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expansion</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                      <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">'inf'</span><span class="p">)):</span>
<span class="w">    </span><span class="sd">"""Duplicate an expansion within a grammar.</span>

<span class="sd">    In the given grammar, take the given expansion of the given `symbol`</span>
<span class="sd">    (if `expansion` is omitted: all symbols), and replace it with a</span>
<span class="sd">    new expansion referring to a duplicate of all originally referenced rules.</span>

<span class="sd">    If `depth` is given, limit duplication to `depth` references</span>
<span class="sd">    (default: unlimited)</span>
<span class="sd">    """</span>
    <span class="n">orig_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">orig_grammar</span><span class="p">,</span> <span class="n">symbol</span><span class="p">,</span>
                       <span class="n">expansion</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">{})</span>

    <span class="c1"># After duplication, we may have unreachable rules; delete them</span>
    <span class="k">for</span> <span class="n">nonterminal</span> <span class="ow">in</span> <span class="n">unreachable_nonterminals</span><span class="p">(</span><span class="n">grammar</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">grammar</span><span class="p">[</span><span class="n">nonterminal</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<details id="Excursion:-Implementing-_duplicate_context()">
<summary>Implementing <code>_duplicate_context()</code></summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The bulk of the work takes place in this helper function.  The additional parameter <code>seen</code> keeps track of symbols already expanded and avoids infinite recursion.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/copy.html" class="import" target="_blank">copy</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
                       <span class="n">orig_grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
                       <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">expansion</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expansion</span><span class="p">],</span>
                       <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
                       <span class="n">seen</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Helper function for `duplicate_context()`"""</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">])):</span>
        <span class="k">if</span> <span class="n">expansion</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">expansion</span><span class="p">:</span>
            <span class="n">new_expansion</span> <span class="o">=</span> <span class="s2">""</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">expansion_to_children</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>                 <span class="c1"># Duplicated already</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">seen</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="p">[]</span> <span class="ow">or</span> <span class="n">depth</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>   <span class="c1"># Terminal symbol or end of recursion</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">s</span>
                <span class="k">else</span><span class="p">:</span>                         <span class="c1"># Nonterminal symbol - duplicate</span>
                    <span class="c1"># Add new symbol with copy of rule</span>
                    <span class="n">new_s</span> <span class="o">=</span> <span class="n">new_symbol</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
                    <span class="n">grammar</span><span class="p">[</span><span class="n">new_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">orig_grammar</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>

                    <span class="c1"># Duplicate its expansions recursively</span>
                    <span class="c1"># {**seen, **{s: new_s}} is seen + {s: new_s}</span>
                    <span class="n">_duplicate_context</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">orig_grammar</span><span class="p">,</span> <span class="n">new_s</span><span class="p">,</span> <span class="n">expansion</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                       <span class="n">depth</span><span class="o">=</span><span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">seen</span><span class="o">=</span><span class="p">{</span><span class="o">**</span><span class="n">seen</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">s</span><span class="p">:</span> <span class="n">new_s</span><span class="p">}})</span>
                    <span class="n">new_expansion</span> <span class="o">+=</span> <span class="n">new_s</span>

            <span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_expansion</span>
</pre></div>

</div>
</div></div>
</div>
</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here's our above example of how <code>duplicate_context()</code> works, now with results.  We let it duplicate the <code>&lt;integer&gt;.&lt;integer&gt;</code> expansion in our expression grammar, and obtain a new grammar with an <code>&lt;integer-1&gt;.&lt;integer-2&gt;</code> expansion where both <code>&lt;integer-1&gt;</code> and <code>&lt;integer-2&gt;</code> refer to copies of the original rules:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"&lt;integer&gt;.&lt;integer&gt;"</span><span class="p">)</span>
<span class="n">dup_expr_grammar</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;start&gt;': ['&lt;expr&gt;'],
 '&lt;expr&gt;': ['&lt;term&gt; + &lt;expr&gt;', '&lt;term&gt; - &lt;expr&gt;', '&lt;term&gt;'],
 '&lt;term&gt;': ['&lt;factor&gt; * &lt;term&gt;', '&lt;factor&gt; / &lt;term&gt;', '&lt;factor&gt;'],
 '&lt;factor&gt;': ['+&lt;factor&gt;',
  '-&lt;factor&gt;',
  '(&lt;expr&gt;)',
  '&lt;integer-1&gt;.&lt;integer-2&gt;',
  '&lt;integer&gt;'],
 '&lt;integer&gt;': ['&lt;digit&gt;&lt;integer&gt;', '&lt;digit&gt;'],
 '&lt;digit&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '&lt;integer-1&gt;': ['&lt;digit-1&gt;&lt;integer-1&gt;', '&lt;digit-2&gt;'],
 '&lt;digit-1&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '&lt;digit-2&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '&lt;integer-2&gt;': ['&lt;digit-3&gt;&lt;integer-2&gt;', '&lt;digit-4&gt;'],
 '&lt;digit-3&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '&lt;digit-4&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Just like above, using such a grammar for coverage fuzzing will now cover digits in a number of contexts.  To be precise, there are five contexts: Regular integers, as well as single-digit and multi-digit whole and fractional parts of floating-point numbers.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;factor&gt;"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(57.5)
2
+-(1 / 3 + 6 / 0 - 7 * 59 * 3 + 8 * 4)
374.88
5.709
0.93
01.1
892.27
219.50
6.636
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The <code>depth</code> parameter controls how deep the duplication should go.  Setting <code>depth</code> to 1 will duplicate only the next rule:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"&lt;integer&gt;.&lt;integer&gt;"</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dup_expr_grammar</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;start&gt;': ['&lt;expr&gt;'],
 '&lt;expr&gt;': ['&lt;term&gt; + &lt;expr&gt;', '&lt;term&gt; - &lt;expr&gt;', '&lt;term&gt;'],
 '&lt;term&gt;': ['&lt;factor&gt; * &lt;term&gt;', '&lt;factor&gt; / &lt;term&gt;', '&lt;factor&gt;'],
 '&lt;factor&gt;': ['+&lt;factor&gt;',
  '-&lt;factor&gt;',
  '(&lt;expr&gt;)',
  '&lt;integer-1&gt;.&lt;integer-2&gt;',
  '&lt;integer&gt;'],
 '&lt;integer&gt;': ['&lt;digit&gt;&lt;integer&gt;', '&lt;digit&gt;'],
 '&lt;digit&gt;': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
 '&lt;integer-1&gt;': ['&lt;digit&gt;&lt;integer-1&gt;', '&lt;digit&gt;'],
 '&lt;integer-2&gt;': ['&lt;digit&gt;&lt;integer-2&gt;', '&lt;digit&gt;']}
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>By default, <code>depth</code> is set to $\infty$, indicating unlimited duplication.  True unbounded duplication could lead to problems for a recursive grammar such as <code>EXPR_GRAMMAR</code>, so <code>duplicate_context()</code> is set to no longer duplicate symbols once duplicated.  Still, if we apply it to duplicate <em>all</em> <code>&lt;expr&gt;</code> expansions, we obtain a grammar with no less than 292 rules:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;expr&gt;"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>292
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This gives us almost 2000 expansions to cover:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>1981
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Duplicating one more time keeps on both growing the grammar and the coverage requirements:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;expr&gt;"</span><span class="p">)</span>
<span class="n">duplicate_context</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">,</span> <span class="s2">"&lt;expr-1&gt;"</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>594
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">dup_expr_grammar</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>3994
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>At this point, plenty of contexts can be covered individually – for instance, multiplications of elements within additions:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">"&lt;expr&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;term-1&gt; + &lt;expr-4&gt;', '&lt;term-5&gt; - &lt;expr-8&gt;', '&lt;term-9&gt;']
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">"&lt;term-1-1&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;factor-1-1&gt; * &lt;term-1-1&gt;', '&lt;factor-2-1&gt; / &lt;term-1-1&gt;', '&lt;factor-3-1&gt;']
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">dup_expr_grammar</span><span class="p">[</span><span class="s2">"&lt;factor-1-1&gt;"</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['+&lt;factor-1-1&gt;',
 '-&lt;factor-1-1&gt;',
 '(&lt;expr-1-1&gt;)',
 '&lt;integer-1-1&gt;.&lt;integer-2-1&gt;',
 '&lt;integer-3-1&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The resulting grammars may no longer be useful for human maintenance; but running a coverage-driven fuzzer such as <code>GrammarCoverageFuzzer()</code> will then go and cover all these expansions in all contexts.  If you want to cover elements in many contexts, then <code>duplicate_context()</code> followed by a coverage-driven fuzzer is your friend.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Covering-Code-by-Covering-Grammars">Covering Code by Covering Grammars</h2><p>With or without context: By systematically covering all input elements, we get a larger variety in our inputs – but does this translate into a wider variety of program behaviors?  After all, these behaviors are what we want to cover, including the unexpected behaviors.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In a grammar, there are elements that directly correspond to program features.  A program handling arithmetic expressions will have functionality that is directly triggered by individual elements - say, an addition feature triggered by the presence of <code>+</code>, subtraction triggered by the presence of <code>-</code>, and floating-point arithmetic triggered by the presence of floating-point numbers in the input.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Such a connection between input structure and functionality leads to a strong <em>correlation between grammar coverage and code coverage</em>.  In other words: If we can achieve a high grammar coverage, this also leads to a high code coverage.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="CGI-Grammars">CGI Grammars</h3><p>Let us explore this relationship on one of our grammars – say, the CGI decoder from the <a href="Coverage.html">chapter on coverage</a>.</p>
</div>
</div>
</div>
</div>

<details id="Excursion:-Creating-the-Plot">
<summary>Creating the Plot</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We compute a mapping <code>coverages</code> where in <code>coverages[x]</code> = <code>{y_1, y_2, ...}</code>, <code>x</code> is the grammar coverage obtained, and <code>y_n</code> is the code coverage obtained for the <code>n</code>-th run.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We first compute the maximum coverage, as in the <a href="Coverage.html">chapter on coverage</a>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Coverage.html" class="import" target="_blank">Coverage</a></span> <span class="kn">import</span> <span class="n">Coverage</span><span class="p">,</span> <span class="n">cgi_decode</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov_max</span><span class="p">:</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">'+'</span><span class="p">)</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">'%20'</span><span class="p">)</span>
    <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">'abc'</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">cgi_decode</span><span class="p">(</span><span class="s1">'%?a'</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now, we run our experiment:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">CGI_GRAMMAR</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coverages</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
    <span class="n">overall_cov</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">max_cov</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
            <span class="n">cgi_decode</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">overall_cov</span> <span class="o">|=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overall_cov</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov_max</span><span class="o">.</span><span class="n">coverage</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">:</span>
            <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We compute the averages for the <code>y</code>-values:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coverages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>and create a scatter plot:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://matplotlib.org/" class="import" target="_blank">matplotlib.pyplot</a></span> <span class="k">as</span> <span class="nn">plt</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://matplotlib.org/" class="import" target="_blank">matplotlib.ticker</a></span> <span class="k">as</span> <span class="nn">mtick</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">"CGI coverage"</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Coverage of cgi_decode() vs. grammar coverage'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'grammar coverage (expansions)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'code coverage (lines)'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>Text(0, 0.5, 'code coverage (lines)')
</pre>
</div>

</div>

<div class="output_area">

<div class="output_image output_png output_subarea ">
<img src="../Images/27485e5e210ed4f8e8261a349b297050.png"/>

</div>

</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This scatter plot shows the relationship between grammar coverage (X axis) and code coverage (Y axis).</p>
</div>
</div>
</div>
</div>

<div class="output_area">

<div class="output_image output_png output_subarea ">
<img src="../Images/ff88d70b414fa2198050ee38b503cbff.png"/>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that the higher the grammar coverage, the higher the code coverage.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This also translates into a correlation coefficient of about 0.9, indicating a strong correlation:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://numpy.org/" class="import" target="_blank">numpy</a></span> <span class="k">as</span> <span class="nn">np</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>array([[1.        , 0.81663071],
       [0.81663071, 1.        ]])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is also confirmed by the Spearman rank correlation:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.scipy.org/doc/scipy/reference/" class="import" target="_blank">scipy.stats</a></span> <span class="kn">import</span> <span class="n">spearmanr</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">spearmanr</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>SignificanceResult(statistic=np.float64(0.9477544699285101), pvalue=np.float64(2.2771918715723359e-10))
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="URL-Grammars">URL Grammars</h3><p>Let us repeat this experiment on URL grammars.  We use the same code as above, except for exchanging the grammars and the function in place:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/urllib.parse.html" class="import" target="_blank">urllib.parse</a></span> <span class="kn">import</span> <span class="n">urlparse</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<details id="Excursion:-Creating-the-Plot">
<summary>Creating the Plot</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Again, we first compute the maximum coverage, making an educated guess as in the <a href="Coverage.html">chapter on coverage</a>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov_max</span><span class="p">:</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">"http://foo.bar/path"</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">"https://foo.bar#fragment"</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">"ftp://user:password@foo.bar?query=value"</span><span class="p">)</span>
    <span class="n">urlparse</span><span class="p">(</span><span class="s2">"ftps://127.0.0.1/?x=1&amp;y=2"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here comes the actual experiment:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">f</span> <span class="o">=</span> <span class="n">GrammarCoverageFuzzer</span><span class="p">(</span><span class="n">URL_GRAMMAR</span><span class="p">,</span> <span class="n">max_nonterminals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">coverages</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

<span class="n">trials</span> <span class="o">=</span> <span class="mi">100</span>
<span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trials</span><span class="p">):</span>
    <span class="n">f</span><span class="o">.</span><span class="n">reset_coverage</span><span class="p">()</span>
    <span class="n">overall_cov</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
            <span class="n">urlparse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">overall_cov</span> <span class="o">|=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">())</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">max_expansion_coverage</span><span class="p">())</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">overall_cov</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">cov_max</span><span class="o">.</span><span class="n">coverage</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">:</span>
            <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">xs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coverages</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">coverages</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">coverages</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">axes</span><span class="p">(</span><span class="n">label</span><span class="o">=</span><span class="s2">"URL coverage"</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>
<span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">mtick</span><span class="o">.</span><span class="n">PercentFormatter</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Coverage of urlparse() vs. grammar coverage'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'grammar coverage (expansions)'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'code coverage (lines)'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>Text(0, 0.5, 'code coverage (lines)')
</pre>
</div>

</div>

<div class="output_area">

<div class="output_image output_png output_subarea ">
<img src="../Images/06a0d73f00bef31eac2cfa3d2996f9fa.png"/>

</div>

</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This scatter plot shows the relationship between grammar coverage (X axis) and code coverage (Y axis).</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">);</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_image output_png output_subarea ">
<img src="../Images/e76fe0d9672244c397b5b62d43de9b28.png"/>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here, we have an even stronger correlation of more than .95:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>array([[1.       , 0.8819171],
       [0.8819171, 1.       ]])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is also confirmed by the Spearman rank correlation:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">spearmanr</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>SignificanceResult(statistic=np.float64(0.9486832980505139), pvalue=np.float64(0.05131670194948612))
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We conclude: If one wants to obtain high code coverage, it is a good idea to strive for high grammar coverage first.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Will-this-always-work?">Will this always work?</h3><p>The correlation observed for the CGI and URL examples will not hold for every program and every structure.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Equivalent-Elements">Equivalent Elements</h4><p>First, some grammar elements are treated uniformly by a program even though the grammar sees them as different symbols.  In the host name of a URL, for instance, we can have many characters, although a URL-handling program treats them all the same.  Likewise, individual digits, once composed into a number, make less of a difference than the value of the number itself.  Hence, achieving variety in digits or characters will not necessarily yield a large difference in functionality.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This problem can be addressed by <em>differentiating elements dependent on their context</em>, and covering alternatives for each context, as discussed above.  The key is to identify the contexts in which variety is required, and those where it is not.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h4 id="Deep-Data-Processing">Deep Data Processing</h4><p>Second, the way the data is processed can make a large difference.  Consider the input to a <em>media player</em>, consisting of compressed media data.  While processing the media data, the media player will show differences in behavior (notably in its output), but these differences cannot be directly triggered through individual elements of the media data.  Likewise, a <em>machine learner</em> that is trained on a large set of inputs typically will not have its behavior controlled by a single syntactic element of the input.  (Well, it could, but then, we would not need a machine learner.)  In these cases of "deep" data processing, achieving structural coverage in the grammar will not necessarily induce code coverage.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>One way to address this problem is to achieve not only <em>syntactic</em>, but actually <em>semantic</em> variety.  In the <a href="GeneratorGrammarFuzzer.html">chapter on fuzzing with constraints</a>, we will see how to specifically generate and filter input values, especially numerical values.  Such generators can also be applied in context, such that each and every facet of the input can be controlled individually.
Also, in the above examples, <em>some</em> parts of the input can still be covered structurally: <em>Metadata</em> (such as author name or composer for the media player) or <em>configuration data</em> (such as settings for the machine learner) can and should be covered systematically; we will see how this is done <a href="ConfigurationFuzzer.html">in the chapter on "Configuration fuzzing"</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Lessons-Learned">Lessons Learned</h2><ul>
<li>Achieving <em>grammar coverage</em> quickly results in a large variety of inputs.</li>
<li>Duplicating grammar rules allows covering elements in specific <em>contexts</em>.</li>
<li>Achieving grammar coverage can help in obtaining <em>code coverage</em>.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Next-Steps">Next Steps</h2><p>From here, you can learn how to</p>
<ul>
<li><a href="ConfigurationFuzzer.html">use grammar coverage to systematically test configurations</a>.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Background">Background</h2><p>The idea of ensuring that each expansion in the grammar is used at least once goes back to Burkhardt [<a href="https://doi.org/10.1007/BF02235512">Burkhardt <em>et al</em>, 1967</a>], to be later rediscovered by Paul Purdom [<a href="https://doi.org/10.1007/BF01932308">Purdom <em>et al</em>, 1972</a>].  The relation between grammar coverage and code coverage was discovered by Nikolas Havrikov, who explores it in his PhD thesis.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Exercises">Exercises</h2></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Exercise-1:-Testing-ls">Exercise 1: Testing ls</h3><p>Consider the Unix <code>ls</code> program, used to list the contents of a directory.  Create a grammar for invoking <code>ls</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">LS_EBNF_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'-&lt;options&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;options&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;option&gt;*'</span><span class="p">],</span>
    <span class="s1">'&lt;option&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="s1">'@'</span><span class="p">,</span>
                 <span class="c1"># many more</span>
                 <span class="p">]</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">LS_EBNF_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Use <code>GrammarCoverageFuzzer</code> to test all options.  Be sure to invoke <code>ls</code> with each option set.</p>

    
<p/><div class="solution_link"><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GrammarCoverageFuzzer.ipynb#Exercises" target="_blank">Use the notebook</a> to work on the exercises and see solutions.</div>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Exercise-2:-Caching">Exercise 2: Caching</h3><p>The value of <code>max_expansion_coverage()</code> depends on the grammar only.  Change the implementation such that the values are precomputed for each symbol and depth upon initialization (<code>__init__()</code>); this way, <code>max_expansion_coverage()</code> can simply look up the value in the table.</p>

    
<p/><div class="solution_link"><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GrammarCoverageFuzzer.ipynb#Exercises" target="_blank">Use the notebook</a> to work on the exercises and see solutions.</div>
</div>
</div>
</div>
</div>

        
<p class="imprint">
<img style="float:right" src="../Images/2f3faa36146c6fb38bbab67add09aa5f.png" alt="Creative Commons License" data-original-src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/>
The content of this project is licensed under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
The source code that is part of the content, as well as the source code used to format and display that content is licensed under the <a href="https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license">MIT License</a>.
<a href="https://github.com/uds-se/fuzzingbook/commits/master/notebooks/GrammarCoverageFuzzer.ipynb" target="_blank)">Last change: 2023-11-11 18:18:06+01:00</a> • 
<a href="#citation" id="cite" onclick="revealCitation()">Cite</a> •
<a href="https://cispa.de/en/impressum" target="_blank">Imprint</a>
</p>



<div id="citation" class="citation" style="display: none;">
<a name="citation"/>
<h2>How to Cite this Work</h2>
<p>
Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler: "<a href="https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html">Grammar Coverage</a>".  In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "<a href="https://www.fuzzingbook.org/">The Fuzzing Book</a>", <a href="https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html">https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html</a>.  Retrieved 2023-11-11 18:18:06+01:00.
</p>
<pre>
@incollection{fuzzingbook2023:GrammarCoverageFuzzer,
    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\"o}hme and Gordon Fraser and Christian Holler},
    booktitle = {The Fuzzing Book},
    title = {Grammar Coverage},
    year = {2023},
    publisher = {CISPA Helmholtz Center for Information Security},
    howpublished = {\url{https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html}},
    note = {Retrieved 2023-11-11 18:18:06+01:00},
    url = {https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html},
    urldate = {2023-11-11 18:18:06+01:00}
}
</pre>
</div>

          
</body>
</html>