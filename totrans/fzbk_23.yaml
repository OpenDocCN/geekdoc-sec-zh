- en: Fuzzing with Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/FuzzingWithConstraints.html](http://www.fuzzingbook.org/html/FuzzingWithConstraints.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In previous chapters, we have seen how [Grammar-Based Fuzzing](GrammarFuzzer.html)
    allows us to efficiently generate myriads of syntactically valid inputs. However,
    there are *semantic* input features that cannot be expressed in a context-free
    grammar, such as
  prefs: []
  type: TYPE_NORMAL
- en: '"$X$ is the length of $Y$";'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"$X$ is an identifier previously declared"; or'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"$X$ should be longer than 4,096 bytes".'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we show how the [ISLa](https://rindphi.github.io/isla/) framework
    allows us to express such features as *constraints* added to a grammar. By having
    ISLa solve these constraints automatically, we produce inputs that are not only
    *syntactically* valid, but actually *semantically* valid. Furthermore, such constraints
    allow us to very precisely *shape* the inputs we want for testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should have read the [chapter on grammars](Grammars.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chapter on [generators and filters](GeneratorGrammarFuzzer.html) addresses
    a similar problem, but with program code instead of constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces the [ISLa](https://rindphi.github.io/isla/) framework,
    consisting of
  prefs: []
  type: TYPE_NORMAL
- en: the *ISLa specification language*, allowing to add *constraints* to a grammar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the *ISLa solver*, solving these constraints to produce semantically (and syntactically)
    valid inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the *ISLa checker*, checking given inputs for whether they satisfy these constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A typical usage of the ISLa solver is as follows. First, install ISLa, using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, you can import the solver as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The ISLa solver needs two things. First, a *grammar* - say, US phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Second, you need *constraints* – a string expressing a condition over one or
    more grammar elements. Common functions include
  prefs: []
  type: TYPE_NORMAL
- en: '`str.len()`, returning the length of a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`str.to.int()`, converting a string to an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we instantiate the ISLa solver with a constraint stating that the area
    code should be above 900:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, invoking `solver.solve()` returns a *solution* for the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`solve()` returns a derivation tree, which typically is converted into a string
    using `str()` as above. The `print()` function does this implicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Subsequent calls of `solve()` return more solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We see that the solver produces a number of inputs that all satisfy the constraint
    - the area code is always more than 900.
  prefs: []
  type: TYPE_NORMAL
- en: The `ISLaSolver()` constructor provides several additional parameters to configure
    the solver, as documented below. Additional `ISLaSolver` methods allow checking
    inputs against constraints, and provide additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="226pt" height="94pt" viewBox="0.00 0.00 226.25 94.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 90)"><g
    id="node1" class="node"><title>ISLaSolver</title> <g id="a_node1"><a xlink:href="isla.solver.ipynb"
    xlink:title="class ISLaSolver:'
  prefs: []
  type: TYPE_NORMAL
- en: The solver class for ISLa formulas/constraints. Its top-level methods are
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.solve`
  prefs: []
  type: TYPE_NORMAL
- en: Use to generate solutions for an ISLa constraint.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.check`
  prefs: []
  type: TYPE_NORMAL
- en: Use to check if an ISLa constraint is satisfied for a given input.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.parse`
  prefs: []
  type: TYPE_NORMAL
- en: Use to parse and validate an input.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.repair`
  prefs: []
  type: TYPE_NORMAL
- en: Use to repair an input such that it satisfies a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`~isla.solver.ISLaSolver.mutate`
  prefs: []
  type: TYPE_NORMAL
- en: 'Use to mutate an input such that the result satisfies a constraint."><text
    text-anchor="start" x="8" y="-69.2" font-family="Patua One, Helvetica, sans-serif"
    font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text> <g id="a_node1_0"><a
    xlink:href="#" xlink:title="ISLaSolver"><g id="a_node1_1"><a xlink:href="isla.solver.ipynb"
    xlink:title="__init__(self, grammar: Union[Mapping[str, Sequence[str]], str],
    formula: Union[isla.language.Formula, str, NoneType] = None, structural_predicates:
    Set[isla.language.StructuralPredicate] = frozenset({StructuralPredicate(name=''inside'',
    arity=2, eval_fun=<function in_tree>), StructuralPredicate(name=''level'', arity=4,
    eval_fun=<function level_check>), StructuralPredicate(name=''consecutive'', arity=2,
    eval_fun=<function consecutive>), StructuralPredicate(name=''before'', arity=2,
    eval_fun=<function is_before>), StructuralPredicate(name=''nth'', arity=3, eval_fun=<function
    is_nth>), StructuralPredicate(name=''same_position'', arity=2, eval_fun=<function
    is_same_position>), StructuralPredicate(name=''after'', arity=2, eval_fun=<function
    is_after>), StructuralPredicate(name=''different_position'', arity=2, eval_fun=<function
    is_different_position>), StructuralPredicate(name=''direct_child'', arity=2, eval_fun=<function
    is_direct_child>)}), semantic_predicates: Set[isla.language.SemanticPredicate]
    = frozenset({SemanticPredicate(count, 3)}), max_number_free_instantiations: int
    = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results:
    int = 5, enforce_unique_trees_in_queue: bool = False, debug: bool = False, cost_computer:
    Optional[ForwardRef(''CostComputer'')] = None, timeout_seconds: Optional[int]
    = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate,
    ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Mapping[str,
    Sequence[str]]], isla.fuzzer.GrammarFuzzer] = <function SolverDefaults.<lambda>>,
    tree_insertion_methods: Optional[int] = None, activate_unsat_support: bool = False,
    grammar_unwinding_threshold: int = 4, initial_tree: returns.maybe.Maybe[isla.derivation_tree.DerivationTree]
    = <Nothing>, enable_optimized_z3_queries: bool = True, start_symbol: Optional[str]
    = None):'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor of :class:`~isla.solver.ISLaSolver` accepts a large number of
  prefs: []
  type: TYPE_NORMAL
- en: parameters. However, all but the first one, :code:`grammar`, are *optional.*
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to construct an ISLa solver is by only providing it with a
  prefs: []
  type: TYPE_NORMAL
- en: grammar only; it then works like a grammar fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import random'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> random.seed(1)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> import string'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> LANG_GRAMMAR = {'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<start>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<stmt>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<stmt>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<assgn> ; <stmt>&quot;,
    &quot;<assgn>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<assgn>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<var> := <rhs>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<rhs>&quot;:'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[&quot;<var>&quot;, &quot;<digit>&quot;],'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<var>&quot;: list(string.ascii_lowercase),'
  prefs: []
  type: TYPE_NORMAL
- en: '... &nbsp;&nbsp;&nbsp;&nbsp;&quot;<digit>&quot;: list(string.digits)'
  prefs: []
  type: TYPE_NORMAL
- en: '... }'
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> from isla.solver import ISLaSolver'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> solver = ISLaSolver(LANG_GRAMMAR)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>>'
  prefs: []
  type: TYPE_NORMAL
- en: '>>> str(solver.solve())'
  prefs: []
  type: TYPE_NORMAL
- en: '''d := 9'''
  prefs: []
  type: TYPE_NORMAL
- en: '>>> str(solver.solve())'
  prefs: []
  type: TYPE_NORMAL
- en: '''v := n ; s := r'''
  prefs: []
  type: TYPE_NORMAL
- en: ':param grammar: The underlying grammar; either, as a &quot;Fuzzing Book&quot;
    dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: or in BNF syntax.
  prefs: []
  type: TYPE_NORMAL
- en: ':param formula: The formula to solve; either a string or a readily parsed'
  prefs: []
  type: TYPE_NORMAL
- en: formula. If no formula is given, a default `true` constraint is assumed, and
  prefs: []
  type: TYPE_NORMAL
- en: the solver falls back to a grammar fuzzer. The number of produced solutions
  prefs: []
  type: TYPE_NORMAL
- en: will then be bound by `max_number_free_instantiations`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param structural_predicates: Structural predicates to use when parsing a'
  prefs: []
  type: TYPE_NORMAL
- en: formula.
  prefs: []
  type: TYPE_NORMAL
- en: ':param semantic_predicates: Semantic predicates to use when parsing a formula.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_free_instantiations: Number of times that nonterminals that'
  prefs: []
  type: TYPE_NORMAL
- en: are not bound by any formula should be expanded by a coverage-based fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_smt_instantiations: Number of solutions of SMT formulas that'
  prefs: []
  type: TYPE_NORMAL
- en: should be produced.
  prefs: []
  type: TYPE_NORMAL
- en: ':param max_number_tree_insertion_results: The maximum number of results when'
  prefs: []
  type: TYPE_NORMAL
- en: solving existential quantifiers by tree insertion.
  prefs: []
  type: TYPE_NORMAL
- en: ':param enforce_unique_trees_in_queue: If true, states with the same tree as
    an'
  prefs: []
  type: TYPE_NORMAL
- en: already existing tree in the queue are discarded, irrespectively of the
  prefs: []
  type: TYPE_NORMAL
- en: constraint.
  prefs: []
  type: TYPE_NORMAL
- en: ':param debug: If true, debug information about the evolution of states is'
  prefs: []
  type: TYPE_NORMAL
- en: collected, notably in the field state_tree. The root of the tree is in the
  prefs: []
  type: TYPE_NORMAL
- en: field state_tree_root. The field costs stores the computed cost values for
  prefs: []
  type: TYPE_NORMAL
- en: all new nodes.
  prefs: []
  type: TYPE_NORMAL
- en: ':param cost_computer: The `CostComputer` class for computing the cost relevant'
  prefs: []
  type: TYPE_NORMAL
- en: to placing states in ISLa's queue.
  prefs: []
  type: TYPE_NORMAL
- en: ':param timeout_seconds: Number of seconds after which the solver will terminate.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param global_fuzzer: If set to True, only one coverage-guided grammar fuzzer'
  prefs: []
  type: TYPE_NORMAL
- en: object is used to finish off unconstrained open derivation trees throughout
  prefs: []
  type: TYPE_NORMAL
- en: the whole generation time. This may be beneficial for some targets; e.g., we
  prefs: []
  type: TYPE_NORMAL
- en: experienced that CSV works significantly faster. However, the achieved k-path
  prefs: []
  type: TYPE_NORMAL
- en: coverage can be lower with that setting.
  prefs: []
  type: TYPE_NORMAL
- en: ':param predicates_unique_in_int_arg: This is needed in certain cases for'
  prefs: []
  type: TYPE_NORMAL
- en: instantiating universal integer quantifiers. The supplied predicates should
  prefs: []
  type: TYPE_NORMAL
- en: have exactly one integer argument, and hold for exactly one integer value
  prefs: []
  type: TYPE_NORMAL
- en: once all other parameters are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: ':param fuzzer_factory: Constructor of the fuzzer to use for instantiating'
  prefs: []
  type: TYPE_NORMAL
- en: '&quot;free&quot; nonterminals.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param tree_insertion_methods: Combination of methods to use for existential'
  prefs: []
  type: TYPE_NORMAL
- en: 'quantifier elimination by tree insertion. Full selection: `DIRECT_EMBEDDING
    &amp;'
  prefs: []
  type: TYPE_NORMAL
- en: SELF_EMBEDDING &amp; CONTEXT_ADDITION`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param activate_unsat_support: Set to True if you assume that a formula might'
  prefs: []
  type: TYPE_NORMAL
- en: be unsatisfiable. This triggers additional tests for unsatisfiability that
  prefs: []
  type: TYPE_NORMAL
- en: reduce input generation performance, but might ensure termination (with a
  prefs: []
  type: TYPE_NORMAL
- en: negative solver result) for unsatisfiable problems for which the solver could
  prefs: []
  type: TYPE_NORMAL
- en: otherwise diverge.
  prefs: []
  type: TYPE_NORMAL
- en: ':param grammar_unwinding_threshold: When querying the SMT solver, ISLa passes
    a'
  prefs: []
  type: TYPE_NORMAL
- en: regular expression for the syntax of the involved nonterminals. If this
  prefs: []
  type: TYPE_NORMAL
- en: syntax is not regular, we unwind the respective part in the reference grammar
  prefs: []
  type: TYPE_NORMAL
- en: up to a depth of `grammar_unwinding_threshold`. If this is too shallow, it can
  prefs: []
  type: TYPE_NORMAL
- en: happen that an equation etc. cannot be solved; if it is too deep, it can
  prefs: []
  type: TYPE_NORMAL
- en: negatively impact performance (and quite tremendously so).
  prefs: []
  type: TYPE_NORMAL
- en: ':param initial_tree: An initial input tree for the queue, if the solver shall'
  prefs: []
  type: TYPE_NORMAL
- en: not start from the tree `(<start>, None)`.
  prefs: []
  type: TYPE_NORMAL
- en: ':param enable_optimized_z3_queries: Enables preprocessing of Z3 queries (mainly'
  prefs: []
  type: TYPE_NORMAL
- en: numeric problems concerning things like length). This can improve performance
  prefs: []
  type: TYPE_NORMAL
- en: significantly; however, it might happen that certain problems cannot be solved
  prefs: []
  type: TYPE_NORMAL
- en: anymore. In that case, this option can/should be deactivated.
  prefs: []
  type: TYPE_NORMAL
- en: ':param start_symbol: This is an alternative to `initial_tree` for starting
    with'
  prefs: []
  type: TYPE_NORMAL
- en: a start symbol different form `<start>`. If `start_symbol` is provided, a tree
  prefs: []
  type: TYPE_NORMAL
- en: consisting of a single root node with the value of `start_symbol` is chosen
    as
  prefs: []
  type: TYPE_NORMAL
- en: 'initial tree."><text text-anchor="start" x="10.62" y="-47" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="isla.solver.ipynb" xlink:title="check(self, inp:
    isla.derivation_tree.DerivationTree | str) -> bool:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluates whether the given derivation tree satisfies the constraint passed
    to
  prefs: []
  type: TYPE_NORMAL
- en: the solver. Raises an `UnknownResultError` if this could not be evaluated
  prefs: []
  type: TYPE_NORMAL
- en: (e.g., because of a solver timeout or a semantic predicate that cannot be
  prefs: []
  type: TYPE_NORMAL
- en: evaluated).
  prefs: []
  type: TYPE_NORMAL
- en: ':param inp: The input to evaluate, either readily parsed or as a string.'
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A truth value."><text text-anchor="start" x="10.62" y="-34.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">check()</text></a></g>
    <g id="a_node1_3"><a xlink:href="isla.solver.ipynb" xlink:title="parse(self, inp:
    str, nonterminal: str = ''<start>'', skip_check: bool = False, silent: bool =
    False) -> isla.derivation_tree.DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: Parses the given input `inp`. Raises a `SyntaxError` if the input does not
  prefs: []
  type: TYPE_NORMAL
- en: satisfy the grammar, a `SemanticError` if it does not satisfy the constraint
  prefs: []
  type: TYPE_NORMAL
- en: (this is only checked if `nonterminal` is &quot;<start>&quot;), and returns
    the parsed
  prefs: []
  type: TYPE_NORMAL
- en: '`DerivationTree` otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param inp: The input to parse.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param nonterminal: The nonterminal to start parsing with, if a string'
  prefs: []
  type: TYPE_NORMAL
- en: corresponding to a sub-grammar shall be parsed. We don't check semantic
  prefs: []
  type: TYPE_NORMAL
- en: correctness in that case.
  prefs: []
  type: TYPE_NORMAL
- en: ':param skip_check: If True, the semantic check is left out.'
  prefs: []
  type: TYPE_NORMAL
- en: ':param silent: If True, no error is sent to the log stream in case of a'
  prefs: []
  type: TYPE_NORMAL
- en: failed parse.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A parsed `DerivationTree`."><text text-anchor="start" x="10.62" y="-21.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">parse()</text></a></g> <g id="a_node1_4"><a xlink:href="isla.solver.ipynb"
    xlink:title="solve(self) -> isla.derivation_tree.DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: Attempts to compute a solution to the given ISLa formula. Returns that solution,
  prefs: []
  type: TYPE_NORMAL
- en: if any. This function can be called repeatedly to obtain more solutions until
  prefs: []
  type: TYPE_NORMAL
- en: 'one of two exception types is raised: A :class:`StopIteration` indicates that'
  prefs: []
  type: TYPE_NORMAL
- en: no more solution can be found; a :class:`TimeoutError` is raised if a timeout
  prefs: []
  type: TYPE_NORMAL
- en: occurred. After that, an exception will be raised every time.
  prefs: []
  type: TYPE_NORMAL
- en: The timeout can be controlled by the :code:`timeout_seconds`
  prefs: []
  type: TYPE_NORMAL
- en: :meth:`constructor <isla.solver.ISLaSolver.__init__>` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: ':return: A solution for the ISLa formula passed to the'
  prefs: []
  type: TYPE_NORMAL
- en: :class:`isla.solver.ISLaSolver`."><text text-anchor="start" x="10.62" y="-8.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="10.00">solve()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>Legend</title>
    <text text-anchor="start" x="99" y="-59" font-family="Patua One, Helvetica, sans-serif"
    font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start"
    x="99" y="-49" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="105" y="-49" font-family="'Fira Mono', 'Source Code
    Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="99" y="-39" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="105" y="-39" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="99" y="-29" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="105" y="-29" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="99" y="-19.95" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'The ISLa functionality is also available on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Semantic Input Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we have frequently used [grammars](Grammars.html) to [systematically
    generate inputs](GrammarFuzzer.html) that [cover input structure](GrammarCoverageFuzzer.html)
    and more. But while it is relatively easy to express the *syntax* of an input
    using a grammar, there are input properties that *cannot* be expressed using a
    grammar. Such input properties are called *semantic* properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate semantic properties using a simple example. We want to test
    some system that is configured by two settings, a *page size* and a *buffer size*.
    Both these come as integer numbers as part of a human-readable configuration file.
    The *syntax* of this file is given by the following grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a visualization of this grammar as a railroad diagram, showing its
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 191.0 62" width="191.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">config</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 540.5 62" width="540.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="108.25" y="35">pagesize=</text></g>
    <g class="non-terminal"><text x="220.5" y="35">pagesize</text></g> <g class="terminal"><text
    x="332.75" y="35">bufsize=</text></g> <g class="non-terminal"><text x="440.75"
    y="35">bufsize</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 165.5 62" width="165.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">int</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 165.5 62" width="165.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">int</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 307.5 62" width="307.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="108.25" y="35">leaddigit</text></g>
    <g class="non-terminal"><text x="212.0" y="35">digits</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 273.5 92" width="273.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="65">digit</text></g>
    <g class="non-terminal"><text x="178.0" y="65">digits</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="80" viewBox="0 0 876.5 80" width="876.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="44">1</text></g></g></g>
    <g><g><g class="terminal"><text x="172.75" y="44">2</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="44">3</text></g></g></g> <g><g><g class="terminal"><text
    x="349.75" y="44">4</text></g></g></g> <g><g><g class="terminal"><text x="438.25"
    y="44">5</text></g></g></g> <g><g><g class="terminal"><text x="526.75" y="44">6</text></g></g></g>
    <g><g><g class="terminal"><text x="615.25" y="44">7</text></g></g></g> <g><g><g
    class="terminal"><text x="703.75" y="44">8</text></g></g></g> <g><g><g class="terminal"><text
    x="792.25" y="44">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this grammar, we can now use any of our grammar-based fuzzers to generate
    valid inputs. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good - and indeed, these random values will help us test our (hypothetical)
    system. But what if we want to *control* these values further, putting our system
    to the test?
  prefs: []
  type: TYPE_NORMAL
- en: A grammar gives us *some* control. If we want to ensure a page size of at least
    100,000, for instance, a rule like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: would do the job. We could also express that the page size should be an odd
    number, by having it end in an odd digit. But if we want to state that the page
    size should be, say, a multiple of 8, or larger or less than the buffer size,
    we are out of luck.
  prefs: []
  type: TYPE_NORMAL
- en: In the [chapter on fuzzing with generators](GeneratorGrammarFuzzer.html), we
    have seen how to attach *program code* to individual rules - program code that
    would either *generate* individual elements right away or *filter* only these
    that satisfy specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attaching code makes things very flexible, but also has several disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it is pretty hard to generate inputs that satisfy multiple constraints
    at once. In essence, you have to code your own *strategy* for generating inputs,
    which at some point negates the advantage of having an abstract representation
    such as a grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, your code is not portable. While a grammar can be easily adapted to
    *any* grammar-based fuzzer, adding, say, Python code, ties you to the Python environment
    forever.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, program code can only be used for *producing* inputs or *checking* inputs,
    but not both. This, again, is a downside compared to a pure grammar representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, we are looking to a more *general* way to express semantic properties
    - and also a more *declarative* way to express semantic properties.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Unrestricted-Grammars"><summary>Unrestricted Grammars</summary>
  prefs: []
  type: TYPE_NORMAL
- en: One very general solution to this problem would be to use *unrestricted* grammars
    rather than the *context-free* grammars we have used so far. In an unrestricted
    grammar, one can have multiple symbols also on the left-hand side of an expansion
    rule, making them very flexible. In fact, unrestricted grammars are *Turing-universal*,
    meaning that they can express any feature that could also be expressed in program
    code; and they could thus check and produce arbitrary strings with arbitrary features.
    (If they finish, that is – unrestricted grammars also suffer from the halting
    problem.) The downside is that there is literally no programming support for unrestricted
    grammars – we'd have to implement all arithmetic, strings, and other functionality
    from scratch in a grammar, which is - well - not fun.</details>
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In recent work, *Dominic Steinhöfel* and *Andreas Zeller* (one of the authors
    of this book) have presented an infrastructure that allows producing inputs with
    *arbitrary properties*, but without having to go through the trouble of implementing
    producers or checkers. Instead, they suggest a dedicated *language* for specifying
    inputs, named [ISLa](https://rindphi.github.io/isla/) (for input specification
    language). *ISLa* combines a standard context-free *grammar* with *constraints*
    that express *semantic* properties of the inputs and their elements. ISLa can
    be used as a *fuzzer* (producing inputs that satisfy the constraints) as well
    as a *checker* (checking inputs whether they satisfy the given constraints).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate ISLa by example. ISLa comes as a Python package named `isla-solver`
    that can be easily installed using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This also installs all dependent packages.
  prefs: []
  type: TYPE_NORMAL
- en: The core of ISLa is the *ISLa Solver* – the component that actually *solves*
    constraints to produce satisfying inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of an `ISLaSolver` takes two mandatory arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The *grammar* is the grammar the solver should produce inputs from.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *constraint* is the constraint the produced inputs should satisfy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To express a constraint, we have a variety of *functions* and *predicates*
    at our disposition. These can be applied to individual elements of the grammar,
    notably their nonterminals. The function `str.len()`, for instance, returns the
    length of a string. If we want to have inputs in which the page size has at least
    6 digits, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `solve()` returns the next produced string from the ISLa solver,
    as a *derivation tree* (seen in the [Chapter on fuzzing with grammars](GrammarFuzzer.html)).
    To convert these into a string, we can use the `str()` converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `print()` method converts its arguments to strings implicitly. To get, say,
    the next 10 solutions, we can thus write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '... and we see that, indeed, each page size has exactly six digits.'
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Derivation-Trees"><summary>Derivation Trees</summary>
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect a derivation tree as returned from `solve()` directly, you will
    get quite a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily visualize the tree, revealing its structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="898pt" height="927pt" viewBox="0.00 0.00 897.62 926.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 922.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="143.38"
    y="-905.45" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="143.38"
    y="-855.2" font-family="Times,serif" font-size="14.00"><config></text></g> <g
    id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="27.38" y="-804.95" font-family="Times,serif" font-size="14.00">pagesize=</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="104.38" y="-804.95" font-family="Times,serif" font-size="14.00"><pagesize></text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="middle" x="182.38" y="-804.95" font-family="Times,serif" font-size="14.00">\nbufsize=</text></g>
    <g id="edge47" class="edge"><title>1->47</title></g> <g id="node49" class="node"><title>48</title>
    <text text-anchor="middle" x="257.38" y="-804.95" font-family="Times,serif" font-size="14.00"><bufsize></text></g>
    <g id="edge48" class="edge"><title>1->48</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="104.38" y="-754.7" font-family="Times,serif" font-size="14.00"><int></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="42.38" y="-704.45" font-family="Times,serif" font-size="14.00"><leaddigit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="115.38" y="-704.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge7" class="edge"><title>4->7</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="42.38" y="-654.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="106.38" y="-654.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="168.38"
    y="-654.2" font-family="Times,serif" font-size="14.00"><digits></text></g> <g
    id="edge10" class="edge"><title>7->10</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="106.38" y="-603.95" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge9" class="edge"><title>8->9</title></g> <g id="node12"
    class="node"><title>11</title> <text text-anchor="middle" x="165.38" y="-603.95"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge11"
    class="edge"><title>10->11</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="227.38" y="-603.95" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge13" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="165.38" y="-553.7" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge12" class="edge"><title>11->12</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="224.38" y="-553.7"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge14"
    class="edge"><title>13->14</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="286.38" y="-553.7" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge16" class="edge"><title>13->16</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="224.38" y="-503.45" font-family="Times,serif" font-size="14.00">9
    (57)</text></g> <g id="edge15" class="edge"><title>14->15</title></g> <g id="node18"
    class="node"><title>17</title> <text text-anchor="middle" x="282.38" y="-503.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge17"
    class="edge"><title>16->17</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="344.38" y="-503.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge19" class="edge"><title>16->19</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="282.38" y="-453.2" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge18" class="edge"><title>17->18</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="340.38" y="-453.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="402.38" y="-453.2" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge22" class="edge"><title>19->22</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="340.38" y="-402.95" font-family="Times,serif" font-size="14.00">7
    (55)</text></g> <g id="edge21" class="edge"><title>20->21</title></g> <g id="node24"
    class="node"><title>23</title> <text text-anchor="middle" x="398.38" y="-402.95"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge23"
    class="edge"><title>22->23</title></g> <g id="node26" class="node"><title>25</title>
    <text text-anchor="middle" x="460.38" y="-402.95" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge25" class="edge"><title>22->25</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="398.38" y="-352.7" font-family="Times,serif" font-size="14.00">4
    (52)</text></g> <g id="edge24" class="edge"><title>23->24</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="456.38" y="-352.7"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="518.38" y="-352.7" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="456.38" y="-302.45" font-family="Times,serif" font-size="14.00">6
    (54)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="514.38" y="-302.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge29"
    class="edge"><title>28->29</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="576.38" y="-302.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge31" class="edge"><title>28->31</title></g> <g id="node31" class="node"><title>30</title>
    <text text-anchor="middle" x="514.38" y="-252.2" font-family="Times,serif" font-size="14.00">8
    (56)</text></g> <g id="edge30" class="edge"><title>29->30</title></g> <g id="node33"
    class="node"><title>32</title> <text text-anchor="middle" x="572.38" y="-252.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge32"
    class="edge"><title>31->32</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="middle" x="634.38" y="-252.2" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge34" class="edge"><title>31->34</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="middle" x="572.38" y="-201.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge33" class="edge"><title>32->33</title></g> <g id="node36"
    class="node"><title>35</title> <text text-anchor="middle" x="630.38" y="-201.95"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge35"
    class="edge"><title>34->35</title></g> <g id="node38" class="node"><title>37</title>
    <text text-anchor="middle" x="692.38" y="-201.95" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge37" class="edge"><title>34->37</title></g> <g id="node37" class="node"><title>36</title>
    <text text-anchor="middle" x="630.38" y="-151.7" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge36" class="edge"><title>35->36</title></g> <g id="node39"
    class="node"><title>38</title> <text text-anchor="middle" x="688.38" y="-151.7"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge38"
    class="edge"><title>37->38</title></g> <g id="node41" class="node"><title>40</title>
    <text text-anchor="middle" x="750.38" y="-151.7" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge40" class="edge"><title>37->40</title></g> <g id="node40" class="node"><title>39</title>
    <text text-anchor="middle" x="688.38" y="-101.45" font-family="Times,serif" font-size="14.00">8
    (56)</text></g> <g id="edge39" class="edge"><title>38->39</title></g> <g id="node42"
    class="node"><title>41</title> <text text-anchor="middle" x="746.38" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge41"
    class="edge"><title>40->41</title></g> <g id="node44" class="node"><title>43</title>
    <text text-anchor="middle" x="808.38" y="-101.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge43" class="edge"><title>40->43</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="middle" x="746.38" y="-51.2" font-family="Times,serif" font-size="14.00">8
    (56)</text></g> <g id="edge42" class="edge"><title>41->42</title></g> <g id="node45"
    class="node"><title>44</title> <text text-anchor="middle" x="804.38" y="-51.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge44"
    class="edge"><title>43->44</title></g> <g id="node47" class="node"><title>46</title>
    <text text-anchor="middle" x="866.38" y="-51.2" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge46" class="edge"><title>43->46</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="middle" x="804.38" y="-0.95" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge45" class="edge"><title>44->45</title></g> <g id="node50"
    class="node"><title>49</title> <text text-anchor="middle" x="257.38" y="-754.7"
    font-family="Times,serif" font-size="14.00"><int></text></g> <g id="edge49" class="edge"><title>48->49</title></g>
    <g id="node51" class="node"><title>50</title> <text text-anchor="middle" x="247.38"
    y="-704.45" font-family="Times,serif" font-size="14.00"><leaddigit></text></g>
    <g id="edge50" class="edge"><title>49->50</title></g> <g id="node53" class="node"><title>52</title>
    <text text-anchor="middle" x="320.38" y="-704.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge52" class="edge"><title>49->52</title></g> <g id="node52" class="node"><title>51</title>
    <text text-anchor="middle" x="247.38" y="-654.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge51" class="edge"><title>50->51</title></g> <g id="node54"
    class="node"><title>53</title> <text text-anchor="middle" x="311.38" y="-654.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge53"
    class="edge"><title>52->53</title></g> <g id="node56" class="node"><title>55</title>
    <text text-anchor="middle" x="373.38" y="-654.2" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge55" class="edge"><title>52->55</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="middle" x="311.38" y="-603.95" font-family="Times,serif" font-size="14.00">0
    (48)</text></g> <g id="edge54" class="edge"><title>53->54</title></g> <g id="node57"
    class="node"><title>56</title> <text text-anchor="middle" x="369.38" y="-603.95"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge56"
    class="edge"><title>55->56</title></g> <g id="node59" class="node"><title>58</title>
    <text text-anchor="middle" x="431.38" y="-603.95" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge58" class="edge"><title>55->58</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="middle" x="369.38" y="-553.7" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge57" class="edge"><title>56->57</title></g> <g id="node60"
    class="node"><title>59</title></g> <g id="edge59" class="edge"><title>58->59</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'By converting the derivation tree into a string, we get the represented string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`print()` does this implicitly, so `print`ing the solution gives us the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Unless you want to inspect the derivation tree or access its elements, converting
    it into a string makes it more manageable.</details>
  prefs: []
  type: TYPE_NORMAL
- en: To express a minimum numeric value, we can use a more elegant way. The function
    `str.to.int()`, for instance, converts a string into an integer. To obtain a page
    size that of at least 100000, we can thus also write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If we want the page size to be in the range of 100 to 200, we can state this
    as a logical conjunction (using `and`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And if we want the page size to be a multiple of seven, we can write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Quiz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which of the following constraints expresses that the page size and the buffer
    size have to be equal? Try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, ISLa constraints can also involve multiple elements. Expressing equality
    between two elements is easy, and uses a single equal sign. (There's no assignment
    in ISLa the `=` could be confused with.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use numerical constraints, stating that the buffer size should
    always be exactly one more than the page size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: All the above functions (like `str.to.int()`) actually stem from the *SMT-LIB*
    library for *satisfiability modulo theories* (SMT), a standard for expressing
    constraints for constraint solvers (like ISLa). The [list of all theories defined
    in SMT-LIB](https://smtlib.cs.uiowa.edu/theories.shtml) lists dozens of functions
    and predicates that can be used in ISLa constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Which constraints are necessary to ensure that all digits are between 1 and
    3? <details id="Excursion:-Using-SMT-LIB-Syntax"><summary>Using SMT-LIB Syntax</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the above "infix" syntax which is familiar to programmers, ISLa also
    supports full SMT-LIB syntax. Instead of writing $f(x_1, x_2, x_3, \dots)$ for
    a function $f$ and its arguments $x_1 \dots x_n$, SMT-LIB uses a "prefix" LISP-like
    syntax in which all functions and operators are written as $(f x_1 x_2 x_3 \dots)$.
    The above predicate would thus be written as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note that for boolean operators such as `and`, we still use the ISLa infix syntax;
    having ISLa handle these operators is more efficient than passing them on to the
    constraint solver.</details>
  prefs: []
  type: TYPE_NORMAL
- en: ISLa on the Command Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you install `isla-solver`, you also get an `isla` command-line tool. This
    allows you to create inputs from the command line or shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Let us first create a *grammar file* suitable for `isla`. `isla` accepts grammars
    in Fuzzingbook format; they need to define a variable named `grammar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can use `isla` as a grammar fuzzer, plain and simple By default,
    `isla solve` produces one single matching output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The true power of `isla`, however, comes to be as we (again) add *constraints*
    to be solved - either in separate *constraint files* or (easier) directly on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `isla` executable provides several options and commands, and is a great
    alternative on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Accessing Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have accessed nonterminals simply by referencing their name, as in
    `<bufsize>` or `<pagesize>`. However, in some cases, this simple method is not
    sufficient. In our configuration grammar, for instance, we may want to access
    (or constrain) `<int>` elements. However, we do not want to constrain *all* integers
    at once, but only those in a particular *context* – say, those that occur as a
    part of a `<pagesize>` element, or only those that occur as part of a `<config>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, ISLa allows referencing *parts* of a given element, using two special
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `<a>.<b>` refers to the *immediate* subpart `<b>` of some element
    `<a>`. That is, `<b>` has to appear in one of the expansion rules of `<a>`. For
    instance, `<pagesize>.<int>` refers to the `<int>` element of a page size. Here
    is an example using the dot operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The expression `<a>..<b>`, however, refers to *any* subpart `<b>` of some element
    `<a>`. That is, `<b>` can appear in the expansion of `<a>`, but also in the expansion
    of any subelement (and any subelement thereof). Here is an example using the double
    dot operator, enforcing *every* digit in a `<config>` element to be `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: To reason about dots and double dots, it helps to visualize the string in question
    as a *derivation tree* discussed in the [chapter on grammar-based fuzzing](GrammarFuzzer.html).
    The derivation tree of the input
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'for instance, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <svg width="405pt" height="324pt" viewBox="0.00 0.00 404.62 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="143.38"
    y="-302.45" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="143.38"
    y="-252.2" font-family="Times,serif" font-size="14.00"><config></text></g> <g
    id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="27.38" y="-201.95" font-family="Times,serif" font-size="14.00">pagesize=</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="104.38" y="-201.95" font-family="Times,serif" font-size="14.00"><pagesize></text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="182.38" y="-201.95" font-family="Times,serif" font-size="14.00">\nbufsize=</text></g>
    <g id="edge11" class="edge"><title>1->11</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="257.38" y="-201.95" font-family="Times,serif" font-size="14.00"><bufsize></text></g>
    <g id="edge12" class="edge"><title>1->12</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="104.38" y="-151.7" font-family="Times,serif" font-size="14.00"><int></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="42.38" y="-101.45" font-family="Times,serif" font-size="14.00"><leaddigit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="115.38" y="-101.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge7" class="edge"><title>4->7</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="42.38" y="-51.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="106.38" y="-51.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="168.38"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digits></text></g> <g id="edge10"
    class="edge"><title>7->10</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="106.38" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge9" class="edge"><title>8->9</title></g> <g id="node14"
    class="node"><title>13</title> <text text-anchor="middle" x="257.38" y="-151.7"
    font-family="Times,serif" font-size="14.00"><int></text></g> <g id="edge13" class="edge"><title>12->13</title></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="247.38"
    y="-101.45" font-family="Times,serif" font-size="14.00"><leaddigit></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="320.38" y="-101.45" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge16" class="edge"><title>13->16</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="247.38" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge15" class="edge"><title>14->15</title></g> <g id="node18"
    class="node"><title>17</title> <text text-anchor="middle" x="311.38" y="-51.2"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge17"
    class="edge"><title>16->17</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="373.38" y="-51.2" font-family="Times,serif" font-size="14.00"><digits></text></g>
    <g id="edge19" class="edge"><title>16->19</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="311.38" y="-0.95" font-family="Times,serif" font-size="14.00">4
    (52)</text></g> <g id="edge18" class="edge"><title>17->18</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: In this tree, the `.` syntax refers to *immediate* children. `<bufsize>.<int>`
    is the one `<int>` node that is the immediate descendant of `<bufsize>` (but not
    any other `<int>` node). In contrast, `<config>..<digit>` refers to *all* `<digit>`
    descendants of the `<config>` node.
  prefs: []
  type: TYPE_NORMAL
- en: If an element has multiple *immediate* children of the same type, one can use
    the special `<a>[$n$]` syntax to access the $n$-th child of type `<a>`. To access
    the first child, $n$ is equal to one, not zero, as in the [XPath abbreviated syntax](https://www.w3.org/TR/1999/REC-xpath-19991116/#path-abbrev).
    In our configuration grammar, there is no expansion including the same nonterminal
    more than once, so we do not need this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a demonstration of indexed dots, consider the following grammar, which
    produces lines of three "a" or "b" characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can force, say, the second character in a line to always be a "b:"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Quantifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all nonterminals in ISLa constraints are *universally* quantified
    - that is, any constraint applying to, say, some `<int>` element applies to *all*
    `<int>` elements in the resulting string. If you only want to constrain *one*
    element, though, you have to (and can) specify this in ISLa, using an *existential
    quantifier*.
  prefs: []
  type: TYPE_NORMAL
- en: To use an existential quantifier in ISLa, use the construct
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: where `VARIABLE` is some identifier, `TYPE` is its type (as a nonterminal),
    and `CONTEXT` is the context (again a nonterminal) in which the constraint should
    hold. `CONSTRAINT` is again a constraint expression, in which you now can make
    use of `VARIABLE` as the element whose existence you assume.
  prefs: []
  type: TYPE_NORMAL
- en: Let us illustrate existential quantification again using a simple example. We
    want to make sure that at least one integer in our generated string has a value
    of more than 1000. So we write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We note that all generated inputs satisfy the constraint of having at least
    one integer that satisfies the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a variable name is optional; if you omit it, you can use the quantified
    nonterminal instead. The above constraint can thus also be expressed in a more
    compact fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Besides existential quantification, there also is *universal* quantification,
    using the `forall` keyword instead of `exists`. If we want *all* elements in some
    context to satisfy a constraint, this comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We see that all `<int>` elements satisfy the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all nonterminals that are re-used directly in constraints are universally
    quantified within the `<start>` symbol, so the above can actually be simplified
    to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '... and you realize that in all our initial constraints, we always had an implicit
    universal quantification.'
  prefs: []
  type: TYPE_NORMAL
- en: Picking Expansions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we'd like a quantifier to apply only for a specific expansion alternative
    of a nonterminal. The form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: means that the CONSTRAINT only applies to a VARIABLE that actually matches the
    expansion given in PATTERN. (Again, we can replace `forall` with `exists`, and
    make this an existential quantification rather than a universal quantification.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using `forall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that when `<int>` is expanded to a lead digit followed by more
    digits, the lead digit becomes `7`. The effect is that all `<int>` values now
    start with a `7` digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can constrain `<int>` as a whole, and thus ensure that all numbers
    are greater than 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: By default, all variables are universally quantified in `<start>`, so the above
    can also be expressed as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Matching Expansion Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a quantification pattern, we can also *name* individual nonterminal elements
    and use them in our constraints. This is done by replacing the nonterminal `<ID>`
    with the special form `{<ID> VARIABLE}` (in curly braces) which then makes the
    variable `VARIABLE` a placeholder for the value matched by `ID`; `VARIABLE` can
    then be used in constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example. In the expansion `<leaddigit><int>`, we want to ensure
    that the `<leaddigit>` is always `9`. Using the special brace form, we make `lead`
    a variable holding the value of `<leaddigit>`, and can then use it in a constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'This (again) ensures that all lead digits should be `9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Could we express the above in a simpler fashion? Yes! For one, we can refer
    to `<leaddigit>` directly rather than introducing variables like `i` and `lead`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, using implicit universal quantification and the dot notation introduced
    earlier, we could write, for instance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: or just
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'and obtain the same result (not necessarily the exact same values, though,
    due to randomness):'
  prefs: []
  type: TYPE_NORMAL
- en: But while universal quantification and dot notation are sufficient for many
    cases, the pattern matching notation is more general and more flexible – even
    if it may be harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using an `ISLaSolver`, we can also check if an string satisfies the constraints.
    This can be applied to inputs, but also to *outputs*; ISLa constraints can thus
    server as *oracles* – that is, *predicates* that check a test result.
  prefs: []
  type: TYPE_NORMAL
- en: Let us check if in a given string, `<pagesize>` and `<bufsize>` are the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: To check the tree, we can pass it into the `evaluate()` method of the `solver`
    – and find that the given input does *not* satisfy our constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: If we repeat the above, however, with an input that satisfies the constraint,
    we obtain a `True` result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Checking constraints is much more efficient than solving them, as ISLa does
    not have to search for possible solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Case Studies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us further illustrate ISLa using a few case studies.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Identifiers in XML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Extensible Markup Language (XML) is a typical example of an input language
    that cannot be fully expressed using a context-free grammar. The problem is not
    so much expressing the *syntax* of XML – the basics are fairly easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 208.0 62" width="208.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="104.0" y="35">xml-tree</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 458.0 62" width="458.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="104.0" y="35">open-tag</text></g>
    <g class="non-terminal"><text x="224.75" y="35">xml-content</text></g> <g class="non-terminal"><text
    x="349.75" y="35">close-tag</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 254.0 62" width="254.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g>
    <g class="non-terminal"><text x="127.0" y="35">id</text></g> <g class="terminal"><text
    x="179.75" y="35">></text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 262.5 62" width="262.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="78.5" y="35"></</text></g>
    <g class="non-terminal"><text x="135.5" y="35">id</text></g> <g class="terminal"><text
    x="188.25" y="35">></text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 208.0 92" width="208.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="104.0" y="35">Text</text></g></g>
    <g><g class="non-terminal"><text x="104.0" y="65">xml-tree</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 248.0 92" width="248.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="124.0" y="35">letter</text></g></g>
    <g><g class="non-terminal"><text x="78.5" y="65">id</text></g> <g class="non-terminal"><text
    x="152.5" y="65">letter</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="198" viewBox="0 0 611.0 198" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="73">b</text></g></g>
    <g><g class="terminal"><text x="84.25" y="43">a</text></g></g> <g><g class="terminal"><text
    x="84.25" y="103">c</text></g></g> <g><g class="terminal"><text x="84.25" y="133">d</text></g></g>
    <g><g class="terminal"><text x="84.25" y="163">e</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="73">g</text></g></g> <g><g class="terminal"><text x="172.75" y="43">f</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">h</text></g></g> <g><g class="terminal"><text
    x="172.75" y="133">i</text></g></g> <g><g class="terminal"><text x="172.75" y="163">j</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="73">l</text></g></g> <g><g class="terminal"><text
    x="261.25" y="43">k</text></g></g> <g><g class="terminal"><text x="261.25" y="103">m</text></g></g>
    <g><g class="terminal"><text x="261.25" y="133">n</text></g></g> <g><g class="terminal"><text
    x="261.25" y="163">o</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="73">q</text></g></g> <g><g class="terminal"><text x="349.75" y="43">p</text></g></g>
    <g><g class="terminal"><text x="349.75" y="103">r</text></g></g> <g><g class="terminal"><text
    x="349.75" y="133">s</text></g></g> <g><g class="terminal"><text x="349.75" y="163">t</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="73">v</text></g></g> <g><g class="terminal"><text
    x="438.25" y="43">u</text></g></g> <g><g class="terminal"><text x="438.25" y="103">w</text></g></g>
    <g><g class="terminal"><text x="438.25" y="133">x</text></g></g> <g><g class="terminal"><text
    x="438.25" y="163">y</text></g></g></g> <g><g><g class="terminal"><text x="526.75"
    y="103">z</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem becomes evident when we produce inputs from the grammar: The `<id>`
    elements in `<open-tag>` and `<close-tag>` do not match.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: If we want the tag IDs to match, we need to come up with a *finite* set of tags
    (as in, say, HTML); then we can extend the grammar with one rule for each tag
    - `<body>...</body>`, `<p>...</p>`, `<strong>...</strong>`, and so on. For an
    *infinite* set of tags, though, as in our grammar, expressing that the two tag
    IDs must match is not possible in a context-free grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'With ISLa, however, constraining the grammar is easy. All we need is the rule
    that constrains the `<xml-tree>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: and we see that the `<id>` tags now indeed match each other.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Solver-Configuration-Parameters"><summary>Solver Configuration
    Parameters</summary>
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration parameter `max_number_smt_instantiations` we passed to the
    `ISLaSolver` object above limits the number of calls to ISLa''s underlying SMT
    solver. Generally, higher numbers lead to more inputs generated per time. Many
    of those will look structurally similar, though. If we aim for structurally diverse
    inputs and do not care about, e.g., the names of tags, it can make sense to choose
    a lower value for this parameter. This is what happens with `max_number_smt_instantiations=10`,
    which is the current default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameter `max_number_free_instantiations` serves a similar purpose: ISla
    randomly instantiates nonterminal symbols whose values are not restricted by a
    constraint. It chooses—surprise!—at most `max_number_free_instantiations` such
    random instantiations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other configuration parameters of interest are `structural_predicates` and
    `semantic_predicates`, which let you extend the ISLa language by passing custom
    structural and semantic predicates to the solver. You can use all the predicates
    in these sets inside the ISLa constraint to solve. Per default, the semantic predicate
    `count(in_tree, NEEDLE, NUM)` and the following structural predicates are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`after(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`consecutive(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count(in_tree, NEEDLE, NUM)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`different_position(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`direct_child(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inside(node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`level(PRED, NONTERMINAL, node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nth(N, node_1, node_2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`same_position(node_1, node_2)`</details>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In contrast to the "input generator" solution in the [chapter on generators](GeneratorGrammarFuzzer),
    our constraint-based solution is purely declarative - and can also be used to
    parse and check inputs. Plus, of course, we can easily add more constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Definitions and Usages in Programming Languages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When testing compilers with generated program code, one often encounters the
    problem that before *using* an identifier, one has to *declare* it first - specifying
    its type, some initial value, and more.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is easily illustrated in the following grammar, which produces
    *sequences of assignments*. Variable names consist of a single lowercase letter;
    values can only be digits; assignments are separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">stmt</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 313.5 92" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="156.75" y="35">assgn</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">assgn</text></g> <g class="terminal"><text
    x="161.0" y="65">;</text></g> <g class="non-terminal"><text x="226.5" y="65">stmt</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 305.0 62" width="305.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">lhs</text></g>
    <g class="terminal"><text x="152.5" y="35">:=</text></g> <g class="non-terminal"><text
    x="222.25" y="35">rhs</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 165.5 62" width="165.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="82.75" y="35">var</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 182.5 92" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">var</text></g></g>
    <g><g class="non-terminal"><text x="91.25" y="65">digit</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="198" viewBox="0 0 611.0 198" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="73">b</text></g></g>
    <g><g class="terminal"><text x="84.25" y="43">a</text></g></g> <g><g class="terminal"><text
    x="84.25" y="103">c</text></g></g> <g><g class="terminal"><text x="84.25" y="133">d</text></g></g>
    <g><g class="terminal"><text x="84.25" y="163">e</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="73">g</text></g></g> <g><g class="terminal"><text x="172.75" y="43">f</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">h</text></g></g> <g><g class="terminal"><text
    x="172.75" y="133">i</text></g></g> <g><g class="terminal"><text x="172.75" y="163">j</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="73">l</text></g></g> <g><g class="terminal"><text
    x="261.25" y="43">k</text></g></g> <g><g class="terminal"><text x="261.25" y="103">m</text></g></g>
    <g><g class="terminal"><text x="261.25" y="133">n</text></g></g> <g><g class="terminal"><text
    x="261.25" y="163">o</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="73">q</text></g></g> <g><g class="terminal"><text x="349.75" y="43">p</text></g></g>
    <g><g class="terminal"><text x="349.75" y="103">r</text></g></g> <g><g class="terminal"><text
    x="349.75" y="133">s</text></g></g> <g><g class="terminal"><text x="349.75" y="163">t</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="73">v</text></g></g> <g><g class="terminal"><text
    x="438.25" y="43">u</text></g></g> <g><g class="terminal"><text x="438.25" y="103">w</text></g></g>
    <g><g class="terminal"><text x="438.25" y="133">x</text></g></g> <g><g class="terminal"><text
    x="438.25" y="163">y</text></g></g></g> <g><g><g class="terminal"><text x="526.75"
    y="103">z</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some assignment sequences produced by the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: We see that the assignment *syntax* is similar to what we have in common programming
    languages. The *semantics*, however, are, well, questionable, as we commonly access
    variables whose values have not been previously defined. Again, this is a *semantic*
    property that cannot be expressed in a context-free grammar alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need here is a constraint specifying that on the right-hand side of
    an assignment, we can only have variable names that occur on the left-hand side.
    In ISLa, we achieve this through the following constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This is much better already, but not perfect yet - we might still have assignments
    like `a := a` or `a := b; b := 5`. That is because our constraints do not yet
    take care of *ordering* – in a `<rhs>` element, we can only use variables that
    are defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, ISLa provides a `before()` predicate: `before(A, B)` expresses
    that the element `A` must occur before the element `B`. With `before()`, we can
    rewrite our constraint as'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '... and thus ensure that on the right-hand-side of assignments, we only use
    identifiers defined earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: In case you find that the assignment sequences are too short, you can use the
    ISLa `count()` predicate. `count(VARIABLE, NONTERMINAL, N)` ensures that the number
    of NONTERMINALs in VARIABLE is exactly N. To have statements with exactly 5 assignments,
    write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using ISLa, we can add and solve *constraints* to grammars, allowing to express
    *semantic properties* of our test inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring constraints (and have a solver solve them) is much more versatile
    than adding generator code, and language-independent, too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ISLa is fun :-)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next chapters, we will continue to focus on semantics. Among others,
    we will learn how to
  prefs: []
  type: TYPE_NORMAL
- en: '[mine grammars from existing inputs](GrammarMiner.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use [symbolic fuzzing](SymbolicFuzzer.html) - that is, using constraint solvers
    to reach particular locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: use [concolic fuzzing](ConcolicFuzzer.html) - that is, combining symbolic fuzzing
    with concrete runs for higher efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ISLa is presented in the paper ["Input Invariants"](https://publications.cispa.saarland/3596/)
    at ESEC/FSE 2022.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [ISLa project](https://github.com/rindPHI/isla) contains the full source
    code and a complete reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: String Encodings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common way of representing strings is *length-prefixed strings*, a representation
    made popular by the *PASCAL* programming language. A length-prefixed string starts
    with a few bytes that encode the length $L$ of the string, followed by the $L$
    actual characters. For instance, assuming that two bytes are used to encode the
    length, the string `"Hello"` could be represented as the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 1: Syntax'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a grammar that defines the syntax of length-prefixed strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/FuzzingWithConstraints.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Semantics'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use ISLa to produce valid length-prefixed strings. Make use of the [SMT-LIB
    string library](https://smtlib.cs.uiowa.edu/theories-UnicodeStrings.shtml) to
    find appropriate conversion functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/FuzzingWithConstraints.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/FuzzingWithConstraints.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing with Constraints](https://www.fuzzingbook.org/html/FuzzingWithConstraints.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/FuzzingWithConstraints.html](https://www.fuzzingbook.org/html/FuzzingWithConstraints.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
