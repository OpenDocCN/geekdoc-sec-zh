- en: Code Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/Coverage.html](http://www.fuzzingbook.org/html/Coverage.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the [previous chapter](Fuzzer.html), we introduced *basic fuzzing* – that
    is, generating random inputs to test programs. How do we measure the effectiveness
    of these tests? One way would be to check the number (and seriousness) of bugs
    found; but if bugs are scarce, we need a *proxy for the likelihood of a test to
    uncover a bug.* In this chapter, we introduce the concept of *code coverage*,
    measuring which parts of a program are actually executed during a test run. Measuring
    such coverage is also crucial for test generators that attempt to cover as much
    code as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You need some understanding of how a program is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have learned about basic fuzzing in the [previous chapter](Fuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces a `Coverage` class allowing you to measure coverage
    for Python programs. Within the context of this book, we use coverage information
    to guide fuzzing towards uncovered locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical usage of the `Coverage` class is in conjunction with a `with` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Printing out a coverage object shows the covered functions, with non-covered
    lines prefixed with `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `trace()` method returns the *trace* – that is, the list of locations executed
    in order. Each location comes as a pair (`function name`, `line`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `coverage()` method returns the *coverage*, that is, the set of locations
    in the trace executed at least once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Coverage sets can be subject to set operations, such as *intersection* (which
    locations are covered in multiple executions) and *difference* (which locations
    are covered in run *a*, but not *b*).
  prefs: []
  type: TYPE_NORMAL
- en: The chapter also discusses how to obtain such coverage from C programs.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="258pt" height="145pt" viewBox="0.00 0.00 257.62 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>Coverage</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class Coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: Track coverage within a `with` block. Use as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]"><text text-anchor="start" x="27.12" y="-120.2" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Coverage</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="Coverage"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__enter__(self) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start of `with` block. Turn on tracing."><text text-anchor="start" x="8" y="-98"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__enter__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="__exit__(self, exc_type: Type, exc_value: BaseException, tb: traceback)
    -> Optional[bool]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'End of `with` block. Turn off tracing."><text text-anchor="start" x="8" y="-85.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__exit__()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="8" y="-72.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__repr__(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: Return a string representation of this object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Show covered (and uncovered) program code"><text text-anchor="start" x="8"
    y="-59.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">__repr__()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="coverage(self) -> Set[Location]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of executed lines, as (function_name, line_number) pairs"><text text-anchor="start"
    x="8" y="-47" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">coverage()</text></a></g> <g id="a_node1_6"><a
    xlink:href="#" xlink:title="function_names(self) -> Set[str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The set of function names seen"><text text-anchor="start" x="8" y="-34.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">function_names()</text></a></g> <g id="a_node1_7"><a xlink:href="#"
    xlink:title="trace(self) -> List[Location]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of executed lines, as (function_name, line_number) pairs"><text text-anchor="start"
    x="8" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">trace()</text></a></g> <g id="a_node1_8"><a
    xlink:href="#" xlink:title="traceit(self, frame: frame, event: str, arg: Any)
    -> Optional[Callable]:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing function. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-8.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-style="italic" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Legend</title> <text text-anchor="start" x="130.38"
    y="-84.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="130.38" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="136.38" y="-74.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="130.38" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="136.38" y="-64.5" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="130.38" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="136.38" y="-54.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="130.38" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A CGI Decoder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by introducing a simple Python function that decodes a CGI-encoded
    string. CGI encoding is used in URLs (i.e., Web addresses) to encode characters
    that would be invalid in a URL, such as blanks and certain punctuation:'
  prefs: []
  type: TYPE_NORMAL
- en: Blanks are replaced by `'+'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other invalid characters are replaced by '`%xx`', where `xx` is the two-digit
    hexadecimal equivalent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In CGI encoding, the string `"Hello, world!"` would thus become `"Hello%2c+world%21"`
    where `2c` and `21` are the hexadecimal equivalents of `','` and `'!'`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The function `cgi_decode()` takes such an encoded string and decodes it back
    to its original form. Our implementation replicates the code from [[Pezzè *et
    al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]. (It even includes its bugs
    – but we won't reveal them at this point.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how `cgi_decode()` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If we want to systematically test `cgi_decode()`, how would we proceed?
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing literature distinguishes two ways of deriving tests: *Black-box
    testing* and *White-box testing.*'
  prefs: []
  type: TYPE_NORMAL
- en: Black-Box Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of *black-box testing* is to derive tests from the *specification*.
    In the above case, we thus would have to test `cgi_decode()` by the features specified
    and documented, including
  prefs: []
  type: TYPE_NORMAL
- en: testing for correct replacement of `'+'`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: testing for correct replacement of `"%xx"`;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: testing for non-replacement of other characters; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: testing for recognition of illegal inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are four assertions (tests) that cover these four features. We can see
    that they all pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of black-box testing is that it finds errors in the *specified*
    behavior. It is independent of a given implementation, and thus allows creating
    tests even before implementation. The downside is that *implemented* behavior
    typically covers more ground than *specified* behavior, and thus tests based on
    specification alone typically do not cover all implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: White-Box Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to black-box testing, *white-box testing* derives tests from the
    *implementation*, notably the internal structure. White-Box testing is closely
    tied to the concept of *covering* structural features of the code. If a statement
    in the code is not executed during testing, for instance, this means that an error
    in this statement cannot be triggered either. White-Box testing thus introduces
    a number of *coverage criteria* that have to be fulfilled before the test can
    be said to be sufficient. The most frequently used coverage criteria are
  prefs: []
  type: TYPE_NORMAL
- en: '*Statement coverage* – each statement in the code must be executed by at least
    one test input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Branch coverage* – each branch in the code must be taken by at least one test
    input. (This translates to each `if` and `while` decision once being true, and
    once being false.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides these, there are far more coverage criteria, including sequences of
    branches taken, loop iterations taken (zero, one, many), data flows between variable
    definitions and usages, and many more; [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]
    has a great overview.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider `cgi_decode()`, above, and reason what we have to do such that
    each statement of the code is executed at least once. We'd have to cover
  prefs: []
  type: TYPE_NORMAL
- en: The block following `if c == '+'`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two blocks following `if c == '%'` (one for valid input, one for invalid)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final `else` case for all other characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This results in the same conditions as with black-box testing, above; again,
    the assertions above indeed would cover every statement in the code. Such a correspondence
    is actually pretty common, since programmers tend to implement different behaviors
    in different code locations; and thus, covering these locations will lead to test
    cases that cover the different (specified) behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of white-box testing is that it finds errors in *implemented*
    behavior. It can be conducted even in cases where the specification does not provide
    sufficient details; actually, it helps in identifying (and thus specifying) corner
    cases in the specification. The downside is that it may miss *non-implemented*
    behavior: If some specified functionality is missing, white-box testing will not
    find it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing Executions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One nice feature of white-box testing is that one can actually automatically
    assess whether some program feature was covered. To this end, one *instruments*
    the execution of the program such that during execution, a special functionality
    keeps track of which code was executed. After testing, this information can be
    passed to the programmer, who can then focus on writing tests that cover the yet
    uncovered code.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, it is rather difficult to set up programs such
    that one can trace their execution. Not so in Python. The function `sys.settrace(f)`
    allows defining a *tracing function* `f()` that is called for each and every line
    executed. Even better, it gets access to the current function and its name, current
    variable contents, and more. It is thus an ideal tool for *dynamic analysis* –
    that is, the analysis of what actually happens during an execution.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how this works, let us again look into a specific execution of
    `cgi_decode()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To track how the execution proceeds through `cgi_decode()`, we make use of
    `sys.settrace()`. First, we define the *tracing function* that will be called
    for each line. It has three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `frame` parameter gets you the current *frame*, allowing access to the
    current location and variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame.f_code` is the currently executed code with `frame.f_code.co_name` being
    the function name;'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame.f_lineno` holds the current line number; and'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frame.f_locals` holds the current local variables and arguments.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `event` parameter is a string with values including `"line"` (a new line
    has been reached) or `"call"` (a function is being called).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `arg` parameter is an additional *argument* for some events; for `"return"`
    events, for instance, `arg` holds the value being returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the tracing function for simply reporting the current line executed,
    which we access through the `frame` argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can switch tracing on and off with `sys.settrace()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When we compute `cgi_decode("a+b")`, we can now see how the execution progresses
    through `cgi_decode()`. After the initialization of `hex_values`, `t`, and `i`,
    we see that the `while` loop is taken three times – one for every character in
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Which lines are these, actually? To this end, we get the source code of `cgi_decode_code`
    and encode it into an array `cgi_decode_lines`, which we will then annotate with
    coverage information. First, let us get the source code of `cgi_encode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`cgi_decode_code` is a string holding the source code. We can print it out
    with Python syntax highlighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Using `splitlines()`, we split the code into an array of lines, indexed by line
    number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`cgi_decode_lines[L]` is line L of the source code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We see that the first line (9) executed is actually the initialization of `hex_values`...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '... followed by the initialization of `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To see which lines actually have been covered at least once, we can convert
    `coverage` into a set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Let us print out the full code, annotating lines not covered with `#`. The idea
    of such an annotation is to direct developer's attention to the non-covered lines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We see that a number of lines (notably comments) have not been executed (marked
    with `#`), simply because they are not executable. However, we also see that the
    lines under `elif c == '%'` have *not* been executed yet. If `"a+b"` were our
    only test case so far, this missing coverage would now encourage us to create
    another test case that actually covers these `#`-marked lines.
  prefs: []
  type: TYPE_NORMAL
- en: A Coverage Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we will make use of coverage again and again – to *measure* the
    effectiveness of different test generation techniques, but also to *guide* test
    generation towards code coverage. Our previous implementation with a global `coverage`
    variable is a bit cumbersome for that. We therefore implement some functionality
    that will help us measure coverage easily.
  prefs: []
  type: TYPE_NORMAL
- en: The key idea of getting coverage is to make use of the Python `with` statement.
    The general form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'executes `BODY` with `OBJECT` being defined (and stored in `VARIABLE`). The
    interesting thing is that at the beginning and end of `BODY`, the special methods
    `OBJECT.__enter__()` and `OBJECT.__exit__()` are automatically invoked; even if
    `BODY` raises an exception. This allows us to define a `Coverage` object where
    `Coverage.__enter__()` automatically turns on tracing and `Coverage.__exit__()`
    automatically turns off tracing again. After tracing, we can make use of special
    methods to access the coverage. This is what this looks like during usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, tracing is automatically turned on during `function_to_be_traced()` and
    turned off again after the `with` block; afterwards, we can access the set of
    lines executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the full implementation with all its bells and whistles. You don''t
    have to get everything; it suffices that you know how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'with Coverage() as cov:'
  prefs: []
  type: TYPE_NORMAL
- en: function_to_be_traced()
  prefs: []
  type: TYPE_NORMAL
- en: c = cov.coverage()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us put this to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `Coverage()` class not only keeps track of lines executed,
    but also of function names. This is useful if you have a program that spans multiple
    files.
  prefs: []
  type: TYPE_NORMAL
- en: For interactive use, we can simply print the coverage object, and obtain a listing
    of the code, again with non-covered lines marked as `#`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Comparing Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we represent coverage as a set of executed lines, we can also apply *set
    operations* on these. For instance, we can find out which lines are covered by
    individual test cases, but not others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is the single line in the code that is executed only in the `'a+b'` input.
  prefs: []
  type: TYPE_NORMAL
- en: We can also compare sets to find out which lines still need to be covered. Let
    us define `cov_max` as the maximum coverage we can achieve. (Here, we do this
    by executing the "good" test cases we already have. In practice, one would statically
    analyze code structure, which we introduce in [the chapter on symbolic testing](SymbolicFuzzer.html).)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can easily see which lines are *not* yet covered by a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Again, these would be the lines handling `"%xx"`, which we have not yet had
    in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage of Basic Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can now use our coverage tracing to assess the *effectiveness* of testing
    methods – in particular, of course, test *generation* methods. Our challenge is
    to achieve maximum coverage in `cgi_decode()` just with random inputs. In principle,
    we should *eventually* get there, as eventually, we will have produced every possible
    string in the universe – but exactly how long is this? To this end, let us run
    just one fuzzing iteration on `cgi_decode()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here's the invocation and the coverage we achieve. We wrap `cgi_decode()` in
    a `try...except` block such that we can ignore `ValueError` exceptions raised
    by illegal `%xx` formats.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Is this already the maximum coverage? Apparently, there are still lines missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Let us try again, increasing coverage over 100 random inputs. We use an array
    `cumulative_coverage` to store the coverage achieved over time; `cumulative_coverage[0]`
    is the total number of lines covered after input 1, `cumulative_coverage[1]` is
    the number of lines covered after inputs 1–2, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a hundred inputs to determine how coverage increases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the coverage increases with each input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7f85ddc0f1be2fe0c842da522e4813aa.png)'
  prefs: []
  type: TYPE_IMG
- en: This is just *one* run, of course; so let's repeat this a number of times and
    plot the averages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f2d46e8b77194e72700415b64304b9aa.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that on average, we get full coverage after 40–60 fuzzing inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Coverage from External Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, not all the world is programming in Python. The good news is that
    the problem of obtaining coverage is ubiquitous, and almost every programming
    language has some facility to measure coverage. Just as an example, let us therefore
    demonstrate how to obtain coverage for a C program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our C program (again) implements `cgi_decode`; this time as a program to be
    executed from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes the C code, first as a Python string. We start with the usual C
    includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes the initialization of `hex_values`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the actual implementation of `cgi_decode()`, using pointers for input
    source (`s`) and output target (`t`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s a driver which takes the first argument and invokes `cgi_decode`
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create the C source code: (Note that the following commands will overwrite
    the file `cgi_decode.c`, if it already exists in the current working directory.
    Be aware of this, if you downloaded the notebooks and are working locally.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we have the C code with its syntax highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We can now compile the C code into an executable. The `--coverage` option instructs
    the C compiler to instrument the code such that at runtime, coverage information
    will be collected. (The exact options vary from compiler to compiler.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When we now execute the program, coverage information will automatically be
    collected and stored in auxiliary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The coverage information is collected by the `gcov` program. For every source
    file given, it produces a new `.gcov` file with coverage information. This is
    either stored in `cgi_decode...` or in `cgi_decode-cgi_decode...` files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In the `.gcov` file, each line is prefixed with the number of times it was called
    (`-` stands for a non-executable line, `#####` stands for zero) as well as the
    line number. We can take a look at `cgi_decode()`, for instance, and see that
    the only code not executed yet is the `return -1` for an illegal input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us read in this file to obtain a coverage set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: With this set, we can now do the same coverage computations as with our Python
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Errors with Basic Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given sufficient time, we can indeed cover each and every line within `cgi_decode()`,
    whatever the programming language would be. This does not mean that they would
    be error-free, though. Since we do not check the result of `cgi_decode()`, the
    function could return any value without us checking or noticing. To catch such
    errors, we would have to set up a *results checker* (commonly called an *oracle*)
    that would verify test results. In our case, we could compare the C and Python
    implementations of `cgi_decode()` and see whether both produce the same results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Where fuzzing is great at, though, is in finding *internal errors* that can
    be detected even without checking the result. Actually, if one runs our `fuzzer()`
    on `cgi_decode()`, one quickly finds such an error, as the following code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it is possible to cause `cgi_decode()` to crash. Why is that? Let''s take
    a look at its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is at the end of the string. After a `'%'` character, our implementation
    will always attempt to access two more (hexadecimal) characters, but if these
    are not there, we will get an `IndexError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is also present in our C variant, which inherits it from the original
    implementation [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Here, `s` is a pointer to the character to be read; `++` increments it by one
    character. In the C implementation, the problem is actually much worse. If the
    `'%'` character is at the end of the string, the above code will first read a
    terminating character (`'\0'` in C strings) and then the following character,
    which may be any memory content after the string, and which thus may cause the
    program to fail uncontrollably. The somewhat good news is that `'\0'` is not a
    valid hexadecimal character, and thus, the C version will "only" read one character
    beyond the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly enough, none of the manual tests we had designed earlier would
    trigger this bug. Actually, neither statement nor branch coverage, nor any of
    the coverage criteria commonly discussed in literature would find it. However,
    a simple fuzzing run can identify the error with a few runs – *if* appropriate
    run-time checks are in place that find such overflows. This definitely calls for
    more fuzzing!
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coverage metrics are a simple and fully automated means to approximate how much
    functionality of a program is actually executed during a test run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number of coverage metrics exist, the most important ones being statement
    coverage and branch coverage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, it is very easy to access the program state during execution, including
    the currently executed code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of the day, let''s clean up: (Note that the following commands will
    delete all files in the current working directory that fit the pattern `cgi_decode.*`.
    Be aware of this, if you downloaded the notebooks and are working locally.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coverage is not only a tool to *measure* test effectiveness, but also a great
    tool to *guide* test generation towards specific goals – in particular uncovered
    code. We use coverage to
  prefs: []
  type: TYPE_NORMAL
- en: '[guide *mutations* of existing inputs towards better coverage in the chapter
    on mutation fuzzing](MutationFuzzer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coverage is a central concept in systematic software testing. For discussions,
    see the books in the [Introduction to Testing](Intro_Testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Fixing `cgi_decode()`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create an appropriate test to reproduce the `IndexError` discussed above. Fix
    `cgi_decode()` to prevent the bug. Show that your test (and additional `fuzzer()`
    runs) no longer expose the bug. Do the same for the C variant.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Branch Coverage'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides statement coverage, *branch coverage* is one of the most frequently
    used criteria to determine the quality of a test. In a nutshell, branch coverage
    measures how many *control decisions* are made in code. In the statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: for instance, both the cases where `CONDITION` is true (branching to `do_a()`)
    and where `CONDITION` is false (branching to `do_b()`) have to be covered. This
    holds for all control statements with a condition (`if`, `while`, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: 'How is branch coverage different from statement coverage? In the above example,
    there is actually no difference. In this one, though, there is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Using statement coverage, a single test case where `CONDITION` is true suffices
    to cover the call to `do_a()`. Using branch coverage, however, we would also have
    to create a test case where `do_a()` is *not* invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using our `Coverage` infrastructure, we can simulate branch coverage by considering
    *pairs of subsequent lines executed*. The `trace()` method gives us the list of
    lines executed one after the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 1: Compute branch coverage'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Define a function `branch_coverage()` that takes a trace and returns the set
    of pairs of subsequent lines in a trace – in the above example, this would be
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Bonus for advanced Python programmers: Define `BranchCoverage` as a subclass
    of `Coverage` and make `branch_coverage()` as above a `coverage()` method of `BranchCoverage`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Comparing statement coverage and branch coverage'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Use `branch_coverage()` to repeat the experiments in this chapter with branch
    coverage rather than statement coverage. Do the manually written test cases cover
    all branches?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Average coverage'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Again, repeat the above experiments with branch coverage. Does `fuzzer()` cover
    all branches, and if so, how many tests does it take on average?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:28:17+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Coverage.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Code Coverage](https://www.fuzzingbook.org/html/Coverage.html)". In
    Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler,
    "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Coverage.html](https://www.fuzzingbook.org/html/Coverage.html).
    Retrieved 2024-11-09 17:28:17+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
