- en: Code Coverage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: 原文：[http://www.fuzzingbook.org/html/Coverage.html](http://www.fuzzingbook.org/html/Coverage.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/Coverage.html](http://www.fuzzingbook.org/html/Coverage.html)
- en: In the [previous chapter](Fuzzer.html), we introduced *basic fuzzing* – that
    is, generating random inputs to test programs. How do we measure the effectiveness
    of these tests? One way would be to check the number (and seriousness) of bugs
    found; but if bugs are scarce, we need a *proxy for the likelihood of a test to
    uncover a bug.* In this chapter, we introduce the concept of *code coverage*,
    measuring which parts of a program are actually executed during a test run. Measuring
    such coverage is also crucial for test generators that attempt to cover as much
    code as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一章](Fuzzer.html)中，我们介绍了*基本模糊测试*——即生成随机输入来测试程序。我们如何衡量这些测试的有效性呢？一种方法就是检查找到的（数量和严重性）错误；但如果错误很少，我们需要一个*测试发现错误的概率的代理*。在本章中，我们引入了*代码覆盖率*的概念，测量在测试运行期间程序的实际执行部分。测量这种覆盖率对于试图覆盖尽可能多代码的测试生成器来说也非常关键。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You need some understanding of how a program is executed.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要了解程序是如何执行的。
- en: You should have learned about basic fuzzing in the [previous chapter](Fuzzer.html).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该在[上一章](Fuzzer.html)中学习过基本模糊测试。
- en: Synopsis
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要[使用本章提供的代码](Importing.html)，请编写
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and then make use of the following features.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: This chapter introduces a `Coverage` class allowing you to measure coverage
    for Python programs. Within the context of this book, we use coverage information
    to guide fuzzing towards uncovered locations.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一个`Coverage`类，允许你测量Python程序的覆盖率。在本书的上下文中，我们使用覆盖率信息来引导模糊测试向未覆盖的位置发展。
- en: 'The typical usage of the `Coverage` class is in conjunction with a `with` clause:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Coverage`类的典型用法是与`with`子句结合使用：'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Printing out a coverage object shows the covered functions, with non-covered
    lines prefixed with `#`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出覆盖率对象显示了覆盖的函数，未覆盖的行以`#`为前缀：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `trace()` method returns the *trace* – that is, the list of locations executed
    in order. Each location comes as a pair (`function name`, `line`).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`trace()`方法返回*跟踪*——即按顺序执行的代码位置列表。每个位置都作为一对（`函数名`，`行`）出现。'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `coverage()` method returns the *coverage*, that is, the set of locations
    in the trace executed at least once:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage()`方法返回*覆盖率*，即至少执行一次的跟踪中的位置集合：'
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Coverage sets can be subject to set operations, such as *intersection* (which
    locations are covered in multiple executions) and *difference* (which locations
    are covered in run *a*, but not *b*).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖集可以受到集合操作的影响，例如*交集*（哪些位置在多次执行中被覆盖）和*差集*（哪些位置在运行*a*中被覆盖，但在*b*中没有）。
- en: The chapter also discusses how to obtain such coverage from C programs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还讨论了如何从C程序中获取此类覆盖率。
- en: '<svg width="258pt" height="145pt" viewBox="0.00 0.00 257.62 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>Coverage</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class Coverage:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="258pt" height="145pt" viewBox="0.00 0.00 257.62 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>覆盖率</title> <g id="a_node1"><a xlink:href="#" xlink:title="class
    Coverage:'
- en: Track coverage within a `with` block. Use as
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`块内跟踪覆盖率。使用如下
- en: '[PRE6]"><text text-anchor="start" x="27.12" y="-120.2" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Coverage</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="Coverage"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__enter__(self) -> Any:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE6]"><text text-anchor="start" x="27.12" y="-120.2" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">覆盖率</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="Coverage"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__enter__(self) -> Any:'
- en: 'Start of `with` block. Turn on tracing."><text text-anchor="start" x="8" y="-98"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__enter__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="__exit__(self, exc_type: Type, exc_value: BaseException, tb: traceback)
    -> Optional[bool]:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`块的开始。开启跟踪。"><text text-anchor="start" x="8" y="-98" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__enter__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="__exit__(self, exc_type: Type,
    exc_value: BaseException, tb: traceback) -> Optional[bool]:'
- en: 'End of `with` block. Turn off tracing."><text text-anchor="start" x="8" y="-85.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__exit__()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="__init__(self) -> None:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`块结束。关闭跟踪。"><text text-anchor="start" x="8" y="-85.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__exit__()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="__init__(self) -> None:'
- en: 'Constructor"><text text-anchor="start" x="8" y="-72.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__repr__(self) -> str:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数"><text text-anchor="start" x="8" y="-72.5" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__exit__(self) -> None:'
- en: Return a string representation of this object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 返回此对象的字符串表示。
- en: 'Show covered (and uncovered) program code"><text text-anchor="start" x="8"
    y="-59.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">__repr__()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="coverage(self) -> Set[Location]:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '显示覆盖（和未覆盖）的程序代码"><text text-anchor="start" x="8" y="-59.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__repr__()</text></a></g>
    <g id="a_node1_5"><a xlink:href="#" xlink:title="coverage(self) -> Set[Location]:'
- en: 'The set of executed lines, as (function_name, line_number) pairs"><text text-anchor="start"
    x="8" y="-47" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">coverage()</text></a></g> <g id="a_node1_6"><a
    xlink:href="#" xlink:title="function_names(self) -> Set[str]:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '执行的行列表，作为（函数名称，行号）对"><text text-anchor="start" x="8" y="-47" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">coverage()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="function_names(self) -> Set[str]:'
- en: 'The set of function names seen"><text text-anchor="start" x="8" y="-34.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">function_names()</text></a></g> <g id="a_node1_7"><a xlink:href="#"
    xlink:title="trace(self) -> List[Location]:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '在函数名称集合中看到的`function_names()`"><text text-anchor="start" x="8" y="-34.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">function_names()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="trace(self) -> List[Location]:'
- en: 'The list of executed lines, as (function_name, line_number) pairs"><text text-anchor="start"
    x="8" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">trace()</text></a></g> <g id="a_node1_8"><a
    xlink:href="#" xlink:title="traceit(self, frame: frame, event: str, arg: Any)
    -> Optional[Callable]:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '执行的行列表，作为（函数名称，行号）对"><text text-anchor="start" x="8" y="-21.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">trace()</text></a></g>
    <g id="a_node1_8"><a xlink:href="#" xlink:title="traceit(self, frame: frame, event:
    str, arg: Any) -> Optional[Callable]:'
- en: Tracing function. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-8.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-style="italic" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Legend</title> <text text-anchor="start" x="130.38"
    y="-84.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="130.38" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="136.38" y="-74.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="130.38" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="136.38" y="-64.5" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="130.38" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="136.38" y="-54.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="130.38" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪函数。在子类中重载。"><text text-anchor="start" x="8" y="-8.75" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>图例</title> <text text-anchor="start" x="130.38"
    y="-84.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">图例</text> <text text-anchor="start" x="130.38" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="136.38" y="-74.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="130.38" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="136.38" y="-64.5" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="130.38" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="136.38" y="-54.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="130.38" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A CGI Decoder
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CGI 解码器
- en: 'We start by introducing a simple Python function that decodes a CGI-encoded
    string. CGI encoding is used in URLs (i.e., Web addresses) to encode characters
    that would be invalid in a URL, such as blanks and certain punctuation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍一个简单的 Python 函数，该函数解码 CGI 编码的字符串。CGI 编码用于 URL（即 Web 地址）中，以编码在 URL 中无效的字符，例如空白和某些标点符号：
- en: Blanks are replaced by `'+'`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空白将被替换为 `'+'`
- en: Other invalid characters are replaced by '`%xx`', where `xx` is the two-digit
    hexadecimal equivalent.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他无效字符将被替换为 '`%xx`'，其中 `xx` 是两位十六进制等效值。
- en: In CGI encoding, the string `"Hello, world!"` would thus become `"Hello%2c+world%21"`
    where `2c` and `21` are the hexadecimal equivalents of `','` and `'!'`, respectively.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CGI 编码中，字符串 `"Hello, world!"` 因此会变成 `"Hello%2c+world%21"`，其中 `2c` 和 `21` 分别是
    `','` 和 `'!'` 的十六进制等效值。
- en: The function `cgi_decode()` takes such an encoded string and decodes it back
    to its original form. Our implementation replicates the code from [[Pezzè *et
    al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]. (It even includes its bugs
    – but we won't reveal them at this point.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `cgi_decode()` 接收这样的编码字符串并将其解码回其原始形式。我们的实现复制了来自 [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]
    的代码。（它甚至包括其错误——但我们现在不会透露它们。）
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is an example of how `cgi_decode()` works:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 `cgi_decode()` 的工作示例：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we want to systematically test `cgi_decode()`, how would we proceed?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要系统地测试 `cgi_decode()`，我们将如何进行？
- en: 'The testing literature distinguishes two ways of deriving tests: *Black-box
    testing* and *White-box testing.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 测试文献区分了两种推导测试的方法：*黑盒测试* 和 *白盒测试*。
- en: Black-Box Testing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 黑盒测试
- en: The idea of *black-box testing* is to derive tests from the *specification*.
    In the above case, we thus would have to test `cgi_decode()` by the features specified
    and documented, including
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的思想是从 *规范* 中推导测试。在上面的情况下，因此我们必须通过指定的和记录的特性来测试 `cgi_decode()`，包括
- en: testing for correct replacement of `'+'`;
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 `'+'` 的正确替换；
- en: testing for correct replacement of `"%xx"`;
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试正确替换 `"%xx"`；
- en: testing for non-replacement of other characters; and
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试其他字符不被替换；
- en: testing for recognition of illegal inputs.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试对非法输入的识别。
- en: 'Here are four assertions (tests) that cover these four features. We can see
    that they all pass:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含了涵盖这四个特征的四个断言（测试）。我们可以看到它们都通过了：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The advantage of black-box testing is that it finds errors in the *specified*
    behavior. It is independent of a given implementation, and thus allows creating
    tests even before implementation. The downside is that *implemented* behavior
    typically covers more ground than *specified* behavior, and thus tests based on
    specification alone typically do not cover all implementation details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒测试的优势在于它能够找到指定行为中的错误。它与特定的实现无关，因此可以在实现之前创建测试。缺点是通常实现的行为比指定行为覆盖的范围更广，因此仅基于规格说明的测试通常不会覆盖所有实现细节。
- en: White-Box Testing
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 白盒测试
- en: In contrast to black-box testing, *white-box testing* derives tests from the
    *implementation*, notably the internal structure. White-Box testing is closely
    tied to the concept of *covering* structural features of the code. If a statement
    in the code is not executed during testing, for instance, this means that an error
    in this statement cannot be triggered either. White-Box testing thus introduces
    a number of *coverage criteria* that have to be fulfilled before the test can
    be said to be sufficient. The most frequently used coverage criteria are
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与黑盒测试相反，*白盒测试* 从 *实现* 中推导测试，特别是内部结构。白盒测试与代码结构特征的 *覆盖* 概念紧密相关。例如，如果在测试期间代码中的某个语句没有被执行，这意味着这个语句中的错误也无法被触发。因此，白盒测试引入了一系列必须满足的
    *覆盖率标准*，在测试被认为足够之前。最常用的覆盖率标准是
- en: '*Statement coverage* – each statement in the code must be executed by at least
    one test input.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*语句覆盖率* – 代码中的每个语句都必须至少被一个测试输入执行。'
- en: '*Branch coverage* – each branch in the code must be taken by at least one test
    input. (This translates to each `if` and `while` decision once being true, and
    once being false.)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分支覆盖率* – 代码中的每个分支都必须至少被一个测试输入执行。（这相当于每个 `if` 和 `while` 决策至少一次为真，至少一次为假。）'
- en: Besides these, there are far more coverage criteria, including sequences of
    branches taken, loop iterations taken (zero, one, many), data flows between variable
    definitions and usages, and many more; [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]
    has a great overview.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，还有更多的覆盖率标准，包括分支序列的执行、循环迭代（零次、一次、多次）、变量定义和用法之间的数据流等等；[[Pezzè 等人，2008](http://ix.cs.uoregon.edu/~michal/book/)]
    有一个很好的概述。
- en: Let us consider `cgi_decode()`, above, and reason what we have to do such that
    each statement of the code is executed at least once. We'd have to cover
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑上面的 `cgi_decode()`，并推理出我们需要做什么才能确保代码中的每个语句至少执行一次。我们需要覆盖
- en: The block following `if c == '+'`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if c == ''+''` 后面的代码块'
- en: The two blocks following `if c == '%'` (one for valid input, one for invalid)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if c == ''%''` 后面的两个代码块（一个用于有效输入，一个用于无效输入）'
- en: The final `else` case for all other characters.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他字符的最终 `else` 情况。
- en: This results in the same conditions as with black-box testing, above; again,
    the assertions above indeed would cover every statement in the code. Such a correspondence
    is actually pretty common, since programmers tend to implement different behaviors
    in different code locations; and thus, covering these locations will lead to test
    cases that cover the different (specified) behaviors.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致与上面黑盒测试相同的条件；再次强调，上面的断言确实会覆盖代码中的每个语句。这种对应关系实际上是相当常见的，因为程序员倾向于在不同的代码位置实现不同的行为；因此，覆盖这些位置将导致覆盖不同（指定）行为的测试用例。
- en: 'The advantage of white-box testing is that it finds errors in *implemented*
    behavior. It can be conducted even in cases where the specification does not provide
    sufficient details; actually, it helps in identifying (and thus specifying) corner
    cases in the specification. The downside is that it may miss *non-implemented*
    behavior: If some specified functionality is missing, white-box testing will not
    find it.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试的优势在于它能够找到实现行为中的错误。即使在规格说明没有提供足够细节的情况下也可以进行；实际上，它有助于识别（并因此指定）规格说明中的边缘情况。缺点是它可能会错过未实现的行为：如果某些指定的功能缺失，白盒测试将不会找到它。
- en: Tracing Executions
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪执行
- en: One nice feature of white-box testing is that one can actually automatically
    assess whether some program feature was covered. To this end, one *instruments*
    the execution of the program such that during execution, a special functionality
    keeps track of which code was executed. After testing, this information can be
    passed to the programmer, who can then focus on writing tests that cover the yet
    uncovered code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒测试的一个优点是，可以实际自动评估某个程序特性是否被覆盖。为此，需要对程序的执行进行 *仪器化*，以便在执行过程中，一个特殊的功能能够跟踪执行了哪些代码。测试完成后，这些信息可以传递给程序员，然后程序员可以专注于编写覆盖尚未覆盖代码的测试。
- en: In most programming languages, it is rather difficult to set up programs such
    that one can trace their execution. Not so in Python. The function `sys.settrace(f)`
    allows defining a *tracing function* `f()` that is called for each and every line
    executed. Even better, it gets access to the current function and its name, current
    variable contents, and more. It is thus an ideal tool for *dynamic analysis* –
    that is, the analysis of what actually happens during an execution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，设置程序以便能够跟踪其执行是非常困难的。但在 Python 中并非如此。`sys.settrace(f)` 函数允许定义一个 *跟踪函数*
    `f()`，该函数会在每执行一行代码时被调用。更好的是，它还可以访问当前函数及其名称、当前变量内容等。因此，它是一个理想的 *动态分析* 工具——也就是说，分析执行过程中实际发生的事情。
- en: To illustrate how this works, let us again look into a specific execution of
    `cgi_decode()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明它是如何工作的，让我们再次查看 `cgi_decode()` 的一个特定执行。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To track how the execution proceeds through `cgi_decode()`, we make use of
    `sys.settrace()`. First, we define the *tracing function* that will be called
    for each line. It has three parameters:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪执行通过 `cgi_decode()` 的过程，我们使用 `sys.settrace()`。首先，我们定义一个 *跟踪函数*，该函数将在每行被调用。它有三个参数：
- en: 'The `frame` parameter gets you the current *frame*, allowing access to the
    current location and variables:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame` 参数让你获取当前的 *帧*，允许访问当前位置和变量：'
- en: '`frame.f_code` is the currently executed code with `frame.f_code.co_name` being
    the function name;'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame.f_code` 是当前正在执行的代码，其中 `frame.f_code.co_name` 是函数名；'
- en: '`frame.f_lineno` holds the current line number; and'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame.f_lineno` 保存当前的行号；并且'
- en: '`frame.f_locals` holds the current local variables and arguments.'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frame.f_locals` 保存当前的局部变量和参数。'
- en: The `event` parameter is a string with values including `"line"` (a new line
    has been reached) or `"call"` (a function is being called).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`event` 参数是一个字符串，包含如 `"line"`（到达了新的一行）或 `"call"`（正在调用一个函数）等值。'
- en: The `arg` parameter is an additional *argument* for some events; for `"return"`
    events, for instance, `arg` holds the value being returned.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arg` 参数是某些事件的附加 *参数*；例如，对于 `"return"` 事件，`arg` 包含返回的值。'
- en: We use the tracing function for simply reporting the current line executed,
    which we access through the `frame` argument.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用跟踪函数仅用于报告当前通过 `frame` 参数访问的执行行。
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can switch tracing on and off with `sys.settrace()`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `sys.settrace()` 来开启和关闭跟踪：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we compute `cgi_decode("a+b")`, we can now see how the execution progresses
    through `cgi_decode()`. After the initialization of `hex_values`, `t`, and `i`,
    we see that the `while` loop is taken three times – one for every character in
    the input.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们计算 `cgi_decode("a+b")` 时，现在我们可以看到执行是如何通过 `cgi_decode()` 的。在初始化 `hex_values`、`t`
    和 `i` 之后，我们看到 `while` 循环被执行了三次——对应输入中的每个字符。
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Which lines are these, actually? To this end, we get the source code of `cgi_decode_code`
    and encode it into an array `cgi_decode_lines`, which we will then annotate with
    coverage information. First, let us get the source code of `cgi_encode`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实际上是哪些行？为此，我们获取 `cgi_decode_code` 的源代码并将其编码到一个数组 `cgi_decode_lines` 中，然后我们将添加覆盖率信息。首先，让我们获取
    `cgi_encode` 的源代码：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`cgi_decode_code` is a string holding the source code. We can print it out
    with Python syntax highlighting:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgi_decode_code` 是一个包含源代码的字符串。我们可以使用 Python 语法高亮打印它：'
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using `splitlines()`, we split the code into an array of lines, indexed by line
    number.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `splitlines()`，我们将代码分割成一个按行号索引的行数组。
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`cgi_decode_lines[L]` is line L of the source code.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgi_decode_lines[L]` 是源代码的第 L 行。'
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We see that the first line (9) executed is actually the initialization of `hex_values`...
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，实际执行的第一行（9）实际上是 `hex_values` 的初始化...
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '... followed by the initialization of `t`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '...然后是 `t` 的初始化：'
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To see which lines actually have been covered at least once, we can convert
    `coverage` into a set:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些行至少执行过一次，我们可以将 `coverage` 转换为一个集合：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let us print out the full code, annotating lines not covered with `#`. The idea
    of such an annotation is to direct developer's attention to the non-covered lines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出完整的代码，并标注未覆盖的行。这种注释的目的是将开发者的注意力引向未覆盖的行。
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We see that a number of lines (notably comments) have not been executed (marked
    with `#`), simply because they are not executable. However, we also see that the
    lines under `elif c == '%'` have *not* been executed yet. If `"a+b"` were our
    only test case so far, this missing coverage would now encourage us to create
    another test case that actually covers these `#`-marked lines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，许多行（特别是注释）尚未执行（用`#`标记），仅仅是因为它们不可执行。然而，我们也可以看到，在`elif c == '%'`下的行尚未执行。如果`"a+b"`是我们迄今为止的唯一测试用例，那么现在这个缺失的覆盖率将鼓励我们创建另一个测试用例，实际上覆盖这些`#`标记的行。
- en: A Coverage Class
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖率类
- en: In this book, we will make use of coverage again and again – to *measure* the
    effectiveness of different test generation techniques, but also to *guide* test
    generation towards code coverage. Our previous implementation with a global `coverage`
    variable is a bit cumbersome for that. We therefore implement some functionality
    that will help us measure coverage easily.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将反复使用覆盖率——不仅是为了*测量*不同测试生成技术的有效性，而且是为了*引导*测试生成向代码覆盖率方向发展。我们之前的全局`coverage`变量实现有点繁琐。因此，我们实现了一些有助于我们轻松测量覆盖率的功能。
- en: The key idea of getting coverage is to make use of the Python `with` statement.
    The general form
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 获取覆盖率的关键思想是利用Python的`with`语句。一般形式
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'executes `BODY` with `OBJECT` being defined (and stored in `VARIABLE`). The
    interesting thing is that at the beginning and end of `BODY`, the special methods
    `OBJECT.__enter__()` and `OBJECT.__exit__()` are automatically invoked; even if
    `BODY` raises an exception. This allows us to define a `Coverage` object where
    `Coverage.__enter__()` automatically turns on tracing and `Coverage.__exit__()`
    automatically turns off tracing again. After tracing, we can make use of special
    methods to access the coverage. This is what this looks like during usage:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BODY`执行时，`OBJECT`被定义（并存储在`VARIABLE`中）。有趣的是，在`BODY`的开始和结束时，特殊方法`OBJECT.__enter__()`和`OBJECT.__exit__()`会自动调用；即使`BODY`抛出异常。这允许我们定义一个`Coverage`对象，其中`Coverage.__enter__()`会自动开启跟踪，而`Coverage.__exit__()`会自动关闭跟踪。跟踪后，我们可以使用特殊方法来访问覆盖率。这是使用时的样子：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, tracing is automatically turned on during `function_to_be_traced()` and
    turned off again after the `with` block; afterwards, we can access the set of
    lines executed.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，跟踪在`function_to_be_traced()`期间自动开启，在`with`块之后再次关闭；之后，我们可以访问已执行的行集。
- en: 'Here''s the full implementation with all its bells and whistles. You don''t
    have to get everything; it suffices that you know how to use it:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包含所有功能的完整实现。您不必了解所有内容；您只需要知道如何使用它：
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'with Coverage() as cov:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'with Coverage() as cov:'
- en: function_to_be_traced()
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: function_to_be_traced()
- en: c = cov.coverage()
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: c = cov.coverage()
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let us put this to use:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其应用于实际：
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, the `Coverage()` class not only keeps track of lines executed,
    but also of function names. This is useful if you have a program that spans multiple
    files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Coverage()`类不仅跟踪已执行的行，还跟踪函数名。如果您有一个跨越多个文件的程序，这很有用。
- en: For interactive use, we can simply print the coverage object, and obtain a listing
    of the code, again with non-covered lines marked as `#`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于交互式使用，我们只需简单地打印覆盖率对象，并获得代码列表，其中未覆盖的行用`#`标记。
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Comparing Coverage
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较覆盖率
- en: 'Since we represent coverage as a set of executed lines, we can also apply *set
    operations* on these. For instance, we can find out which lines are covered by
    individual test cases, but not others:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将覆盖率表示为已执行行的集合，因此我们也可以对这些集合应用*集合操作*。例如，我们可以找出哪些行被单个测试用例覆盖，但未被其他测试用例覆盖：
- en: '[PRE46]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is the single line in the code that is executed only in the `'a+b'` input.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码中仅在`'a+b'`输入下执行的单独一行。
- en: We can also compare sets to find out which lines still need to be covered. Let
    us define `cov_max` as the maximum coverage we can achieve. (Here, we do this
    by executing the "good" test cases we already have. In practice, one would statically
    analyze code structure, which we introduce in [the chapter on symbolic testing](SymbolicFuzzer.html).)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以比较集合，以找出哪些行仍然需要被覆盖。让我们定义`cov_max`为我们能实现的最大覆盖率。（在这里，我们通过执行我们已有的“良好”测试用例来完成此操作。在实践中，人们会静态分析代码结构，我们将在[符号测试章节](SymbolicFuzzer.html)中介绍。）
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we can easily see which lines are *not* yet covered by a test case:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以轻松地看到哪些行还没有被测试用例覆盖：
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, these would be the lines handling `"%xx"`, which we have not yet had
    in the input.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些是处理`"%xx"`的行，我们还没有在输入中遇到。
- en: Coverage of Basic Fuzzing
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本模糊测试覆盖率
- en: 'We can now use our coverage tracing to assess the *effectiveness* of testing
    methods – in particular, of course, test *generation* methods. Our challenge is
    to achieve maximum coverage in `cgi_decode()` just with random inputs. In principle,
    we should *eventually* get there, as eventually, we will have produced every possible
    string in the universe – but exactly how long is this? To this end, let us run
    just one fuzzing iteration on `cgi_decode()`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用我们的覆盖率跟踪来评估测试方法的有效性——特别是测试生成方法的有效性。我们的挑战是仅通过随机输入在`cgi_decode()`中实现最大覆盖率。原则上，我们最终应该达到那里，因为最终我们将产生宇宙中每一个可能字符串——但具体需要多长时间呢？为此，让我们对`cgi_decode()`运行一次模糊测试迭代：
- en: '[PRE51]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here's the invocation and the coverage we achieve. We wrap `cgi_decode()` in
    a `try...except` block such that we can ignore `ValueError` exceptions raised
    by illegal `%xx` formats.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调用和获得的覆盖率。我们将`cgi_decode()`包裹在`try...except`块中，这样我们就可以忽略由非法`%xx`格式引发的`ValueError`异常。
- en: '[PRE54]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Is this already the maximum coverage? Apparently, there are still lines missing:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是最大覆盖率了吗？显然，还有一些行没有覆盖到：
- en: '[PRE56]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Let us try again, increasing coverage over 100 random inputs. We use an array
    `cumulative_coverage` to store the coverage achieved over time; `cumulative_coverage[0]`
    is the total number of lines covered after input 1, `cumulative_coverage[1]` is
    the number of lines covered after inputs 1–2, and so on.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试，通过100个随机输入增加覆盖率。我们使用一个数组`cumulative_coverage`来存储随时间获得的覆盖率；`cumulative_coverage[0]`是在输入1后覆盖的行总数，`cumulative_coverage[1]`是在输入1-2后覆盖的行数，依此类推。
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let us create a hundred inputs to determine how coverage increases:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一百个输入来确定覆盖率是如何增加的：
- en: '[PRE60]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here''s how the coverage increases with each input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每次输入增加覆盖率的方式如下：
- en: '[PRE61]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![](../Images/7f85ddc0f1be2fe0c842da522e4813aa.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/7f85ddc0f1be2fe0c842da522e4813aa.png)'
- en: This is just *one* run, of course; so let's repeat this a number of times and
    plot the averages.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是**一次**运行；所以让我们重复多次并绘制平均值。
- en: '[PRE66]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![](../Images/f2d46e8b77194e72700415b64304b9aa.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/f2d46e8b77194e72700415b64304b9aa.png)'
- en: We see that on average, we get full coverage after 40–60 fuzzing inputs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，平均来说，在40-60次模糊测试输入后，我们就能获得完整的覆盖率。
- en: Getting Coverage from External Programs
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从外部程序获取覆盖率
- en: Of course, not all the world is programming in Python. The good news is that
    the problem of obtaining coverage is ubiquitous, and almost every programming
    language has some facility to measure coverage. Just as an example, let us therefore
    demonstrate how to obtain coverage for a C program.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并非全世界都在用Python编程。好消息是，获取覆盖率的问题无处不在，几乎每种编程语言都有一些工具可以测量覆盖率。因此，让我们以一个例子来展示如何为一个C程序获取覆盖率。
- en: 'Our C program (again) implements `cgi_decode`; this time as a program to be
    executed from the command line:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的C程序（再次）实现了`cgi_decode`；这次是一个可以从命令行执行的程序：
- en: '[PRE69]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here comes the C code, first as a Python string. We start with the usual C
    includes:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是C代码，首先作为一个Python字符串。我们以常用的C头文件开始：
- en: '[PRE70]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here comes the initialization of `hex_values`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`hex_values`的初始化：
- en: '[PRE71]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Here''s the actual implementation of `cgi_decode()`, using pointers for input
    source (`s`) and output target (`t`):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`cgi_decode()`的实际实现，使用指针作为输入源（`s`）和输出目标（`t`）：
- en: '[PRE72]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, here''s a driver which takes the first argument and invokes `cgi_decode`
    with it:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个驱动程序，它接受第一个参数并使用它调用`cgi_decode`：
- en: '[PRE73]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let us create the C source code: (Note that the following commands will overwrite
    the file `cgi_decode.c`, if it already exists in the current working directory.
    Be aware of this, if you downloaded the notebooks and are working locally.)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建C源代码：（注意，以下命令将覆盖当前工作目录中已存在的`cgi_decode.c`文件。如果您下载了笔记本并在本地工作，请注意这一点。）
- en: '[PRE74]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And here we have the C code with its syntax highlighted:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们带有语法高亮的C代码：
- en: '[PRE75]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We can now compile the C code into an executable. The `--coverage` option instructs
    the C compiler to instrument the code such that at runtime, coverage information
    will be collected. (The exact options vary from compiler to compiler.)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将C代码编译成可执行文件。`--coverage`选项指示C编译器对代码进行仪器化，以便在运行时收集覆盖率信息。（具体的选项因编译器而异。）
- en: '[PRE78]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we now execute the program, coverage information will automatically be
    collected and stored in auxiliary files:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在执行程序时，覆盖率信息将自动收集并存储在辅助文件中：
- en: '[PRE79]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The coverage information is collected by the `gcov` program. For every source
    file given, it produces a new `.gcov` file with coverage information. This is
    either stored in `cgi_decode...` or in `cgi_decode-cgi_decode...` files.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率信息是由 `gcov` 程序收集的。对于每个提供的源文件，它都会生成一个新的 `.gcov` 文件，其中包含覆盖率信息。这些信息存储在 `cgi_decode...`
    或 `cgi_decode-cgi_decode...` 文件中。
- en: '[PRE81]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the `.gcov` file, each line is prefixed with the number of times it was called
    (`-` stands for a non-executable line, `#####` stands for zero) as well as the
    line number. We can take a look at `cgi_decode()`, for instance, and see that
    the only code not executed yet is the `return -1` for an illegal input.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `.gcov` 文件中，每一行都带有被调用的次数（`-` 表示不可执行的行，`#####` 表示零）以及行号。我们可以查看 `cgi_decode()`，例如，并看到唯一尚未执行的代码是非法输入的
    `return -1`。
- en: '[PRE83]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let us read in this file to obtain a coverage set:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在该文件中读取以获取覆盖集：
- en: '[PRE85]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: With this set, we can now do the same coverage computations as with our Python
    programs.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个集合，我们现在可以执行与我们的Python程序相同的覆盖计算。
- en: Finding Errors with Basic Fuzzing
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本模糊测试查找错误
- en: Given sufficient time, we can indeed cover each and every line within `cgi_decode()`,
    whatever the programming language would be. This does not mean that they would
    be error-free, though. Since we do not check the result of `cgi_decode()`, the
    function could return any value without us checking or noticing. To catch such
    errors, we would have to set up a *results checker* (commonly called an *oracle*)
    that would verify test results. In our case, we could compare the C and Python
    implementations of `cgi_decode()` and see whether both produce the same results.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 给予足够的时间，我们确实可以覆盖 `cgi_decode()` 中的每一行，无论编程语言是什么。但这并不意味着它们会没有错误。由于我们没有检查 `cgi_decode()`
    的结果，该函数可以返回任何值，而无需我们检查或注意。为了捕获这样的错误，我们需要设置一个 *结果检查器*（通常称为 *预言机*），它会验证测试结果。在我们的情况下，我们可以比较
    `cgi_decode()` 的C和Python实现，看看它们是否产生相同的结果。
- en: 'Where fuzzing is great at, though, is in finding *internal errors* that can
    be detected even without checking the result. Actually, if one runs our `fuzzer()`
    on `cgi_decode()`, one quickly finds such an error, as the following code shows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管模糊测试在发现 *内部错误* 方面很出色，即使不检查结果也可以检测到这些错误。实际上，如果有人在我们的 `fuzzer()` 上运行 `cgi_decode()`，很快就会找到这样的错误，如下面的代码所示：
- en: '[PRE89]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'So, it is possible to cause `cgi_decode()` to crash. Why is that? Let''s take
    a look at its input:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以导致 `cgi_decode()` 崩溃。为什么是这样呢？让我们看看它的输入：
- en: '[PRE92]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The problem here is at the end of the string. After a `'%'` character, our implementation
    will always attempt to access two more (hexadecimal) characters, but if these
    are not there, we will get an `IndexError` exception.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是字符串的末尾。在 `'%'` 字符之后，我们的实现将始终尝试访问两个额外的（十六进制）字符，但如果这些字符不存在，我们将得到一个 `IndexError`
    异常。
- en: 'This problem is also present in our C variant, which inherits it from the original
    implementation [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题也存在于我们的C变体中，它是从原始实现继承的 [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)]：
- en: '[PRE94]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Here, `s` is a pointer to the character to be read; `++` increments it by one
    character. In the C implementation, the problem is actually much worse. If the
    `'%'` character is at the end of the string, the above code will first read a
    terminating character (`'\0'` in C strings) and then the following character,
    which may be any memory content after the string, and which thus may cause the
    program to fail uncontrollably. The somewhat good news is that `'\0'` is not a
    valid hexadecimal character, and thus, the C version will "only" read one character
    beyond the end of the string.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s` 是指向要读取的字符的指针；`++` 通过一个字符增加它。在C实现中，问题实际上更严重。如果字符串末尾有 `'%'` 字符，上述代码将首先读取一个终止字符（C字符串中的
    `'\0'`），然后是字符串之后的下一个字符，这可能是字符串之后的任何内存内容，因此可能会使程序无法控制地失败。有些好消息是 `'\0'` 不是一个有效的十六进制字符，因此C版本“仅”会读取字符串末尾的一个字符。
- en: Interestingly enough, none of the manual tests we had designed earlier would
    trigger this bug. Actually, neither statement nor branch coverage, nor any of
    the coverage criteria commonly discussed in literature would find it. However,
    a simple fuzzing run can identify the error with a few runs – *if* appropriate
    run-time checks are in place that find such overflows. This definitely calls for
    more fuzzing!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，我们之前设计的所有手动测试都不会触发这个错误。实际上，无论是语句覆盖率、分支覆盖率，还是文献中常讨论的任何覆盖率标准，都无法找到它。然而，通过简单的模糊测试运行，可以在几次运行中识别出这个错误——*如果*有适当的运行时检查来发现这样的溢出。这确实需要更多的模糊测试！
- en: Lessons Learned
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Coverage metrics are a simple and fully automated means to approximate how much
    functionality of a program is actually executed during a test run.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率指标是一种简单且完全自动化的方法，可以近似地估算在测试运行期间程序实际执行的功能量。
- en: A number of coverage metrics exist, the most important ones being statement
    coverage and branch coverage.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在许多覆盖率指标，其中最重要的包括语句覆盖率和分支覆盖率。
- en: In Python, it is very easy to access the program state during execution, including
    the currently executed code.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中，在执行期间访问程序状态非常容易，包括当前正在执行的代码。
- en: 'At the end of the day, let''s clean up: (Note that the following commands will
    delete all files in the current working directory that fit the pattern `cgi_decode.*`.
    Be aware of this, if you downloaded the notebooks and are working locally.)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们清理一下：（注意以下命令将删除当前工作目录中所有符合模式`cgi_decode.*`的文件。如果你已经下载了笔记本并在本地工作，请注意这一点。）
- en: '[PRE95]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Next Steps
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: Coverage is not only a tool to *measure* test effectiveness, but also a great
    tool to *guide* test generation towards specific goals – in particular uncovered
    code. We use coverage to
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率不仅是一种*测量*测试有效性的工具，而且是一种很好的*指导*测试生成以实现特定目标的工具——特别是未覆盖的代码。我们使用覆盖率来
- en: '[guide *mutations* of existing inputs towards better coverage in the chapter
    on mutation fuzzing](MutationFuzzer.html)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在突变模糊测试章节中指导现有输入的*突变*以获得更好的覆盖率](MutationFuzzer.html)'
- en: Background
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Coverage is a central concept in systematic software testing. For discussions,
    see the books in the [Introduction to Testing](Intro_Testing.html).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率是系统化软件测试中的一个核心概念。有关讨论，请参阅[测试简介](Intro_Testing.html)中的书籍。
- en: Exercises
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: Fixing `cgi_decode()`'
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：修复`cgi_decode()`
- en: Create an appropriate test to reproduce the `IndexError` discussed above. Fix
    `cgi_decode()` to prevent the bug. Show that your test (and additional `fuzzer()`
    runs) no longer expose the bug. Do the same for the C variant.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个适当的测试用例来重现上面讨论的`IndexError`。修复`cgi_decode()`以防止错误。展示你的测试（以及额外的`fuzzer()`运行）不再暴露错误。对于C变体也做同样的事情。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)来完成练习并查看解决方案。'
- en: 'Exercise 2: Branch Coverage'
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：分支覆盖率
- en: Besides statement coverage, *branch coverage* is one of the most frequently
    used criteria to determine the quality of a test. In a nutshell, branch coverage
    measures how many *control decisions* are made in code. In the statement
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语句覆盖率外，*分支覆盖率*是确定测试质量最常用的标准之一。简而言之，分支覆盖率衡量代码中做出的*控制决策*数量。在以下语句中
- en: '[PRE97]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: for instance, both the cases where `CONDITION` is true (branching to `do_a()`)
    and where `CONDITION` is false (branching to `do_b()`) have to be covered. This
    holds for all control statements with a condition (`if`, `while`, etc.).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，无论是`CONDITION`为真（分支到`do_a()`）还是`CONDITION`为假（分支到`do_b()`），这两种情况都需要被覆盖。这适用于所有带有条件的控制语句（如`if`、`while`等）。
- en: 'How is branch coverage different from statement coverage? In the above example,
    there is actually no difference. In this one, though, there is:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 分支覆盖率与语句覆盖率有何不同？在上面的例子中，实际上没有区别。然而，在这个例子中，确实有：
- en: '[PRE98]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Using statement coverage, a single test case where `CONDITION` is true suffices
    to cover the call to `do_a()`. Using branch coverage, however, we would also have
    to create a test case where `do_a()` is *not* invoked.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语句覆盖率，只要有一个测试用例中`CONDITION`为真，就足以覆盖对`do_a()`的调用。然而，使用分支覆盖率，我们还需要创建一个测试用例，其中`do_a()`没有被调用。
- en: 'Using our `Coverage` infrastructure, we can simulate branch coverage by considering
    *pairs of subsequent lines executed*. The `trace()` method gives us the list of
    lines executed one after the other:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`Coverage`基础设施，我们可以通过考虑*后续执行的代码行对*来模拟分支覆盖率。`trace()`方法为我们提供了依次执行的代码行列表：
- en: '[PRE99]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Part 1: Compute branch coverage'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：计算分支覆盖率
- en: Define a function `branch_coverage()` that takes a trace and returns the set
    of pairs of subsequent lines in a trace – in the above example, this would be
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个函数 `branch_coverage()`，它接受一个跟踪并返回跟踪中后续行的对集 - 在上述示例中，这将是对
- en: '[PRE101]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Bonus for advanced Python programmers: Define `BranchCoverage` as a subclass
    of `Coverage` and make `branch_coverage()` as above a `coverage()` method of `BranchCoverage`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 高级 Python 程序员奖励：将 `BranchCoverage` 定义为 `Coverage` 的子类，并使 `branch_coverage()`
    成为 `BranchCoverage` 的 `coverage()` 方法。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Part 2: Comparing statement coverage and branch coverage'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：比较语句覆盖率和分支覆盖率
- en: Use `branch_coverage()` to repeat the experiments in this chapter with branch
    coverage rather than statement coverage. Do the manually written test cases cover
    all branches?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `branch_coverage()` 重复本章中的实验，使用分支覆盖率而不是语句覆盖率。手动编写的测试用例是否覆盖了所有分支？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Part 3: Average coverage'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第三部分：平均覆盖率
- en: Again, repeat the above experiments with branch coverage. Does `fuzzer()` cover
    all branches, and if so, how many tests does it take on average?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，使用分支覆盖率重复上述实验。`fuzzer()` 是否覆盖了所有分支，如果是的话，平均需要多少次测试？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Coverage.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:28:17+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Coverage.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受 [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
    的许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，受 [MIT 许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)
    的许可。 [最后修改：2024-11-09 17:28:17+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Coverage.ipynb)
    • [引用](#citation) • [版权信息](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Code Coverage](https://www.fuzzingbook.org/html/Coverage.html)". In
    Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler,
    "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Coverage.html](https://www.fuzzingbook.org/html/Coverage.html).
    Retrieved 2024-11-09 17:28:17+01:00.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[代码覆盖率](https://www.fuzzingbook.org/html/Coverage.html)". In Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "[模糊测试书](https://www.fuzzingbook.org/)",
    [https://www.fuzzingbook.org/html/Coverage.html](https://www.fuzzingbook.org/html/Coverage.html).
    Retrieved 2024-11-09 17:28:17+01:00.'
- en: '[PRE102]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
