- en: Greybox Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/GreyboxFuzzer.html](http://www.fuzzingbook.org/html/GreyboxFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the [previous chapter](MutationFuzzer.html), we have introduced *mutation-based
    fuzzing*, a technique that generates fuzz inputs by applying small mutations to
    given inputs. In this chapter, we show how to *guide* these mutations towards
    specific goals such as coverage. The algorithms in this chapter stem from the
    popular [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/) (AFL) fuzzer, in
    particular from its [AFLFast](https://github.com/mboehme/aflfast) and [AFLGo](https://github.com/aflgo/aflgo)
    flavors. We will explore the greybox fuzzing algorithm behind AFL and how we can
    exploit it to solve various problems for automated vulnerability detection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the introduction on [mutation-based fuzzing](MutationFuzzer.html) is
    recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces advanced methods for grey-box fuzzing inspired by the
    popular AFL fuzzer. The `GreyboxFuzzer` class has three arguments. First, a list
    of seed inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Second, a *mutator* that changes individual parts of the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, a *power schedule* that assigns fuzzing effort across the population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These three go into the `GreyboxFuzzer` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GreyboxFuzzer` class is used in conjunction with a `FunctionCoverageRunner`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After fuzzing, we can inspect the population:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Besides the simple `PowerSchedule`, we can have advanced power schedules.
  prefs: []
  type: TYPE_NORMAL
- en: '`AFLFastSchedule` assigns high energy to "unusual" paths not taken very often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AFLGoSchedule` assigns high energy to paths close to uncovered program locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AFLGoSchedule` class constructor requires a `distance` metric from each
    node towards target locations, as determined via analysis of the program code.
    See the chapter for details.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="861pt" height="460pt" viewBox="0.00 0.00 860.88 460.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 456)"><g
    id="node1" class="node"><title>CountingGreyboxFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class CountingGreyboxFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Count how often individual paths are exercised."><text text-anchor="start"
    x="13.25" y="-50.08" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">CountingGreyboxFuzzer</text> <g id="a_node1_0"><a
    xlink:href="#" xlink:title="CountingGreyboxFuzzer"><g id="a_node1_1"><a xlink:href="#"
    xlink:title="run(self, runner: MutationFuzzer.FunctionCoverageRunner) -> Tuple[Any,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inform scheduler about path frequency"><text text-anchor="start" x="67.25"
    y="-27.88" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">run()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="reset(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reset path frequency"><text text-anchor="start" x="67.25" y="-15.12" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">reset()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>GreyboxFuzzer</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class GreyboxFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Coverage-guided mutational fuzzing."><text text-anchor="start" x="41.75" y="-172.07"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">GreyboxFuzzer</text> <g id="a_node2_3"><a xlink:href="#" xlink:title="GreyboxFuzzer"><g
    id="a_node2_4"><a xlink:href="#" xlink:title="run(self, runner: MutationFuzzer.FunctionCoverageRunner)
    -> Tuple[Any, str]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run function(inp) while tracking coverage.
  prefs: []
  type: TYPE_NORMAL
- en: If we reach new coverage,
  prefs: []
  type: TYPE_NORMAL
- en: 'add inp to population and its coverage to population_coverage"><text text-anchor="start"
    x="67.25" y="-149.88" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">run()</text></a></g>
    <g id="a_node2_5"><a xlink:href="#" xlink:title="reset(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reset the initial population, seed index, coverage information"><text text-anchor="start"
    x="67.25" y="-137.12" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">reset()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>CountingGreyboxFuzzer->GreyboxFuzzer</title></g>
    <g id="node3" class="node"><title>AdvancedMutationFuzzer</title> <g id="a_node3"><a
    xlink:href="#" xlink:title="class AdvancedMutationFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for mutation-based fuzzing."><text text-anchor="start" x="8" y="-313.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">AdvancedMutationFuzzer</text> <g id="a_node3_6"><a xlink:href="#"
    xlink:title="AdvancedMutationFuzzer"><g id="a_node3_7"><a xlink:href="#" xlink:title="__init__(self,
    seeds: List[str], mutator: Mutator, schedule: PowerSchedule) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`seeds` - a list of (input) strings to mutate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`mutator` - the mutator to apply.'
  prefs: []
  type: TYPE_NORMAL
- en: '`schedule` - the power schedule to apply."><text text-anchor="start" x="34.25"
    y="-291" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node3_8"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns first each seed once and then generates new inputs"><text text-anchor="start"
    x="34.25" y="-278.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz()</text></a></g>
    <g id="a_node3_9"><a xlink:href="#" xlink:title="create_candidate(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns an input generated by fuzzing a seed in the population"><text text-anchor="start"
    x="34.25" y="-264.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">create_candidate()</text></a></g> <g id="a_node3_10"><a
    xlink:href="#" xlink:title="reset(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reset the initial population and seed index"><text text-anchor="start" x="34.25"
    y="-252.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-style="italic" font-size="10.00">reset()</text></a></g></a></g></a></g></g>
    <g id="edge2" class="edge"><title>GreyboxFuzzer->AdvancedMutationFuzzer</title></g>
    <g id="node4" class="node"><title>Fuzzer</title> <g id="a_node4"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="67.62" y="-435.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node4_11"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node4_12"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="58.25" y="-413" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node4_13"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="58.25" y="-400.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node4_14"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="58.25" y="-387.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g> <g id="a_node4_15"><a
    xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="58.25"
    y="-374.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge3" class="edge"><title>AdvancedMutationFuzzer->Fuzzer</title></g> <g
    id="node5" class="node"><title>AFLFastSchedule</title> <g id="a_node5"><a xlink:href="#"
    xlink:title="class AFLFastSchedule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exponential power schedule as implemented in AFL"><text text-anchor="start"
    x="186.5" y="-172.07" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">AFLFastSchedule</text> <g id="a_node5_16"><a
    xlink:href="#" xlink:title="AFLFastSchedule"><g id="a_node5_17"><a xlink:href="#"
    xlink:title="__init__(self, exponent: float) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="196.25" y="-149.88" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node5_18"><a xlink:href="#"
    xlink:title="assignEnergy(self, population: collections.abc.Sequence[Seed]) ->
    None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign exponential energy inversely proportional to path frequency"><text text-anchor="start"
    x="196.25" y="-137.12" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">assignEnergy()</text></a></g></a></g></a></g></g>
    <g id="node6" class="node"><title>PowerSchedule</title> <g id="a_node6"><a xlink:href="#"
    xlink:title="class PowerSchedule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define how fuzzing time should be distributed across the population."><text
    text-anchor="start" x="270.38" y="-313.2" font-family="Patua One, Helvetica, sans-serif"
    font-weight="bold" font-size="14.00" fill="#b03a2e">PowerSchedule</text> <g id="a_node6_19"><a
    xlink:href="#" xlink:title="PowerSchedule"><g id="a_node6_20"><a xlink:href="#"
    xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="263.25" y="-291" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node6_21"><a xlink:href="#"
    xlink:title="assignEnergy(self, population: collections.abc.Sequence[Seed]) ->
    None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigns each seed the same energy"><text text-anchor="start" x="263.25" y="-278.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">assignEnergy()</text></a></g> <g id="a_node6_22"><a xlink:href="#"
    xlink:title="choose(self, population: collections.abc.Sequence[Seed]) -> Seed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose weighted by normalized energy."><text text-anchor="start" x="263.25"
    y="-264.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">choose()</text></a></g> <g id="a_node6_23"><a xlink:href="#"
    xlink:title="normalizedEnergy(self, population: collections.abc.Sequence[Seed])
    -> List[float]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normalize energy"><text text-anchor="start" x="263.25" y="-251.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">normalizedEnergy()</text></a></g></a></g></a></g></g>
    <g id="edge4" class="edge"><title>AFLFastSchedule->PowerSchedule</title></g> <g
    id="node7" class="node"><title>AFLGoSchedule</title> <g id="a_node7"><a xlink:href="#"
    xlink:title="class AFLGoSchedule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign high energy to seeds close to the target"><text text-anchor="start"
    x="331" y="-43.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">AFLGoSchedule</text> <g id="a_node7_24"><a xlink:href="#"
    xlink:title="AFLGoSchedule"><g id="a_node7_25"><a xlink:href="#" xlink:title="assignEnergy(self,
    population: collections.abc.Sequence[Seed]):'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns each seed energy inversely proportional
  prefs: []
  type: TYPE_NORMAL
- en: 'to the average function-level distance to target."><text text-anchor="start"
    x="336.25" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">assignEnergy()</text></a></g></a></g></a></g></g>
    <g id="node8" class="node"><title>DirectedSchedule</title> <g id="a_node8"><a
    xlink:href="#" xlink:title="class DirectedSchedule:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign high energy to seeds close to some target"><text text-anchor="start"
    x="325.75" y="-178.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">DirectedSchedule</text> <g id="a_node8_26"><a
    xlink:href="#" xlink:title="DirectedSchedule"><g id="a_node8_27"><a xlink:href="#"
    xlink:title="__init__(self, distance: Dict[str, int], exponent: float) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="324.25" y="-156.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node8_28"><a xlink:href="#"
    xlink:title="__getFunctions__(self, coverage: Set[Location]) -> Set[str]"><text
    text-anchor="start" x="324.25" y="-142.5" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">__getFunctions__()</text></a></g>
    <g id="a_node8_29"><a xlink:href="#" xlink:title="assignEnergy(self, population:
    collections.abc.Sequence[Seed]) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns each seed energy inversely proportional
  prefs: []
  type: TYPE_NORMAL
- en: 'to the average function-level distance to target."><text text-anchor="start"
    x="324.25" y="-130.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">assignEnergy()</text></a></g></a></g></a></g></g>
    <g id="edge5" class="edge"><title>AFLGoSchedule->DirectedSchedule</title></g>
    <g id="edge6" class="edge"><title>DirectedSchedule->PowerSchedule</title></g>
    <g id="node9" class="node"><title>DictMutator</title> <g id="a_node9"><a xlink:href="#"
    xlink:title="class DictMutator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Variant of `Mutator` inserting keywords from a dictionary"><text text-anchor="start"
    x="503.38" y="-50.08" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">DictMutator</text> <g id="a_node9_30"><a xlink:href="#"
    xlink:title="DictMutator"><g id="a_node9_31"><a xlink:href="#" xlink:title="__init__(self,
    dictionary: collections.abc.Sequence[str]) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`dictionary` - a list of strings that can be used as keywords"><text text-anchor="start"
    x="469.25" y="-27.88" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node9_32"><a xlink:href="#" xlink:title="insert_from_dictionary(self,
    s: str) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns `s` with a keyword from the dictionary inserted"><text text-anchor="start"
    x="469.25" y="-14.12" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">insert_from_dictionary()</text></a></g></a></g></a></g></g>
    <g id="node10" class="node"><title>Mutator</title> <g id="a_node10"><a xlink:href="#"
    xlink:title="class Mutator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mutate strings"><text text-anchor="start" x="515.38" y="-191.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Mutator</text>
    <g id="a_node10_33"><a xlink:href="#" xlink:title="Mutator"><g id="a_node10_34"><a
    xlink:href="#" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="466.25" y="-169" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node10_35"><a xlink:href="#"
    xlink:title="delete_random_character(self, s: str) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns s with a random character deleted"><text text-anchor="start" x="466.25"
    y="-155.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">delete_random_character()</text></a></g> <g id="a_node10_36"><a
    xlink:href="#" xlink:title="flip_random_character(self, s: str) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns s with a random bit flipped in a random position"><text text-anchor="start"
    x="466.25" y="-142.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">flip_random_character()</text></a></g> <g id="a_node10_37"><a
    xlink:href="#" xlink:title="insert_random_character(self, s: str) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns s with a random character inserted"><text text-anchor="start" x="466.25"
    y="-129.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">insert_random_character()</text></a></g> <g id="a_node10_38"><a
    xlink:href="#" xlink:title="mutate(self, inp: Any) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return s with a random mutation applied. Can be overloaded in subclasses."><text
    text-anchor="start" x="466.25" y="-118" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">mutate()</text></a></g></a></g></a></g></g>
    <g id="edge7" class="edge"><title>DictMutator->Mutator</title></g> <g id="node11"
    class="node"><title>Seed</title> <g id="a_node11"><a xlink:href="#" xlink:title="class
    Seed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Represent an input with additional attributes"><text text-anchor="start" x="663"
    y="-56.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">Seed</text> <g id="a_node11_39"><a xlink:href="#" xlink:title="Seed"><g
    id="a_node11_40"><a xlink:href="#" xlink:title="__init__(self, data: str) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize from seed data"><text text-anchor="start" x="647.25" y="-34.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__init__()</text></a></g> <g id="a_node11_41"><a xlink:href="#"
    xlink:title="__repr__(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns data as string representation of the seed"><text text-anchor="start"
    x="647.25" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__repr__()</text></a></g> <g id="a_node11_42"><a
    xlink:href="#" xlink:title="__str__(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: Returns data as string representation of the seed"><text text-anchor="start"
    x="647.25" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">__str__()</text></a></g></a></g></a></g></g> <g id="node12"
    class="node"><title>Legend</title> <text text-anchor="start" x="733.62" y="-52.62"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="733.62" y="-42.62" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="739.62" y="-42.62" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="733.62" y="-32.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="739.62" y="-32.62" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="733.62" y="-22.62" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="739.62" y="-22.62" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="733.62" y="-13.57" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'AFL: An Effective Greybox Fuzzer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The algorithms in this chapter stem from the popular [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)
    (AFL) fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: AFL is a *mutation-based fuzzer*. Meaning, AFL generates new inputs by slightly
    modifying a seed input (i.e., mutation), or by joining the first half of one input
    with the second half of another (i.e., splicing).
  prefs: []
  type: TYPE_NORMAL
- en: AFL is also a *greybox fuzzer* (not blackbox nor whitebox). Meaning, AFL leverages
    coverage-feedback to learn how to reach deeper into the program. It is not entirely
    blackbox because AFL leverages at least *some* program analysis. It is not entirely
    whitebox either because AFL does not build on heavyweight program analysis or
    constraint solving. Instead, AFL uses lightweight program instrumentation to glean
    some information about the (branch) coverage of a generated input. If a generated
    input increases coverage, it is added to the seed corpus for further fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: To instrument a program, AFL injects a piece of code right after every conditional
    jump instruction. When executed, this so-called trampoline assigns the exercised
    branch a unique identifier and increments a counter that is associated with this
    branch. For efficiency, only a coarse branch hit count is maintained. In other
    words, for each input the fuzzer knows which branches and roughly how often they
    are exercised. The instrumentation is usually done at compile-time, i.e., when
    the program source code is compiled to an executable binary. However, it is possible
    to run AFL on non-instrumented binaries using tools such as a virtual machine
    (e.g., [QEMU](https://github.com/mirrorer/afl/blob/master/qemu_mode)) or a dynamic
    instrumentation tool (e.g., [Intel PinTool](https://github.com/vanhauser-thc/afl-pin)).
    For Python programs, we can collect coverage information without any instrumentation
    (see chapter on [collecting coverage](Coverage.html#Coverage-of-Basic-Fuzzing)).
  prefs: []
  type: TYPE_NORMAL
- en: Ingredients for Greybox Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with discussing the most important parts we need for mutational testing
    and goal guidance.
  prefs: []
  type: TYPE_NORMAL
- en: Mutators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduce specific classes for mutating a seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we'll introduce the `Mutator` class. Given a seed input `inp`, the mutator
    returns a slightly modified version of `inp`. In the [chapter on greybox grammar
    fuzzing](GreyboxGrammarFuzzer.html), we extend this class to consider the input
    grammar for smart greybox fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For insertion, we add a random character in a random position.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For deletion, if the string is non-empty choose a random position and delete
    the character. Otherwise, use the insertion-operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For substitution, if the string is non-empty choose a random position and flip
    a random bit in the character. Otherwise, use the insertion-operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The main method is `mutate` which chooses a random mutation operator from the
    list of operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's try the mutator. You can actually interact with such a "cell" and try
    other inputs by loading this chapter as Jupyter notebook. After opening, run all
    cells in the notebook using "Kernel -> Restart & Run All".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Seeds and Power Schedules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we introduce a new concept; the *power schedule*. A power schedule distributes
    the precious fuzzing time among the seeds in the population. Our objective is
    to maximize the time spent fuzzing those (most progressive) seeds which lead to
    higher coverage increase in shorter time.
  prefs: []
  type: TYPE_NORMAL
- en: We call the likelihood with which a seed is chosen from the population as the
    seed's *energy*. Throughout a fuzzing campaign, we would like to prioritize seeds
    that are more promising. Simply said, we do not want to waste energy fuzzing non-progressive
    seeds. We call the procedure that decides a seed's energy as the fuzzer's *power
    schedule*. For instance, AFL's schedule assigns more energy to seeds that are
    shorter, that execute faster, and yield coverage increases more often.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is some information that we need to attach to each seed in addition
    to the seed's data. Hence, we define the following `Seed` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The power schedule that is implemented below assigns each seed the same energy.
    Once a seed is in the population, it will be fuzzed as often as any other seed
    in the population.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can squeeze long for-loops into much smaller statements.
  prefs: []
  type: TYPE_NORMAL
- en: '`lambda x: ...` returns a function that takes `x` as input. Lambda allows for
    quick definitions unnamed functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map(f, l)` returns a list where the function `f` is applied to each element
    in list `l`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`random.choices(l, weights)[0]` returns element `l[i]` with probability in
    `weights[i]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's see whether this power schedule chooses seeds uniformly at random. We
    ask the schedule 10k times to choose a seed from the population of three seeds
    (A, B, C) and keep track of the number of times we have seen each seed. We should
    see each seed about 3.3k times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Looks good. Every seed has been chosen about a third of the time.
  prefs: []
  type: TYPE_NORMAL
- en: Runners and a Sample Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll start with a small sample program of six lines. In order to collect coverage
    information during execution, we import the `FunctionCoverageRunner` class from
    the chapter on [mutation-based fuzzing](MutationFuzzer.html#Guiding-by-Coverage).
  prefs: []
  type: TYPE_NORMAL
- en: The `FunctionCoverageRunner` constructor takes a Python `function` to execute.
    The function `run` takes an input, passes it on to the Python `function`, and
    collects the coverage information for this execution. The function `coverage()`
    returns a list of tuples `(function name, line number)` for each statement that
    has been covered in the Python `function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `crashme()` function raises an exception for the input "bad!". Let's see
    which statements are covered for the input "good".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In `crashme`, the input "good" only covers the if-statement in line 2\. The
    branch condition `len(s) > 0 and s[0] == 'b'` evaluates to False.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Blackbox Mutation-based Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's integrate both the mutator and power schedule into a fuzzer. We'll start
    with a blackbox fuzzer -- which does *not* leverage any coverage information.
  prefs: []
  type: TYPE_NORMAL
- en: Our `AdvancedMutationFuzzer` class is an advanced and *parameterized* version
    of the `MutationFuzzer` class from the [chapter on mutation-based fuzzing](MutationFuzzer.html).
    It also inherits from the [Fuzzer](Fuzzer.html#Fuzzer-Classes) class. For now,
    we only need to know the functions `fuzz()` which returns a generated input and
    `runs()` which executes `fuzz()` a specified number of times. For our `AdvancedMutationFuzzer`
    class, we override the function `fuzz()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `AdvancedMutationFuzzer` is constructed with a set of initial seeds, a mutator,
    and a power schedule. Throughout the fuzzing campaign, it maintains a seed corpus
    called `population`. The function `fuzz` returns either an unfuzzed seed from
    the initial seeds, or the result of fuzzing a seed in the population. The function
    `create_candidate` handles the latter. It randomly chooses an input from the population
    and applies a number of mutations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Okay, let's take the mutation fuzzer for a spin. Given a single seed, we ask
    it to generate three inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how many statements the mutation-based blackbox fuzzer covers in a
    campaign with n=30k inputs.
  prefs: []
  type: TYPE_NORMAL
- en: The fuzzer function `runs(crashme_runner, trials=n)` generates `n` inputs and
    executes them on the `crashme` function via the `crashme_runner`. As stated earlier,
    the `crashme_runner` also collects coverage information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In order to measure coverage, we import the [population_coverage](Coverage.html#Coverage-of-Basic-Fuzzing)
    function. It takes a set of inputs and a Python function, executes the inputs
    on that function and collects coverage information. Specifically, it returns a
    tuple `(all_coverage, cumulative_coverage)` where `all_coverage` is the set of
    statements covered by all inputs, and `cumulative_coverage` is the number of statements
    covered as the number of executed inputs increases. We are just interested in
    the latter to plot coverage over time.
  prefs: []
  type: TYPE_NORMAL
- en: We extract the generated inputs from the blackbox fuzzer and measure coverage
    as the number of inputs increases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The following generated inputs increased the coverage for our `crashme` [example](#Runner-and-Sample-Program).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '***Summary***. This is how a blackbox mutation-based fuzzer works. We have
    integrated the *mutator* to generate inputs by fuzzing a provided set of initial
    seeds and the *power schedule* to decide which seed to choose next.'
  prefs: []
  type: TYPE_NORMAL
- en: Greybox Mutation-based Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to a blackbox fuzzer, a greybox fuzzer like [AFL](http://lcamtuf.coredump.cx/afl/)
    *does* leverage coverage information. Specifically, a greybox fuzzer adds to the
    seed population generated inputs which increase code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The method `run()` is inherited from the [Fuzzer](Fuzzer.html#Fuzzer-Classes)
    class. It is called to generate and execute exactly one input. We override this
    function to add an input to the `population` that increases coverage. The greybox
    fuzzer attribute `coverages_seen` maintains the set of statements, that have previously
    been covered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let's take our greybox fuzzer for a spin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Does the greybox fuzzer cover more statements after generating the same number
    of test inputs?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Our seed population for our [example](#Runner-and-Sample-Program) now contains
    the following seeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Coverage-feedback is indeed helpful. The new seeds are like bread crumbs or
    milestones that guide the fuzzer to progress more quickly into deeper code regions.
    Following is a simple plot showing the coverage achieved over time for both fuzzers
    on our simple [example](#Runner-and-Sample-Program).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e5e5b618bd9a39a3ac727c24ee7a44f8.png)'
  prefs: []
  type: TYPE_IMG
- en: '***Summary***. We have seen how a greybox fuzzer "discovers" interesting seeds
    that can lead to more progress. From the input `good`, our greybox fuzzer has
    slowly learned how to generate the input `bad!` which raises the exception. Now,
    how can we do that even faster?'
  prefs: []
  type: TYPE_NORMAL
- en: '***Try it***. How much coverage would be achieved over time using a blackbox
    *generation-based* fuzzer? Try plotting the coverage for all three fuzzers. You
    can define the blackbox generation-based fuzzer as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can execute your own code by opening this chapter as Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '***Read***. This is the high-level view how AFL works, one of the most successful
    vulnerability detection tools. If you are interested in the technical details,
    have a look at: [https://github.com/mirrorer/afl/blob/master/docs/technical_details.txt](https://github.com/mirrorer/afl/blob/master/docs/technical_details.txt)'
  prefs: []
  type: TYPE_NORMAL
- en: Boosted Greybox Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our boosted greybox fuzzer assigns more energy to seeds that promise to achieve
    more coverage. We change the power schedule such that seeds that exercise "unusual"
    paths have more energy. With *unusual paths*, we mean paths that are not exercised
    very often by generated inputs.
  prefs: []
  type: TYPE_NORMAL
- en: In order to identify which path is exercised by an input, we leverage the function
    `getPathID` from the section on [trace coverage](WhenIsEnough.html#Trace-Coverage).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The function `getPathID` returns a unique hash for a coverage set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There are several ways to assign energy based on how unusual the exercised path
    is. In this case, we implement an *exponential power schedule* which computes
    the energy $e(s)$ for a seed $s$ as follows $$e(s) = \frac{1}{f(p(s))^a}$$ where
  prefs: []
  type: TYPE_NORMAL
- en: $p(s)$ returns the ID of the path exercised by $s$,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $f(p)$ returns the number of times the path $p$ is exercised by generated inputs,
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $a$ is a given exponent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the greybox fuzzer, let's keep track of the number of times $f(p)$ each path
    $p$ is exercised, and update the power schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Okay, let's run our boosted greybox fuzzer $n=10k$ times on our simple [example](#Runner-and-Sample-Program).
    We set the exponentent of our exponential power schedule to $a=5$.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/44f169205cc358f4ec7b557fe0213571.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How does it compare to our greybox fuzzer with the classical power schedule?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/7cb4f21664bd5a7cac1274709eff19c9.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The exponential power schedule shaves some of the executions of the "high-frequency
    path" off and adds them to the lower-frequency paths. The path executed least
    often is either not at all exercised using the traditional power schedule or it
    is exercised much less often.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at the energy that is assigned to the discovered seeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Exactly. Our new exponential power schedule assigns most energy to the seed
    exercising the lowest-frequency path.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare them in terms of coverage achieved over time for our simple [example](#Runner-and-Sample-Program).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/f6ba12726e7e0aa475fa4a262f73f665.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the boosted greybox fuzzer (with the exponential power schedule)
    achieves coverage much faster.
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary***. By fuzzing seeds more often that exercise low-frequency paths,
    we can explore program paths in a much more efficient manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Try it***. You can try other exponents for the fast power schedule, or change
    the power schedule entirely. Note that a large exponent can lead to overflows
    and imprecisions in the floating point arithmetic producing unexpected results.
    You can execute your own code by opening this chapter as Jupyter notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Read***. You can find out more about fuzzer boosting in the paper "[Coverage-based
    Greybox Fuzzing as Markov Chain](https://mboehme.github.io/paper/CCS16.pdf)" [[Böhme
    *et al*, 2018](https://mboehme.github.io/paper/CCS16.pdf)] and check out the implementation
    into AFL at [[http://github.com/mboehme/aflfast](http://github.com/mboehme/aflfast)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Complex Example: HTMLParser'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's compare the three fuzzers on a more realistic example, the Python [HTML
    parser](https://docs.python.org/3/library/html.parser.html). We run all three
    fuzzers $n=5k$ times on the HTMLParser, starting with the "empty" seed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How do the fuzzers compare in terms of coverage over time?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/2fba186fe95204c3be1474314ff5beff.png)'
  prefs: []
  type: TYPE_IMG
- en: Both greybox fuzzers clearly outperform the blackbox fuzzer. The reason is that
    the greybox fuzzer "discovers" interesting inputs along the way. Let's have a
    look at the last 10 inputs generated by the greybox versus blackbox fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The greybox fuzzer executes much more complicated inputs, many of which include
    special characters such as opening and closing brackets and chevrons (i.e., `<,
    >, [, ]`). Yet, many important keywords, such as `<html>` are still missing.
  prefs: []
  type: TYPE_NORMAL
- en: To inform the fuzzer about these important keywords, we will need [grammars](Grammars.html);
    in the section on [smart greybox fuzzing](LangFuzzer.html), we combine them with
    the techniques above.
  prefs: []
  type: TYPE_NORMAL
- en: '***Try it***. You can re-run these experiments to understand the variance of
    fuzzing experiments. Sometimes, the fuzzer that we claim to be superior does not
    seem to outperform the inferior fuzzer. In order to do this, you just need to
    open this chapter as Jupyter notebook.'
  prefs: []
  type: TYPE_NORMAL
- en: Directed Greybox Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you just want the fuzzer to reach some dangerous location in the
    source code. This could be a location where you expect a buffer overflow. Or you
    want to test a recent change in your code base. How do we direct the fuzzer towards
    these locations?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we introduce directed greybox fuzzing as an optimization problem.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the Maze
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide a meaningful example where you can easily change the code complexity
    and target location, we generate the maze source code from the maze provided as
    string. This example is loosely based on an old [blog post](https://feliam.wordpress.com/2010/10/07/the-symbolic-maze/)
    on symbolic execution by Felipe Andres Manzano (Quick shout-out!).
  prefs: []
  type: TYPE_NORMAL
- en: You simply specify the maze as a string. Like so.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The code is generated using the function `generate_maze_code()`. We'll hide
    the implementation and instead explain what it does. If you are interested in
    the coding, go [here](ControlFlow.html#Example:-Maze).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The objective is to get the "X" to the "#" by providing inputs `D` for down,
    `U` for up, `L` for left, and `R` for right.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Each character in `maze_string` represents a tile. For each tile, a tile-function
    is generated.
  prefs: []
  type: TYPE_NORMAL
- en: If the current tile is "benign" (`), the tile-function corresponding to the
    next input character (D, U, L, R) is called. Unexpected input characters are ignored.
    If no more input characters are left, it returns "VALID" and the current maze
    state.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``*   If the current tile is a "trap" (`+`,`|`,`-`), it returns "INVALID" and
    the current maze state.*   If the current tile is the "target" (`#`), it returns
    "SOLVED" and the current maze state.``'
  prefs: []
  type: TYPE_NORMAL
- en: '`***Try it***. You can test other sequences of input characters, or even change
    the maze entirely. In order to execute your own code, you just need to open this
    chapter as Jupyter notebook.    To get an idea of the generated code, lets look
    at the static [call graph](https://en.wikipedia.org/wiki/Call_graph). A call graph
    shows the order in which functions can be executed.`  [PRE91] from [ControlFlow](ControlFlow.html)
    import callgraph  [PRE92] callgraph(maze_code)  [PRE93] class DictMutator(Mutator):   """Variant
    of `Mutator` inserting keywords from a dictionary"""      def __init__(self, dictionary:
    Sequence[str]) -> None:   """Constructor.  `dictionary` - a list of strings that
    can be used as keywords  """         super().__init__()         self.dictionary
    = dictionary         self.mutators.append(self.insert_from_dictionary)      def
    insert_from_dictionary(self, s: str) -> str:   """Returns `s` with a keyword from
    the dictionary inserted"""         pos = random.randint(0, len(s))         random_keyword
    = random.choice(self.dictionary)         return s[:pos] + random_keyword + s[pos:]  [PRE94]
    class MazeMutator(DictMutator):     def __init__(self, dictionary: Sequence[str])
    -> None:         super().__init__(dictionary)         self.mutators.append(self.delete_last_character)         self.mutators.append(self.append_from_dictionary)      def
    append_from_dictionary(self, s: str) -> str:   """Returns s with a keyword from
    the dictionary appended"""         random_keyword = random.choice(self.dictionary)         return
    s + random_keyword      def delete_last_character(self, s: str) -> str:   """Returns
    s without the last character"""         if len(s) > 0:             return s[:-1]         return
    s  [PRE95] n = 20000 seed_input = " "  # empty seed  maze_mutator = MazeMutator(["L",
    "R", "U", "D"]) maze_schedule = PowerSchedule() maze_fuzzer = GreyboxFuzzer([seed_input],
    maze_mutator, maze_schedule)  start = time.time() maze_fuzzer.runs(FunctionCoverageRunner(maze),
    trials=n) end = time.time()  "It took the fuzzer %0.2f seconds to generate and
    execute %d inputs." % (end - start, n)  [PRE96] ''It took the fuzzer 8.27 seconds
    to generate and execute 20000 inputs.''  [PRE97] def print_stats(fuzzer: GreyboxFuzzer)
    -> None:     total = len(fuzzer.population)     solved = 0     invalid = 0     valid
    = 0     for seed in fuzzer.population:         s = maze(str(seed.data))         if
    "INVALID" in s:             invalid += 1         elif "VALID" in s:             valid
    += 1         elif "SOLVED" in s:             solved += 1             if solved
    == 1:                 print("First solution: %s" % repr(seed))         else:             print("??")      print("""Out
    of %d seeds, * %4d solved the maze, * %4d were valid but did not solve the maze,
    and * %4d were invalid""" % (total, solved, valid, invalid))  [PRE98] print_stats(maze_fuzzer)  [PRE99]
    Out of 1275 seeds, *    0 solved the maze, *  319 were valid but did not solve
    the maze, and *  956 were invalid  [PRE100] target = target_tile() target  [PRE101]
    ''tile_6_7''  [PRE102] import [networkx](https://networkx.org/) as nx  [PRE103]
    from [ControlFlow](ControlFlow.html) import get_callgraph  [PRE104] cg = get_callgraph(maze_code)
    for node in cg.nodes():     if target in node:         target_node = node         break  [PRE105]
    target_node  [PRE106] ''callgraphX__tile_6_7''  [PRE107] distance = {} for node
    in cg.nodes():     if "__" in node:         name = node.split("__")[-1]     else:         name
    = node     try:         distance[name] = nx.shortest_path_length(cg, node, target_node)     except:         distance[name]
    = 0xFFFF  [PRE108] {k: distance[k] for k in list(distance) if distance[k] < 0xFFFF}  [PRE109]
    {''callgraphX'': 1,  ''maze'': 23,  ''tile_2_1'': 22,  ''tile_2_3'': 8,  ''tile_2_4'':
    7,  ''tile_2_5'': 6,  ''tile_2_6'': 5,  ''tile_2_7'': 4,  ''tile_3_1'': 21,  ''tile_3_3'':
    9,  ''tile_3_7'': 3,  ''tile_4_1'': 20,  ''tile_4_3'': 10,  ''tile_4_4'': 11,  ''tile_4_5'':
    12,  ''tile_4_7'': 2,  ''tile_5_1'': 19,  ''tile_5_5'': 13,  ''tile_5_7'': 1,  ''tile_6_1'':
    18,  ''tile_6_2'': 17,  ''tile_6_3'': 16,  ''tile_6_4'': 15,  ''tile_6_5'': 14,  ''tile_6_7'':
    0}  [PRE110] class DirectedSchedule(PowerSchedule):   """Assign high energy to
    seeds close to some target"""      def __init__(self, distance: Dict[str, int],
    exponent: float) -> None:         self.distance = distance         self.exponent
    = exponent      def __getFunctions__(self, coverage: Set[Location]) -> Set[str]:         functions
    = set()         for f, _ in set(coverage):             functions.add(f)         return
    functions      def assignEnergy(self, population: Sequence[Seed]) -> None:   """Assigns
    each seed energy inversely proportional  to the average function-level distance
    to target."""         for seed in population:             if seed.distance < 0:                 num_dist
    = 0                 sum_dist = 0                 for f in self.__getFunctions__(seed.coverage):                     if
    f in list(self.distance):                         sum_dist += self.distance[f]                         num_dist
    += 1                 seed.distance = sum_dist / num_dist                 seed.energy
    = (1 / seed.distance) ** self.exponent  [PRE111] directed_schedule = DirectedSchedule(distance,
    3) directed_fuzzer = GreyboxFuzzer([seed_input], maze_mutator, directed_schedule)  start
    = time.time() directed_fuzzer.runs(FunctionCoverageRunner(maze), trials=n) end
    = time.time()  "It took the fuzzer %0.2f seconds to generate and execute %d inputs."
    % (end - start, n)  [PRE112] ''It took the fuzzer 10.55 seconds to generate and
    execute 20000 inputs.''  [PRE113] print_stats(directed_fuzzer)  [PRE114] Out of
    2524 seeds, *    0 solved the maze, *  916 were valid but did not solve the maze,
    and * 1608 were invalid  [PRE115] y = [seed.distance for seed in directed_fuzzer.population]
    x = range(len(y)) plt.scatter(x, y) plt.ylim(0, max(y)) plt.xlabel("Seed ID")
    plt.ylabel("Distance");  [PRE116] class AFLGoSchedule(DirectedSchedule):   """Assign
    high energy to seeds close to the target"""      def assignEnergy(self, population:
    Sequence[Seed]):   """Assigns each seed energy inversely proportional  to the
    average function-level distance to target."""         min_dist: Union[int, float]
    = 0xFFFF         max_dist: Union[int, float] = 0          for seed in population:             if
    seed.distance < 0:                 num_dist = 0                 sum_dist = 0                 for
    f in self.__getFunctions__(seed.coverage):                     if f in list(self.distance):                         sum_dist
    += self.distance[f]                         num_dist += 1                 seed.distance
    = sum_dist / num_dist             if seed.distance < min_dist:                 min_dist
    = seed.distance             if seed.distance > max_dist:                 max_dist
    = seed.distance          for seed in population:             if seed.distance
    == min_dist:                 if min_dist == max_dist:                     seed.energy
    = 1                 else:                     seed.energy = max_dist - min_dist             else:                 seed.energy
    = (max_dist - min_dist) / (seed.distance - min_dist)  [PRE117] aflgo_schedule
    = AFLGoSchedule(distance, 3) aflgo_fuzzer = GreyboxFuzzer([seed_input], maze_mutator,
    aflgo_schedule)  start = time.time() aflgo_fuzzer.runs(FunctionCoverageRunner(maze),
    trials=n) end = time.time()  "It took the fuzzer %0.2f seconds to generate and
    execute %d inputs." % (end - start, n)  [PRE118] ''It took the fuzzer 16.13 seconds
    to generate and execute 20000 inputs.''  [PRE119] print_stats(aflgo_fuzzer)  [PRE120]
    First solution: lMDD+D4DM69WGR>PR?RRqUUVLJLGUURRRRDDDD Out of 4071 seeds, *  649
    solved the maze, *  438 were valid but did not solve the maze, and * 2984 were
    invalid  [PRE121] for seed in aflgo_fuzzer.population:     s = maze(str(seed.data))     if
    "SOLVED" in s:         filtered = "".join(list(filter(lambda c: c in "UDLR", seed.data)))         print(filtered)         break  [PRE122]
    DDDDRRRRUULLUURRRRDDDD  [PRE123] import [os](https://docs.python.org/3/library/os.html)  [PRE124]
    if os.path.exists(''callgraph.dot''):     os.remove(''callgraph.dot'')  if os.path.exists(''callgraph.py''):     os.remove(''callgraph.py'')  [PRE125]
    class MutationFuzzer(AdvancedMutationFuzzer):     pass  [PRE126] @incollection{fuzzingbook2023:GreyboxFuzzer,     author
    = {Andreas Zeller and Rahul Gopinath and Marcel B{\"o}hme and Gordon Fraser and
    Christian Holler},     booktitle = {The Fuzzing Book},     title = {Greybox Fuzzing},     year
    = {2023},     publisher = {CISPA Helmholtz Center for Information Security},     howpublished
    = {\url{https://www.fuzzingbook.org/html/GreyboxFuzzer.html}},     note = {Retrieved
    2023-11-11 18:18:06+01:00},     url = {https://www.fuzzingbook.org/html/GreyboxFuzzer.html},     urldate
    = {2023-11-11 18:18:06+01:00} }  [PRE127]`'
  prefs: []
  type: TYPE_NORMAL
