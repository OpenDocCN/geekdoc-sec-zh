- en: 6 Underhanded code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Underhanded code** is code that looks like it is doing one thing but actually
    does something else. It usually refers to code nefariously written in this way
    to sneak malicious behavior not obviously visible on code inspection. However
    the same applies also when the underhanded behavior has been added by mistake
    - in fact the ideal attack would also give the attacker the possibility to say
    it was an honest mistake.'
  prefs: []
  type: TYPE_NORMAL
- en: '[@Wheeler2020] provides a more systematic view of underhanded code than is
    given here. This chapter presents some examples to give an overview of the attack
    and how a compiler can (and can’t) help, although this probably doesn’t classify
    as “low level” software security.'
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Assignment and equality confusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the most classic example of underhanded code in C-style languages is
    code that takes advantage of the fact that the assignment (`=`) and the equality
    operator (`==`) look very similar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here `permission_level` is not compared to `LEVEL_ADMIN`, but rather assigned
    that value. Meaning that if `LEVEL_ADMIN` is a non-zero value the if condition
    will evaluate to true.
  prefs: []
  type: TYPE_NORMAL
- en: Both Clang and GCC detects this example with warning option `-Wparentheses`.
    Adding a pair of parentheses around the assignment silences that warning. Those
    extra parentheses would probably draw a reviewer’s attention in this specific
    example but had the condition been more complex with multiple subexpressions combined
    with `||` and `&&` the parentheses had looked normal.
  prefs: []
  type: TYPE_NORMAL
- en: This could be written off as a language design problem. Traditionally Python
    has not supported using assignment as expressions, effectively sidestepping this
    particular problem. When assignment expressions were added to the language [@pep572]
    (in python 3.8) the more visually distinct “walrus operator” `:=` was used to
    avoid this risk of confusing with the comparison operator. Even in cases where
    it is an existing language the compiler can provide options to forbid risky constructs
    for those who want and can opt in to it, essentially creating a new language that
    is a subset of the original language.
  prefs: []
  type: TYPE_NORMAL
- en: 6.2 goto fail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The “goto-fail” bug, officially known as [CVE-2014-1266](https://nvd.nist.gov/vuln/detail/CVE-2014-1266),
    caused Apple devices to not correctly validate certificates in TLS connections.
    It effectively disables the verification the function is supposed to do, and is
    easy to miss in code review. This was most likely a mistake that was not added
    intentionally, but still has the characteristics of underhanded code.
  prefs: []
  type: TYPE_NORMAL
- en: The bug was caused by a duplicated “goto fail” line, which was indented making
    it look like it was guarded by previous if clause, when it in fact always was
    executed. Since the `err` variable was set to 0 (i.e no error) inside the if,
    the function would always return 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At the time of the bug they didn’t but nowadays both GCC and Clang have a `-Wmisleading-indentation`
    option that detects this kind problem.
  prefs: []
  type: TYPE_NORMAL
- en: Also automatic code formatting tools such as clang-format would help finding
    this issue as it will fix the misleading indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 6.3 Trojan Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Trojan Source” attacks described by [@Boucher2023] is another way underhanded
    code could be achieved by doing something that makes the editor (or other thing
    that displays code to the user) render the code in a different way than the compiler
    parses it.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by using unicode features. Support for bidirectional text is one
    such feature, where it has special characters to mark regions of text to be right-to-left
    or left-to-right to allow mixing e.g Arabic and English in the same document.
    If these are used in cunning ways they can make the text render in a way that
    makes a word look like it is *inside* a comment but to the compiler, which parses
    it in the order it appears in the file, sees it is *after* the comment.
  prefs: []
  type: TYPE_NORMAL
- en: GCC provides [`-Wbidi-chars`](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#index-Wbidi-chars_003d)
    to detect usage of writing direction markers. Clang compiler [doesn’t](https://bugs.chromium.org/p/llvm/issues/detail?id=11#c9)
    provide such warning, but has a check in [clang-tidy](https://clang.llvm.org/extra/clang-tidy/checks/misc/misleading-bidirectional.html)
  prefs: []
  type: TYPE_NORMAL
- en: Another variant of “trojan source” is usage of homoglyphs, different characters
    that looks similar or even identical (depending on font). As an example, unicode
    contains the character “Division Slash” (U+2215) which is different from the ordinary
    ascii slash “Solidus” (U+002F).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the final slash on the first line isn’t a slash but another similarly looking
    character that the compiler doesn’t understand as end of comment it means that
    the whole snippet is commented out.
  prefs: []
  type: TYPE_NORMAL
