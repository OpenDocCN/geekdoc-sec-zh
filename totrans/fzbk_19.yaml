- en: Fuzzing with Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html](http://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we show how to extend grammars with *functions* – pieces of
    code that get executed during grammar expansion, and that can generate, check,
    or change elements produced. Adding functions to a grammar allows for very versatile
    test generation, bringing together the best of grammar generation and programming.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: As this chapter deeply interacts with the techniques discussed in the [chapter
    on efficient grammar fuzzing](GrammarFuzzer.html), a good understanding of the
    techniques is recommended.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces the ability to attach *functions* to individual production
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A `pre` function is executed *before* the expansion takes place. Its result
    (typically a string) can *replace* the actual expansion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `post` function is executed *after* the expansion has taken place. If it returns
    a string, the string replaces the expansion; if it returns `False`, it triggers
    a new expansion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both functions can return `None` to not interfere with grammar production at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: To attach a function `F` to an individual expansion `S` in a grammar, replace
    `S` with a pair
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example, To take an area code from a list that is given programmatically,
    we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A `GeneratorGrammarFuzzer` will extract and interpret these options. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the area codes now all stem from `pick_area_code()`. Such definitions
    allow closely tying program code (such as `pick_area_code()`) to grammars.
  prefs: []
  type: TYPE_NORMAL
- en: The `PGGCFuzzer` class incorporates all features from [the `GrammarFuzzer` class](GrammarFuzzer.html)
    and its [coverage-based](GrammarCoverageFuzzer.html), [probabilistic-based](ProbabilisticGrammarFuzzer.html),
    and [generator-based](GeneratorGrammarFuzzer.html) derivatives.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="566pt" height="877pt" viewBox="0.00 0.00 565.75 876.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 872.75)"><g
    id="node1" class="node"><title>PGGCFuzzer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class PGGCFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one grammar-based fuzzer that supports all fuzzingbook features"><text
    text-anchor="start" x="162.12" y="-21.2" font-family="Patua One, Helvetica, sans-serif"
    font-weight="bold" font-size="14.00" fill="#b03a2e">PGGCFuzzer</text></a></g></g>
    <g id="node2" class="node"><title>ProbabilisticGeneratorGrammarCoverageFuzzer</title>
    <g id="a_node2"><a xlink:href="#" xlink:title="class ProbabilisticGeneratorGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: Join the features of `GeneratorGrammarFuzzer`
  prefs: []
  type: TYPE_NORMAL
- en: 'and `ProbabilisticGrammarCoverageFuzzer`"><text text-anchor="start" x="52.62"
    y="-166.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ProbabilisticGeneratorGrammarCoverageFuzzer</text>
    <g id="a_node2_0"><a xlink:href="#" xlink:title="ProbabilisticGeneratorGrammarCoverageFuzzer"><g
    id="a_node2_1"><a xlink:href="#" xlink:title="__init__(self, grammar: Dict[str,
    List[Expansion]], *, replacement_attempts: int = 10, **kwargs) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All other keywords go into `ProbabilisticGrammarFuzzer`."><text text-anchor="start"
    x="143" y="-144.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node2_2"><a xlink:href="#" xlink:title="fuzz_tree(self) -> DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="143"
    y="-132" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text></a></g>
    <g id="a_node2_3"><a xlink:href="#" xlink:title="add_tree_coverage(self, tree:
    DerivationTree) -> None"><text text-anchor="start" x="143" y="-118.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">add_tree_coverage()</text></a></g>
    <g id="a_node2_4"><a xlink:href="#" xlink:title="restart_expansion(self) -> None"><text
    text-anchor="start" x="143" y="-106.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">restart_expansion()</text></a></g>
    <g id="a_node2_5"><a xlink:href="#" xlink:title="supported_opts(self) -> Set[str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set of supported options. To be overloaded in subclasses."><text text-anchor="start"
    x="143" y="-93.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">supported_opts()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>PGGCFuzzer->ProbabilisticGeneratorGrammarCoverageFuzzer</title></g>
    <g id="node3" class="node"><title>GeneratorGrammarFuzzer</title> <g id="a_node3"><a
    xlink:href="#" xlink:title="class GeneratorGrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="11.38" y="-562.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GeneratorGrammarFuzzer</text> <g id="a_node3_6"><a
    xlink:href="#" xlink:title="GeneratorGrammarFuzzer"><g id="a_node3_7"><a xlink:href="#"
    xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], replacement_attempts:
    int = 10, **kwargs) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="8" y="-540.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node3_8"><a xlink:href="#" xlink:title="fuzz_tree(self) -> DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="8"
    y="-527.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text></a></g>
    <g id="a_node3_9"><a xlink:href="#" xlink:title="apply_result(self, result: Any,
    children: List[DerivationTree]) -> List[DerivationTree]"><text text-anchor="start"
    x="8" y="-513.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">apply_result()</text></a></g> <g id="a_node3_10"><a
    xlink:href="#" xlink:title="choose_tree_expansion(self, tree: DerivationTree,
    expandable_children: List[DerivationTree]) -> int:'
  prefs: []
  type: TYPE_NORMAL
- en: Return index of subtree in `expandable_children`
  prefs: []
  type: TYPE_NORMAL
- en: 'to be selected for expansion. Defaults to random."><text text-anchor="start"
    x="8" y="-502" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-style="italic" font-size="10.00">choose_tree_expansion()</text></a></g> <g
    id="a_node3_11"><a xlink:href="#" xlink:title="eval_function(self, tree, function)"><text
    text-anchor="start" x="8" y="-488.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">eval_function()</text></a></g>
    <g id="a_node3_12"><a xlink:href="#" xlink:title="expand_tree_once(self, tree:
    DerivationTree) -> DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an unexpanded symbol in tree; expand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can be overloaded in subclasses."><text text-anchor="start" x="8" y="-476.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">expand_tree_once()</text></a></g> <g id="a_node3_13"><a xlink:href="#"
    xlink:title="find_expansion(self, tree)"><text text-anchor="start" x="8" y="-462.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">find_expansion()</text></a></g>
    <g id="a_node3_14"><a xlink:href="#" xlink:title="process_chosen_children(self,
    children: List[DerivationTree], expansion: Expansion) -> List[DerivationTree]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process children after selection. &nbsp;By default, does nothing."><text text-anchor="start"
    x="8" y="-451" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-style="italic" font-size="10.00">process_chosen_children()</text></a></g>
    <g id="a_node3_15"><a xlink:href="#" xlink:title="reset_generators(self) -> None"><text
    text-anchor="start" x="8" y="-437.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">reset_generators()</text></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="restart_expansion(self) -> None"><text
    text-anchor="start" x="8" y="-425.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">restart_expansion()</text></a></g>
    <g id="a_node3_17"><a xlink:href="#" xlink:title="run_generator(self, expansion:
    Expansion, function: Callable) -> Iterator"><text text-anchor="start" x="8" y="-411.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">run_generator()</text></a></g>
    <g id="a_node3_18"><a xlink:href="#" xlink:title="run_post_functions(self, tree:
    DerivationTree, depth: Union[int, float] = inf) -> Tuple[bool, Optional[List[DerivationTree]]]"><text
    text-anchor="start" x="8" y="-399" font-family="''Fira Mono'', ''Source Code Pro'',
    ''Courier'', monospace" font-size="10.00">run_post_functions()</text></a></g>
    <g id="a_node3_19"><a xlink:href="#" xlink:title="run_post_functions_locally(self,
    new_tree: DerivationTree) -> DerivationTree"><text text-anchor="start" x="8" y="-386.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">run_post_functions_locally()</text></a></g>
    <g id="a_node3_20"><a xlink:href="#" xlink:title="supported_opts(self) -> Set[str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set of supported options. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-374.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">supported_opts()</text></a></g></a></g></a></g></g>
    <g id="edge2" class="edge"><title>ProbabilisticGeneratorGrammarCoverageFuzzer->GeneratorGrammarFuzzer</title></g>
    <g id="node6" class="node"><title>ProbabilisticGrammarCoverageFuzzer</title> <g
    id="a_node6"><a xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="class
    ProbabilisticGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce from grammars, aiming for coverage of all expansions."><text text-anchor="start"
    x="192.38" y="-234.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ProbabilisticGrammarCoverageFuzzer</text></a></g></g>
    <g id="edge5" class="edge"><title>ProbabilisticGeneratorGrammarCoverageFuzzer->ProbabilisticGrammarCoverageFuzzer</title></g>
    <g id="node4" class="node"><title>GrammarFuzzer</title> <g id="a_node4"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="184.12" y="-755.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarFuzzer</text> <g id="a_node4_21"><a xlink:href="#"
    xlink:title="GrammarFuzzer"><g id="a_node4_22"><a xlink:href="GrammarFuzzer.html"
    xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol:
    str = ''<start>'', min_nonterminals: int = 0, max_nonterminals: int = 10, disp:
    bool = False, log: Union[bool, int] = False) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="201" y="-733.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node4_23"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a string from the grammar."><text text-anchor="start" x="201" y="-720.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node4_24"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -> DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="201"
    y="-707.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text></a></g></a></g></a></g></g>
    <g id="edge3" class="edge"><title>GeneratorGrammarFuzzer->GrammarFuzzer</title></g>
    <g id="node5" class="node"><title>Fuzzer</title> <g id="a_node5"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="213.38" y="-851.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node5_25"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node5_26"><a
    xlink:href="Fuzzer.html" xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner
    object>) -> Tuple[subprocess.CompletedProcess, str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="216" y="-829.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node5_27"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="216"
    y="-817" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge4" class="edge"><title>GrammarFuzzer->Fuzzer</title></g> <g id="node7"
    class="node"><title>GrammarCoverageFuzzer</title> <g id="a_node7"><a xlink:href="GrammarCoverageFuzzer.html"
    xlink:title="class GrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce from grammars, aiming for coverage of all expansions."><text text-anchor="start"
    x="230.25" y="-307.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text></a></g></g> <g id="edge6"
    class="edge"><title>ProbabilisticGrammarCoverageFuzzer->GrammarCoverageFuzzer</title></g>
    <g id="node10" class="node"><title>ProbabilisticGrammarFuzzer</title> <g id="a_node10"><a
    xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="class ProbabilisticGrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A grammar-based fuzzer respecting probabilities in grammars."><text text-anchor="start"
    x="374.25" y="-635.83" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ProbabilisticGrammarFuzzer</text></a></g></g>
    <g id="edge10" class="edge"><title>ProbabilisticGrammarCoverageFuzzer->ProbabilisticGrammarFuzzer</title></g>
    <g id="node8" class="node"><title>SimpleGrammarCoverageFuzzer</title> <g id="a_node8"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class SimpleGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing expansions, prefer expansions not covered."><text text-anchor="start"
    x="209.62" y="-469.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text></a></g></g>
    <g id="edge7" class="edge"><title>GrammarCoverageFuzzer->SimpleGrammarCoverageFuzzer</title></g>
    <g id="node9" class="node"><title>TrackingGrammarCoverageFuzzer</title> <g id="a_node9"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class TrackingGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Track grammar coverage during production"><text text-anchor="start" x="127.88"
    y="-646.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">TrackingGrammarCoverageFuzzer</text> <g id="a_node9_28"><a xlink:href="#"
    xlink:title="TrackingGrammarCoverageFuzzer"><g id="a_node9_29"><a xlink:href="GrammarCoverageFuzzer.html"
    xlink:title="__init__(self, *args, **kwargs) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="204" y="-624" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge8" class="edge"><title>SimpleGrammarCoverageFuzzer->TrackingGrammarCoverageFuzzer</title></g>
    <g id="edge9" class="edge"><title>TrackingGrammarCoverageFuzzer->GrammarFuzzer</title></g>
    <g id="edge11" class="edge"><title>ProbabilisticGrammarFuzzer->GrammarFuzzer</title></g>
    <g id="node11" class="node"><title>Legend</title> <text text-anchor="start" x="264.38"
    y="-40.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="264.38" y="-30.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="270.38" y="-30.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="264.38" y="-20.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="270.38" y="-20.5" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="264.38" y="-10.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="270.38" y="-10.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="264.38" y="-1.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Test a Credit Card System'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you work with a shopping system that – among several other features
    – allows customers to pay with a credit card. Your task is to test the payment
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things simple, we will assume that we need only two pieces of data
    – a 16-digit credit card number and an amount to be charged. Both pieces can be
    easily generated with grammars, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this works neatly – we can generate arbitrary amounts and credit card
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when actually testing our system with this data, we find two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: We'd like to test *specific* amounts being charged – for instance, amounts that
    would excess the credit card limit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We find that 9 out of 10 credit card numbers are rejected because of having
    an incorrect checksum. This is fine if we want to test rejection of credit card
    numbers – but if we want to test the actual functionality of processing a charge,
    we need *valid* numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could go and ignore these issues; after all, eventually, it is only a matter
    of time until large amounts and valid numbers are generated. As it comes to the
    first concern, we could also address it by changing the grammar appropriately
    – say, to only produce charges that have at least six leading digits. However,
    generalizing this to arbitrary ranges of values will be cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: The second concern, the checksums of credit card numbers, however, runs deeper
    – at least as far as grammars are concerned, is that a complex arithmetic operation
    like a checksum cannot be expressed in a grammar alone – at least not in the *context-free
    grammars* we use here. (In principle, one *could* do this in a *context–sensitive*
    grammar, but specifying this would be no fun at all.) What we want is a mechanism
    that allows us to *attach programmatic computations* to our grammars, bringing
    together the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Functions to Expansions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key idea of this chapter is to *extend* grammars such that one can *attach
    Python functions* to individual expansions. These functions can be executed
  prefs: []
  type: TYPE_NORMAL
- en: '*before* expansion, *replacing* the element to be expanded by a computed value;
    or'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*after* expansion, *checking* generated elements, and possibly also replacing
    them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both cases, functions are specified using the `opts()` expansion mechanism
    introduced in the [chapter on grammars](Grammars.html). They are thus tied to
    a specific expansion $e$ of a symbol $s$.
  prefs: []
  type: TYPE_NORMAL
- en: Functions Called Before Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function defined using the `pre` option is invoked *before* expansion of $s$
    into $e$. Its value *replaces* the expansion $e$ to be produced. To generate a
    value for the credit card example, above, we could define a *pre-expansion* generator
    function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With `opts()`, we could attach this function to the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: with the intention that whenever `<float>` is expanded, the function `high_charge`
    would be invoked to generate a value for `<float>`. (The actual expansion in the
    grammar would still be present for fuzzers that ignore functions, such as `GrammarFuzzer`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since functions tied to a grammar are frequently very simple, we can also *inline*
    them using a *lambda* expression. A *lambda expression* is used for *anonymous*
    functions that are limited in scope and functionality. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we don't have to give the `function` to be applied twice a name (say,
    `square()`); instead, we apply it inline within the invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `lambda`, this is what our grammar looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Functions Called After Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A function defined using the `post` option is invoked *after* expansion of
    $s$ into $e$, passing the expanded values of the symbols in $e$ as arguments.
    A post-expansion function can serve in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It can serve as a *constraint* or *filter* on the expanded values, returning
    `True` if the expansion is valid, and `False` if not; if it returns `False`, another
    expansion is attempted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It can also serve as a *repair*, returning a string value; like pre-expansion
    functions, the returned value replaces the expansion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For our credit card example, we can choose both ways. If we have a function
    `check_credit_card(s)` which returns `True` for a valid number `s` and `False`
    for invalid ones, we would go for the first option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With such a filter, only valid credit cards will be produced. On average, it
    will still take 10 attempts for each time `check_credit_card()` is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a function `fix_credit_card(s)` which changes the number such that
    the checksum is valid and returns the "fixed" number, we can make use of this
    one instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, each number is generated only once and then repaired. This is very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: The checksum function used for credit cards is the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm),
    a simple yet effective formula.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make use of these functions in our credit card grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A Class for Integrating Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it is easy to specify functions, our grammar fuzzer will simply ignore
    them just as it ignores all extensions. It will issue a warning, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define a special fuzzer that actually invokes the given `pre` and
    `post` functions and acts accordingly. We name this a `GeneratorGrammarFuzzer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We define custom functions to access the `pre` and `post` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `order` attribute will be used [later in this chapter](#Ordering-Expansions).
  prefs: []
  type: TYPE_NORMAL
- en: Generating Elements before Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first task will be implementing the pre-expansion functions – that is, the
    function that would be invoked *before* expansion to replace the value to be expanded.
    To this end, we hook into the `process_chosen_children()` method, which gets the
    selected children before expansion. We set it up such that it invokes the given
    `pre` function and applies its result on the children, possibly replacing them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The method `apply_result()` takes the result from the pre-expansion function
    and applies it on the children. The exact effect depends on the type of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: A *string* $s$ replaces the entire expansion with $s$.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *list* $[x_1, x_2, \dots, x_n]$ replaces the $i$-th symbol with $x_i$ for
    every $x_i$ that is not `None`. Specifying `None` as a list element $x_i$ is useful
    to leave that element unchanged. If $x_i$ is not a string, it is converted to
    a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value of `None` is ignored. This is useful if one wants to simply call a function
    upon expansion, with no effect on the expanded strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boolean* values are ignored. This is useful for post-expansion functions,
    discussed below.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All *other types* are converted to strings, replacing the entire expansion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Numeric Ranges'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the above extensions, we have full support for pre-expansion functions.
    Using the augmented `CHARGE_GRAMMAR`, we find that the pre-expansion `lambda`
    function is actually used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The log reveals a bit more details what happens when the pre-expansion function
    is called. We see that the expansion `<integer>.<digit><digit>` is directly replaced
    by the computed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: More Numeric Ranges'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use such pre-expansion functions in other contexts, too. Suppose we
    want to generate arithmetic expressions in which each number is between 100 and
    200\. We can extend `EXPR_GRAMMAR` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Support for Python Generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python language has its own concept of generator functions, which we of
    course want to support as well. A *generator function in Python* is a function
    that returns a so-called *iterator object* which we can iterate over, one value
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: To create a generator function in Python, one defines a normal function, using
    the `yield` statement instead of a `return` statement. While a `return` statement
    terminates the function, a `yield` statement pauses its execution, saving all
    of its state, to be resumed later for the next successive calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a generator function. When first invoked, `iterate()`
    yields the value 1, followed by 2, 3, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `iterate` in a loop, just like the `range()` function (which also
    is a generator function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use `iterate()` as a pre-expansion generator function, ensuring
    it will create one successive integer after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To support generators, our `process_chosen_children()` method, above, checks
    whether a function is a generator; if so, it invokes the `run_generator()` method.
    When `run_generator()` sees the function for the first time during a `fuzz_tree()`
    (or `fuzz()`) call, it invokes the function to create a generator object; this
    is saved in the `generators` attribute, and then called. Subsequent calls directly
    go to the generator, preserving state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this work? Let us run our fuzzer on the above grammar, using `iterator()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We see that the expression contains all integers starting with 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specifying our own Python generator function such as `iterate()`,
    we can also use one of the built-in Python generators such as `range()`. This
    will also generate integers starting with 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use Python list comprehensions, by adding their generator
    functions in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that both above grammars will actually cause the fuzzer to raise an exception
    when more than 1,000 integers are created, but you will find it very easy to fix
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `yield` is actually an expression, not a statement, so it is also possible
    to have a `lambda` expression `yield` a value. If you find some reasonable use
    for this, let us know.
  prefs: []
  type: TYPE_NORMAL
- en: Checking and Repairing Elements after Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now turn to our second set of functions to be supported – namely, post-expansion
    functions. The simplest way of using them is to run them once the entire tree
    is generated, taking care of replacements as with `pre` functions. If one of them
    returns `False`, however, we start anew.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The method `run_post_functions()` is applied recursively on all nodes of the
    derivation tree. For each node, it determines the expansion applied, and then
    runs the function associated with that expansion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The helper method `find_expansion()` takes a subtree `tree` and determines the
    expansion from the grammar that was applied to create the children in `tree`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The method `eval_function()` is the one that takes care of actually invoking
    the post-expansion function. It creates an argument list containing the expansions
    of all nonterminal children – that is, one argument for each symbol in the grammar
    expansion. It then calls the given function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that unlike pre-expansion functions, post-expansion functions typically
    process the values already produced, so we do not support Python generators here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Negative Expressions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us try out these post-expression functions on an example. Suppose we want
    to produce only arithmetic expressions that evaluate to a negative number – for
    instance, to feed such generated expressions into a compiler or some other external
    system. Doing so constructively with `pre` functions would be very difficult.
    Instead, we can define a constraint that checks for precisely this property, using
    the Python `eval()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `eval()` function takes a string and evaluates it according to Python
    rules. Since the syntax of our generated expressions is slightly different from
    Python, and since Python can raise arithmetic exceptions during evaluation, we
    need a means to handle such errors gracefully. The function `eval_with_exception()`
    wraps around `eval()`; if an exception occurs during evaluation, it returns False
    – which causes the production algorithm to produce another value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is indeed negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Matching XML Tags'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Post-expansion functions can not only be used to *check* expansions, but also
    to repair them. To this end, we can have them return a string or a list of strings;
    just like pre-expansion functions, these strings would then replace the entire
    expansion or individual symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider *XML documents*, which are composed of text within
    matching *XML tags*. For instance, consider the following fragment in HTML, a
    subset of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '**A bold text**'
  prefs: []
  type: TYPE_NORMAL
- en: This fragment consists of two HTML (XML) tags that surround the text; the tag
    name (`strong`) is present both in the opening (`<strong>`) as well as in the
    closing (`</strong>`) tag.
  prefs: []
  type: TYPE_NORMAL
- en: For a *finite* set of tags (for instance, the HTML tags `<strong>`, `<head>`,
    `<body>`, `<form>`, and so on), we could define a context-free grammar that parses
    it; each pair of tags would make up an individual rule in the grammar. If the
    set of tags is *infinite*, though, as with general XML, we cannot define an appropriate
    grammar; that is because the constraint that the closing tag must match the opening
    tag is context-sensitive and thus does not fit context-free grammars.
  prefs: []
  type: TYPE_NORMAL
- en: (Incidentally, if the closing tag had the identifier *reversed* (`</gnorts>`),
    then a context-free grammar could describe it. Make this a programming exercise.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can address this problem by introducing appropriate post-expansion functions
    that automatically make the closing tag match the opening tag. Let us start with
    a simple grammar for producing XML trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'If we fuzz using this grammar, we get non-matching XML tags, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up a post-expansion function that sets the second identifier to the
    string found in the first solves the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Checksums'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As our last example, let us consider the checksum problem from the introduction.
    With our newly defined repair mechanisms, we can now generate credit card numbers
    that are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The validity extends to the entire grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Local Checking and Repairing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have always first generated an entire expression tree, only to check
    it later for validity. This can become expensive: If several elements are first
    generated only to find later that one of them is invalid, we spend a lot of time
    trying (randomly) to regenerate a matching input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the issue, let us create an expression grammar in which all
    digits consist of zeros and ones. Rather than doing this constructively, though,
    we filter out all non-conforming expressions after the fact, using a `post` constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This works, but is very slow; it can take several seconds before a matching
    expression is found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We can address the problem by checking constraints not only for the final subtree,
    but also for partial subtrees as soon as they are complete. To this end, we extend
    the method `expand_tree_once()` such that it invokes the post-expansion function
    as soon as all symbols in a subtree are expanded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The main work takes place in the helper method `run_post_functions_locally()`.
    It runs the post-expansion function $f$ with `run_post_functions()` only on the
    current node by setting `depth` to zero, as any completed subtrees would have
    their post-expansion functions ran already. If $f$ returns `False`, `run_post_functions_locally()`
    returns a non-expanded symbol, such that the main driver can try another expansion.
    It does so for up to 10 times (configurable via a `replacement_attempts` parameter
    during construction); after that, it raises a `RestartExpansionException` to restart
    creating the tree from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The class constructor method and `fuzz_tree()` are set up to handle the additional
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Definitions and Uses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the above generators and constraints, we can also address complex examples.
    The `VAR_GRAMMAR` grammar from [the chapter on parsers](Parser.html) defines a
    number of variables as arithmetic expressions (which in turn can contain variables,
    too). Applying a simple `GrammarFuzzer` on the grammar produces plenty of identifiers,
    but each identifier has a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: What we'd like is that within expressions, only identifiers *previously defined*
    should be used. To this end, we introduce a set of functions around a *symbol
    table*, which keeps track of all variables already defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To make use of the symbol table, we attach pre- and post-expansion functions
    to `VAR_GRAMMAR` that define and lookup identifiers from the symbol table. We
    name our extended grammar `CONSTRAINED_VAR_GRAMMAR`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set up the grammar such that after each time an identifier is defined,
    we store its name in the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Second, we make sure that when an identifier is generated, we pick it from the
    symbol table, too. (We use `post` here such that we can return `False` if no identifier
    is yet available, leading to another expansion being made.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we clear the symbol table each time we (re)start an expansion. This
    is helpful as we may occasionally have to restart expansions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Fuzzing with this grammar ensures that each identifier used is actually defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Ordering Expansions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While our previous def/use example ensures that each *used* variable also is
    a *defined* variable, it does not take care of the *order* in which these definitions
    are made. In fact, it is possible that first, the term on the right-hand side
    of a `;` expands, creating an entry in the symbol table, which is then later used
    in the expression on the left hand side. We can demonstrate this by actually evaluating
    the produced variable assignments in Python, using `exec()` to execute the sequence
    of assignments. (Little known fact: Python *does* support `;` as statement separator.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: To address this issue, we allow explicitly specifying an *ordering of expansions*.
    For our previous fuzzers, such an ordering was inconsequential, as eventually,
    all symbols would be expanded; if we have expansion functions with side effects,
    though, having control over the ordering in which expansions are made (and thus
    over the ordering in which the associated functions are called) can be important.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify orderings, we assign a special attribute `order` to individual expansions.
    This is a list with a number for each symbol in the expansion stating in which
    order the expansions are to be made, starting with the smallest one. As an example,
    the following rule specifies that the left-hand side of a `;` separator should
    be expanded first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we want the definition of a variable to be produced only *after*
    the expression is expanded, since otherwise, the expression might already refer
    to the defined variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'The helper `exp_order()` allows us to retrieve the order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: To control the ordering in which symbols are expanded, we hook into the method
    `choose_tree_expansion()`, which is specifically set for being extended in subclasses.
    It proceeds through the list `expandable_children` of expandable children to choose
    from and matches them with the nonterminal children from the expansion to determine
    their order number. The index `min_given_order` of the expandable child with the
    lowest order number is then returned, choosing this child for expansion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, our fuzzer can now respect orderings, and all variables are properly
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Real programming languages not only have one global scope, but multiple local
    scopes, frequently nested. By carefully organizing global and local symbol tables,
    we can set up a grammar to handle all of these. However, when fuzzing compilers
    and interpreters, we typically focus on single functions, for which one single
    scope is enough to make most inputs valid.
  prefs: []
  type: TYPE_NORMAL
- en: All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us close this chapter by integrating our generator features with the other
    grammar features introduced earlier, in particular [coverage-driven fuzzing](GrammarCoverageFuzzer.html)
    and [probabilistic grammar fuzzing](ProbabilisticGrammarFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: The general idea to integrate the individual features is through *multiple inheritance*,
    which we already used for `ProbabilisticGrammarCoverageFuzzer`, introduced in
    the [exercises on probabilistic fuzzing](ProbabilisticGrammarFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Generators and Probabilistic Fuzzing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probabilistic fuzzing integrates very easily with generators, as both extend
    `GrammarFuzzer` in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We have to implement `supported_opts()` as the merger of both superclasses.
    At the same time, we also set up the constructor such that it invokes both.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us give our joint class a simple test, using probabilities to favor long
    identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Generators and Grammar Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzing based on grammar coverage is a bigger challenge. Not so much for the
    methods overloaded in both; we can resolve these just as above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that during expansion, we *may* generate (and cover) expansions
    that we later drop (for instance, because a `post` function returns `False`).
    Hence, we have to *remove* this coverage which is no longer present in the final
    production.
  prefs: []
  type: TYPE_NORMAL
- en: We resolve the problem by *rebuilding the coverage* from the final tree after
    it is produced. To this end, we hook into the `fuzz_tree()` method. We have it
    save the original coverage before creating the tree, restoring it afterwards.
    Then we traverse the resulting tree, adding its coverage back again (`add_tree_coverage()`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, we ensure that if we do have to restart an expansion from
    scratch, we also restore the previous coverage such that we can start fully anew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us try this out. After we have produced a string, we should see its coverage
    in `expansion_coverage()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Fuzzing again would eventually cover all letters in identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: With `ProbabilisticGeneratorGrammarCoverageFuzzer`, we now have a grammar fuzzer
    that combines efficient grammar fuzzing with coverage, probabilities, and generator
    functions. The only thing that is missing is a shorter name. `PGGCFuzzer`, maybe?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions attached to grammar expansions can serve
  prefs: []
  type: TYPE_NORMAL
- en: as *generators* to efficiently produce a symbol expansion from a function;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as *constraints* to check produced strings against (complex) validity conditions;
    and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as *repairs* to apply changes to produced strings, such as checksums and identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this chapter, we have powerful grammars which we can use in a number of
    domains:'
  prefs: []
  type: TYPE_NORMAL
- en: In the [chapter on fuzzing APIs](APIFuzzer.html), we show how to produce complex
    data structures for testing, making use of `GeneratorGrammarFuzzer` features to
    combine grammars and generator functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the [chapter on fuzzing User Interfaces](WebFuzzer.html), we make use of
    `GeneratorGrammarFuzzer` to produce complex user interface inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For fuzzing APIs, generator functions are very common. In the [chapter on API
    fuzzing](APIFuzzer.html), we show how to combine them with grammars for even richer
    test generation.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of generator functions and grammars is mostly possible because
    we define and make use of grammars in an all-Python environment. We are not aware
    of another grammar-based fuzzing system that exhibits similar features.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Tree Processing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, our `pre` and `post` processing functions all accept and produce strings.
    In some circumstances, however, it can be useful to access the *derivation trees*
    directly – for instance, to access and check some child element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your task is to extend `GeneratorGrammarFuzzer` with pre- and post-processing
    functions that can accept and return derivation trees. To this end, proceed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `GeneratorGrammarFuzzer` such that a function can return a derivation
    tree (a tuple) or a list of derivation trees, which would then replace subtrees
    in the same way as strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extend `GeneratorGrammarFuzzer` with a `post_tree` attribute which takes a function
    just like `post`, except that its arguments would be derivation trees.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Attribute Grammars'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Set up a mechanism through which it is possible to attach arbitrary *attributes*
    to individual elements in the derivation tree. Expansion functions could attach
    such attributes to individual symbols (say, by returning `opts()`), and also access
    attributes of symbols in later calls. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-01-10 15:45:59+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/GeneratorGrammarFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing with Generators](https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html](https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html).
    Retrieved 2024-01-10 15:45:59+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
