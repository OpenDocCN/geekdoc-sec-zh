- en: Concolic Fuzzing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号模糊测试
- en: 原文：[http://www.fuzzingbook.org/html/ConcolicFuzzer.html](http://www.fuzzingbook.org/html/ConcolicFuzzer.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/ConcolicFuzzer.html](http://www.fuzzingbook.org/html/ConcolicFuzzer.html)
- en: In the [chapter on information flow](InformationFlow.html), we have seen how
    one can use dynamic taints to produce more intelligent test cases than simply
    looking for program crashes. We have also seen how one can use the taints to update
    the grammar, and hence focus more on the dangerous methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[信息流章节](InformationFlow.html)中，我们看到了如何使用动态污点来生成比仅仅寻找程序崩溃更智能的测试用例。我们也看到了如何使用污点来更新语法，从而更专注于危险的方法。
- en: While taints are helpful, uninterpreted strings is only one of the attack vectors.
    Can we say anything more about the properties of variables at any point in the
    execution? For example, can we say for sure that a function will always receive
    the buffers with the correct length?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然污点很有帮助，但未解释的字符串只是攻击向量之一。我们能否对执行过程中任何点的变量属性说些什么？例如，我们能否肯定地说一个函数将始终接收到正确长度的缓冲区？
- en: '*Concolic execution* offers a solution here. The idea of *concolic execution*
    over a function is as follows: We start with a sample input for the function,
    and execute the function under trace. At each point the execution passes through
    a conditional, we *save the conditional encountered* in the form of *relations
    between symbolic variables.* Here, a *symbolic variable* can be thought of as
    a sort of placeholder for the real variable, sort of like the x in solving for
    x in Algebra. The symbolic variables can be used to specify relations without
    actually solving them.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号执行*在这里提供了一个解决方案。对于函数的*符号执行*的想法如下：我们从函数的一个样本输入开始，在跟踪下执行函数。在执行通过每个条件点时，我们以*符号变量之间的关系*的形式*保存遇到的条件*。在这里，一个*符号变量*可以被视为一种真实变量的占位符，类似于在代数中求解x时使用的x。符号变量可以用来指定关系，而无需实际解决它们。'
- en: With concolic execution, one can collect the constraints that an execution path
    encounters, and use it to answer questions about the program behavior at any point
    we prefer along the program execution path. We can further use concolic execution
    to enhance fuzzing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通过符号执行，我们可以收集执行路径遇到的约束，并使用它来回答关于程序在任何我们喜欢的程序执行路径点的行为的问题。我们可以进一步使用符号执行来增强模糊测试。
- en: In this chapter, we explore in depth how to execute a Python function concolically,
    and how concolic execution can be used to enhance fuzzing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了如何执行Python函数的符号执行，以及如何利用符号执行来增强模糊测试。
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should have read the [chapter on coverage](Coverage.html).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该已经阅读了[覆盖率章节](Coverage.html)。
- en: You should have read the [chapter on information flow](InformationFlow.html).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该已经阅读了[信息流章节](InformationFlow.html)。
- en: A familiarity with the basic idea of [SMT solvers](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)
    would be useful.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉[SMT求解器](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)的基本概念会有所帮助。
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Synopsis
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要[使用本章提供的代码](Importing.html)，请编写
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and then make use of the following features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter defines two main classes: `SimpleConcolicFuzzer` and `ConcolicGrammarFuzzer`.
    The `SimpleConcolicFuzzer` first uses a sample input to collect predicates encountered.
    The fuzzer then negates random predicates to generate new input constraints. These,
    when solved, produce inputs that explore paths that are close to the original
    path.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章定义了两个主要类：`SimpleConcolicFuzzer`和`ConcolicGrammarFuzzer`。`SimpleConcolicFuzzer`首先使用样本输入收集遇到的谓词。模糊器随后否定随机谓词以生成新的输入约束。这些约束在解决后产生探索接近原始路径的路径的输入。
- en: ConcolicTracer
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcolicTracer
- en: At the heart of both fuzzers lies the concept of a *concolic tracer*, capturing
    symbolic variables and path conditions as a program gets executed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模糊器的核心概念是一个*符号跟踪器*，它捕获程序执行过程中的符号变量和路径条件。
- en: '`ConcolicTracer` is used in a `with` block; the syntax `tracer[function]` executes
    `function` within the `tracer` while capturing conditions. Here is an example
    for the `cgi_decode()` function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcolicTracer`在`with`块中使用；`tracer[function]`的语法在`tracer`中执行`function`，同时捕获条件。以下是对`cgi_decode()`函数的示例：'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once executed, we can retrieve the symbolic variables in the `decls` attribute.
    This is a mapping of symbolic variables to types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们可以在`decls`属性中检索符号变量。这是一个符号变量到类型的映射。
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The extracted path conditions can be found in the `path` attribute:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的路径条件可以在`path`属性中找到：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `context` attribute holds a pair of `decls` and `path` attributes; this
    is useful for passing it into the `ConcolicTracer` constructor.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`context` 属性包含一对 `decls` 和 `path` 属性；这对于将其传递给 `ConcolicTracer` 构造函数很有用。'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can solve these constraints to obtain a value for the function parameters
    that follow the same path as the original (traced) invocation:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解决这些约束，以获得一个与原始（跟踪）调用相同路径的函数参数值：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `zeval()` function also allows passing *alternate* or *negated* constraints.
    See the chapter for examples.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeval()` 函数还允许传递 *替代* 或 *否定* 约束。请参阅相关章节中的示例。'
- en: '<svg width="250pt" height="145pt" viewBox="0.00 0.00 250.25 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>ConcolicTracer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ConcolicTracer:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="250pt" height="145pt" viewBox="0.00 0.00 250.25 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>ConcolicTracer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ConcolicTracer:'
- en: 'Trace function execution, tracking variables and path conditions"><text text-anchor="start"
    x="8" y="-120.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ConcolicTracer</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="ConcolicTracer"><g id="a_node1_1"><a xlink:href="#" xlink:title="__call__(self,
    *args):'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '跟踪函数执行，跟踪变量和路径条件"><text text-anchor="start" x="8" y="-120.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ConcolicTracer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="ConcolicTracer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__call__(self, *args):'
- en: 'Call self as a function."><text text-anchor="start" x="13.62" y="-98" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__call__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="__init__(self, context=None):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '将 self 作为函数调用。"><text text-anchor="start" x="13.62" y="-98" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__call__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="__init__(self, context=None):'
- en: 'Constructor."><text text-anchor="start" x="13.62" y="-85.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="zeval(self, predicates=None,
    *, python=False, log=False):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数。"><text text-anchor="start" x="13.62" y="-85.25" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="zeval(self, predicates=None,
    *, python=False, log=False):'
- en: Evaluate `predicates` in current context.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前上下文中评估 `predicates`。
- en: '- If `python` is set, use the z3 Python API; otherwise use z3 standalone.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '- 如果设置了 `python`，则使用 z3 Python API；否则使用 z3 独立版本。'
- en: '- If `log` is set, show input to z3.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `log`，则显示 z3 的输入。
- en: Return a pair (`result`, `solution`) where
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个对 (`result`, `solution`)，其中
- en: '- `result` is either `''sat''` (satisfiable); then'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '- `result` 是 `''sat''`（可满足）时；'
- en: solution` is a mapping of variables to (value, type) pairs; or
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`solution` 是变量到（值，类型）对的映射；或者'
- en: '- `result` is not `''sat''`, indicating an error; then `solution` is `None`"><text
    text-anchor="start" x="13.62" y="-72.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">zeval()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__enter__(self)"><text text-anchor="start"
    x="13.62" y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__enter__()</text></a></g> <g id="a_node1_5"><a xlink:href="#"
    xlink:title="__exit__(self, exc_type, exc_value, tb)"><text text-anchor="start"
    x="13.62" y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__exit__()</text></a></g> <g id="a_node1_6"><a xlink:href="#"
    xlink:title="__getitem__(self, fn)"><text text-anchor="start" x="13.62" y="-33.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">__getitem__()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="concolic(self, args)"><text text-anchor="start"
    x="13.62" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">concolic()</text></a></g> <g id="a_node1_8"><a xlink:href="#"
    xlink:title="smt_expr(self, show_decl=False, simplify=False, path=[])"><text text-anchor="start"
    x="13.62" y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">smt_expr()</text></a></g></a></g></a></g></g> <g
    id="node2" class="node"><title>Legend</title> <text text-anchor="start" x="123"
    y="-84.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="123" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="129" y="-74.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="123" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="129" y="-64.5" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="123" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="129" y="-54.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="123" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '- `result`不是`''sat''`，表示错误；然后`solution`是`None`"><text text-anchor="start" x="13.62"
    y="-72.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">zeval()</text></a></g> <g id="a_node1_4"><a
    xlink:href="#" xlink:title="__enter__(self)"><text text-anchor="start" x="13.62"
    y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">__enter__()</text></a></g> <g id="a_node1_5"><a xlink:href="#"
    xlink:title="__exit__(self, exc_type, exc_value, tb)"><text text-anchor="start"
    x="13.62" y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__exit__()</text></a></g> <g id="a_node1_6"><a xlink:href="#"
    xlink:title="__getitem__(self, fn)"><text text-anchor="start" x="13.62" y="-33.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">__getitem__()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="concolic(self, args)"><text text-anchor="start"
    x="13.62" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">concolic()</text></a></g> <g id="a_node1_8"><a xlink:href="#"
    xlink:title="smt_expr(self, show_decl=False, simplify=False, path=[])"><text text-anchor="start"
    x="13.62" y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">smt_expr()</text></a></g></a></g></a></g></g> <g
    id="node2" class="node"><title>图例</title> <text text-anchor="start" x="123" y="-84.5"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">图例</text> <text text-anchor="start" x="123" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="129" y="-74.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="123" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="129" y="-64.5" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="123" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="129" y="-54.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="123" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>'
- en: SimpleConcolicFuzzer
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SimpleConcolicFuzzer
- en: 'The constraints obtained from `ConcolicTracer` are added to the concolic fuzzer
    as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ConcolicTracer`获得的约束被添加到Concolic fuzzer中，如下所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The concolic fuzzer then uses the constraints added to guide its fuzzing as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Concolic fuzzer随后使用添加的约束来指导其模糊测试，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see how the additional inputs generated explore additional paths.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到额外的输入是如何探索额外路径的。
- en: '<svg width="294pt" height="229pt" viewBox="0.00 0.00 294.38 228.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 224.75)"><g
    id="node1" class="node"><title>SimpleConcolicFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class SimpleConcolicFuzzer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="294pt" height="229pt" viewBox="0.00 0.00 294.38 228.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 224.75)"><g
    id="node1" class="node"><title>SimpleConcolicFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class SimpleConcolicFuzzer:'
- en: 'Base class for fuzzers."><text text-anchor="start" x="8" y="-81.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleConcolicFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="SimpleConcolicFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '模糊器的基类。"><text text-anchor="start" x="8" y="-81.95" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleConcolicFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="SimpleConcolicFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self):'
- en: 'Constructor"><text text-anchor="start" x="35.75" y="-59.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="fuzz(self):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数"><text text-anchor="start" x="35.75" y="-59.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="fuzz(self):'
- en: 'Return fuzz input"><text text-anchor="start" x="35.75" y="-47" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node1_3"><a xlink:href="#" xlink:title="add_trace(self,
    trace, s)"><text text-anchor="start" x="35.75" y="-33.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">add_trace()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="get_newpath(self)"><text text-anchor="start"
    x="35.75" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">get_newpath()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="next_choice(self)"><text text-anchor="start" x="35.75"
    y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">next_choice()</text></a></g></a></g></a></g></g> <g id="node2"
    class="node"><title>Fuzzer</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入"><text text-anchor="start" x="35.75" y="-47" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node1_3"><a xlink:href="#" xlink:title="add_trace(self,
    trace, s)"><text text-anchor="start" x="35.75" y="-33.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">add_trace()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="get_newpath(self)"><text text-anchor="start"
    x="35.75" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">get_newpath()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="next_choice(self)"><text text-anchor="start" x="35.75"
    y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">next_choice()</text></a></g></a></g></a></g></g> <g id="node2"
    class="node"><title>Fuzzer</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
- en: 'Base class for fuzzers."><text text-anchor="start" x="54.12" y="-203.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node2_6"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node2_7"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '模糊器的基类。"><text text-anchor="start" x="54.12" y="-203.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node2_6"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node2_7"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
- en: 'Constructor"><text text-anchor="start" x="44.75" y="-181.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_8"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数"><text text-anchor="start" x="44.75" y="-181.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_8"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
- en: 'Return fuzz input"><text text-anchor="start" x="44.75" y="-169" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_9"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入"><text text-anchor="start" x="44.75" y="-169" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_9"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="44.75" y="-156.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node2_10"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 `runner` 并使用模糊输入，`trials` 次数"><text text-anchor="start" x="44.75" y="-156.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node2_10"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="44.75"
    y="-143.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>SimpleConcolicFuzzer->Fuzzer</title></g> <g
    id="node3" class="node"><title>Legend</title> <text text-anchor="start" x="167.12"
    y="-65.38" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="167.12" y="-55.38" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="173.12" y="-55.38" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="167.12" y="-45.38" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="173.12" y="-45.38" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="167.12" y="-35.38" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="173.12" y="-35.38" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="167.12" y="-26.32" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `runner` 并使用模糊输入，`trials` 次数"><text text-anchor="start" x="44.75" y="-143.5"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="10.00">runs()</text></a></g></a></g></a></g></g> <g id="edge1" class="edge"><title>SimpleConcolicFuzzer->Fuzzer</title></g>
    <g id="node3" class="node"><title>图例</title> <text text-anchor="start" x="167.12"
    y="-65.38" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">图例</text> <text text-anchor="start" x="167.12" y="-55.38" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="173.12" y="-55.38" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">公共方法()</text> <text text-anchor="start"
    x="167.12" y="-45.38" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="173.12" y="-45.38" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">私有方法()</text> <text text-anchor="start"
    x="167.12" y="-35.38" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="173.12" y="-35.38" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">重载方法()</text>
    <text text-anchor="start" x="167.12" y="-26.32" font-family="Helvetica,sans-Serif"
    font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: ConcolicGrammarFuzzer
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcolicGrammarFuzzer
- en: The `SimpleConcolicFuzzer` simply explores all paths near the original path
    traversed by the sample input. It uses a simple mechanism to explore the paths
    that are near the paths that it knows about, and other than code paths, knows
    nothing about the input.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: The `SimpleConcolicFuzzer` simply explores all paths near the original path
    traversed by the sample input. It uses a simple mechanism to explore the paths
    that are near the paths that it knows about, and other than code paths, knows
    nothing about the input.
- en: 'The `ConcolicGrammarFuzzer` on the other hand, knows about the input grammar,
    and can collect feedback from the subject under fuzzing. It can lift some constraints
    encountered to the grammar, enabling deeper fuzzing. It is used as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ConcolicGrammarFuzzer` 了解输入语法，并且可以在模糊测试过程中收集来自受试者的反馈。它可以将遇到的一些约束提升到语法中，从而实现更深入的模糊测试。其使用方法如下：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<svg width="318pt" height="478pt" viewBox="0.00 0.00 317.62 478.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 474.25)"><g
    id="node1" class="node"><title>ConcolicGrammarFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class ConcolicGrammarFuzzer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="318pt" height="478pt" viewBox="0.00 0.00 317.62 478.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 474.25)"><g
    id="node1" class="node"><title>ConcolicGrammarFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class ConcolicGrammarFuzzer:'
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="13.62" y="-94.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ConcolicGrammarFuzzer</text> <g id="a_node1_0"><a
    xlink:href="#" xlink:title="ConcolicGrammarFuzzer"><g id="a_node1_1"><a xlink:href="#"
    xlink:title="fuzz(self):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '使用推导树高效地生成语法字符串。"><text text-anchor="start" x="13.62" y="-94.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ConcolicGrammarFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="ConcolicGrammarFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="fuzz(self):'
- en: 'Produce a string from the grammar."><text text-anchor="start" x="41" y="-72.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node1_2"><a
    xlink:href="#" xlink:title="coalesce(self, children)"><text text-anchor="start"
    x="41" y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">coalesce()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="prune_tokens(self, tokens)"><text text-anchor="start" x="41" y="-46"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">prune_tokens()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="prune_tree(self, tree, tokens)"><text
    text-anchor="start" x="41" y="-33.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">prune_tree()</text></a></g> <g
    id="a_node1_5"><a xlink:href="#" xlink:title="tree_to_string(self, tree)"><text
    text-anchor="start" x="41" y="-20.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">tree_to_string()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="update_grammar(self, trace)"><text
    text-anchor="start" x="41" y="-7.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">update_grammar()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>GrammarFuzzer</title> <g id="a_node2"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法中生成字符串。"><text text-anchor="start" x="41" y="-72.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node1_2"><a xlink:href="#" xlink:title="coalesce(self,
    children)"><text text-anchor="start" x="41" y="-58.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">coalesce()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="prune_tokens(self, tokens)"><text
    text-anchor="start" x="41" y="-46" font-family="''Fira Mono'', ''Source Code Pro'',
    ''Courier'', monospace" font-size="10.00">prune_tokens()</text></a></g> <g id="a_node1_4"><a
    xlink:href="#" xlink:title="prune_tree(self, tree, tokens)"><text text-anchor="start"
    x="41" y="-33.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">prune_tree()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="tree_to_string(self, tree)"><text text-anchor="start"
    x="41" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">tree_to_string()</text></a></g> <g id="a_node1_6"><a
    xlink:href="#" xlink:title="update_grammar(self, trace)"><text text-anchor="start"
    x="41" y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">update_grammar()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>GrammarFuzzer</title> <g id="a_node2"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="39.12" y="-331.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarFuzzer</text> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="GrammarFuzzer"><g id="a_node2_8"><a xlink:href="GrammarFuzzer.html"
    xlink:title="__init__(self, grammar: Dict[str, List[Union[str, Tuple[str, Dict[str,
    Any]]]]], start_symbol: str = ''<start>'', min_nonterminals: int = 0, max_nonterminals:
    int = 10, disp: bool = False, log: Union[bool, int] = False) -> None:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '使用推导树高效地生成语法字符串。"><text text-anchor="start" x="39.12" y="-331.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="GrammarFuzzer"><g id="a_node2_8"><a
    xlink:href="GrammarFuzzer.html" xlink:title="__init__(self, grammar: Dict[str,
    List[Union[str, Tuple[str, Dict[str, Any]]]]], start_symbol: str = ''<start>'',
    min_nonterminals: int = 0, max_nonterminals: int = 10, disp: bool = False, log:
    Union[bool, int] = False) -> None:'
- en: Produce strings from `grammar`, starting with `start_symbol`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从`grammar`中生成字符串，以`start_symbol`开始。
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`min_nonterminals`或`max_nonterminals`，则使用它们作为限制
- en: for the number of nonterminals produced.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 生成非终结符的数量。
- en: If `disp` is set, display the intermediate derivation trees.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`disp`被设置，显示中间的推导树。"><text text-anchor="start" x="41" y="-72.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node1_2"><a xlink:href="#" xlink:title="coalesce(self,
    children)"><text text-anchor="start" x="41" y="-58.75" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">coalesce()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="prune_tokens(self, tokens)"><text
    text-anchor="start" x="41" y="-46" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-size="10.00">prune_tokens()</text></a></g> <g id="a_node1_4"><a
    xlink:href="#" xlink:title="prune_tree(self, tree, tokens)"><text text-anchor="start"
    x="41" y="-33.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">prune_tree()</text></a></g> <g id="a_node1_5"><a xlink:href="#"
    xlink:title="tree_to_string(self, tree)"><text text-anchor="start" x="41" y="-20.5"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">tree_to_string()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="update_grammar(self, trace)"><text
    text-anchor="start" x="41" y="-7.75" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-size="10.00">update_grammar()</text></a></g></a></g></a></g></g>
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="8" y="-309.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node2_9"><a xlink:href="GrammarFuzzer.html" xlink:title="check_grammar(self)
    -> None:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '如果设置了`log`，则将中间步骤作为文本显示在标准输出上。《初始化()`</text></a></g> <g id="a_node2_9"><a xlink:href="GrammarFuzzer.html"
    xlink:title="check_grammar(self) -> None:'
- en: 'Check the grammar passed"><text text-anchor="start" x="8" y="-296.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">check_grammar()</text></a></g>
    <g id="a_node2_10"><a xlink:href="GrammarFuzzer.html" xlink:title="choose_node_expansion(self,
    node: Tuple[str, Optional[List[Any]]], children_alternatives: List[List[Tuple[str,
    Optional[List[Any]]]]]) -> int:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '检查传递的语法。《检查语法()`</text></a></g> <g id="a_node2_10"><a xlink:href="GrammarFuzzer.html"
    xlink:title="choose_node_expansion(self, node: Tuple[str, Optional[List[Any]]],
    children_alternatives: List[List[Tuple[str, Optional[List[Any]]]]]) -> int:'
- en: Return index of expansion in `children_alternatives` to be selected.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`children_alternatives`中要选择的扩展索引。
- en: '''children_alternatives`: a list of possible children for `node`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`''children_alternatives''`: `node`的可能子节点列表。'
- en: 'Defaults to random. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-283.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">choose_node_expansion()</text></a></g>
    <g id="a_node2_11"><a xlink:href="GrammarFuzzer.html" xlink:title="choose_tree_expansion(self,
    tree: Tuple[str, Optional[List[Any]]], children: List[Tuple[str, Optional[List[Any]]]])
    -> int:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '默认为随机。在子类中重载。《选择节点扩展()`</text></a></g> <g id="a_node2_11"><a xlink:href="GrammarFuzzer.html"
    xlink:title="choose_tree_expansion(self, tree: Tuple[str, Optional[List[Any]]],
    children: List[Tuple[str, Optional[List[Any]]]]) -> int:'
- en: Return index of subtree in `children` to be selected for expansion.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回要扩展的子树在`children`中的索引。
- en: 'Defaults to random."><text text-anchor="start" x="8" y="-271" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">choose_tree_expansion()</text></a></g>
    <g id="a_node2_12"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_node_randomly(self,
    node: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '默认为随机。《选择树扩展()`</text></a></g> <g id="a_node2_12"><a xlink:href="GrammarFuzzer.html"
    xlink:title="expand_node_randomly(self, node: Tuple[str, Optional[List[Any]]])
    -> Tuple[str, Optional[List[Any]]]:'
- en: 'Choose a random expansion for `node` and return it"><text text-anchor="start"
    x="8" y="-258.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">expand_node_randomly()</text></a></g>
    <g id="a_node2_13"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_tree(self,
    tree: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '为`node`选择一个随机扩展并返回它。《随机扩展节点()`</text></a></g> <g id="a_node2_13"><a xlink:href="GrammarFuzzer.html"
    xlink:title="expand_tree(self, tree: Tuple[str, Optional[List[Any]]]) -> Tuple[str,
    Optional[List[Any]]]:'
- en: 'Expand `tree` in a three-phase strategy until all expansions are complete."><text
    text-anchor="start" x="8" y="-245.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">expand_tree()</text></a></g>
    <g id="a_node2_14"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_tree_once(self,
    tree: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '以三阶段策略扩展`tree`，直到所有扩展都完成。《扩展树()`</text></a></g> <g id="a_node2_14"><a xlink:href="GrammarFuzzer.html"
    xlink:title="expand_tree_once(self, tree: Tuple[str, Optional[List[Any]]]) ->
    Tuple[str, Optional[List[Any]]]:'
- en: Choose an unexpanded symbol in tree; expand it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在树中选择一个未扩展的符号；扩展它。
- en: 'Can be overloaded in subclasses."><text text-anchor="start" x="8" y="-232.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">expand_tree_once()</text></a></g> <g id="a_node2_15"><a
    xlink:href="GrammarFuzzer.html" xlink:title="expand_tree_with_strategy(self, tree:
    Tuple[str, Optional[List[Any]]], expand_node_method: Callable, limit: Optional[int]
    = None):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '可在子类中重载。"><text text-anchor="start" x="8" y="-232.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">expand_tree_once()</text></a></g> <g id="a_node2_15"><a xlink:href="GrammarFuzzer.html"
    xlink:title="expand_tree_with_strategy(self, tree: Tuple[str, Optional[List[Any]]],
    expand_node_method: Callable, limit: Optional[int] = None):'
- en: Expand tree using `expand_node_method` as node expansion function
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`expand_node_method`作为节点扩展函数展开树
- en: 'until the number of possible expansions reaches `limit`."><text text-anchor="start"
    x="8" y="-220" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">expand_tree_with_strategy()</text></a></g>
    <g id="a_node2_16"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '直到可能的扩展数量达到`limit`。"><text text-anchor="start" x="8" y="-220" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">expand_tree_with_strategy()</text></a></g>
    <g id="a_node2_16"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
- en: 'Produce a string from the grammar."><text text-anchor="start" x="8" y="-207.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node2_17"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -> Tuple[str, Optional[List[Any]]]:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法中生成一个字符串。"><text text-anchor="start" x="8" y="-207.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_17"><a xlink:href="GrammarFuzzer.html"
    xlink:title="fuzz_tree(self) -> Tuple[str, Optional[List[Any]]]:'
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="8"
    y="-194.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g> <g id="a_node2_18"><a
    xlink:href="GrammarFuzzer.html" xlink:title="log_tree(self, tree: Tuple[str, Optional[List[Any]]])
    -> None:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法中生成一个推导树。"><text text-anchor="start" x="8" y="-194.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g>
    <g id="a_node2_18"><a xlink:href="GrammarFuzzer.html" xlink:title="log_tree(self,
    tree: Tuple[str, Optional[List[Any]]]) -> None:'
- en: 'Output a tree if self.log is set; if self.display is also set, show the tree
    structure"><text text-anchor="start" x="8" y="-181.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">log_tree()</text></a></g>
    <g id="a_node2_19"><a xlink:href="GrammarFuzzer.html" xlink:title="process_chosen_children(self,
    chosen_children: List[Tuple[str, Optional[List[Any]]]], expansion: Union[str,
    Tuple[str, Dict[str, Any]]]) -> List[Tuple[str, Optional[List[Any]]]]:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '如果self.log被设置，则输出一个树；如果self.display也被设置，则显示树结构"><text text-anchor="start" x="8"
    y="-181.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">log_tree()</text></a></g> <g id="a_node2_19"><a
    xlink:href="GrammarFuzzer.html" xlink:title="process_chosen_children(self, chosen_children:
    List[Tuple[str, Optional[List[Any]]]], expansion: Union[str, Tuple[str, Dict[str,
    Any]]]) -> List[Tuple[str, Optional[List[Any]]]]:'
- en: 'Process children after selection. &nbsp;By default, does nothing."><text text-anchor="start"
    x="8" y="-169" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">process_chosen_children()</text></a></g>
    <g id="a_node2_20"><a xlink:href="GrammarFuzzer.html" xlink:title="supported_opts(self)
    -> Set[str]:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '选择后处理子节点。默认情况下，不执行任何操作。"><text text-anchor="start" x="8" y="-169" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">process_chosen_children()</text></a></g>
    <g id="a_node2_20"><a xlink:href="GrammarFuzzer.html" xlink:title="supported_opts(self)
    -> Set[str]:'
- en: 'Set of supported options. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-156.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">supported_opts()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>ConcolicGrammarFuzzer->GrammarFuzzer</title></g>
    <g id="node3" class="node"><title>Fuzzer</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '支持的选项集合。在子类中可重载。"><text text-anchor="start" x="8" y="-156.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">supported_opts()</text></a></g></a></g></a></g></g> <g id="edge1"
    class="edge"><title>ConcolicGrammarFuzzer->GrammarFuzzer</title></g> <g id="node3"
    class="node"><title>Fuzzer</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
- en: 'Base class for fuzzers."><text text-anchor="start" x="68.38" y="-453.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node3_21"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node3_22"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '模糊器的基类。"><text text-anchor="start" x="68.38" y="-453.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node3_21"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node3_22"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
- en: 'Constructor"><text text-anchor="start" x="59" y="-431.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_23"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数"><text text-anchor="start" x="59" y="-431.25" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_23"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
- en: 'Return fuzz input"><text text-anchor="start" x="59" y="-418.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node3_24"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入"><text text-anchor="start" x="59" y="-418.5" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node3_24"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="59" y="-405.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node3_25"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '使用模糊输入运行 `runner`"><text text-anchor="start" x="59" y="-405.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">run()</text></a></g>
    <g id="a_node3_25"><a xlink:href="Fuzzer.html" xlink:title="runs(self, runner:
    Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess,
    str]]:'
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="59"
    y="-393" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="10.00">runs()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>GrammarFuzzer->Fuzzer</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="190.38"
    y="-71.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="190.38" y="-61.75" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="196.38" y="-61.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="190.38" y="-51.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="196.38" y="-51.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="190.38" y="-41.75" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="196.38" y="-41.75" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="190.38" y="-32.7" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模糊输入运行 `runner`，`trials` 次数"><text text-anchor="start" x="59" y="-393" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge2" class="edge"><title>GrammarFuzzer->Fuzzer</title></g> <g id="node4"
    class="node"><title>图例</title> <text text-anchor="start" x="190.38" y="-71.75"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">图例</text> <text text-anchor="start" x="190.38" y="-61.75" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="196.38" y="-61.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="190.38" y="-51.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="196.38" y="-51.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="190.38" y="-41.75" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="196.38" y="-41.75" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="190.38" y="-32.7" font-family="Helvetica,sans-Serif"
    font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: Tracking Constraints
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 追踪约束
- en: In the chapter on [information flow](InformationFlow), we have seen how dynamic
    taints can be used to direct fuzzing by indicating which part of input reached
    interesting places. However, dynamic taint tracking is limited in the information
    that it can propagate. For example, we might want to explore what happens when
    certain properties of the input changes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于[信息流](InformationFlow)的章节中，我们看到了如何使用动态污点来通过指示输入的哪一部分到达了有趣的地方来指导模糊测试。然而，动态污点跟踪在它能够传播的信息方面是有限的。例如，我们可能想要探索当输入的某些属性发生变化时会发生什么。
- en: For example, say we have a function `factorial()` that returns the *factorial
    value* of its input.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个返回输入的*阶乘值*的函数`factorial()`。
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We exercise the function with a value of `5`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`5`的值来测试这个函数。
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Is this sufficient to explore all the features of the function? How do we know?
    One way to verify that we have explored all features is to look at the *coverage
    obtained*. First we need to extend the `Coverage` class from the [chapter on coverage](Coverage.html)
    to provide us with coverage arcs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否足以探索函数的所有特性？我们如何知道？验证我们已经探索了所有特性的方法之一是查看*获得的覆盖范围*。首先，我们需要将`Coverage`类从[关于覆盖的章节](Coverage.html)扩展，以提供覆盖弧。
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, we use the `Tracer` to obtain the coverage arcs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`Tracer`来获取覆盖弧。
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now use the coverage arcs to visualize the coverage obtained.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用覆盖弧来可视化所获得的覆盖范围。
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
- en: We see that the path `[1, 2, 5, 8, 11, 12, 13, 14]` is covered (green) but sub-paths
    such as `[2, 3]`, `[5, 6]` and `[8, 9]` are unexplored (red). What we need is
    the ability to generate inputs such that the `True` branch is taken at `2`. How
    do we do that?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到路径`[1, 2, 5, 8, 11, 12, 13, 14]`被覆盖（绿色），但子路径如`[2, 3]`、`[5, 6]`和`[8, 9]`未被探索（红色）。我们需要的是生成输入，使得在`2`处采纳`True`分支的能力。我们如何做到这一点？
- en: Concolic Execution
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号执行
- en: One way to cover additional branches is to look at the execution path being
    taken, and collect the *conditional constraints* that the path encounters. Then
    we can try to produce inputs that lead us to taking the non-traversed path.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖额外分支的一种方法是通过查看正在执行的路径，并收集路径遇到的*条件约束*。然后我们可以尝试生成引导我们采取未遍历路径的输入。
- en: First, let us step through the function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们逐步分析这个函数。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The line (1) is simply the entry point of the function. We know that the input
    is `n`, which is an integer.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行（1）仅仅是函数的入口点。我们知道输入是`n`，它是一个整数。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The line (2) is a predicate `n < 0`. Since the next line taken is line (5),
    we know that at this point in the execution path, the predicate was `false`.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行（2）是一个断言`n < 0`。由于接下来采取的是行（5），我们知道在执行路径的这个点上，断言是`false`。
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We notice that this is one of the predicates where the `true` branch was not
    taken. How do we generate a value that takes the `true` branch here? One way is
    to use symbolic variables to represent the input, encode the constraint, and use
    an *SMT Solver* to solve the negation of the constraint.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，这是其中之一，`true`分支没有被采纳的断言。我们如何生成一个能够采纳`true`分支的值呢？一种方法是用符号变量来表示输入，编码约束，并使用*SMT求解器*来解决约束的否定。
- en: As we mentioned in the introduction to the chapter, a symbolic variable can
    be thought of as a sort of placeholder for the real variable, sort of like the
    `x` in solving for `x` in Algebra. These variables can be used to encode constraints
    placed on the variables in the program. We identify what constraints the variable
    is supposed to obey, and finally produce a value that obeys all constraints imposed.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在章节引言中提到的，符号变量可以被视为真实变量的某种占位符，类似于在代数中求解`x`时的`x`。这些变量可以用来编码程序中变量的约束。我们确定变量应该遵守的约束，并最终产生一个遵守所有施加约束的值。
- en: Solving Constraints
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决约束
- en: To solve these constraints, one can use a *Satisfiability Modulo Theories* (SMT)
    solver. An SMT solver is built on top of a *SATISFIABILITY* (SAT) solver. A SAT
    solver is being used to check whether boolean formulas in first order logic (e.g.
    `(a | b ) & (~a | ~b)`) can be satisfied using any assignments for the variables
    (e.g `a = true, b = false`). An SMT solver extends these SAT solvers to specific
    background theories -- for example, *theory of integers*, or *theory of strings*.
    That is, given a string constraint expressed as a formula with string variables
    (e.g. `h + t == 'hello,world'`), an SMT solver that understands *theory of strings*
    can be used to check if that constraint can be satisfied, and if satisfiable,
    provide an instantiation of concrete values for the variables used in the formula
    (e.g `h = 'hello,', t = 'world'`).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这些约束，可以使用 *理论可满足性 (SMT)* 求解器。SMT 求解器建立在 *可满足性 (SAT)* 求解器之上。SAT 求解器用于检查一阶逻辑中的布尔公式（例如
    `(a | b ) & (~a | ~b)`）是否可以通过任何变量的赋值（例如 `a = true, b = false`）来满足。SMT 求解器将这些 SAT
    求解器扩展到特定的背景理论 -- 例如，*整数理论* 或 *字符串理论*。也就是说，给定一个以字符串变量表示的公式（例如 `h + t == 'hello,world'`）作为字符串约束，一个理解
    *字符串理论* 的 SMT 求解器可以用来检查该约束是否可以满足，如果可以满足，则提供公式中使用的变量的具体值实例（例如 `h = 'hello,', t
    = 'world'`）。
- en: We use the SMT solver Z3 in this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 SMT 求解器 Z3。
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let us set up Z3 first. To ensure that the string constraints we use in this
    chapter are successfully evaluated, we need to specify the `z3str3` solver. Further,
    we set the timeout for Z3 computations to 30 seconds.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先设置 Z3。为了确保本章中使用的字符串约束能够成功评估，我们需要指定 `z3str3` 求解器。此外，我们将 Z3 计算的超时时间设置为 30
    秒。
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To encode constraints, we need symbolic variables. Here, we make `zn` a placeholder
    for the Z3 symbolic integer variable `n`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要编码约束，我们需要符号变量。在这里，我们将 `zn` 作为 Z3 符号整数变量 `n` 的占位符。
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Remember the constraint `(n < 0)` from line 2 in `factorial()`? We can now encode
    the constraint as follows.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 `factorial()` 第 2 行的约束 `(n < 0)` 吗？我们现在可以将这个约束编码如下。
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: n < 0
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: n < 0
- en: We previously traced `factorial(5)`. We saw that with input `5`, the execution
    took the `else` branch on the predicate `n < 0`. We can express this observation
    as follows.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前追踪了 `factorial(5)` 的执行过程。我们注意到，当输入为 `5` 时，执行流程进入了谓词 `n < 0` 的 `else` 分支。我们可以这样表达这个观察结果。
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ¬(n < 0)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ¬(n < 0)
- en: 'Let us now solve constraints. The `z3.solve()` method checks if the constraints
    are satisfiable; if they are, it also provides values for variables such that
    the constraints are satisfied. For example, we can ask Z3 for an input that will
    take the `else` branch as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来解决约束。`z3.solve()` 方法检查约束是否可满足；如果是，它还提供变量的值，使得约束得到满足。例如，我们可以要求 Z3 提供一个输入，使其执行时进入
    `else` 分支，如下所示：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is *a solution* (albeit a trivial one). SMT solvers can be used to solve
    much harder problems. For example, here is how one can solve a quadratic equation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 *解决方案*（尽管是一个平凡的解决方案）。SMT 求解器可以用来解决更难的问题。例如，下面是如何解一个二次方程的。
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, this is *one solution*. We can ask z3 to give us another solution as
    follows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这是一个 *解决方案*。我们可以要求 z3 给我们另一个解决方案，如下所示。
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Indeed, both `x = 5` and `x = 1/2` are solutions to the quadratic equation $2x^2
    -11x + 5 = 0$
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`x = 5` 和 `x = 1/2` 都是二次方程 $2x^2 -11x + 5 = 0$ 的解
- en: Similarly, we can ask *Z3* for an input that satisfies the constraint encoded
    in line 2 of `factorial()` so that we take the `if` branch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以要求 *Z3* 提供一个输入，使其满足 `factorial()` 第 2 行中编码的约束，从而进入 `if` 分支。
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That is, if one uses `-1` as an input to `factorial()`, it is guaranteed to
    take the `if` branch in line 2 during execution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是如果将 `-1` 作为 `factorial()` 的输入，它保证在执行过程中进入第 2 行的 `if` 分支。
- en: Let us try using that with our coverage. Here, the `-1` is the solution from
    above.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用这个方法来提高我们的覆盖率。在这里，`-1` 是上面的解决方案。
- en: '[PRE43]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
- en: 'Ok, so we have managed to cover a little more of the graph. Let us continue
    with our original input of `factorial(5)`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们已经覆盖了图中的更多部分。让我们继续使用原始输入 `factorial(5)`：
- en: In line (5) we encounter a new predicate `n == 0`, for which we again took the
    false branch.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 (5) 行，我们遇到了一个新的谓词 `n == 0`，对于这个谓词，我们又选择了 `false` 分支。
- en: '[PRE45]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The predicates required, to follow the path until this point are as follows.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的谓词，以跟随路径到这一点如下。
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If we continue to line (8), we encounter another predicate, for which again,
    we took the `false` branch
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们继续到第 (8) 行，我们会遇到另一个谓词，对于这个谓词，我们又选择了 `false` 分支
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The predicates encountered so far are as follows
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止遇到的谓词如下
- en: '[PRE50]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To take the branch at (6), we essentially have to obey the predicates until
    that point, but invert the last predicate.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择（6）处的分支，我们本质上必须遵守直到那个点的谓词，但反转最后一个谓词。
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What we are doing here is tracing the execution corresponding to a particular
    input `factorial(5)`, using concrete values, and along with it, keeping *symbolic
    shadow variables* that enable us to capture the constraints. As we mentioned in
    the introduction, this particular method of execution where one tracks concrete
    execution using symbolic variables is called *Concolic Execution*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是跟踪对应于特定输入`factorial(5)`的执行，使用具体值，并与之一起，保持*符号阴影变量*，使我们能够捕获约束。正如我们在引言中提到的，这种通过使用符号变量跟踪具体执行的方法被称为*符号化执行*。
- en: How do we automate this process? One method is to use a similar infrastructure
    as that of the chapter on [information flow](InformationFlow.html), and use the
    Python inheritance to create *symbolic proxy objects* that can track the concrete
    execution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何自动化这个过程呢？一种方法是使用与[信息流](InformationFlow.html)章节中类似的基础设施，并使用Python继承来创建可以跟踪具体执行的*符号代理对象*。
- en: A Concolic Tracer
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号化跟踪器
- en: Let us now define a class to *collect* symbolic variables and path conditions
    during an execution. The idea is to have a `ConcolicTracer` class that is invoked
    in a `with` block. To execute a function while tracing its path conditions, we
    need to *transform* its arguments, which we do by invoking functions through a
    `[]` item access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个类来在执行过程中*收集*符号变量和路径条件。想法是有一个在`with`块中调用的`ConcolicTracer`类。为了在跟踪其路径条件的同时执行一个函数，我们需要*转换*其参数，我们通过通过`[]`项访问调用函数来实现。
- en: 'This is a typical usage of a `ConcolicTracer`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的`ConcolicTracer`用法：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After execution, we can access the symbolic variables in the `decls` attribute:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，我们可以通过`decls`属性访问符号变量：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'whereas the `path` attribute lists the precondition paths encountered:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 而`path`属性列出了遇到的先决条件路径：
- en: '[PRE55]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `context` attribute contains a pair of declarations and paths:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`属性包含一对声明和路径：'
- en: '[PRE56]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If you read this for the first time, skip the implementation and head right
    to the examples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你第一次阅读这篇文章，请跳过实现部分，直接查看示例。
- en: <details id="Excursion:-Implementing-ConcolicTracer"><summary>Implementing ConcolicTracer</summary>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-ConcolicTracer"><summary>实现ConcolicTracer</summary>
- en: Let us now implement `ConcolicTracer`. Its constructor accepts a single `context`
    argument which contains the declarations for the symbolic variables seen so far,
    and path conditions seen so far. We only need this in case of nested contexts.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现`ConcolicTracer`。它的构造函数接受一个`context`参数，该参数包含迄今为止看到的符号变量的声明和路径条件。我们只需要在嵌套上下文中使用它。
- en: '[PRE57]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We add the enter and exit methods for the `with` block.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`with`块添加了进入和退出方法。
- en: '[PRE58]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We use introspection to determine the arguments to the function, which is hooked
    into the `getitem()` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用内省来确定函数的参数，该参数被钩入`getitem()`方法。
- en: '[PRE59]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, the function itself is invoked using the `call` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`call`方法调用函数本身。
- en: '[PRE60]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For now, we define `concolic()` as a transparent function. It will be modified
    to produce symbolic variables later.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将`concolic()`定义为透明的函数。稍后它将被修改以产生符号变量。
- en: '[PRE61]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We now have things in place for *tracing* functions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经为*跟踪*函数准备好了：
- en: '[PRE62]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And for retrieving results (but not actually *computing* them):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以及用于检索结果（但实际上并不*计算*它们）：
- en: '[PRE63]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Both `decls` and `path` attributes will be set by concolic proxy objects, which
    we define next.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`decls`和`path`属性将由我们接下来定义的符号化代理对象设置。'
- en: Concolic Proxy Objects
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 符号化代理对象
- en: We now define the concolic proxy objects that can be used for concolic tracing.
    First, we define the `zproxy_create()` method that given a class name, correctly
    creates an instance of that class, and the symbolic corresponding variable, and
    registers the symbolic variable in the context information `context`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义可以用于符号化跟踪的符号化代理对象。首先，我们定义`zproxy_create()`方法，它给定一个类名，正确地创建该类的实例和相应的符号变量，并在上下文信息`context`中注册符号变量。
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: A Proxy Class for Booleans
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 布尔代理类
- en: First, we define the `zbool` class which is used to track the predicates encountered.
    It is a wrapper class that contains both symbolic (`z`) and concrete (`v`) values.
    The concrete value is used to determine which path to take, and the symbolic value
    is used to collect the predicates encountered.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义用于跟踪遇到的谓词的 `zbool` 类。它是一个包装类，包含符号（`z`）和具体（`v`）值。具体值用于确定要采取的路径，符号值用于收集遇到的谓词。
- en: The initialization is done in two parts. The first one is using `zproxy_create()`
    to correctly initialize and register the shadow symbolic variable corresponding
    to the passed argument. This is used exclusively when the symbolic variable needs
    to be initialized first. In all other cases, the constructor is called with the
    preexisting symbolic value.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化分为两部分进行。第一部分是使用 `zproxy_create()` 正确初始化和注册与传递的参数对应的阴影符号变量。这仅在符号变量需要首先初始化时使用。在其他所有情况下，使用现有的符号值调用构造函数。
- en: '[PRE68]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here is how it is used. We create a symbolic variable `my_bool_arg` with a
    value of `True` in the current context of the concolic tracer:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用的。我们在 concolic tracer 的当前上下文中创建一个具有 `True` 值的符号变量 `my_bool_arg`：
- en: '[PRE69]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now access the symbolic name in the `z` attribute:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以访问 `z` 属性中的符号名称：
- en: '[PRE70]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: my_bool_arg
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: my_bool_arg
- en: 'The value is in the `v` attribute:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 值位于 `v` 属性中：
- en: '[PRE71]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Note that the context of the enclosing `ConcolicTracer()` is automatically
    updated (via `zproxy_create()`) to hold the variable declarations and types:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，封装的 `ConcolicTracer()` 的上下文会自动更新（通过 `zproxy_create()`），以包含变量声明和类型：
- en: '[PRE73]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The context can also be reached through the `context` attribute; both point
    to the same data structure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文也可以通过 `context` 属性访问；两者指向相同的数据结构。
- en: '[PRE75]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Negation of Encoded formula
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 编码公式的否定
- en: The `zbool` class allows negation of its concrete and symbolic values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`zbool` 类允许对其具体和符号值进行否定。'
- en: '[PRE77]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here is how it can be used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用它的。
- en: '[PRE78]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: ¬my_bool_arg
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: ¬my_bool_arg
- en: '[PRE80]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Registering Predicates on Conditionals
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在条件上注册谓词
- en: 'The `zbool` class is being used to track Boolean conditions that arise during
    program execution. It tracks such conditions by registering the corresponding
    symbolic expressions in the context as soon as it is evaluated. On evaluation,
    the `__bool__()` method is called; so we can hook into this one:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`zbool` 类正在被用来跟踪程序执行过程中出现的布尔条件。它通过在评估时立即在上下文中注册相应的符号表达式来跟踪这些条件。在评估时，会调用 `__bool__()`
    方法；因此，我们可以挂钩到这个方法：'
- en: '[PRE84]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `zbool` class can be used to keep track of Boolean values and conditions
    encountered during the execution. For example, we can encode the conditions encountered
    by Line 6 in `factorial()` as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`zbool` 类可以用来跟踪执行过程中遇到的布尔值和条件。例如，我们可以将 `factorial()` 中第 6 行遇到的条件编码如下：'
- en: First, we define the concrete value (`ca`), and its shadow symbolic variable
    (`za`).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义具体的值（`ca`）及其阴影符号变量（`za`）。
- en: '[PRE85]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Then, we wrap it in `zbool`, and use it in a conditional, forcing the conditional
    to be registered in the context.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将其包装在 `zbool` 中，并在条件中使用它，强制条件在上下文中注册。
- en: '[PRE86]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We can retrieve the registered conditional as follows.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式检索已注册的条件。
- en: '[PRE88]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: A Proxy Class for Integers
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 整数的代理类
- en: Next, we define a symbolic wrapper `zint` for `int`. This class keeps track
    of the `int` variables used and the predicates encountered in `context`. Finally,
    it also keeps the concrete value so that it can be used to determine the path
    to take. As the `zint` extends the primitive `int` class, we have to define a
    *new* method to open it for extension.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个用于 `int` 的符号包装器 `zint`。这个类跟踪在 `context` 中使用的 `int` 变量和遇到的谓词。最后，它还保留具体值，以便可以用来确定要采取的路径。由于
    `zint` 扩展了原始的 `int` 类，我们必须定义一个 *新* 方法来允许其扩展。
- en: '[PRE90]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As in the case of `zbool`, the initialization takes place in two parts. The
    first using `create()` if a new symbolic argument is being registered, and then
    the usual initialization.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `zbool` 的情况一样，初始化也分为两部分进行。第一部分是如果正在注册新的符号参数，则使用 `create()`，然后进行常规初始化。
- en: '[PRE91]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `int` value of a `zint` object is its concrete value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`zint` 对象的 `int` 值是其具体值。'
- en: '[PRE92]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Using these proxies is as follows.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些代理的方式如下。
- en: '[PRE93]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: int_arg
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: int_arg
- en: '[PRE95]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The `zint` class is often used to do arithmetic with, or compare to other `int`s.
    These `int`s can be either a variable or a constant value. We define a helper
    method `_zv()` that checks what kind of `int` a given value is, and produces the
    correct symbolic equivalent.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`zint` 类通常用于与其他 `int` 进行算术运算或比较。这些 `int` 可以是一个变量或一个常量值。我们定义了一个辅助方法 `_zv()`，用于检查给定值是哪种
    `int`，并生成正确的符号等价物。'
- en: '[PRE99]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: It can be used as follows
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用以下方式使用
- en: '[PRE100]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Equality between Integers
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数之间的等价
- en: Two integers can be compared for equality using *ne* and *eq*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 两个整数可以使用 `ne` 和 `eq` 进行等价比较。
- en: '[PRE105]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We also define *req* using *eq* in case the int being compared is on the left-hand
    side.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用 `eq` 定义了 `*req*`，以防比较的整数在左侧。
- en: '[PRE106]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: It can be used as follows.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以用以下方式使用。
- en: '[PRE107]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Comparisons between Integers
  id: totrans-280
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数之间的比较
- en: Integers can also be compared for ordering, and the methods for this are defined
    below.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 整数也可以用于比较顺序，相关的方法定义如下。
- en: '[PRE109]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: We use the comparisons and equality operators to provide the other missing operators.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用比较和等价运算符来提供其他缺失的运算符。
- en: '[PRE110]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: These functions can be used as follows.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数可以用以下方式使用。
- en: '[PRE111]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Binary Operators for Integers
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数的二元运算符
- en: We implement relevant arithmetic operators for integers as described in the
    [Python documentation](https://docs.python.org/3/reference/datamodel.html#object.__add__).
    (The commented out operators are not directly available for `z3.ArithRef`. They
    need to be implemented separately if needed. See the exercises for how it can
    be done.)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了整数的相关算术运算符，如 [Python 文档](https://docs.python.org/3/reference/datamodel.html#object.__add__)
    中所述。（注释掉的运算符对于 `z3.ArithRef` 不是直接可用的。如果需要，它们需要单独实现。参见练习，了解如何实现。）
- en: '[PRE113]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Integer Unary Operators
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 整数一元运算符
- en: We also implement the relevant unary operators as below.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了以下相关的一元运算符。
- en: '[PRE122]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can use the unary operators we defined above as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上面定义的一元运算符如下：
- en: '[PRE127]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Using an Integer in a Boolean Context
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在布尔上下文中使用整数
- en: An integer may be converted to a boolean context in conditionals or as part
    of boolean predicates such as `or`, `and` and `not`. In these cases, the `__bool__()`
    method gets called. Unfortunately, this method requires a primitive boolean value.
    Hence, we force the current integer formula to a boolean predicate and register
    it in the current context.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 整数可以在条件语句或作为布尔谓词（如 `or`、`and` 和 `not`）的一部分转换为布尔上下文。在这些情况下，会调用 `__bool__()` 方法。不幸的是，此方法需要一个原始布尔值。因此，我们将当前整数公式强制转换为布尔谓词，并在当前上下文中注册它。
- en: '[PRE129]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: It is used as follows
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用如下
- en: '[PRE130]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Remaining Methods of the ConcolicTracer
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ConcolicTracer 的剩余方法
- en: We now complete some methods of the `ConcolicTracer`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在完成 `ConcolicTracer` 的某些方法。
- en: Translating to the SMT Expression Format
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换为 SMT 表达式格式
- en: Given that we are using an SMT Solver z3, it is often useful to retrieve the
    corresponding SMT expression for a symbolic expression. This can be used as an
    argument to `z3` or other SMT solvers.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 SMT 求解器 z3，检索符号表达式的对应 SMT 表达式通常很有用。这可以用作 `z3` 或其他 SMT 求解器的参数。
- en: 'The format of the SMT expression ([SMT-LIB](http://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf))
    is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: SMT 表达式的格式（[SMT-LIB](http://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf)）如下：
- en: Variables declarations in [S-EXP](https://en.wikipedia.org/wiki/S-expression)
    format. E.g. The following declares a symbolic integer variable `x`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[S-EXP](https://en.wikipedia.org/wiki/S-expression) 格式的变量声明。例如，以下声明了一个符号整数变量
    `x`'
- en: '[PRE133]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This declares a `bit vector` `b` of length `8`
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这声明了一个长度为 `8` 的 `bit vector` `b`
- en: '[PRE134]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This declares a symbolic real variable `r`
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这声明了一个符号实变量 `r`
- en: '[PRE135]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This declares a symbolic string variable `s`
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这声明了一个符号字符串变量 `s`
- en: '[PRE136]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The declared variables can be used in logical formulas that are encoded in *S-EXP*
    format. For example, here is a logical formula.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 声明的变量可以用于编码在 *S-EXP* 格式的逻辑公式中。例如，这里是一个逻辑公式。
- en: '[PRE137]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Here is another example, using string variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个例子，使用字符串变量。
- en: '[PRE138]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: To see how to use `smt_expr()`, let us consider an example. The `triangle()`
    function is used to determine if the given sides to a triangle result in an `equilateral`
    triangle, an `isosceles` triangle, or a `scalene` triangle. It is implemented
    as follows.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 `smt_expr()`，让我们考虑一个例子。`triangle()` 函数用于确定给定的三角形边长是否构成一个 `equilateral`
    三角形、一个 `isosceles` 三角形或一个 `scalene` 三角形。它的实现如下。
- en: '[PRE140]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: To make `triangle()` run under `ConcolicTracer`, we first define the (symbolic)
    arguments. The triangle being defined has sides `1, 1, 1`. i.e. it is an `equilateral`
    triangle.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 `triangle()` 在 `ConcolicTracer` 下运行，我们首先定义（符号）参数。定义的三角形边长为 `1, 1, 1`，即它是一个
    `equilateral` 三角形。
- en: '[PRE143]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: We can now call `smt_expr()` to retrieve the SMT expression as below.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用 `smt_expr()` 来检索以下 SMT 表达式。
- en: '[PRE145]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: The collected predicates can also be solved directly using the Python z3 API.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 收集到的谓词也可以直接使用 Python z3 API 解决。
- en: '[PRE147]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Generating Fresh Names
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成新名称
- en: While using the proxy classes, we often will have to generate new symbolic variables,
    with names that have not been used before. For this, we define `fresh_name()`
    that always generates unique integers for names.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用代理类时，我们通常需要生成新的符号变量，这些变量的名称之前未被使用过。为此，我们定义了 `fresh_name()`，它总是为名称生成唯一的整数。
- en: '[PRE149]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'It can be used as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以这样使用：
- en: '[PRE151]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Translating Arguments to Concolic Proxies
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将参数翻译为 Concolic 代理
- en: We had previously defined `concolic()` as a transparent function. We now provide
    the full implementation of this function. It inspects a given function's parameters,
    and infers the parameter types from the concrete arguments passed in. It then
    uses this information to instantiate the correct proxy classes for each argument.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已将 `concolic()` 定义为一个透明函数。现在我们提供这个函数的完整实现。它检查给定函数的参数，并从传递的具体参数中推断参数类型。然后它使用这些信息为每个参数实例化正确的代理类。
- en: '[PRE155]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'This is how it gets used:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的使用方法：
- en: '[PRE156]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: With the new `concolic()` method, the arguments to the factorial are correctly
    associated with symbolic variables, which allows us to retrieve the predicates
    encountered.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的 `concolic()` 方法，阶乘的参数被正确地与符号变量关联，这允许我们检索遇到的谓词。
- en: '[PRE157]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: As before, we can also print out the SMT expression which can be passed directly
    to command line SMT solvers.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还可以打印出可以直接传递给命令行 SMT 求解器的 SMT 表达式。
- en: '[PRE159]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: We next define methods to evaluate the SMT expression both in Python and from
    command line.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了在 Python 和命令行中评估 SMT 表达式的方法。
- en: Evaluating the Concolic Expressions
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 评估 Concolic 表达式
- en: We define `zeval()` to solve the predicates in a context, and return results.
    It has two modes. The `python` mode uses `z3` Python API to solve and return the
    results. If the `python` mode is false, it writes the SMT expression to a file,
    and invokes the command line `z3` for a solution.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `zeval()` 来在上下文中解决谓词，并返回结果。它有两种模式。`python` 模式使用 `z3` Python API 解决并返回结果。如果
    `python` 模式为假，则将 SMT 表达式写入文件，并调用命令行 `z3` 进行求解。
- en: '[PRE161]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Using the Python API
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Python API
- en: Given a set of predicates that the function encountered, and the tracer under
    which the function was executed, the `zeval_py()` function first declares the
    relevant symbolic variables, and uses the `z3.Solver()`to provide a set of inputs
    that would trace the same path through the function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 给定函数遇到的谓词集以及函数执行的跟踪器，`zeval_py()` 函数首先声明相关的符号变量，并使用 `z3.Solver()` 提供一组输入，这些输入会在函数中跟踪相同的路径。
- en: '[PRE162]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'It can be used as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以这样使用：
- en: '[PRE163]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: That is, given the set of constraints, the assignment `n == 5` conforms to all
    constraints.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 即，给定约束集，赋值 `n == 5` 符合所有约束。
- en: Using the Command Line
  id: totrans-379
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用命令行
- en: The `zeval_smt()` function writes the SMT expression to the file system, and
    calls the `z3` SMT solver command line to solve it. The result of SMT expression
    is again an `sexpr`. Hence, we first define `parse_sexp()` to parse and return
    the correct values.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`zeval_smt()` 函数将 SMT 表达式写入文件系统，并调用 `z3` SMT 求解器的命令行来解决问题。SMT 表达式的结果是另一个 `sexpr`。因此，我们首先定义
    `parse_sexp()` 来解析并返回正确的值。'
- en: '[PRE166]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The `parse_sexp()` function can be used as follows
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样使用 `parse_sexp()` 函数
- en: '[PRE170]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We now define `zeval_smt()` which uses the `z3` command line directly, and uses
    `parse_sexp()` to parse and return the solutions to function arguments if any.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义 `zeval_smt()`，它直接使用 `z3` 命令行，并使用 `parse_sexp()` 解析并返回函数参数的解决方案（如果有的话）。
- en: '[PRE172]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: We can now use `zeval()` as follows.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样使用 `zeval()`。
- en: '[PRE176]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Indeed, we get similar results (`n == 5`) from using the command line as from
    using the Python API.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，无论是使用命令行还是使用 Python API，我们都得到了类似的结果 (`n == 5`)。
- en: A Proxy Class for Strings
  id: totrans-399
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串代理类
- en: Here, we define the proxy string class `zstr`. First we define our initialization
    routines. Since `str` is a primitive type, we define `new` to extend it.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们定义了代理字符串类 `zstr`。首先我们定义我们的初始化例程。由于 `str` 是一个原始类型，我们定义 `new` 来扩展它。
- en: '[PRE180]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: As before, initialization proceeds with `create()` and the constructor.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，初始化通过 `create()` 和构造函数进行。
- en: '[PRE181]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: We also define `_zv()` helper to help us with methods that accept another string
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了 `_zv()` 辅助函数，以帮助我们在接受另一个字符串的方法中使用。
- en: '[PRE182]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Hack to use the ASCII value of a character.
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符的 ASCII 值的技巧。
- en: '**Note:** Temporary solution; This block should go away as soon as [this commit](https://github.com/Z3Prover/z3/issues/5764)
    is released, which allows us to use the Python API directly.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：** 暂时解决方案；这个块应该在 [这个提交](https://github.com/Z3Prover/z3/issues/5764) 发布后消失，这允许我们直接使用
    Python API。'
- en: '[PRE183]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Retrieving Ordinal Value
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取序数值
- en: We define `zord` that given a symbolic one character long string, obtains the
    `ord()` for that.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义 `zord`，它给定一个符号化的单字符长字符串，获取该字符串的 `ord()` 值。
- en: '[PRE184]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: We use it as follows
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它
- en: '[PRE185]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: No new variables are defined.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义新的变量。
- en: '[PRE187]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Here is the smtlib representation.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 smtlib 的表示形式。
- en: '[PRE189]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: We can specify what the result of `ord()` should be, and call `z3.solve()` to
    provide us with a solution that will provide the required result.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定 `ord()` 的结果，并调用 `z3.solve()` 以提供所需的解决方案。
- en: '[PRE191]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Translating an Ordinal Value to ASCII
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将序数值转换为 ASCII
- en: Similarly, we can convert the ASCII value back to a single character string
    using `zchr()`
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用 `zchr()` 将 ASCII 值转换回单个字符字符串。
- en: '[PRE195]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: For using it, we first define a bitvector that is 8 bits long.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它之前，我们首先定义一个长度为 8 位的位向量。
- en: '[PRE196]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: We can now retrieve the `chr()` representation as below.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以按以下方式检索 `chr()` 表示形式。
- en: '[PRE197]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: No new variables are defined.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 没有定义新的变量。
- en: '[PRE198]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: As before, we can specify what the end result of calling `chr()` should be to
    get the original argument.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们可以指定调用 `chr()` 后的最终结果，以获取原始参数。
- en: '[PRE202]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Equality between Strings
  id: totrans-441
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串之间的等价性
- en: The equality of `zstr` is defined similar to that of `zint`
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '`zstr` 的等价性定义与 `zint` 类似'
- en: '[PRE204]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The `zstr` class is used as follows.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`zstr` 类的使用方法如下。'
- en: '[PRE205]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: It works even if we have more than one character.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有多个字符，它也能正常工作。
- en: '[PRE209]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Length of Strings
  id: totrans-456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串长度
- en: Unfortunately, in Python, we can't override `len()` to return a new datatype.
    Hence, we work around that.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在 Python 中，我们无法覆盖 `len()` 以返回新的数据类型。因此，我们绕过这个问题。
- en: '[PRE215]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Concatenation of Strings
  id: totrans-471
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串连接
- en: What if we need to concatenate two strings? We need additional helpers to accomplish
    that.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要连接两个字符串怎么办？我们需要额外的辅助函数来完成这个操作。
- en: '[PRE228]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: Here is how it can be used. First, we create the wrapped arguments
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用它的。首先，我们创建包装后的参数
- en: '[PRE229]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: The addition of symbolic variables is preserved in `context`
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 符号变量的添加在 `context` 中被保留
- en: '[PRE231]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Producing Substrings
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生成子字符串
- en: Similarly, accessing substrings also require extra help.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，访问子字符串也需要额外的帮助。
- en: '[PRE233]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: An Iterator Class for Strings
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串的迭代器类
- en: We define the iterator as follows.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义迭代器如下。
- en: '[PRE234]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Here is how it can be used.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用它的。
- en: '[PRE235]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: Again, the context shows predicates encountered.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，上下文显示了遇到的谓词。
- en: '[PRE237]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: The function `zeval()` returns a solution for the predicate. Note that the value
    returned is not exactly the argument that we passed in. This is a consequence
    of the predicates we have. That is, we have no constraints on what the character
    value on `s[2]` should be.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `zeval()` 返回谓词的解。请注意，返回的值并不是我们传入的参数。这是由于我们有的谓词。也就是说，我们没有对 `s[2]` 上的字符值施加约束。
- en: '[PRE239]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: Translating to Upper and Lower Equivalents
  id: totrans-495
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 转换为大小写等效
- en: A major complication is supporting `upper()` and `lower()` methods. We use the
    previously defined `zchr()` and `zord()` functions to accomplish this.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要复杂点是支持 `upper()` 和 `lower()` 方法。我们使用之前定义的 `zchr()` 和 `zord()` 函数来完成此操作。
- en: '[PRE241]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: The `lower()` function is similar to `upper()` except that the character ranges
    are switched, and the lowercase is above uppercase. Hence, we add the difference
    to the ordinal to make a character to lowercase.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower()` 函数与 `upper()` 类似，除了字符范围相反，小写字母位于大写字母之上。因此，我们将差值加到序数上，以将字符转换为小写。'
- en: '[PRE242]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: Here is how `upper()` is used.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用 `upper()` 的。
- en: '[PRE243]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Again, we use `zeval()` to solve the collected constraints, and verify that
    our constraints are correct.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用 `zeval()` 解决收集到的约束，并验证我们的约束是否正确。
- en: '[PRE245]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Here is a larger example using `lower()`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `lower()` 的更大例子：
- en: '[PRE247]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Again, we obtain the right input value.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们获得了正确的输入值。
- en: Checking for String Prefixes
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查字符串前缀
- en: We define `startswith()`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了 `startswith()`。
- en: '[PRE251]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: An example.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子。
- en: '[PRE252]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: As before, the predicates only ensure that the `startswith()` returned a true
    value. Hence, our solution reflects that.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，谓词只确保 `startswith()` 返回了真值。因此，我们的解决方案反映了这一点。
- en: Finding Substrings
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找子字符串
- en: We also define `find()`
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了 `find()`。
- en: '[PRE259]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: An example.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子。
- en: '[PRE260]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: As before, the predicates only ensure that the `find()` returned a value greater
    than -1\. Hence, our solution reflects that.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，谓词只确保 `find()` 返回的值大于 -1。因此，我们的解决方案反映了这一点。
- en: Remove Space from Ends
  id: totrans-533
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从末尾移除空格
- en: We next implement `strip()`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现 `strip()`。
- en: '[PRE264]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: Example usage.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用法。
- en: '[PRE278]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The `strip()` has generated the right constraints.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip()`生成了正确的约束。'
- en: Splitting Strings
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 分割字符串
- en: We implement string `split()` as follows.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式实现字符串`split()`。
- en: '[PRE283]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Trip Wire
  id: totrans-564
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 陷阱线
- en: For easier debugging, we abort any calls to methods in `str` that are not overridden
    by `zstr`.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于调试，我们终止对`str`中未由`zstr`覆盖的方法的任何调用。
- en: '[PRE289]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]</details>'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE292]</details>'
- en: 'Example: Triangle'
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：三角形
- en: We previously showed how to run `triangle()` under `ConcolicTracer`.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前展示了如何在`ConcolicTracer`下运行`triangle()`。
- en: '[PRE293]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'The symbolic variables are as follows:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 符号变量如下：
- en: '[PRE295]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'The predicates are as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 谓词如下：
- en: '[PRE297]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'Using `zeval()`, we solve these path conditions and obtain a solution. We find
    that Z3 gives us three distinct integer values:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`zeval()`解决这些路径条件并获得解决方案。我们发现Z3给了我们三个不同的整数值：
- en: '[PRE299]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: (Note that some values may be negative. Indeed, `triangle()` works with negative
    length values, too, even if real triangles only have positive lengths.)
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: （注意，某些值可能是负数。实际上，`triangle()`也使用负长度值，即使真实三角形只有正长度。）
- en: 'If we invoke `triangle()` with these very values, we take the *exact same path*
    as the original input:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这些值调用`triangle()`，我们将采取与原始输入*完全相同的路径*：
- en: '[PRE301]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: We can have z3 *negate* individual conditions – and thus take different paths.
    First, we retrieve the symbolic variables.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让z3 *否定*个别条件——从而采取不同的路径。首先，我们检索符号变量。
- en: '[PRE303]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Then, we pass a negated predicate to `zeval()`. The key (here: `1`) determines
    which predicate the new predicate will replace.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一个否定谓词传递给`zeval()`。键（这里：`1`）确定新谓词将替换哪个谓词。
- en: '[PRE306]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The updated predicate returns `isosceles` as expected. By negating further conditions,
    we can systematically explore all branches in `triangle()`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的谓词如预期返回`isosceles`。通过否定进一步的条件，我们可以系统地探索`triangle()`中的所有分支。
- en: 'Example: Decoding CGI Strings'
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：解码CGI字符串
- en: Let us apply `ConcolicTracer` on our example program `cgi_decode()` from the
    [chapter on coverage](Coverage.html). Note that we need to rewrite its code slightly,
    as the hash lookups in `hex_values` can not be used for transferring constraints
    yet.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在[覆盖率章节](Coverage.html)中提到的示例程序`cgi_decode()`上应用`ConcolicTracer`。请注意，我们需要稍微重写其代码，因为`hex_values`中的哈希查找还不能用于传递约束。
- en: '[PRE310]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Once executed, we can retrieve the symbolic variables in the `decls` attribute.
    This is a mapping of symbolic variables to types.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行，我们就可以在`decls`属性中检索到符号变量。这是一个符号变量到类型的映射。
- en: '[PRE315]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'The extracted path conditions can be found in the `path` attribute:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 提取的路径条件可以在`path`属性中找到：
- en: '[PRE317]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: The `context` attribute holds a pair of `decls` and `path` attributes; this
    is useful for passing it into the `ConcolicTracer` constructor.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`属性包含一对`decls`和`path`属性；这对于将其传递给`ConcolicTracer`构造函数很有用。'
- en: '[PRE319]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'We can solve these constraints to obtain a value for the function parameters
    that follow the same path as the original (traced) invocation:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解决这些约束以获得与原始（跟踪）调用相同路径的函数参数的值：
- en: '[PRE320]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '*Negating* some of these constraints will yield different paths taken, and
    thus greater code coverage. This is what our concolic fuzzers (see later) do.
    Let us go and negate the first constraint, namely that the first character should
    *not* be a `+` character:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 否定其中一些约束将产生不同的路径，从而提高代码覆盖率。这正是我们的concolic模糊器（见后）所做的。让我们去否定第一个约束，即第一个字符*不应*是`+`字符：
- en: '[PRE322]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 0 < Length(cgi_decode_s_str_1)
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 0 < Length(cgi_decode_s_str_1)
- en: 'To compute the negated string, we have to construct it via z3 primitives:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算否定字符串，我们必须通过z3原语来构建它：
- en: '[PRE323]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: str.substr(cgi_decode_s_str_1, 0, 1) = "a"
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: str.substr(cgi_decode_s_str_1, 0, 1) = "a"
- en: 'Invoking `zeval()` with the path condition to be changed obtains a new input
    that satisfies the negated predicate:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 使用要更改的路径条件调用`zeval()`获得满足否定谓词的新输入：
- en: '[PRE325]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: '[PRE328]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'We can validate that `new_s` indeed takes the new path by re-running the tracer
    with `new_s` as input:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重新运行带有`new_s`作为输入的tracer来验证`new_s`确实采取了新的路径：
- en: '[PRE331]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: '[PRE332]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: By negating further conditions, we can explore more and more code.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 通过否定进一步的条件，我们可以探索更多的代码。
- en: 'Example: Round'
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：四舍五入
- en: Here is a function that gives you the nearest ten's multiplier
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个给你最近的十倍乘数的函数
- en: '[PRE334]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: As before, we execute the function under the `ConcolicTracer` context.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在`ConcolicTracer`上下文中执行函数。
- en: '[PRE335]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'We verify that we were able to capture all the predicates:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证了我们能够捕获所有谓词：
- en: '[PRE336]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: We use `zeval()` to obtain more inputs that take the same path.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`zeval()`来获取更多采取相同路径的输入。
- en: '[PRE338]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Example: Absolute Maximum'
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：绝对最大值
- en: Do our concolic proxies work across functions? Say we have a function `max_value()`
    as below.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 concolic 代理是否在函数之间工作？比如说我们有一个函数 `max_value()` 如下。
- en: '[PRE340]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: It is called by another function `abs_max()`
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 它由另一个函数 `abs_max()` 调用。
- en: '[PRE341]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: Using the `Concolic()` context on `abs_max()`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `abs_max()` 上使用 `Concolic()` 上下文。
- en: '[PRE342]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: As expected, we have the predicates across functions.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们在函数之间有谓词。
- en: '[PRE343]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: Solving the predicates works as expected.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 解决谓词按预期工作。
- en: Using negative numbers as arguments so that a different branch is taken in `abs_value()`
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 使用负数作为参数，以便在 `abs_value()` 中采取不同的分支。
- en: '[PRE347]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: The solution reflects our predicates. (We used `a > 0` in `abs_value()`).
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 该解决方案反映了我们的谓词。（我们在 `abs_value()` 中使用了 `a > 0`）。
- en: 'Example: Binomial Coefficient'
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：二项式系数
- en: For a larger example that uses different kinds of variables, say we want to
    compute the binomial coefficient by the following formulas
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个使用不同类型变量的更大示例，比如说我们想通过以下公式计算二项式系数
- en: $$ ^nP_k=\frac{n!}{(n-k)!} $$
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: $$ ^nP_k=\frac{n!}{(n-k)!} $$
- en: $$ \binom nk=\,^nC_k=\frac{^nP_k}{k!} $$
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: $$ \binom nk=\,^nC_k=\frac{^nP_k}{k!} $$
- en: we define the functions as follows.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义函数如下。
- en: '[PRE352]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: '[PRE354]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: As before, we run the function under `ConcolicTracer`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们在 `ConcolicTracer` 下运行该函数。
- en: '[PRE356]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: Then call `zeval()` to evaluate.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用 `zeval()` 进行评估。
- en: '[PRE357]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'Example: Database'
  id: totrans-679
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：数据库
- en: For a larger example using the Concolic String class `zstr`, we use the DB class
    from the [chapter on information flow](InformationFlow.html).
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个使用 Concolic 字符串类 `zstr` 的更大示例，我们使用来自 [信息流章节](InformationFlow.html) 的 DB
    类。
- en: '[PRE359]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: We first populate our database.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先填充我们的数据库。
- en: '[PRE362]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: We are now ready to fuzz our `DB` class. Hash functions are difficult to handle
    directly (because they rely on internal C functions). Hence we modify `table()`
    slightly.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备模糊测试我们的 `DB` 类。散列函数难以直接处理（因为它们依赖于内部 C 函数）。因此，我们稍微修改了 `table()`。
- en: '[PRE366]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: To make it easy, we define a single function `db_select()` that directly invokes
    `db.sql()`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们定义了一个单独的函数 `db_select()`，它直接调用 `db.sql()`。
- en: '[PRE367]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: We now want to run SQL statements under our `ConcolicTracer`, and collect predicates
    obtained.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们想在 `ConcolicTracer` 下运行 SQL 语句，并收集得到的谓词。
- en: '[PRE368]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'The predicates encountered during the execution are as follows:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 执行过程中遇到的谓词如下：
- en: '[PRE369]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: We can use `zeval()` as before to solve the constraints.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像之前一样使用 `zeval()` 来解决约束。
- en: '[PRE371]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: Fuzzing with Constraints
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带约束的模糊测试
- en: The `SimpleConcolicFuzzer` class starts with a sample input generated by some
    other fuzzer. It then runs the function being tested under `ConcolicTracer`, and
    collects the path predicates. It then negates random predicates within the path
    and solves it with Z3 to produce a new output that is guaranteed to take a different
    path than the original.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleConcolicFuzzer` 类从由其他模糊测试器生成的样本输入开始。然后它在 `ConcolicTracer` 下运行正在测试的函数，并收集路径谓词。然后它对路径内的随机谓词取反，并用
    Z3 解决它，以产生一个新的输出，该输出保证采取与原始输出不同的路径。'
- en: As with `ConcolicTracer`, above, please first look at the examples before digging
    into the implementation.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面的 `ConcolicTracer` 一样，请首先查看示例，然后再深入研究实现。
- en: <details id="Excursion:-Implementing-SimpleConcolicFuzzer"><summary>Implementing
    SimpleConcolicFuzzer</summary>
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-SimpleConcolicFuzzer"><summary>实现 SimpleConcolicFuzzer</summary>
- en: First, we import the `Fuzzer` interface, and write example program `hang_if_no_space()`
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `Fuzzer` 接口，并编写示例程序 `hang_if_no_space()`
- en: '[PRE373]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: Representing Decisions
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 决策表示
- en: To make the fuzzer work, we need a way to represent decisions made during trace.
    We keep this in a *binary tree* where each node represents a decision made, and
    each leaf represents a complete path. A node in the binary tree is represented
    by the `TraceNode` class.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模糊测试器工作，我们需要一种表示在跟踪期间做出的决策的方法。我们将其保存在一个 *二叉树* 中，其中每个节点代表一个做出的决策，每个叶子节点代表一个完整的路径。二叉树中的节点由
    `TraceNode` 类表示。
- en: When a new node is added, it represents a decision taken by the parent on some
    predicate. This predicate is supplied as `smt_val`, which is `True` for this child
    to be reached. Since the predicate is actually present in the parent node, we
    also carry a member `smt` which will be updated by the first child to be added.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 当添加新节点时，它代表父节点在某个谓词上做出的决策。这个谓词作为 `smt_val` 提供，对于这个子节点来说，它是 `True` 以到达。由于谓词实际上存在于父节点中，我们还携带一个成员
    `smt`，它将由第一个添加的子节点更新。
- en: '[PRE377]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: We add a `PlausibleChild` class to track the leaf nodes.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个 `PlausibleChild` 类来跟踪叶子节点。
- en: '[PRE378]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: When the leaf nodes are used to generate new paths, we expect its sibling `TraceNode`
    to have been already explored. Hence, we make use of the sibling's values for
    context `cc`, and the `smt_val` from the parent.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用叶子节点生成新的路径时，我们期望其兄弟 `TraceNode` 已经被探索。因此，我们使用兄弟的值作为上下文 `cc` 和父节点的 `smt_val`。
- en: '[PRE379]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: The `PlausibleChild` instance is used to generate new paths to explore using
    `path_expression()`.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlausibleChild` 实例用于使用 `path_expression()` 生成新的探索路径。'
- en: '[PRE380]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: The `TraceTree` class helps us keep track of the binary tree. In the beginning,
    the root is a sentinel `TraceNode` instance, and simply have two plausible children
    as leaves. As soon as the first trace is added, one of the plausible children
    will become a true child.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceTree` 类帮助我们跟踪二叉树。一开始，根节点是一个哨兵 `TraceNode` 实例，并且简单地有两个可能的子节点作为叶子节点。一旦添加了第一个跟踪，其中一个可能的子节点将变成一个真正的子节点。'
- en: '[PRE381]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: The `add_trace()` method of the `TraceTree` provides a way for new traces to
    be added. It is kept separate from the initialization as we might want to add
    more than one trace from the same function.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '`TraceTree` 的 `add_trace()` 方法提供了一种添加新跟踪的方式。它被单独保留在初始化之外，因为我们可能希望从同一个函数添加多个跟踪。'
- en: '[PRE382]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: To make `add_trace()` work, we need a little more infrastructure, that we define
    below.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `add_trace()` 方法工作，我们需要更多的基础设施，我们将在下面定义。
- en: The `bit()` method translates a predicate to a bit that corresponds to the decision
    taken at each predicate. If the `if` branch is taken, the result is `1`, while
    `else` branch is indicated by `0`. The pattern indicates the bit-pattern of decisions
    required to reach the leaf from the root.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`bit()` 方法将谓词转换为一个与每个谓词所做决策相对应的位。如果选择 `if` 分支，结果是 `1`，而 `else` 分支由 `0` 表示。模式表示从根到叶子所需的决定的位模式。'
- en: '[PRE383]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Each node knows how to add a new child, and get the path to root, which is cached.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点都知道如何添加一个新的子节点，并获取到根的路径，该路径被缓存。
- en: When we add a child to the root node, it means that there was a decision in
    the current node, and the child is the result of the decision. Hence, to get the
    decision being made, we simplify the `smt` expression, and check if it starts
    with `not`. If it does not start with a `not`, we interpret that as the current
    decision in the node. If it starts with `not`, then we interpret that `not(smt)`
    was the expression being evaluated in the current node.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将子节点添加到根节点时，这意味着当前节点有一个决策，子节点是决策的结果。因此，为了获取正在进行的决策，我们简化 `smt` 表达式，并检查它是否以
    `not` 开头。如果它不以 `not` 开头，我们将其解释为节点中的当前决策。如果它以 `not` 开头，那么我们将其解释为当前节点正在评估的表达式 `not(smt)`。
- en: We know the first decision made only after going through the program at least
    once. As soon as the program is traversed, we update the parent with the decision
    that resulted in the current child.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只知道在至少遍历程序一次之后做出的第一个决策。一旦程序被遍历，我们就更新父节点，以反映导致当前子节点的决策。
- en: '[PRE384]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: The path to root from any node is computed once and cached.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何节点到根的路径只计算一次并缓存。
- en: '[PRE385]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: The SimpleConcolicFuzzer class
  id: totrans-733
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SimpleConcolicFuzzer` 类'
- en: The `SimpleConcolicFuzzer` is defined with the `Fuzzer` interface.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleConcolicFuzzer` 使用 `Fuzzer` 接口定义。'
- en: '[PRE386]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: The `add_trace()` method we defined earlier is used as follows. First, we use
    a random string to generate the concolic trace.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的 `add_trace()` 方法如下使用。首先，我们使用一个随机字符串生成 concolic 跟踪。
- en: '[PRE387]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: Next, we initialize and add this trace to the fuzzer.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化并将此跟踪添加到模糊测试器中。
- en: '[PRE388]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: The path we added above can be obtained from the `TraceTree` as below.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的路径可以从以下 `TraceTree` 中获得。
- en: '[PRE391]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: Below are the registered leaves that we can explore at this moment.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们现在可以探索的已注册的叶子节点。
- en: '[PRE393]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Next, we need a way to visualize the constructed tree.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一种方法来可视化构建的树。
- en: '[PRE395]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: <svg width="700pt" height="409pt" viewBox="0.00 0.00 699.50 409.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 405.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="570.75"
    y="-387.95" font-family="Times,serif" font-size="14.00">(0) Length(hang_if_no_space_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.75" y="-323.45" font-family="Times,serif" font-size="14.00">(1) str.substr(hang_if_no_space_s_str_1,
    0, 1) == " "</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="537.19" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="659.75"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>0->12</title> <text text-anchor="middle" x="626.6" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="402.75" y="-258.95" font-family="Times,serif" font-size="14.00">(2)
    Length(hang_if_no_space_s_str_1) <= 1</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="452.11" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="557.75"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge11"
    class="edge"><title>1->11</title> <text text-anchor="middle" x="529.52" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="312.75" y="-194.45" font-family="Times,serif" font-size="14.00">(3)
    str.substr(hang_if_no_space_s_str_1, 1, 1) == " "</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="369.19" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="491.75"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>2->10</title> <text text-anchor="middle" x="458.6" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-129.95" font-family="Times,serif" font-size="14.00">(4)
    Length(hang_if_no_space_s_str_1) <= 2</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="284.11" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="389.75"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge9"
    class="edge"><title>3->9</title> <text text-anchor="middle" x="361.52" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="144.75" y="-65.45" font-family="Times,serif" font-size="14.00">(5)
    str.substr(hang_if_no_space_s_str_1, 2, 1) == " "</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="201.19" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="323.75"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge8"
    class="edge"><title>4->8</title> <text text-anchor="middle" x="290.6" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="119.75" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge6" class="edge"><title>5->6</title> <text text-anchor="middle"
    x="137.86" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="170.75"
    y="-0.95" font-family="Times,serif" font-size="14.00">* ab d</text></g> <g id="edge7"
    class="edge"><title>5->7</title> <text text-anchor="middle" x="163.45" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="700pt" height="409pt" viewBox="0.00 0.00 699.50 409.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 405.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="570.75"
    y="-387.95" font-family="Times,serif" font-size="14.00">(0) Length(hang_if_no_space_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.75" y="-323.45" font-family="Times,serif" font-size="14.00">(1) str.substr(hang_if_no_space_s_str_1,
    0, 1) == " "</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="537.19" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="659.75"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>0->12</title> <text text-anchor="middle" x="626.6" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="402.75" y="-258.95" font-family="Times,serif" font-size="14.00">(2)
    Length(hang_if_no_space_s_str_1) <= 1</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="452.11" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="557.75"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge11"
    class="edge"><title>1->11</title> <text text-anchor="middle" x="529.52" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="312.75" y="-194.45" font-family="Times,serif" font-size="14.00">(3)
    str.substr(hang_if_no_space_s_str_1, 1, 1) == " "</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="369.19" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="491.75"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>2->10</title> <text text-anchor="middle" x="458.6" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-129.95" font-family="Times,serif" font-size="14.00">(4)
    Length(hang_if_no_space_s_str_1) <= 2</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="284.11" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="389.75"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge9"
    class="edge"><title>3->9</title> <text text-anchor="middle" x="361.52" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="144.75" y="-65.45" font-family="Times,serif" font-size="14.00">(5)
    str.substr(hang_if_no_space_s_str_1, 2, 1) == " "</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="201.19" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="323.75"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge8"
    class="edge"><title>4->8</title> <text text-anchor="middle" x="290.6" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="119.75" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge6" class="edge"><title>5->6</title> <text text-anchor="middle"
    x="137.86" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="170.75"
    y="-0.95" font-family="Times,serif" font-size="14.00">* ab d</text></g> <g id="edge7"
    class="edge"><title>5->7</title> <text text-anchor="middle" x="163.45" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
- en: For example, the pattern `00000:0` corresponds to the following predicates.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，模式 `00000:0` 对应以下谓词。
- en: '[PRE401]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: Similarly the pattern `:1` corresponds to the following predicates.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，模式 `:1` 对应以下谓词。
- en: '[PRE405]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: We can now generate the next input to be generated by looking for a leaf that
    is incompletely explored. The idea is to collect all leaf nodes, and choose one
    at random.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过寻找一个不完全探索的叶子节点来生成下一个要生成的输入。想法是收集所有叶子节点，并随机选择一个。
- en: '[PRE409]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: We use the `next_choice()` as follows.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下使用 `next_choice()`。
- en: '[PRE410]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[PRE413]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: We get the next choice for exploration, and expand the path expression, and
    return it together with a context using `get_newpath()`
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获取下一个探索的选择，并扩展路径表达式，然后使用 `get_newpath()` 方法返回它以及一个上下文。
- en: '[PRE415]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: The fuzzing method
  id: totrans-778
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模糊测试方法
- en: The `fuzz()` method simply generates new lists of predicates, and solves them
    to produce new inputs.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '`fuzz()`方法简单地生成新的谓词列表，并求解它们以产生新的输入。'
- en: '[PRE418]</details>'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE418]</details>'
- en: To illustrate `SimpleConcolicFuzzer`, let us apply it on our example program
    `cgi_decode()` from the `Coverage` chapter. Note that we cannot use it directly
    as the hash lookups in `hex_values` can not be used for transferring constraints
    yet.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明`SimpleConcolicFuzzer`，让我们将其应用于`Coverage`章节中的示例程序`cgi_decode()`。请注意，我们不能直接使用它，因为`hex_values`中的哈希查找还不能用于传递约束。
- en: '[PRE419]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: The *trace tree* shows the path conditions encountered so far. Any blue edge
    towards a "?" implies that there is a path not yet taken.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪树*显示了迄今为止遇到的路径条件。任何指向"?"的蓝色边都意味着有一条尚未走过的路径。'
- en: '[PRE423]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: <svg width="674pt" height="603pt" viewBox="0.00 0.00 673.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="563.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="481.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="533.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="644.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="614.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="398.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="450.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="563.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="533.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="329.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="373.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="466.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="441.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="247.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="299.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="410.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="380.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="232.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="244.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="369.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="322.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="325.55" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="417.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="401.05" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="674pt" height="603pt" viewBox="0.00 0.00 673.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="563.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="481.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="533.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="644.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="614.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="398.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="450.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="563.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="533.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="329.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="373.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="466.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="441.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="247.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="299.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="410.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="380.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="232.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="244.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="369.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="322.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="325.55" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="417.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="401.05" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
- en: So, we fuzz to get a new path that is not empty.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们进行模糊测试以获取一个非空的新路径。
- en: '[PRE424]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: We can now obtain the new trace as before.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以像之前一样获得新的跟踪信息。
- en: '[PRE426]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: The new trace is added to our fuzzer using `add_trace()`
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add_trace()`将新的跟踪信息添加到我们的模糊测试器中。
- en: '[PRE427]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: The updated binary tree is as follows. Note the difference between the child
    nodes of `Root` node.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的二叉树如下。注意`Root`节点的子节点之间的差异。
- en: '[PRE428]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: <svg width="673pt" height="603pt" viewBox="0.00 0.00 672.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="562.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="532.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="643.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="613.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="397.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="449.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="562.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="532.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="328.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="372.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="465.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="440.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="246.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="298.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="409.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="379.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="231.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="243.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="368.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="321.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="324.96" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="415.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A+</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="399.46" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="673pt" height="603pt" viewBox="0.00 0.00 672.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="562.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="532.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="643.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="613.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="397.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="449.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="562.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="532.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="328.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="372.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="465.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="440.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="246.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="298.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="409.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="379.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="231.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="243.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="368.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="321.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="324.96" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="415.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A+</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="399.46" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
- en: 'A complete fuzzer run is as follows:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的模糊测试运行如下：
- en: '[PRE429]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: <svg width="981pt" height="603pt" viewBox="0.00 0.00 980.88 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="638.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="562.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="610.56" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="714.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">*</text></g> <g id="edge36"
    class="edge"><title>0->36</title> <text text-anchor="middle" x="686.56" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="437.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="514.45" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="688.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">(2) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge13" class="edge"><title>1->13</title> <text text-anchor="middle"
    x="640.04" y="-484.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="328.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">(3) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title> <text text-anchor="middle"
    x="396.01" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="460.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* %</text></g> <g id="edge12"
    class="edge"><title>2->12</title> <text text-anchor="middle" x="454.31" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="291.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="316.56" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="445.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">*  </text></g> <g id="edge11"
    class="edge"><title>3->11</title> <text text-anchor="middle" x="400.73" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="185.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="251.24" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="350.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>4->10</title> <text text-anchor="middle" x="329.53" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="102.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    Length(cgi_decode_s_str_1) <= 2</text></g> <g id="edge6" class="edge"><title>5->6</title>
    <text text-anchor="middle" x="154.68" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="238.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A%</text></g> <g id="edge9"
    class="edge"><title>5->9</title> <text text-anchor="middle" x="220" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="88.38" y="-129.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="100" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="136.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">* AB</text></g> <g id="edge8"
    class="edge"><title>6->8</title> <text text-anchor="middle" x="125.8" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="667.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge14" class="edge"><title>13->14</title>
    <text text-anchor="middle" x="683.13" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node36" class="node"><title>35</title> <text text-anchor="middle" x="823.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* +</text></g> <g id="edge35"
    class="edge"><title>13->35</title> <text text-anchor="middle" x="771.34" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="611.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge15" class="edge"><title>14->15</title>
    <text text-anchor="middle" x="647.77" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="862.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">(4) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge26" class="edge"><title>14->26</title> <text text-anchor="middle"
    x="785.72" y="-355.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="495.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge16" class="edge"><title>15->16</title> <text text-anchor="middle"
    x="567.14" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="632.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge25"
    class="edge"><title>15->25</title> <text text-anchor="middle" x="627.13" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="449.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge17" class="edge"><title>16->17</title>
    <text text-anchor="middle" x="479.87" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="610.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* +A</text></g> <g id="edge24"
    class="edge"><title>16->24</title> <text text-anchor="middle" x="566.55" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="349.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge18" class="edge"><title>17->18</title>
    <text text-anchor="middle" x="411.71" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="514.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge23"
    class="edge"><title>17->23</title> <text text-anchor="middle" x="491.07" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="254.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge19" class="edge"><title>18->19</title>
    <text text-anchor="middle" x="313.76" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="391.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge22"
    class="edge"><title>18->22</title> <text text-anchor="middle" x="377.51" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="228.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge20" class="edge"><title>19->20</title> <text text-anchor="middle"
    x="247.08" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="middle" x="281.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* +AB</text></g> <g id="edge21"
    class="edge"><title>19->21</title> <text text-anchor="middle" x="273.67" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="799.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge27" class="edge"><title>26->27</title>
    <text text-anchor="middle" x="839.89" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node35" class="node"><title>34</title> <text text-anchor="middle" x="959.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">* ++</text></g> <g id="edge34"
    class="edge"><title>26->34</title> <text text-anchor="middle" x="922.94" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="780.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge28" class="edge"><title>27->28</title>
    <text text-anchor="middle" x="794.95" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="945.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge33"
    class="edge"><title>27->33</title> <text text-anchor="middle" x="888.83" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="676.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge29" class="edge"><title>28->29</title>
    <text text-anchor="middle" x="741.07" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="813.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge32"
    class="edge"><title>28->32</title> <text text-anchor="middle" x="803.21" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node31" class="node"><title>30</title>
    <text text-anchor="middle" x="649.38" y="-65.45" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge30" class="edge"><title>29->30</title> <text text-anchor="middle"
    x="668.67" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="middle" x="702.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">* ++A</text></g> <g id="edge31"
    class="edge"><title>29->31</title> <text text-anchor="middle" x="695.08" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="981pt" height="603pt" viewBox="0.00 0.00 980.88 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="638.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="562.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="610.56" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="714.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">*</text></g> <g id="edge36"
    class="edge"><title>0->36</title> <text text-anchor="middle" x="686.56" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="437.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="514.45" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="688.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">(2) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge13" class="edge"><title>1->13</title> <text text-anchor="middle"
    x="640.04" y="-484.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="328.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">(3) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title> <text text-anchor="middle"
    x="396.01" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="460.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* %</text></g> <g id="edge12"
    class="edge"><title>2->12</title> <text text-anchor="middle" x="454.31" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="291.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="316.56" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="445.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">*  </text></g> <g id="edge11"
    class="edge"><title>3->11</title> <text text-anchor="middle" x="400.73" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="185.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="251.24" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="350.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>4->10</title> <text text-anchor="middle" x="329.53" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="102.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    Length(cgi_decode_s_str_1) <= 2</text></g> <g id="edge6" class="edge"><title>5->6</title>
    <text text-anchor="middle" x="154.68" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="238.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A%</text></g> <g id="edge9"
    class="edge"><title>5->9</title> <text text-anchor="middle" x="220" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="88.38" y="-129.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="100" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="136.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">* AB</text></g> <g id="edge8"
    class="edge"><title>6->8</title> <text text-anchor="middle" x="125.8" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="667.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge14" class="edge"><title>13->14</title>
    <text text-anchor="middle" x="683.13" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node36" class="node"><title>35</title> <text text-anchor="middle" x="823.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* +</text></g> <g id="edge35"
    class="edge"><title>13->35</title> <text text-anchor="middle" x="771.34" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="611.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge15" class="edge"><title>14->15</title>
    <text text-anchor="middle" x="647.77" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="862.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">(4) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge26" class="edge"><title>14->26</title> <text text-anchor="middle"
    x="785.72" y="-355.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="495.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge16" class="edge"><title>15->16</title> <text text-anchor="middle"
    x="567.14" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="632.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge25"
    class="edge"><title>15->25</title> <text text-anchor="middle" x="627.13" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="449.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge17" class="edge"><title>16->17</title>
    <text text-anchor="middle" x="479.87" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="610.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* +A</text></g> <g id="edge24"
    class="edge"><title>16->24</title> <text text-anchor="middle" x="566.55" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="349.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge18" class="edge"><title>17->18</title>
    <text text-anchor="middle" x="411.71" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="514.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge23"
    class="edge"><title>17->23</title> <text text-anchor="middle" x="491.07" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="254.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge19" class="edge"><title>18->19</title>
    <text text-anchor="middle" x="313.76" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="391.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge22"
    class="edge"><title>18->22</title> <text text-anchor="middle" x="377.51" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="228.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge20" class="edge"><title>19->20</title> <text text-anchor="middle"
    x="247.08" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="middle" x="281.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* +AB</text></g> <g id="edge21"
    class="edge"><title>19->21</title> <text text-anchor="middle" x="273.67" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="799.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge27" class="edge"><title>26->27</title>
    <text text-anchor="middle" x="839.89" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node35" class="node"><title>34</title> <text text-anchor="middle" x="959.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">* ++</text></g> <g id="edge34"
    class="edge"><title>26->34</title> <text text-anchor="middle" x="922.94" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="780.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge28" class="edge"><title>27->28</title>
    <text text-anchor="middle" x="794.95" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="945.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge33"
    class="edge"><title>27->33</title> <text text-anchor="middle" x="888.83" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="676.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge29" class="edge"><title>28->29</title>
    <text text-anchor="middle" x="741.07" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="813.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge32"
    class="edge"><title>28->32</title> <text text-anchor="middle" x="803.21" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node31" class="node"><title>30</title>
    <text text-anchor="middle" x="649.38" y="-65.45" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge30" class="edge"><title>29->30</title> <text text-anchor="middle"
    x="668.67" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="middle" x="702.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">* ++A</text></g> <g id="edge31"
    class="edge"><title>29->31</title> <text text-anchor="middle" x="695.08" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
- en: '**Note.** Our concolic tracer is limited in that it does not track changes
    in the string length. This leads it to treat every string with same prefix as
    the same string.'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意。**我们的concolic跟踪器有限制，因为它不跟踪字符串长度的变化。这导致它将具有相同前缀的每个字符串视为相同的字符串。'
- en: The `SimpleConcolicFuzzer` is reasonably efficient at exploring paths near the
    path followed by a given sample input. However, it is not very intelligent when
    it comes to choosing which paths to follow. We look at another fuzzer that lifts
    the predicates obtained to the grammar and achieves better fuzzing.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleConcolicFuzzer`在探索给定样本输入路径附近的路径方面相当高效。然而，在选择要遵循的路径时，它并不非常智能。我们来看看另一个将获得的谓词提升到语法的模糊测试器，并实现更好的模糊测试。'
- en: Concolic Grammar Fuzzing
  id: totrans-807
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Concolic语法模糊测试
- en: The concolic framework can be used directly in grammar-based fuzzing. We implement
    a class `ConcolicGrammarFuzzer` which does this.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: Concolic框架可以直接用于基于语法的模糊测试。我们实现了一个名为`ConcolicGrammarFuzzer`的类来完成这项工作。
- en: <details id="Excursion:-Implementing-ConcolicGrammarFuzzer"><summary>Implementing
    ConcolicGrammarFuzzer</summary>
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-ConcolicGrammarFuzzer"><summary>实现ConcolicGrammarFuzzer</summary>
- en: First, we extend our `GrammarFuzzer` with a helper method `tree_to_string()`
    such that we can retrieve the derivation tree of the fuzz output. We also define
    `prune_tree()` and `coalesce()` methods to reduce the depth of sub trees. These
    methods accept a list of tokens types such that a node belonging to the token
    type gets converted from a tree to a leaf node by calling `tree_to_string()`.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们扩展我们的`GrammarFuzzer`，添加一个辅助方法`tree_to_string()`，以便我们可以检索模糊输出的推导树。我们还定义了`prune_tree()`和`coalesce()`方法来减少子树的深度。这些方法接受一个标记类型列表，使得属于标记类型的节点通过调用`tree_to_string()`从树转换为叶节点。
- en: '[PRE433]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: We can now use the fuzzer to produce inputs for our DB.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用模糊测试器为我们的数据库生成输入。
- en: '[PRE436]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: Our fuzzer returns with an exception. It is unable to find the specified table.
    Let us examine the predicates it encountered.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模糊测试器返回时抛出异常。它无法找到指定的表。让我们检查它遇到的谓词。
- en: '[PRE441]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: Note that we can obtain constraints that are not present in the grammar from
    using the `ConcolicTracer`. In particular, see how we are able to obtain the condition
    that the table needs to be `inventory` (Predicate 11) for the fuzzing to succeed.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以通过使用`ConcolicTracer`获得语法中不存在的约束。特别是，看看我们如何能够获得表需要是`inventory`（谓词11）的条件，以便模糊测试成功。
- en: How do we lift these to the grammar? and in particular how do we do it automatically?
    One option we have is to simply switch the last predicate obtained. In our case,
    the last predicate is (11). Can we simply invert the predicate and solve it again?
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这些内容提升到语法中？特别是如何自动完成？我们有一个选项是简单地切换最后获得的谓词。在我们的例子中，最后的谓词是（11）。我们能否简单地反转谓词并再次求解？
- en: '[PRE443]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: Indeed, this will not work as the string lengths being compared to are different.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这不会起作用，因为正在比较的字符串长度不同。
- en: '[PRE447]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[PRE448]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: A better idea is to investigate what *string* comparisons are being made, and
    associate that with the corresponding nodes in the grammar. Let us examine our
    derivation tree (pruned to avoid recursive structures, and to focus on important
    parts).
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的想法是调查正在进行的什么*字符串*比较，并将其与语法中的相应节点关联起来。让我们检查我们的推导树（修剪以避免递归结构，并专注于重要部分）。
- en: '[PRE449]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: <svg width="220pt" height="173pt" viewBox="0.00 0.00 219.62 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="104.25"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="104.25" y="-101.45"
    font-family="Times,serif" font-size="14.00"><query></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="17.25"
    y="-51.2" font-family="Times,serif" font-size="14.00">select</text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="75.25" y="-51.2" font-family="Times,serif" font-size="14.00"><exprs></text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="133.25" y="-51.2" font-family="Times,serif" font-size="14.00">from</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="190.25" y="-51.2" font-family="Times,serif" font-size="14.00"><table></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="75.25" y="-0.95" font-family="Times,serif" font-size="14.00">t4(I,N)!=b(k)/O!=(K4(:/Z))</text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="190.25" y="-0.95" font-family="Times,serif" font-size="14.00">I7</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g></g></svg>
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="220pt" height="173pt" viewBox="0.00 0.00 219.62 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="104.25"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="104.25" y="-101.45"
    font-family="Times,serif" font-size="14.00"><query></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="17.25"
    y="-51.2" font-family="Times,serif" font-size="14.00">select</text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="75.25" y="-51.2" font-family="Times,serif" font-size="14.00"><exprs></text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="133.25" y="-51.2" font-family="Times,serif" font-size="14.00">from</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="190.25" y="-51.2" font-family="Times,serif" font-size="14.00"><table></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="75.25" y="-0.95" font-family="Times,serif" font-size="14.00">t4(I,N)!=b(k)/O!=(K4(:/Z))</text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="190.25" y="-0.95" font-family="Times,serif" font-size="14.00">I7</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g></g></svg>
- en: 'Can we identify which part of the input was supplied by which part of the grammar?
    We define `span()` that can recover this information from the derivation tree.
    For a given node, let us assume that the start point is known. Then, for processing
    the children, we proceed as follows: We choose one child at a time from left to
    right, and compute the length of the child. The length of the children before
    the current child in addition to our starting point gives the starting point of
    the current child. The end point for each node is simply the end point of its
    last children (or the length of its node if it is a leaf).'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否识别输入的哪一部分是由语法的哪一部分提供的？我们定义了`span()`，可以从推导树中恢复此信息。对于给定的节点，让我们假设起点是已知的。然后，在处理子节点时，我们按以下方式进行：我们一次选择一个子节点，从左到右进行，并计算子节点的长度。当前子节点之前的子节点长度加上我们的起点给出了当前子节点的起点。每个节点的终点简单地是其最后一个子节点的终点（或其节点长度，如果它是叶子节点）。
- en: '[PRE451]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'We use it as follows:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它：
- en: '[PRE453]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: '[PRE454]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: We can check if we got the right values as follows.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式检查我们是否得到了正确的值。
- en: '[PRE456]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: Next, we need to obtain all the comparisons made in each predicate. For that,
    we define two helper functions. The first is `unwrap_substrings()` that translates
    multiple calls to `z3.SubString` and returns the start, and length of the given
    z3 string expression.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取每个谓词中做出的所有比较。为此，我们定义了两个辅助函数。第一个是`unwrap_substrings()`，它将多个对`z3.SubString`的调用转换为给定的z3字符串表达式的起始位置和长度。
- en: '[PRE458]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: We define `traverse_z3()` that traverses a given z3 string expression, and collects
    all direct string comparisons to a substring of the original argument.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`traverse_z3()`，它遍历给定的z3字符串表达式，并收集所有直接字符串比较到原始参数的子串。
- en: '[PRE459]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: All that we need now is to declare string variables that match the substrings
    in `comparisons`, and solve for them for each item in the path. For that, we define
    `find_alternatives()`.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要声明与`comparisons`中的子串匹配的字符串变量，并为路径中的每个项目求解它们。为此，我们定义了`find_alternatives()`。
- en: '[PRE462]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: We use it as follows.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用它。
- en: '[PRE463]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: So, we have our alternatives for each key in the grammar. We can now update
    our grammar as follows.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们为语法中的每个键有了我们的备选方案。我们现在可以按以下方式更新我们的语法。
- en: '[PRE465]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: We made a choice here. We could have completely overwritten the definition of
    `<table>` . Instead, we added our new alternatives to the existing definition.
    This way, our fuzzer will also attempt other values for `<table>` once in a while.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们做出了一个选择。我们本可以完全覆盖`<table>`的定义。相反，我们添加了我们的新备选方案到现有定义中。这样，我们的模糊测试器也会偶尔尝试`<table>`的其他值。
- en: '[PRE467]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: Let us try fuzzing with our new grammar.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试用我们新的语法进行模糊测试。
- en: '[PRE469]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: That is, we were able to reach the dangerous method `my_eval()`. In effect,
    what we have done is to lift parts of predicates to the grammar. The new grammar
    can generate inputs that reach deeper into the program than before. Note that
    we have only handled the equality predicate. One can also lift the '<' and '>'
    comparison operators to the grammar if required.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 即，我们能够到达危险的方法`my_eval()`。实际上，我们所做的是将谓词的部分提升到语法中。新的语法可以生成比以前更深入程序的输入。请注意，我们只处理了相等谓词。如果需要，也可以将`<`和`>`比较运算符提升到语法中。
- en: Compare the output of our fuzzer to the original `GrammarFuzzer` below.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的模糊测试器的输出与下面的原始`GrammarFuzzer`进行比较。
- en: '[PRE472]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: As can be seen, the original grammar fuzzer is unable to proceed beyond the
    table verification.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，原始语法模糊测试器无法超越表验证。
- en: Pruning and Updating
  id: totrans-872
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修剪和更新
- en: We implement these methods in `ConcolicGrammarFuzzer`. The method `update_grammar()`
    allows `ConcolicGrammarFuzzer` to collect feedback from concolic fuzzing, and
    update the grammar used for fuzzing accordingly.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ConcolicGrammarFuzzer`中实现了这些方法。`update_grammar()`方法允许`ConcolicGrammarFuzzer`从concolic模糊测试中收集反馈，并相应地更新用于模糊测试的语法。
- en: '[PRE474]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: The `fuzz()` method simply generates the derivation tree, computes the span
    range, and returns the string generated from the derivation tree.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '`fuzz()`方法简单地生成推导树，计算跨度范围，并返回从推导树生成的字符串。'
- en: '[PRE475]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: To ensure that our approach works, let us update our tables slightly.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的方法有效，让我们稍微更新我们的表。
- en: '[PRE476]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]</details>'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE478]</details>'
- en: The `ConcolicGrammarFuzzer` is used as follows.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcolicGrammarFuzzer`的使用如下。'
- en: '[PRE479]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: As can be seen, the fuzzer starts with no knowledge of the tables `vehicles`,
    `months` and `years`, but identifies it from the concolic execution, and lifts
    it to the grammar. This allows us to improve the effectiveness of fuzzing.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，模糊测试器开始时对`vehicles`、`months`和`years`表没有任何了解，但它从concolic执行中识别出来，并将其提升到语法中。这使我们能够提高模糊测试的有效性。
- en: Limitations
  id: totrans-885
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 局限性
- en: As with dynamic taint analysis, implicit control flow can obscure the predicates
    encountered during concolic execution. However, this limitation could be overcome
    to some extent by wrapping any constants in the source with their respective proxy
    objects. Similarly, calls to internal C functions can cause the symbolic information
    to be discarded, and only partial information may be obtained.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 就像动态污点分析一样，隐式控制流可能会在冲突执行中掩盖遇到的谓词。然而，这种限制可以通过将源中的任何常量与其相应的代理对象包装起来在一定程度上克服。同样，调用内部C函数可能会导致符号信息丢失，并且只能获得部分信息。
- en: Lessons Learned
  id: totrans-887
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Concolic execution can often provide more information than taint analysis with
    respect to the program behavior. However, this comes at a much larger runtime
    cost. Hence, unlike taint analysis, real-time analysis is often not possible.
  id: totrans-888
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲突执行在程序行为方面可以提供比污点分析更多的信息。然而，这需要更大的运行时成本。因此，与污点分析不同，实时分析通常是不可能的。
- en: Similar to taint analysis, concolic execution also suffers from limitations
    such as indirect control flow and internal function calls.
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与污点分析类似，冲突执行也受到诸如间接控制流和内部函数调用等限制。
- en: Predicates from concolic execution can be used in conjunction with fuzzing to
    provide an even more robust indication of incorrect behavior than taints, and
    can be used to create grammars that are better at producing valid inputs.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲突执行的谓词可以与模糊测试结合使用，以提供比污点更稳健的不正确行为指示，并且可以用于创建更擅长生成有效输入的语法。
- en: Next Steps
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: A costlier but stronger alternative to concolic fuzzing is [symbolic fuzzing](SymbolicFuzzer.html).
    Similarly, [search based fuzzing](SearchBasedFuzzer.html) can often provide a
    cheaper exploration strategy than relying on SMT solvers to provide inputs slightly
    different from the current path.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于冲突模糊测试，[符号模糊测试](SymbolicFuzzer.html)是一个成本更高但更强的替代方案。同样，[基于搜索的模糊测试](SearchBasedFuzzer.html)通常比依赖于SMT求解器提供与当前路径略有不同的输入的探索策略更便宜。
- en: Background
  id: totrans-893
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: The technique of concolic execution was originally used to inform and expand
    the scope of *symbolic execution* [[King *et al*, 1976](https://doi.org/10.1145/360248.360252)],
    a static analysis technique for program analysis. Laron et al. cite{Larson2003}
    was the first to use the concolic execution technique.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突执行技术最初用于告知并扩展符号执行*的*范围 [[King *et al*, 1976](https://doi.org/10.1145/360248.360252)]，这是一种用于程序分析的静态分析技术。Laron等人引用{Larson2003}是第一个使用冲突执行技术的人。
- en: The idea of using proxy objects for collecting constraints was pioneered by
    Cadar et al. [Cadar *et al*, 2005]. The concolic execution technique for Python
    programs used in this chapter was pioneered by PeerCheck [[A. Bruni *et al*, 2011](https://hoheinzollern.files.wordpress.com/2008/04/seer1.pdf)],
    and Python Error Finder [[Damián Barsotti *et al*, 2018](https://doi.org/https://doi.org/10.1016/j.entcs.2018.06.003)].
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代理对象收集约束的想法是由Cadar等人开创的[Cadar *et al*, 2005]。本章中使用的Python程序冲突执行技术是由PeerCheck
    [[A. Bruni *et al*, 2011](https://hoheinzollern.files.wordpress.com/2008/04/seer1.pdf)]和Python
    Error Finder [[Damián Barsotti *et al*, 2018](https://doi.org/https://doi.org/10.1016/j.entcs.2018.06.003)]开创的。
- en: Exercises
  id: totrans-896
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: Implement a Concolic Float Proxy Class'
  id: totrans-897
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：实现冲突浮点代理类
- en: While implementing the `zint` binary operators, we asserted that the results
    were `int`. However, that need not be the case. For example, division can result
    in `float`. Hence, we need proxy objects for `float`. Can you implement a similar
    proxy object for `float` and fix the `zint` binary operator definition?
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`zint`二进制运算符时，我们断言结果是`int`。然而，情况并不一定如此。例如，除法可能得到`float`。因此，我们需要为`float`创建代理对象。你能实现一个类似的`float`代理对象并修复`zint`二进制运算符的定义吗？
- en: '**Solution.** The solution is as follows.'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**。解决方案如下。'
- en: As in the case of `zint`, we first open up `zfloat` for extension.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`zint`的情况一样，我们首先为`zfloat`扩展打开。
- en: '[PRE481]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: We then implement the initialization methods.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现初始化方法。
- en: '[PRE482]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: The helper for when one of the arguments in a binary operation is not `float`.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 当二进制操作中的一个参数不是`float`时的辅助方法。
- en: '[PRE483]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: Coerce `float` into bool value for use in conditionals.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 将`float`强制转换为布尔值以用于条件语句。
- en: '[PRE484]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: Define the common proxy method for comparison methods
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 定义比较方法的通用代理方法
- en: '[PRE485]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: We apply the comparison methods on the defined `zfloat` class.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义的`zfloat`类上应用比较方法。
- en: '[PRE486]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: '[PRE487]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: Similarly, we define the common proxy method for binary operators.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们定义了二进制运算符的通用代理方法。
- en: '[PRE488]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: And apply them on `zfloat`
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 在`zfloat`上应用它们
- en: '[PRE489]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: These are used as follows.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用法如下。
- en: '[PRE491]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: Finally, we fix the `zint` binary wrapper to correctly create `zfloat` when
    needed.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们修复 `zint` 二进制包装器，以便在需要时正确创建 `zfloat`。
- en: '[PRE494]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: Checking whether it worked as expected.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 检查它是否按预期工作。
- en: '[PRE496]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-927
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: '[PRE498]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: 'Exercise 2: Bit Manipulation'
  id: totrans-929
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：位操作
- en: Similar to floats, implementing the bit manipulation functions such as `xor`
    involves converting `int` to its bit vector equivalents, performing operations
    on them, and converting it back to the original type. Can you implement the bit
    manipulation operations for `zint`?
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 与浮点数类似，实现位操作函数如 `xor` 需要将 `int` 转换为其位向量等价物，对它们进行操作，然后再将其转换回原始类型。你能实现 `zint`
    的位操作吗？
- en: '**Solution.** The solution is as follows.'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**。解决方案如下。'
- en: We first define the proxy method as before.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义代理方法，就像之前一样。
- en: '[PRE499]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: It is then applied to the `zint` class.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将它应用于 `zint` 类。
- en: '[PRE500]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: Invert is the only unary bit manipulation method.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: Invert 是唯一的单目位操作方法。
- en: '[PRE504]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: The `my_fn()` computes `xor` and returns `True` if the `xor` results in a non-zero
    value.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_fn()` 函数计算 `xor` 并在结果为非零值时返回 `True`。'
- en: '[PRE505]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: Using that under `ConcolicTracer`
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ConcolicTracer` 下使用
- en: '[PRE506]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: We log the computed SMT expression to verify that everything went well.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 我们记录计算出的 SMT 表达式以验证一切是否顺利。
- en: '[PRE508]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: We can confirm from the formulas generated that the bit manipulation functions
    worked correctly.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从生成的公式中确认位操作函数是否正确工作。
- en: 'Exercise 3: String Translation Functions'
  id: totrans-951
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：字符串转换函数
- en: We have seen how to define `upper()` and `lower()`. Can you define the `capitalize()`,
    `title()`, and `swapcase()` methods?
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何定义 `upper()` 和 `lower()`。你能定义 `capitalize()`、`title()` 和 `swapcase()`
    方法吗？
- en: '**Solution.** Solution not yet available.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**。解决方案尚未提供。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/ConcolicFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-954
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容根据 [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
    License](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可。内容的一部分源代码，以及用于格式化和显示该内容的源代码，根据
    [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)
    许可。最后更改日期：2024-11-09 17:07:29+01:00。[引用](#citation) • [印记](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-955
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用此作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Concolic Fuzzing](https://www.fuzzingbook.org/html/ConcolicFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/ConcolicFuzzer.html](https://www.fuzzingbook.org/html/ConcolicFuzzer.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler:
    "[Concolic Fuzzing](https://www.fuzzingbook.org/html/ConcolicFuzzer.html)"。在 Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler 的 "[The
    Fuzzing Book](https://www.fuzzingbook.org/)" 中，[https://www.fuzzingbook.org/html/ConcolicFuzzer.html](https://www.fuzzingbook.org/html/ConcolicFuzzer.html)。检索日期：2024-11-09
    17:07:29+01:00。'
- en: '[PRE511]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
