- en: Concolic Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/ConcolicFuzzer.html](http://www.fuzzingbook.org/html/ConcolicFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the [chapter on information flow](InformationFlow.html), we have seen how
    one can use dynamic taints to produce more intelligent test cases than simply
    looking for program crashes. We have also seen how one can use the taints to update
    the grammar, and hence focus more on the dangerous methods.
  prefs: []
  type: TYPE_NORMAL
- en: While taints are helpful, uninterpreted strings is only one of the attack vectors.
    Can we say anything more about the properties of variables at any point in the
    execution? For example, can we say for sure that a function will always receive
    the buffers with the correct length?
  prefs: []
  type: TYPE_NORMAL
- en: '*Concolic execution* offers a solution here. The idea of *concolic execution*
    over a function is as follows: We start with a sample input for the function,
    and execute the function under trace. At each point the execution passes through
    a conditional, we *save the conditional encountered* in the form of *relations
    between symbolic variables.* Here, a *symbolic variable* can be thought of as
    a sort of placeholder for the real variable, sort of like the x in solving for
    x in Algebra. The symbolic variables can be used to specify relations without
    actually solving them.'
  prefs: []
  type: TYPE_NORMAL
- en: With concolic execution, one can collect the constraints that an execution path
    encounters, and use it to answer questions about the program behavior at any point
    we prefer along the program execution path. We can further use concolic execution
    to enhance fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore in depth how to execute a Python function concolically,
    and how concolic execution can be used to enhance fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should have read the [chapter on coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have read the [chapter on information flow](InformationFlow.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A familiarity with the basic idea of [SMT solvers](https://en.wikipedia.org/wiki/Satisfiability_modulo_theories)
    would be useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter defines two main classes: `SimpleConcolicFuzzer` and `ConcolicGrammarFuzzer`.
    The `SimpleConcolicFuzzer` first uses a sample input to collect predicates encountered.
    The fuzzer then negates random predicates to generate new input constraints. These,
    when solved, produce inputs that explore paths that are close to the original
    path.'
  prefs: []
  type: TYPE_NORMAL
- en: ConcolicTracer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the heart of both fuzzers lies the concept of a *concolic tracer*, capturing
    symbolic variables and path conditions as a program gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcolicTracer` is used in a `with` block; the syntax `tracer[function]` executes
    `function` within the `tracer` while capturing conditions. Here is an example
    for the `cgi_decode()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once executed, we can retrieve the symbolic variables in the `decls` attribute.
    This is a mapping of symbolic variables to types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The extracted path conditions can be found in the `path` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `context` attribute holds a pair of `decls` and `path` attributes; this
    is useful for passing it into the `ConcolicTracer` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve these constraints to obtain a value for the function parameters
    that follow the same path as the original (traced) invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `zeval()` function also allows passing *alternate* or *negated* constraints.
    See the chapter for examples.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="250pt" height="145pt" viewBox="0.00 0.00 250.25 145.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 141)"><g
    id="node1" class="node"><title>ConcolicTracer</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ConcolicTracer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Trace function execution, tracking variables and path conditions"><text text-anchor="start"
    x="8" y="-120.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ConcolicTracer</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="ConcolicTracer"><g id="a_node1_1"><a xlink:href="#" xlink:title="__call__(self,
    *args):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Call self as a function."><text text-anchor="start" x="13.62" y="-98" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__call__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="__init__(self, context=None):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor."><text text-anchor="start" x="13.62" y="-85.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="zeval(self, predicates=None,
    *, python=False, log=False):'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate `predicates` in current context.
  prefs: []
  type: TYPE_NORMAL
- en: '- If `python` is set, use the z3 Python API; otherwise use z3 standalone.'
  prefs: []
  type: TYPE_NORMAL
- en: '- If `log` is set, show input to z3.'
  prefs: []
  type: TYPE_NORMAL
- en: Return a pair (`result`, `solution`) where
  prefs: []
  type: TYPE_NORMAL
- en: '- `result` is either `''sat''` (satisfiable); then'
  prefs: []
  type: TYPE_NORMAL
- en: solution` is a mapping of variables to (value, type) pairs; or
  prefs: []
  type: TYPE_NORMAL
- en: '- `result` is not `''sat''`, indicating an error; then `solution` is `None`"><text
    text-anchor="start" x="13.62" y="-72.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">zeval()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__enter__(self)"><text text-anchor="start"
    x="13.62" y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__enter__()</text></a></g> <g id="a_node1_5"><a xlink:href="#"
    xlink:title="__exit__(self, exc_type, exc_value, tb)"><text text-anchor="start"
    x="13.62" y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">__exit__()</text></a></g> <g id="a_node1_6"><a xlink:href="#"
    xlink:title="__getitem__(self, fn)"><text text-anchor="start" x="13.62" y="-33.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">__getitem__()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="concolic(self, args)"><text text-anchor="start"
    x="13.62" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">concolic()</text></a></g> <g id="a_node1_8"><a xlink:href="#"
    xlink:title="smt_expr(self, show_decl=False, simplify=False, path=[])"><text text-anchor="start"
    x="13.62" y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">smt_expr()</text></a></g></a></g></a></g></g> <g
    id="node2" class="node"><title>Legend</title> <text text-anchor="start" x="123"
    y="-84.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="123" y="-74.5" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="129" y="-74.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="123" y="-64.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="129" y="-64.5" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="123" y="-54.5" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="129" y="-54.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="123" y="-45.45" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: SimpleConcolicFuzzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The constraints obtained from `ConcolicTracer` are added to the concolic fuzzer
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The concolic fuzzer then uses the constraints added to guide its fuzzing as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We see how the additional inputs generated explore additional paths.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="294pt" height="229pt" viewBox="0.00 0.00 294.38 228.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 224.75)"><g
    id="node1" class="node"><title>SimpleConcolicFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class SimpleConcolicFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="8" y="-81.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleConcolicFuzzer</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="SimpleConcolicFuzzer"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="35.75" y="-59.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="fuzz(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="35.75" y="-47" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node1_3"><a xlink:href="#" xlink:title="add_trace(self,
    trace, s)"><text text-anchor="start" x="35.75" y="-33.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">add_trace()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="get_newpath(self)"><text text-anchor="start"
    x="35.75" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">get_newpath()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="next_choice(self)"><text text-anchor="start" x="35.75"
    y="-7.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">next_choice()</text></a></g></a></g></a></g></g> <g id="node2"
    class="node"><title>Fuzzer</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="54.12" y="-203.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node2_6"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node2_7"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="44.75" y="-181.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node2_8"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="44.75" y="-169" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_9"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="44.75" y="-156.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node2_10"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="44.75"
    y="-143.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>SimpleConcolicFuzzer->Fuzzer</title></g> <g
    id="node3" class="node"><title>Legend</title> <text text-anchor="start" x="167.12"
    y="-65.38" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="167.12" y="-55.38" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="173.12" y="-55.38" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="167.12" y="-45.38" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="173.12" y="-45.38" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="167.12" y="-35.38" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="173.12" y="-35.38" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="167.12" y="-26.32" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: ConcolicGrammarFuzzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SimpleConcolicFuzzer` simply explores all paths near the original path
    traversed by the sample input. It uses a simple mechanism to explore the paths
    that are near the paths that it knows about, and other than code paths, knows
    nothing about the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConcolicGrammarFuzzer` on the other hand, knows about the input grammar,
    and can collect feedback from the subject under fuzzing. It can lift some constraints
    encountered to the grammar, enabling deeper fuzzing. It is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="318pt" height="478pt" viewBox="0.00 0.00 317.62 478.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 474.25)"><g
    id="node1" class="node"><title>ConcolicGrammarFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class ConcolicGrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="13.62" y="-94.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ConcolicGrammarFuzzer</text> <g id="a_node1_0"><a
    xlink:href="#" xlink:title="ConcolicGrammarFuzzer"><g id="a_node1_1"><a xlink:href="#"
    xlink:title="fuzz(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a string from the grammar."><text text-anchor="start" x="41" y="-72.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node1_2"><a
    xlink:href="#" xlink:title="coalesce(self, children)"><text text-anchor="start"
    x="41" y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">coalesce()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="prune_tokens(self, tokens)"><text text-anchor="start" x="41" y="-46"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">prune_tokens()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="prune_tree(self, tree, tokens)"><text
    text-anchor="start" x="41" y="-33.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">prune_tree()</text></a></g> <g
    id="a_node1_5"><a xlink:href="#" xlink:title="tree_to_string(self, tree)"><text
    text-anchor="start" x="41" y="-20.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">tree_to_string()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="update_grammar(self, trace)"><text
    text-anchor="start" x="41" y="-7.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">update_grammar()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>GrammarFuzzer</title> <g id="a_node2"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="39.12" y="-331.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarFuzzer</text> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="GrammarFuzzer"><g id="a_node2_8"><a xlink:href="GrammarFuzzer.html"
    xlink:title="__init__(self, grammar: Dict[str, List[Union[str, Tuple[str, Dict[str,
    Any]]]]], start_symbol: str = ''<start>'', min_nonterminals: int = 0, max_nonterminals:
    int = 10, disp: bool = False, log: Union[bool, int] = False) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="8" y="-309.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node2_9"><a xlink:href="GrammarFuzzer.html" xlink:title="check_grammar(self)
    -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the grammar passed"><text text-anchor="start" x="8" y="-296.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">check_grammar()</text></a></g>
    <g id="a_node2_10"><a xlink:href="GrammarFuzzer.html" xlink:title="choose_node_expansion(self,
    node: Tuple[str, Optional[List[Any]]], children_alternatives: List[List[Tuple[str,
    Optional[List[Any]]]]]) -> int:'
  prefs: []
  type: TYPE_NORMAL
- en: Return index of expansion in `children_alternatives` to be selected.
  prefs: []
  type: TYPE_NORMAL
- en: '''children_alternatives`: a list of possible children for `node`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defaults to random. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-283.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">choose_node_expansion()</text></a></g>
    <g id="a_node2_11"><a xlink:href="GrammarFuzzer.html" xlink:title="choose_tree_expansion(self,
    tree: Tuple[str, Optional[List[Any]]], children: List[Tuple[str, Optional[List[Any]]]])
    -> int:'
  prefs: []
  type: TYPE_NORMAL
- en: Return index of subtree in `children` to be selected for expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defaults to random."><text text-anchor="start" x="8" y="-271" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">choose_tree_expansion()</text></a></g>
    <g id="a_node2_12"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_node_randomly(self,
    node: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose a random expansion for `node` and return it"><text text-anchor="start"
    x="8" y="-258.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">expand_node_randomly()</text></a></g>
    <g id="a_node2_13"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_tree(self,
    tree: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expand `tree` in a three-phase strategy until all expansions are complete."><text
    text-anchor="start" x="8" y="-245.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">expand_tree()</text></a></g>
    <g id="a_node2_14"><a xlink:href="GrammarFuzzer.html" xlink:title="expand_tree_once(self,
    tree: Tuple[str, Optional[List[Any]]]) -> Tuple[str, Optional[List[Any]]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose an unexpanded symbol in tree; expand it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can be overloaded in subclasses."><text text-anchor="start" x="8" y="-232.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">expand_tree_once()</text></a></g> <g id="a_node2_15"><a
    xlink:href="GrammarFuzzer.html" xlink:title="expand_tree_with_strategy(self, tree:
    Tuple[str, Optional[List[Any]]], expand_node_method: Callable, limit: Optional[int]
    = None):'
  prefs: []
  type: TYPE_NORMAL
- en: Expand tree using `expand_node_method` as node expansion function
  prefs: []
  type: TYPE_NORMAL
- en: 'until the number of possible expansions reaches `limit`."><text text-anchor="start"
    x="8" y="-220" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">expand_tree_with_strategy()</text></a></g>
    <g id="a_node2_16"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a string from the grammar."><text text-anchor="start" x="8" y="-207.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node2_17"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -> Tuple[str, Optional[List[Any]]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="8"
    y="-194.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g> <g id="a_node2_18"><a
    xlink:href="GrammarFuzzer.html" xlink:title="log_tree(self, tree: Tuple[str, Optional[List[Any]]])
    -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output a tree if self.log is set; if self.display is also set, show the tree
    structure"><text text-anchor="start" x="8" y="-181.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">log_tree()</text></a></g>
    <g id="a_node2_19"><a xlink:href="GrammarFuzzer.html" xlink:title="process_chosen_children(self,
    chosen_children: List[Tuple[str, Optional[List[Any]]]], expansion: Union[str,
    Tuple[str, Dict[str, Any]]]) -> List[Tuple[str, Optional[List[Any]]]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process children after selection. &nbsp;By default, does nothing."><text text-anchor="start"
    x="8" y="-169" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">process_chosen_children()</text></a></g>
    <g id="a_node2_20"><a xlink:href="GrammarFuzzer.html" xlink:title="supported_opts(self)
    -> Set[str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set of supported options. To be overloaded in subclasses."><text text-anchor="start"
    x="8" y="-156.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">supported_opts()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>ConcolicGrammarFuzzer->GrammarFuzzer</title></g>
    <g id="node3" class="node"><title>Fuzzer</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="68.38" y="-453.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node3_21"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node3_22"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="59" y="-431.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_23"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="59" y="-418.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node3_24"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="59" y="-405.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">run()</text></a></g> <g id="a_node3_25"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="59"
    y="-393" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="10.00">runs()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>GrammarFuzzer->Fuzzer</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="190.38"
    y="-71.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="190.38" y="-61.75" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="196.38" y="-61.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="190.38" y="-51.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="196.38" y="-51.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="190.38" y="-41.75" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="196.38" y="-41.75" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="190.38" y="-32.7" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the chapter on [information flow](InformationFlow), we have seen how dynamic
    taints can be used to direct fuzzing by indicating which part of input reached
    interesting places. However, dynamic taint tracking is limited in the information
    that it can propagate. For example, we might want to explore what happens when
    certain properties of the input changes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have a function `factorial()` that returns the *factorial
    value* of its input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We exercise the function with a value of `5`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Is this sufficient to explore all the features of the function? How do we know?
    One way to verify that we have explored all features is to look at the *coverage
    obtained*. First we need to extend the `Coverage` class from the [chapter on coverage](Coverage.html)
    to provide us with coverage arcs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use the `Tracer` to obtain the coverage arcs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the coverage arcs to visualize the coverage obtained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: We see that the path `[1, 2, 5, 8, 11, 12, 13, 14]` is covered (green) but sub-paths
    such as `[2, 3]`, `[5, 6]` and `[8, 9]` are unexplored (red). What we need is
    the ability to generate inputs such that the `True` branch is taken at `2`. How
    do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: Concolic Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to cover additional branches is to look at the execution path being
    taken, and collect the *conditional constraints* that the path encounters. Then
    we can try to produce inputs that lead us to taking the non-traversed path.
  prefs: []
  type: TYPE_NORMAL
- en: First, let us step through the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The line (1) is simply the entry point of the function. We know that the input
    is `n`, which is an integer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The line (2) is a predicate `n < 0`. Since the next line taken is line (5),
    we know that at this point in the execution path, the predicate was `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We notice that this is one of the predicates where the `true` branch was not
    taken. How do we generate a value that takes the `true` branch here? One way is
    to use symbolic variables to represent the input, encode the constraint, and use
    an *SMT Solver* to solve the negation of the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the introduction to the chapter, a symbolic variable can
    be thought of as a sort of placeholder for the real variable, sort of like the
    `x` in solving for `x` in Algebra. These variables can be used to encode constraints
    placed on the variables in the program. We identify what constraints the variable
    is supposed to obey, and finally produce a value that obeys all constraints imposed.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve these constraints, one can use a *Satisfiability Modulo Theories* (SMT)
    solver. An SMT solver is built on top of a *SATISFIABILITY* (SAT) solver. A SAT
    solver is being used to check whether boolean formulas in first order logic (e.g.
    `(a | b ) & (~a | ~b)`) can be satisfied using any assignments for the variables
    (e.g `a = true, b = false`). An SMT solver extends these SAT solvers to specific
    background theories -- for example, *theory of integers*, or *theory of strings*.
    That is, given a string constraint expressed as a formula with string variables
    (e.g. `h + t == 'hello,world'`), an SMT solver that understands *theory of strings*
    can be used to check if that constraint can be satisfied, and if satisfiable,
    provide an instantiation of concrete values for the variables used in the formula
    (e.g `h = 'hello,', t = 'world'`).
  prefs: []
  type: TYPE_NORMAL
- en: We use the SMT solver Z3 in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Let us set up Z3 first. To ensure that the string constraints we use in this
    chapter are successfully evaluated, we need to specify the `z3str3` solver. Further,
    we set the timeout for Z3 computations to 30 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To encode constraints, we need symbolic variables. Here, we make `zn` a placeholder
    for the Z3 symbolic integer variable `n`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Remember the constraint `(n < 0)` from line 2 in `factorial()`? We can now encode
    the constraint as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: n < 0
  prefs: []
  type: TYPE_NORMAL
- en: We previously traced `factorial(5)`. We saw that with input `5`, the execution
    took the `else` branch on the predicate `n < 0`. We can express this observation
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: ¬(n < 0)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now solve constraints. The `z3.solve()` method checks if the constraints
    are satisfiable; if they are, it also provides values for variables such that
    the constraints are satisfied. For example, we can ask Z3 for an input that will
    take the `else` branch as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is *a solution* (albeit a trivial one). SMT solvers can be used to solve
    much harder problems. For example, here is how one can solve a quadratic equation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Again, this is *one solution*. We can ask z3 to give us another solution as
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, both `x = 5` and `x = 1/2` are solutions to the quadratic equation $2x^2
    -11x + 5 = 0$
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can ask *Z3* for an input that satisfies the constraint encoded
    in line 2 of `factorial()` so that we take the `if` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That is, if one uses `-1` as an input to `factorial()`, it is guaranteed to
    take the `if` branch in line 2 during execution.
  prefs: []
  type: TYPE_NORMAL
- en: Let us try using that with our coverage. Here, the `-1` is the solution from
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="418pt" height="564pt" viewBox="0.00 0.00 418.25 564.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 560)"><g
    id="node1" class="node"><title>1</title> <text text-anchor="middle" x="98.75"
    y="-527.83" font-family="Times,serif" font-size="14.00">1: enter: factorial(n)</text></g>
    <g id="node7" class="node"><title>3</title> <text text-anchor="middle" x="98.75"
    y="-451.82" font-family="Times,serif" font-size="14.00">2: if: n < 0</text></g>
    <g id="edge5" class="edge"><title>1->3</title></g> <g id="node2" class="node"><title>2</title>
    <text text-anchor="middle" x="142.75" y="-15.82" font-family="Times,serif" font-size="14.00">1:
    exit: factorial(n)</text></g> <g id="node3" class="node"><title>4</title> <text
    text-anchor="middle" x="47.75" y="-163.82" font-family="Times,serif" font-size="14.00">3:
    return None</text></g> <g id="edge1" class="edge"><title>4->2</title></g> <g id="node4"
    class="node"><title>6</title> <text text-anchor="middle" x="123.75" y="-307.82"
    font-family="Times,serif" font-size="14.00">6: return 1</text></g> <g id="edge2"
    class="edge"><title>6->2</title></g> <g id="node5" class="node"><title>8</title>
    <text text-anchor="middle" x="193.75" y="-235.82" font-family="Times,serif" font-size="14.00">9:
    return 1</text></g> <g id="edge3" class="edge"><title>8->2</title></g> <g id="node6"
    class="node"><title>13</title> <text text-anchor="middle" x="229.75" y="-91.83"
    font-family="Times,serif" font-size="14.00">16: return v</text></g> <g id="edge4"
    class="edge"><title>13->2</title></g> <g id="edge6" class="edge"><title>3->4</title></g>
    <g id="node8" class="node"><title>5</title> <text text-anchor="middle" x="150.75"
    y="-379.82" font-family="Times,serif" font-size="14.00">5: if: n == 0</text></g>
    <g id="edge7" class="edge"><title>3->5</title></g> <g id="edge8" class="edge"><title>5->6</title></g>
    <g id="node9" class="node"><title>7</title> <text text-anchor="middle" x="253.75"
    y="-307.82" font-family="Times,serif" font-size="14.00">8: if: n == 1</text></g>
    <g id="edge9" class="edge"><title>5->7</title></g> <g id="edge10" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="283.75"
    y="-235.82" font-family="Times,serif" font-size="14.00">11: v = 1</text></g> <g
    id="edge11" class="edge"><title>7->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="308.75" y="-163.82" font-family="Times,serif" font-size="14.00">12:
    while: n != 0</text></g> <g id="edge12" class="edge"><title>9->10</title></g>
    <g id="edge16" class="edge"><title>10->13</title></g> <g id="node13" class="node"><title>11</title>
    <text text-anchor="middle" x="331.75" y="-91.83" font-family="Times,serif" font-size="14.00">13:
    v = v * n</text></g> <g id="edge14" class="edge"><title>10->11</title></g> <g
    id="node12" class="node"><title>12</title> <text text-anchor="middle" x="367.75"
    y="-15.82" font-family="Times,serif" font-size="14.00">14: n = n - 1</text></g>
    <g id="edge13" class="edge"><title>12->10</title></g> <g id="edge15" class="edge"><title>11->12</title></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ok, so we have managed to cover a little more of the graph. Let us continue
    with our original input of `factorial(5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: In line (5) we encounter a new predicate `n == 0`, for which we again took the
    false branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The predicates required, to follow the path until this point are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If we continue to line (8), we encounter another predicate, for which again,
    we took the `false` branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The predicates encountered so far are as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To take the branch at (6), we essentially have to obey the predicates until
    that point, but invert the last predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is tracing the execution corresponding to a particular
    input `factorial(5)`, using concrete values, and along with it, keeping *symbolic
    shadow variables* that enable us to capture the constraints. As we mentioned in
    the introduction, this particular method of execution where one tracks concrete
    execution using symbolic variables is called *Concolic Execution*.
  prefs: []
  type: TYPE_NORMAL
- en: How do we automate this process? One method is to use a similar infrastructure
    as that of the chapter on [information flow](InformationFlow.html), and use the
    Python inheritance to create *symbolic proxy objects* that can track the concrete
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: A Concolic Tracer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now define a class to *collect* symbolic variables and path conditions
    during an execution. The idea is to have a `ConcolicTracer` class that is invoked
    in a `with` block. To execute a function while tracing its path conditions, we
    need to *transform* its arguments, which we do by invoking functions through a
    `[]` item access.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical usage of a `ConcolicTracer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, we can access the symbolic variables in the `decls` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'whereas the `path` attribute lists the precondition paths encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `context` attribute contains a pair of declarations and paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If you read this for the first time, skip the implementation and head right
    to the examples.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-ConcolicTracer"><summary>Implementing ConcolicTracer</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Let us now implement `ConcolicTracer`. Its constructor accepts a single `context`
    argument which contains the declarations for the symbolic variables seen so far,
    and path conditions seen so far. We only need this in case of nested contexts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We add the enter and exit methods for the `with` block.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We use introspection to determine the arguments to the function, which is hooked
    into the `getitem()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the function itself is invoked using the `call` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For now, we define `concolic()` as a transparent function. It will be modified
    to produce symbolic variables later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have things in place for *tracing* functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And for retrieving results (but not actually *computing* them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Both `decls` and `path` attributes will be set by concolic proxy objects, which
    we define next.
  prefs: []
  type: TYPE_NORMAL
- en: Concolic Proxy Objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now define the concolic proxy objects that can be used for concolic tracing.
    First, we define the `zproxy_create()` method that given a class name, correctly
    creates an instance of that class, and the symbolic corresponding variable, and
    registers the symbolic variable in the context information `context`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: A Proxy Class for Booleans
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, we define the `zbool` class which is used to track the predicates encountered.
    It is a wrapper class that contains both symbolic (`z`) and concrete (`v`) values.
    The concrete value is used to determine which path to take, and the symbolic value
    is used to collect the predicates encountered.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization is done in two parts. The first one is using `zproxy_create()`
    to correctly initialize and register the shadow symbolic variable corresponding
    to the passed argument. This is used exclusively when the symbolic variable needs
    to be initialized first. In all other cases, the constructor is called with the
    preexisting symbolic value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how it is used. We create a symbolic variable `my_bool_arg` with a
    value of `True` in the current context of the concolic tracer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now access the symbolic name in the `z` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: my_bool_arg
  prefs: []
  type: TYPE_NORMAL
- en: 'The value is in the `v` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the context of the enclosing `ConcolicTracer()` is automatically
    updated (via `zproxy_create()`) to hold the variable declarations and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The context can also be reached through the `context` attribute; both point
    to the same data structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Negation of Encoded formula
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `zbool` class allows negation of its concrete and symbolic values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here is how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: ¬my_bool_arg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Registering Predicates on Conditionals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The `zbool` class is being used to track Boolean conditions that arise during
    program execution. It tracks such conditions by registering the corresponding
    symbolic expressions in the context as soon as it is evaluated. On evaluation,
    the `__bool__()` method is called; so we can hook into this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zbool` class can be used to keep track of Boolean values and conditions
    encountered during the execution. For example, we can encode the conditions encountered
    by Line 6 in `factorial()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the concrete value (`ca`), and its shadow symbolic variable
    (`za`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Then, we wrap it in `zbool`, and use it in a conditional, forcing the conditional
    to be registered in the context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We can retrieve the registered conditional as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: A Proxy Class for Integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next, we define a symbolic wrapper `zint` for `int`. This class keeps track
    of the `int` variables used and the predicates encountered in `context`. Finally,
    it also keeps the concrete value so that it can be used to determine the path
    to take. As the `zint` extends the primitive `int` class, we have to define a
    *new* method to open it for extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: As in the case of `zbool`, the initialization takes place in two parts. The
    first using `create()` if a new symbolic argument is being registered, and then
    the usual initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `int` value of a `zint` object is its concrete value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Using these proxies is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: int_arg
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The `zint` class is often used to do arithmetic with, or compare to other `int`s.
    These `int`s can be either a variable or a constant value. We define a helper
    method `_zv()` that checks what kind of `int` a given value is, and produces the
    correct symbolic equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: It can be used as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Equality between Integers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Two integers can be compared for equality using *ne* and *eq*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: We also define *req* using *eq* in case the int being compared is on the left-hand
    side.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: It can be used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Comparisons between Integers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Integers can also be compared for ordering, and the methods for this are defined
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: We use the comparisons and equality operators to provide the other missing operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: These functions can be used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Binary Operators for Integers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We implement relevant arithmetic operators for integers as described in the
    [Python documentation](https://docs.python.org/3/reference/datamodel.html#object.__add__).
    (The commented out operators are not directly available for `z3.ArithRef`. They
    need to be implemented separately if needed. See the exercises for how it can
    be done.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Integer Unary Operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also implement the relevant unary operators as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the unary operators we defined above as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Using an Integer in a Boolean Context
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An integer may be converted to a boolean context in conditionals or as part
    of boolean predicates such as `or`, `and` and `not`. In these cases, the `__bool__()`
    method gets called. Unfortunately, this method requires a primitive boolean value.
    Hence, we force the current integer formula to a boolean predicate and register
    it in the current context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: It is used as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Remaining Methods of the ConcolicTracer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We now complete some methods of the `ConcolicTracer`.
  prefs: []
  type: TYPE_NORMAL
- en: Translating to the SMT Expression Format
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given that we are using an SMT Solver z3, it is often useful to retrieve the
    corresponding SMT expression for a symbolic expression. This can be used as an
    argument to `z3` or other SMT solvers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the SMT expression ([SMT-LIB](http://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf))
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables declarations in [S-EXP](https://en.wikipedia.org/wiki/S-expression)
    format. E.g. The following declares a symbolic integer variable `x`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This declares a `bit vector` `b` of length `8`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This declares a symbolic real variable `r`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This declares a symbolic string variable `s`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The declared variables can be used in logical formulas that are encoded in *S-EXP*
    format. For example, here is a logical formula.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Here is another example, using string variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: To see how to use `smt_expr()`, let us consider an example. The `triangle()`
    function is used to determine if the given sides to a triangle result in an `equilateral`
    triangle, an `isosceles` triangle, or a `scalene` triangle. It is implemented
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: To make `triangle()` run under `ConcolicTracer`, we first define the (symbolic)
    arguments. The triangle being defined has sides `1, 1, 1`. i.e. it is an `equilateral`
    triangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: We can now call `smt_expr()` to retrieve the SMT expression as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: The collected predicates can also be solved directly using the Python z3 API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Generating Fresh Names
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: While using the proxy classes, we often will have to generate new symbolic variables,
    with names that have not been used before. For this, we define `fresh_name()`
    that always generates unique integers for names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Translating Arguments to Concolic Proxies
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We had previously defined `concolic()` as a transparent function. We now provide
    the full implementation of this function. It inspects a given function's parameters,
    and infers the parameter types from the concrete arguments passed in. It then
    uses this information to instantiate the correct proxy classes for each argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it gets used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: With the new `concolic()` method, the arguments to the factorial are correctly
    associated with symbolic variables, which allows us to retrieve the predicates
    encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: As before, we can also print out the SMT expression which can be passed directly
    to command line SMT solvers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: We next define methods to evaluate the SMT expression both in Python and from
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating the Concolic Expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We define `zeval()` to solve the predicates in a context, and return results.
    It has two modes. The `python` mode uses `z3` Python API to solve and return the
    results. If the `python` mode is false, it writes the SMT expression to a file,
    and invokes the command line `z3` for a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Using the Python API
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Given a set of predicates that the function encountered, and the tracer under
    which the function was executed, the `zeval_py()` function first declares the
    relevant symbolic variables, and uses the `z3.Solver()`to provide a set of inputs
    that would trace the same path through the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: That is, given the set of constraints, the assignment `n == 5` conforms to all
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Command Line
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `zeval_smt()` function writes the SMT expression to the file system, and
    calls the `z3` SMT solver command line to solve it. The result of SMT expression
    is again an `sexpr`. Hence, we first define `parse_sexp()` to parse and return
    the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: The `parse_sexp()` function can be used as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: We now define `zeval_smt()` which uses the `z3` command line directly, and uses
    `parse_sexp()` to parse and return the solutions to function arguments if any.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: We can now use `zeval()` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, we get similar results (`n == 5`) from using the command line as from
    using the Python API.
  prefs: []
  type: TYPE_NORMAL
- en: A Proxy Class for Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Here, we define the proxy string class `zstr`. First we define our initialization
    routines. Since `str` is a primitive type, we define `new` to extend it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: As before, initialization proceeds with `create()` and the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: We also define `_zv()` helper to help us with methods that accept another string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Hack to use the ASCII value of a character.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note:** Temporary solution; This block should go away as soon as [this commit](https://github.com/Z3Prover/z3/issues/5764)
    is released, which allows us to use the Python API directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving Ordinal Value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We define `zord` that given a symbolic one character long string, obtains the
    `ord()` for that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: We use it as follows
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: No new variables are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Here is the smtlib representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: We can specify what the result of `ord()` should be, and call `z3.solve()` to
    provide us with a solution that will provide the required result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Translating an Ordinal Value to ASCII
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similarly, we can convert the ASCII value back to a single character string
    using `zchr()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: For using it, we first define a bitvector that is 8 bits long.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: We can now retrieve the `chr()` representation as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: No new variables are defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: As before, we can specify what the end result of calling `chr()` should be to
    get the original argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Equality between Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The equality of `zstr` is defined similar to that of `zint`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The `zstr` class is used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: It works even if we have more than one character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Length of Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Unfortunately, in Python, we can't override `len()` to return a new datatype.
    Hence, we work around that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Concatenation of Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: What if we need to concatenate two strings? We need additional helpers to accomplish
    that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Here is how it can be used. First, we create the wrapped arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The addition of symbolic variables is preserved in `context`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Producing Substrings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similarly, accessing substrings also require extra help.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: An Iterator Class for Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We define the iterator as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Here is how it can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Again, the context shows predicates encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: The function `zeval()` returns a solution for the predicate. Note that the value
    returned is not exactly the argument that we passed in. This is a consequence
    of the predicates we have. That is, we have no constraints on what the character
    value on `s[2]` should be.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Translating to Upper and Lower Equivalents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A major complication is supporting `upper()` and `lower()` methods. We use the
    previously defined `zchr()` and `zord()` functions to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: The `lower()` function is similar to `upper()` except that the character ranges
    are switched, and the lowercase is above uppercase. Hence, we add the difference
    to the ordinal to make a character to lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Here is how `upper()` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Again, we use `zeval()` to solve the collected constraints, and verify that
    our constraints are correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a larger example using `lower()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Again, we obtain the right input value.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for String Prefixes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We define `startswith()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: An example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: As before, the predicates only ensure that the `startswith()` returned a true
    value. Hence, our solution reflects that.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Substrings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also define `find()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: An example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: As before, the predicates only ensure that the `find()` returned a value greater
    than -1\. Hence, our solution reflects that.
  prefs: []
  type: TYPE_NORMAL
- en: Remove Space from Ends
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We next implement `strip()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Example usage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: The `strip()` has generated the right constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting Strings
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We implement string `split()` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Trip Wire
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For easier debugging, we abort any calls to methods in `str` that are not overridden
    by `zstr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Triangle'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We previously showed how to run `triangle()` under `ConcolicTracer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'The symbolic variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicates are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `zeval()`, we solve these path conditions and obtain a solution. We find
    that Z3 gives us three distinct integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: (Note that some values may be negative. Indeed, `triangle()` works with negative
    length values, too, even if real triangles only have positive lengths.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If we invoke `triangle()` with these very values, we take the *exact same path*
    as the original input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: We can have z3 *negate* individual conditions – and thus take different paths.
    First, we retrieve the symbolic variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we pass a negated predicate to `zeval()`. The key (here: `1`) determines
    which predicate the new predicate will replace.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: The updated predicate returns `isosceles` as expected. By negating further conditions,
    we can systematically explore all branches in `triangle()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Decoding CGI Strings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us apply `ConcolicTracer` on our example program `cgi_decode()` from the
    [chapter on coverage](Coverage.html). Note that we need to rewrite its code slightly,
    as the hash lookups in `hex_values` can not be used for transferring constraints
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Once executed, we can retrieve the symbolic variables in the `decls` attribute.
    This is a mapping of symbolic variables to types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'The extracted path conditions can be found in the `path` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: The `context` attribute holds a pair of `decls` and `path` attributes; this
    is useful for passing it into the `ConcolicTracer` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve these constraints to obtain a value for the function parameters
    that follow the same path as the original (traced) invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '*Negating* some of these constraints will yield different paths taken, and
    thus greater code coverage. This is what our concolic fuzzers (see later) do.
    Let us go and negate the first constraint, namely that the first character should
    *not* be a `+` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 0 < Length(cgi_decode_s_str_1)
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the negated string, we have to construct it via z3 primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: str.substr(cgi_decode_s_str_1, 0, 1) = "a"
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking `zeval()` with the path condition to be changed obtains a new input
    that satisfies the negated predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'We can validate that `new_s` indeed takes the new path by re-running the tracer
    with `new_s` as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: By negating further conditions, we can explore more and more code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Round'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a function that gives you the nearest ten's multiplier
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: As before, we execute the function under the `ConcolicTracer` context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'We verify that we were able to capture all the predicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: We use `zeval()` to obtain more inputs that take the same path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Absolute Maximum'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do our concolic proxies work across functions? Say we have a function `max_value()`
    as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: It is called by another function `abs_max()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Concolic()` context on `abs_max()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we have the predicates across functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Solving the predicates works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Using negative numbers as arguments so that a different branch is taken in `abs_value()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: The solution reflects our predicates. (We used `a > 0` in `abs_value()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Binomial Coefficient'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a larger example that uses different kinds of variables, say we want to
    compute the binomial coefficient by the following formulas
  prefs: []
  type: TYPE_NORMAL
- en: $$ ^nP_k=\frac{n!}{(n-k)!} $$
  prefs: []
  type: TYPE_NORMAL
- en: $$ \binom nk=\,^nC_k=\frac{^nP_k}{k!} $$
  prefs: []
  type: TYPE_NORMAL
- en: we define the functions as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: As before, we run the function under `ConcolicTracer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Then call `zeval()` to evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Database'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a larger example using the Concolic String class `zstr`, we use the DB class
    from the [chapter on information flow](InformationFlow.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: We first populate our database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to fuzz our `DB` class. Hash functions are difficult to handle
    directly (because they rely on internal C functions). Hence we modify `table()`
    slightly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: To make it easy, we define a single function `db_select()` that directly invokes
    `db.sql()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: We now want to run SQL statements under our `ConcolicTracer`, and collect predicates
    obtained.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'The predicates encountered during the execution are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: We can use `zeval()` as before to solve the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing with Constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SimpleConcolicFuzzer` class starts with a sample input generated by some
    other fuzzer. It then runs the function being tested under `ConcolicTracer`, and
    collects the path predicates. It then negates random predicates within the path
    and solves it with Z3 to produce a new output that is guaranteed to take a different
    path than the original.
  prefs: []
  type: TYPE_NORMAL
- en: As with `ConcolicTracer`, above, please first look at the examples before digging
    into the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-SimpleConcolicFuzzer"><summary>Implementing
    SimpleConcolicFuzzer</summary>
  prefs: []
  type: TYPE_NORMAL
- en: First, we import the `Fuzzer` interface, and write example program `hang_if_no_space()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: Representing Decisions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make the fuzzer work, we need a way to represent decisions made during trace.
    We keep this in a *binary tree* where each node represents a decision made, and
    each leaf represents a complete path. A node in the binary tree is represented
    by the `TraceNode` class.
  prefs: []
  type: TYPE_NORMAL
- en: When a new node is added, it represents a decision taken by the parent on some
    predicate. This predicate is supplied as `smt_val`, which is `True` for this child
    to be reached. Since the predicate is actually present in the parent node, we
    also carry a member `smt` which will be updated by the first child to be added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: We add a `PlausibleChild` class to track the leaf nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: When the leaf nodes are used to generate new paths, we expect its sibling `TraceNode`
    to have been already explored. Hence, we make use of the sibling's values for
    context `cc`, and the `smt_val` from the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: The `PlausibleChild` instance is used to generate new paths to explore using
    `path_expression()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: The `TraceTree` class helps us keep track of the binary tree. In the beginning,
    the root is a sentinel `TraceNode` instance, and simply have two plausible children
    as leaves. As soon as the first trace is added, one of the plausible children
    will become a true child.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: The `add_trace()` method of the `TraceTree` provides a way for new traces to
    be added. It is kept separate from the initialization as we might want to add
    more than one trace from the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: To make `add_trace()` work, we need a little more infrastructure, that we define
    below.
  prefs: []
  type: TYPE_NORMAL
- en: The `bit()` method translates a predicate to a bit that corresponds to the decision
    taken at each predicate. If the `if` branch is taken, the result is `1`, while
    `else` branch is indicated by `0`. The pattern indicates the bit-pattern of decisions
    required to reach the leaf from the root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Each node knows how to add a new child, and get the path to root, which is cached.
  prefs: []
  type: TYPE_NORMAL
- en: When we add a child to the root node, it means that there was a decision in
    the current node, and the child is the result of the decision. Hence, to get the
    decision being made, we simplify the `smt` expression, and check if it starts
    with `not`. If it does not start with a `not`, we interpret that as the current
    decision in the node. If it starts with `not`, then we interpret that `not(smt)`
    was the expression being evaluated in the current node.
  prefs: []
  type: TYPE_NORMAL
- en: We know the first decision made only after going through the program at least
    once. As soon as the program is traversed, we update the parent with the decision
    that resulted in the current child.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: The path to root from any node is computed once and cached.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: The SimpleConcolicFuzzer class
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `SimpleConcolicFuzzer` is defined with the `Fuzzer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: The `add_trace()` method we defined earlier is used as follows. First, we use
    a random string to generate the concolic trace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Next, we initialize and add this trace to the fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: The path we added above can be obtained from the `TraceTree` as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Below are the registered leaves that we can explore at this moment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need a way to visualize the constructed tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="700pt" height="409pt" viewBox="0.00 0.00 699.50 409.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 405.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="570.75"
    y="-387.95" font-family="Times,serif" font-size="14.00">(0) Length(hang_if_no_space_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.75" y="-323.45" font-family="Times,serif" font-size="14.00">(1) str.substr(hang_if_no_space_s_str_1,
    0, 1) == " "</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="537.19" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="659.75"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>0->12</title> <text text-anchor="middle" x="626.6" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="402.75" y="-258.95" font-family="Times,serif" font-size="14.00">(2)
    Length(hang_if_no_space_s_str_1) <= 1</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="452.11" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="557.75"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge11"
    class="edge"><title>1->11</title> <text text-anchor="middle" x="529.52" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="312.75" y="-194.45" font-family="Times,serif" font-size="14.00">(3)
    str.substr(hang_if_no_space_s_str_1, 1, 1) == " "</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="369.19" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="491.75"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>2->10</title> <text text-anchor="middle" x="458.6" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-129.95" font-family="Times,serif" font-size="14.00">(4)
    Length(hang_if_no_space_s_str_1) <= 2</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="284.11" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="389.75"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge9"
    class="edge"><title>3->9</title> <text text-anchor="middle" x="361.52" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="144.75" y="-65.45" font-family="Times,serif" font-size="14.00">(5)
    str.substr(hang_if_no_space_s_str_1, 2, 1) == " "</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="201.19" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="323.75"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge8"
    class="edge"><title>4->8</title> <text text-anchor="middle" x="290.6" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="119.75" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge6" class="edge"><title>5->6</title> <text text-anchor="middle"
    x="137.86" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="170.75"
    y="-0.95" font-family="Times,serif" font-size="14.00">* ab d</text></g> <g id="edge7"
    class="edge"><title>5->7</title> <text text-anchor="middle" x="163.45" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: For example, the pattern `00000:0` corresponds to the following predicates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Similarly the pattern `:1` corresponds to the following predicates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: We can now generate the next input to be generated by looking for a leaf that
    is incompletely explored. The idea is to collect all leaf nodes, and choose one
    at random.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: We use the `next_choice()` as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: We get the next choice for exploration, and expand the path expression, and
    return it together with a context using `get_newpath()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: The fuzzing method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `fuzz()` method simply generates new lists of predicates, and solves them
    to produce new inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate `SimpleConcolicFuzzer`, let us apply it on our example program
    `cgi_decode()` from the `Coverage` chapter. Note that we cannot use it directly
    as the hash lookups in `hex_values` can not be used for transferring constraints
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: The *trace tree* shows the path conditions encountered so far. Any blue edge
    towards a "?" implies that there is a path not yet taken.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="674pt" height="603pt" viewBox="0.00 0.00 673.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="563.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="481.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="533.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="644.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="614.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="398.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="450.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="563.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="533.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="329.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="373.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="466.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="441.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="247.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="299.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="410.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="380.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="232.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="244.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="369.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="322.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="325.55" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="417.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="401.05" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: So, we fuzz to get a new path that is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: We can now obtain the new trace as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: The new trace is added to our fuzzer using `add_trace()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: The updated binary tree is as follows. Note the difference between the child
    nodes of `Root` node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="673pt" height="603pt" viewBox="0.00 0.00 672.75 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="562.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="480.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="532.09" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="643.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge18"
    class="edge"><title>0->18</title> <text text-anchor="middle" x="613.51" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="397.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="449.68" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="562.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge17"
    class="edge"><title>1->17</title> <text text-anchor="middle" x="532.09" y="-484.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="328.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    Length(cgi_decode_s_str_1) <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title>
    <text text-anchor="middle" x="372.43" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="465.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge16"
    class="edge"><title>2->16</title> <text text-anchor="middle" x="440.84" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="246.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="298.09" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="409.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge15"
    class="edge"><title>3->15</title> <text text-anchor="middle" x="379.51" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="231.38" y="-258.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge5" class="edge"><title>4->5</title> <text text-anchor="middle"
    x="243.59" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="368.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge6" class="edge"><title>4->6</title> <text text-anchor="middle"
    x="321.68" y="-291.2" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="254.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">(6) str.substr(cgi_decode_s_str_1,
    2, 1) == "+"</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="324.96" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="middle" x="415.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A+</text></g> <g id="edge14"
    class="edge"><title>6->14</title> <text text-anchor="middle" x="399.46" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="171.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge8" class="edge"><title>7->8</title>
    <text text-anchor="middle" x="223.68" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="336.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge13"
    class="edge"><title>7->13</title> <text text-anchor="middle" x="306.09" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="102.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge9" class="edge"><title>8->9</title>
    <text text-anchor="middle" x="146.43" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="239.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge12"
    class="edge"><title>8->12</title> <text text-anchor="middle" x="214.84" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="77.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge10" class="edge"><title>9->10</title> <text text-anchor="middle"
    x="95.49" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node12" class="node"><title>11</title> <text text-anchor="middle" x="127.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* a+c</text></g> <g id="edge11"
    class="edge"><title>9->11</title> <text text-anchor="middle" x="120.49" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete fuzzer run is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="981pt" height="603pt" viewBox="0.00 0.00 980.88 602.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 598.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="638.38"
    y="-581.45" font-family="Times,serif" font-size="14.00">(0) Length(cgi_decode_s_str_1)
    <= 0</text></g> <g id="node2" class="node"><title>1</title> <text text-anchor="middle"
    x="562.38" y="-516.95" font-family="Times,serif" font-size="14.00">(1) str.substr(cgi_decode_s_str_1,
    0, 1) == "+"</text></g> <g id="edge1" class="edge"><title>0->1</title> <text text-anchor="middle"
    x="610.56" y="-549.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="714.38"
    y="-516.95" font-family="Times,serif" font-size="14.00">*</text></g> <g id="edge36"
    class="edge"><title>0->36</title> <text text-anchor="middle" x="686.56" y="-549.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="437.38" y="-452.45" font-family="Times,serif" font-size="14.00">(2)
    str.substr(cgi_decode_s_str_1, 0, 1) == "%"</text></g> <g id="edge2" class="edge"><title>1->2</title>
    <text text-anchor="middle" x="514.45" y="-484.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node14" class="node"><title>13</title> <text text-anchor="middle" x="688.38"
    y="-452.45" font-family="Times,serif" font-size="14.00">(2) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge13" class="edge"><title>1->13</title> <text text-anchor="middle"
    x="640.04" y="-484.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="328.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">(3) Length(cgi_decode_s_str_1)
    <= 1</text></g> <g id="edge3" class="edge"><title>2->3</title> <text text-anchor="middle"
    x="396.01" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="460.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* %</text></g> <g id="edge12"
    class="edge"><title>2->12</title> <text text-anchor="middle" x="454.31" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="291.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge4" class="edge"><title>3->4</title>
    <text text-anchor="middle" x="316.56" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="middle" x="445.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">*  </text></g> <g id="edge11"
    class="edge"><title>3->11</title> <text text-anchor="middle" x="400.73" y="-355.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="185.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge5" class="edge"><title>4->5</title>
    <text text-anchor="middle" x="251.24" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="350.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge10"
    class="edge"><title>4->10</title> <text text-anchor="middle" x="329.53" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="102.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    Length(cgi_decode_s_str_1) <= 2</text></g> <g id="edge6" class="edge"><title>5->6</title>
    <text text-anchor="middle" x="154.68" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="238.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* A%</text></g> <g id="edge9"
    class="edge"><title>5->9</title> <text text-anchor="middle" x="220" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="88.38" y="-129.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge7" class="edge"><title>6->7</title> <text text-anchor="middle"
    x="100" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="136.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">* AB</text></g> <g id="edge8"
    class="edge"><title>6->8</title> <text text-anchor="middle" x="125.8" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="667.38" y="-387.95" font-family="Times,serif" font-size="14.00">(3)
    str.substr(cgi_decode_s_str_1, 1, 1) == "+"</text></g> <g id="edge14" class="edge"><title>13->14</title>
    <text text-anchor="middle" x="683.13" y="-420.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node36" class="node"><title>35</title> <text text-anchor="middle" x="823.38"
    y="-387.95" font-family="Times,serif" font-size="14.00">* +</text></g> <g id="edge35"
    class="edge"><title>13->35</title> <text text-anchor="middle" x="771.34" y="-420.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="611.38" y="-323.45" font-family="Times,serif" font-size="14.00">(4)
    str.substr(cgi_decode_s_str_1, 1, 1) == "%"</text></g> <g id="edge15" class="edge"><title>14->15</title>
    <text text-anchor="middle" x="647.77" y="-355.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="862.38"
    y="-323.45" font-family="Times,serif" font-size="14.00">(4) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge26" class="edge"><title>14->26</title> <text text-anchor="middle"
    x="785.72" y="-355.7" font-family="Times,serif" font-size="14.00">1</text></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="495.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">(5) Length(cgi_decode_s_str_1)
    <= 2</text></g> <g id="edge16" class="edge"><title>15->16</title> <text text-anchor="middle"
    x="567.14" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="632.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge25"
    class="edge"><title>15->25</title> <text text-anchor="middle" x="627.13" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="449.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge17" class="edge"><title>16->17</title>
    <text text-anchor="middle" x="479.87" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="610.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">* +A</text></g> <g id="edge24"
    class="edge"><title>16->24</title> <text text-anchor="middle" x="566.55" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="349.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge18" class="edge"><title>17->18</title>
    <text text-anchor="middle" x="411.71" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="514.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge23"
    class="edge"><title>17->23</title> <text text-anchor="middle" x="491.07" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="254.38" y="-65.45" font-family="Times,serif" font-size="14.00">(8)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge19" class="edge"><title>18->19</title>
    <text text-anchor="middle" x="313.76" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="391.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge22"
    class="edge"><title>18->22</title> <text text-anchor="middle" x="377.51" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="228.38" y="-0.95" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge20" class="edge"><title>19->20</title> <text text-anchor="middle"
    x="247.08" y="-33.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="middle" x="281.38"
    y="-0.95" font-family="Times,serif" font-size="14.00">* +AB</text></g> <g id="edge21"
    class="edge"><title>19->21</title> <text text-anchor="middle" x="273.67" y="-33.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="799.38" y="-258.95" font-family="Times,serif" font-size="14.00">(5)
    str.substr(cgi_decode_s_str_1, 2, 1) == "+"</text></g> <g id="edge27" class="edge"><title>26->27</title>
    <text text-anchor="middle" x="839.89" y="-291.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node35" class="node"><title>34</title> <text text-anchor="middle" x="959.38"
    y="-258.95" font-family="Times,serif" font-size="14.00">* ++</text></g> <g id="edge34"
    class="edge"><title>26->34</title> <text text-anchor="middle" x="922.94" y="-291.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="780.38" y="-194.45" font-family="Times,serif" font-size="14.00">(6)
    str.substr(cgi_decode_s_str_1, 2, 1) == "%"</text></g> <g id="edge28" class="edge"><title>27->28</title>
    <text text-anchor="middle" x="794.95" y="-226.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="945.38"
    y="-194.45" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge33"
    class="edge"><title>27->33</title> <text text-anchor="middle" x="888.83" y="-226.7"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="676.38" y="-129.95" font-family="Times,serif" font-size="14.00">(7)
    Length(cgi_decode_s_str_1) <= 3</text></g> <g id="edge29" class="edge"><title>28->29</title>
    <text text-anchor="middle" x="741.07" y="-162.2" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="813.38"
    y="-129.95" font-family="Times,serif" font-size="14.00">? (63)</text></g> <g id="edge32"
    class="edge"><title>28->32</title> <text text-anchor="middle" x="803.21" y="-162.2"
    font-family="Times,serif" font-size="14.00">1</text></g> <g id="node31" class="node"><title>30</title>
    <text text-anchor="middle" x="649.38" y="-65.45" font-family="Times,serif" font-size="14.00">?
    (63)</text></g> <g id="edge30" class="edge"><title>29->30</title> <text text-anchor="middle"
    x="668.67" y="-97.7" font-family="Times,serif" font-size="14.00">0</text></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="middle" x="702.38"
    y="-65.45" font-family="Times,serif" font-size="14.00">* ++A</text></g> <g id="edge31"
    class="edge"><title>29->31</title> <text text-anchor="middle" x="695.08" y="-97.7"
    font-family="Times,serif" font-size="14.00">1</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '**Note.** Our concolic tracer is limited in that it does not track changes
    in the string length. This leads it to treat every string with same prefix as
    the same string.'
  prefs: []
  type: TYPE_NORMAL
- en: The `SimpleConcolicFuzzer` is reasonably efficient at exploring paths near the
    path followed by a given sample input. However, it is not very intelligent when
    it comes to choosing which paths to follow. We look at another fuzzer that lifts
    the predicates obtained to the grammar and achieves better fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Concolic Grammar Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concolic framework can be used directly in grammar-based fuzzing. We implement
    a class `ConcolicGrammarFuzzer` which does this.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-ConcolicGrammarFuzzer"><summary>Implementing
    ConcolicGrammarFuzzer</summary>
  prefs: []
  type: TYPE_NORMAL
- en: First, we extend our `GrammarFuzzer` with a helper method `tree_to_string()`
    such that we can retrieve the derivation tree of the fuzz output. We also define
    `prune_tree()` and `coalesce()` methods to reduce the depth of sub trees. These
    methods accept a list of tokens types such that a node belonging to the token
    type gets converted from a tree to a leaf node by calling `tree_to_string()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: We can now use the fuzzer to produce inputs for our DB.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Our fuzzer returns with an exception. It is unable to find the specified table.
    Let us examine the predicates it encountered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can obtain constraints that are not present in the grammar from
    using the `ConcolicTracer`. In particular, see how we are able to obtain the condition
    that the table needs to be `inventory` (Predicate 11) for the fuzzing to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: How do we lift these to the grammar? and in particular how do we do it automatically?
    One option we have is to simply switch the last predicate obtained. In our case,
    the last predicate is (11). Can we simply invert the predicate and solve it again?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Indeed, this will not work as the string lengths being compared to are different.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: A better idea is to investigate what *string* comparisons are being made, and
    associate that with the corresponding nodes in the grammar. Let us examine our
    derivation tree (pruned to avoid recursive structures, and to focus on important
    parts).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="220pt" height="173pt" viewBox="0.00 0.00 219.62 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="104.25"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="104.25" y="-101.45"
    font-family="Times,serif" font-size="14.00"><query></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="17.25"
    y="-51.2" font-family="Times,serif" font-size="14.00">select</text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="75.25" y="-51.2" font-family="Times,serif" font-size="14.00"><exprs></text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="133.25" y="-51.2" font-family="Times,serif" font-size="14.00">from</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="190.25" y="-51.2" font-family="Times,serif" font-size="14.00"><table></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="75.25" y="-0.95" font-family="Times,serif" font-size="14.00">t4(I,N)!=b(k)/O!=(K4(:/Z))</text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="190.25" y="-0.95" font-family="Times,serif" font-size="14.00">I7</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we identify which part of the input was supplied by which part of the grammar?
    We define `span()` that can recover this information from the derivation tree.
    For a given node, let us assume that the start point is known. Then, for processing
    the children, we proceed as follows: We choose one child at a time from left to
    right, and compute the length of the child. The length of the children before
    the current child in addition to our starting point gives the starting point of
    the current child. The end point for each node is simply the end point of its
    last children (or the length of its node if it is a leaf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: We can check if we got the right values as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to obtain all the comparisons made in each predicate. For that,
    we define two helper functions. The first is `unwrap_substrings()` that translates
    multiple calls to `z3.SubString` and returns the start, and length of the given
    z3 string expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: We define `traverse_z3()` that traverses a given z3 string expression, and collects
    all direct string comparisons to a substring of the original argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: All that we need now is to declare string variables that match the substrings
    in `comparisons`, and solve for them for each item in the path. For that, we define
    `find_alternatives()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: We use it as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: So, we have our alternatives for each key in the grammar. We can now update
    our grammar as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: We made a choice here. We could have completely overwritten the definition of
    `<table>` . Instead, we added our new alternatives to the existing definition.
    This way, our fuzzer will also attempt other values for `<table>` once in a while.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Let us try fuzzing with our new grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: That is, we were able to reach the dangerous method `my_eval()`. In effect,
    what we have done is to lift parts of predicates to the grammar. The new grammar
    can generate inputs that reach deeper into the program than before. Note that
    we have only handled the equality predicate. One can also lift the '<' and '>'
    comparison operators to the grammar if required.
  prefs: []
  type: TYPE_NORMAL
- en: Compare the output of our fuzzer to the original `GrammarFuzzer` below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, the original grammar fuzzer is unable to proceed beyond the
    table verification.
  prefs: []
  type: TYPE_NORMAL
- en: Pruning and Updating
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We implement these methods in `ConcolicGrammarFuzzer`. The method `update_grammar()`
    allows `ConcolicGrammarFuzzer` to collect feedback from concolic fuzzing, and
    update the grammar used for fuzzing accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: The `fuzz()` method simply generates the derivation tree, computes the span
    range, and returns the string generated from the derivation tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that our approach works, let us update our tables slightly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: The `ConcolicGrammarFuzzer` is used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, the fuzzer starts with no knowledge of the tables `vehicles`,
    `months` and `years`, but identifies it from the concolic execution, and lifts
    it to the grammar. This allows us to improve the effectiveness of fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with dynamic taint analysis, implicit control flow can obscure the predicates
    encountered during concolic execution. However, this limitation could be overcome
    to some extent by wrapping any constants in the source with their respective proxy
    objects. Similarly, calls to internal C functions can cause the symbolic information
    to be discarded, and only partial information may be obtained.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Concolic execution can often provide more information than taint analysis with
    respect to the program behavior. However, this comes at a much larger runtime
    cost. Hence, unlike taint analysis, real-time analysis is often not possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to taint analysis, concolic execution also suffers from limitations
    such as indirect control flow and internal function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicates from concolic execution can be used in conjunction with fuzzing to
    provide an even more robust indication of incorrect behavior than taints, and
    can be used to create grammars that are better at producing valid inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A costlier but stronger alternative to concolic fuzzing is [symbolic fuzzing](SymbolicFuzzer.html).
    Similarly, [search based fuzzing](SearchBasedFuzzer.html) can often provide a
    cheaper exploration strategy than relying on SMT solvers to provide inputs slightly
    different from the current path.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The technique of concolic execution was originally used to inform and expand
    the scope of *symbolic execution* [[King *et al*, 1976](https://doi.org/10.1145/360248.360252)],
    a static analysis technique for program analysis. Laron et al. cite{Larson2003}
    was the first to use the concolic execution technique.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of using proxy objects for collecting constraints was pioneered by
    Cadar et al. [Cadar *et al*, 2005]. The concolic execution technique for Python
    programs used in this chapter was pioneered by PeerCheck [[A. Bruni *et al*, 2011](https://hoheinzollern.files.wordpress.com/2008/04/seer1.pdf)],
    and Python Error Finder [[Damián Barsotti *et al*, 2018](https://doi.org/https://doi.org/10.1016/j.entcs.2018.06.003)].
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Implement a Concolic Float Proxy Class'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While implementing the `zint` binary operators, we asserted that the results
    were `int`. However, that need not be the case. For example, division can result
    in `float`. Hence, we need proxy objects for `float`. Can you implement a similar
    proxy object for `float` and fix the `zint` binary operator definition?
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** The solution is as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: As in the case of `zint`, we first open up `zfloat` for extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: We then implement the initialization methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: The helper for when one of the arguments in a binary operation is not `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Coerce `float` into bool value for use in conditionals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: Define the common proxy method for comparison methods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: We apply the comparison methods on the defined `zfloat` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we define the common proxy method for binary operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: And apply them on `zfloat`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: These are used as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we fix the `zint` binary wrapper to correctly create `zfloat` when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: Checking whether it worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 2: Bit Manipulation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to floats, implementing the bit manipulation functions such as `xor`
    involves converting `int` to its bit vector equivalents, performing operations
    on them, and converting it back to the original type. Can you implement the bit
    manipulation operations for `zint`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** The solution is as follows.'
  prefs: []
  type: TYPE_NORMAL
- en: We first define the proxy method as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: It is then applied to the `zint` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Invert is the only unary bit manipulation method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: The `my_fn()` computes `xor` and returns `True` if the `xor` results in a non-zero
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Using that under `ConcolicTracer`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: We log the computed SMT expression to verify that everything went well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: We can confirm from the formulas generated that the bit manipulation functions
    worked correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: String Translation Functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have seen how to define `upper()` and `lower()`. Can you define the `capitalize()`,
    `title()`, and `swapcase()` methods?
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Solution not yet available.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/ConcolicFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Concolic Fuzzing](https://www.fuzzingbook.org/html/ConcolicFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/ConcolicFuzzer.html](https://www.fuzzingbook.org/html/ConcolicFuzzer.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
