- en: Mining Function Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/DynamicInvariants.html](http://www.fuzzingbook.org/html/DynamicInvariants.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When testing a program, one not only needs to cover its several behaviors; one
    also needs to *check* whether the result is as expected. In this chapter, we introduce
    a technique that allows us to *mine* function specifications from a set of given
    executions, resulting in abstract and formal *descriptions* of what the function
    expects and what it delivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'These so-called *dynamic invariants* produce pre- and post-conditions over
    function arguments and variables from a set of executions. They are useful in
    a variety of contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic invariants provide important information for [symbolic fuzzing](SymbolicFuzzer.html),
    such as types and ranges of function arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic invariants provide pre- and postconditions for formal program proofs
    and verification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic invariants provide numerous assertions that can check whether function
    behavior has changed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks provided by dynamic invariants can be very useful as *oracles* for checking
    the effects of generated tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traditionally, dynamic invariants are dependent on the executions they are derived
    from. However, when paired with comprehensive test generators, they quickly become
    very precise, as we show in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should be familiar with tracing program executions, as in the [chapter on
    coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this section, we access the internal *abstract syntax tree* representations
    of Python programs and transform them, as in the [chapter on information flow](InformationFlow.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides two classes that automatically extract specifications
    from a function and a set of inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TypeAnnotator` for *types*, and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvariantAnnotator` for *pre-* and *postconditions*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both work by *observing* a function and its invocations within a `with` clause.
    Here is an example for the type annotator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `typed_functions()` method will return a representation of `sum2()` annotated
    with types observed during execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The invariant annotator works similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `functions_with_invariants()` method will return a representation of `sum2()`
    annotated with inferred pre- and postconditions that all hold for the observed
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Such type specifications and invariants can be helpful as *oracles* (to detect
    deviations from a given set of runs) as well as for all kinds of *symbolic code
    analyses*. The chapter gives details on how to customize the properties checked
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Specifications and Assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When implementing a function or program, one usually works against a *specification*
    – a set of documented requirements to be satisfied by the code. Such specifications
    can come in natural language. A formal specification, however, allows the computer
    to check whether the specification is satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the [introduction to testing](Intro_Testing.html), we have seen how *preconditions*
    and *postconditions* can describe what a function does. Consider the following
    (simple) square root function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The assertion `assert p` checks the condition `p`; if it does not hold, execution
    is aborted. Here, the actual body is not yet written; we use the assertions as
    a specification of what `any_sqrt()` *expects*, and what it *delivers*.
  prefs: []
  type: TYPE_NORMAL
- en: The topmost assertion is the *precondition*, stating the requirements on the
    function arguments. The assertion at the end is the *postcondition*, stating the
    properties of the function result (including its relationship with the original
    arguments). Using these pre- and postconditions as a specification, we can now
    go and implement a square root function that satisfies them. Once implemented,
    we can have the assertions check at runtime whether `any_sqrt()` works as expected;
    a [symbolic](SymbolicFuzzer.html) or [concolic](ConcolicFuzzer.html) test generator
    will even specifically try to find inputs where the assertions do *not* hold.
    (An assertion can be seen as a conditional branch towards aborting the execution,
    and any technique that tries to cover all code branches will also try to invalidate
    as many assertions as possible.)
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not every piece of code is developed with explicit specifications
    in the first place; let alone does most code comes with formal pre- and post-conditions.
    (Just take a look at the chapters in this book.) This is a pity: As Ken Thompson
    famously said, "Without specifications, there are no bugs – only surprises". It
    is also a problem for testing, since, of course, testing needs some specification
    to test against. This raises the interesting question: Can we somehow *retrofit*
    existing code with "specifications" that properly describe their behavior, allowing
    developers to simply *check* them rather than having to write them from scratch?
    This is what we do in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Generic Error Checking is Not Enough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go into *mining* specifications, let us first discuss why it could
    be useful to *have* them. As a motivating example, consider the full implementation
    of a square root function from the [introduction to testing](Intro_Testing.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`my_sqrt()` does not come with any functionality that would check types or
    values. Hence, it is easy for callers to make mistakes when calling `my_sqrt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At least, the Python system catches these errors at runtime. The following
    call, however, simply lets the function enter an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Our goal is to avoid such errors by *annotating* functions with information
    that prevents errors like the above ones. The idea is to provide a *specification*
    of expected properties – a specification that can then be checked at runtime or
    statically.
  prefs: []
  type: TYPE_NORMAL
- en: \todo{Introduce the concept of *contract*.}
  prefs: []
  type: TYPE_NORMAL
- en: Specifying and Checking Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our Python code, one of the most important "specifications" we need is *types*.
    Python being a "dynamically" typed language means that all data types are determined
    at run time; the code itself does not explicitly state whether a variable is an
    integer, a string, an array, a dictionary – or whatever.
  prefs: []
  type: TYPE_NORMAL
- en: As *writer* of Python code, omitting explicit type declarations may save time
    (and allows for some fun hacks). It is not sure whether a lack of types helps
    in *reading* and *understanding* code for humans. For a *computer* trying to analyze
    code, the lack of explicit types is detrimental. If, say, a constraint solver,
    sees `if x:` and cannot know whether `x` is supposed to be a number or a string,
    this introduces an *ambiguity*. Such ambiguities may multiply over the entire
    analysis in a combinatorial explosion – or in the analysis yielding an overly
    inaccurate result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python 3.6 and later allows data types as *annotations* to function arguments
    (actually, to all variables) and return values. We can, for instance, state that
    `my_sqrt()` is a function that accepts a floating-point value and returns one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By default, such annotations are ignored by the Python interpreter. Therefore,
    one can still call `my_sqrt_typed()` with a string as an argument and get the
    exact same result as above. However, one can make use of special *typechecking*
    modules that would check types – *dynamically* at runtime or *statically* by analyzing
    the code without having to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excursion: Runtime Type Checking'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: (Commented out as `enforce` is not supported by Python 3.9)
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `enforce` package provides a function decorator that automatically
    inserts type-checking code that is executed at runtime. Here is how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, invoking `my_sqrt_with_checked_type_annotations()` raises an exception
    when invoked with a type different from the one declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that this error is not caught by the "untyped" variant, where passing a
    boolean value happily returns $\sqrt{1}$ as result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In Python (and other languages), the boolean values `True` and `False` can be
    implicitly converted to the integers 1 and 0; however, it is hard to think of
    a call to `sqrt()` where this would not be an error.
  prefs: []
  type: TYPE_NORMAL
- en: Static Type Checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type annotations can also be checked *statically* – that is, without even running
    the code. Let us create a simple Python file consisting of the above `my_sqrt_typed()`
    definition and a bad invocation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the contents of our newly created Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Mypy](http://mypy-lang.org) is a type checker for Python programs. As it checks
    types statically, types induce no overhead at runtime; plus, a static check can
    be faster than a lengthy series of tests with runtime type checking enabled. Let
    us see what `mypy` produces on the above file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We see that `mypy` complains about untyped function definitions such as `my_sqrt()`;
    most important, however, it finds that the call to `my_sqrt_with_type_annotations()`
    in the last line has the wrong type.
  prefs: []
  type: TYPE_NORMAL
- en: With `mypy`, we can achieve the same type safety with Python as in statically
    typed languages – provided that we as programmers also produce the necessary type
    annotations. Is there a simple way to obtain these?
  prefs: []
  type: TYPE_NORMAL
- en: Mining Type Specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our first task will be to mine type annotations (as part of the code) from
    *values* we observe at run time. These type annotations would be *mined* from
    actual function executions, *learning* from (normal) runs what the expected argument
    and return types should be. By observing a series of calls such as these, we could
    infer that both `x` and the return value are of type `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we mine types from executions? The answer is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: We *observe* a function during execution
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We track the *types* of its arguments
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We include these types as *annotations* into the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To do so, we can make use of Python's tracing facility we already observed in
    the [chapter on coverage](Coverage.html). With every call to a function, we retrieve
    the arguments, their values, and their types.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To observe argument types at runtime, we define a *tracer function* that tracks
    the execution of `my_sqrt()`, checking its arguments and return values. The `Tracker`
    class is set to trace functions in a `with` block as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As in the [chapter on coverage](Coverage.html), we use the `sys.settrace()`
    function to trace individual functions during execution. We turn on tracking when
    the `with` block starts; at this point, the `__enter__()` method is called. When
    execution of the `with` block ends, `__exit()__` is called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `traceit()` method does nothing yet; this is done in specialized subclasses.
    The `CallTracker` class implements a `traceit()` function that checks for function
    calls and returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`trace_call()` is called when a function is called; it retrieves the function
    name and current arguments, and saves them on a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When the function returns, `trace_return()` is called. We now also have the
    return value. We log the whole call with arguments and return value (if desired)
    and save it in our list of calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`simple_call_string()` is a helper for logging that prints out calls in a user-friendly
    manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`add_call()` saves the calls in a list; each function name has its own list.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using `calls()`, we can retrieve the list of calls, either for a given function,
    or for all functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now put this to use. We turn on logging to track the individual calls
    and their return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, we can retrieve the individual calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Each call is pair (`argument_list`, `return_value`), where `argument_list` is
    a list of pairs (`parameter_name`, `value`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If the function does not return a value, `return_value` is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Getting Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Despite what you may have read or heard, Python actually *is* a typed language.
    It is just that it is *dynamically typed* – types are used and checked only at
    runtime (rather than declared in the code, where they can be *statically checked*
    at compile time). We can thus retrieve types of all values within Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrieve the type of the first argument to `my_sqrt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as the type of the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, we see that (so far), `my_sqrt()` is a function taking (among others)
    integers and floats and returning floats. We could declare `my_sqrt()` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This is a representation we could place in a static type checker, allowing to
    check whether calls to `my_sqrt()` actually pass a number. A dynamic type checker
    could run such checks at runtime. And of course, any [symbolic interpretation](SymbolicFuzzer.html)
    will greatly profit from the additional annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Python does not do anything with such annotations. However, tools
    can access annotations from functions and other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is how run-time checkers access the annotations to check against.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Function Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our plan is to annotate functions automatically, based on the types we have
    seen. To do so, we need a few modules that allow us to convert a function into
    a tree representation (called *abstract syntax trees*, or ASTs) and back; we already
    have seen these in the chapters on [concolic](ConcolicFuzzer.html) and [symbolic](SymbolicFuzzer.html)
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We can get the source of a Python function using `inspect.getsource()`. (Note
    that this does not work for functions defined in other notebooks.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To view these in a visually pleasing form, our function `print_content(s, suffix)`
    formats and highlights the string `s` as if it were a file with ending `suffix`.
    We can thus view (and highlight) the source as if it were a Python file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Parsing this gives us an abstract syntax tree (AST) – a representation of the
    program in tree form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: What does this AST look like? The helper functions `ast.dump()` (textual output)
    and `showast.show_ast()` (graphical output with [showast](https://github.com/hchasestevens/show_ast))
    allow us to inspect the structure of the tree. We see that the function starts
    as a `FunctionDef` with name and arguments, followed by a body, which is a list
    of statements of type `Expr` (the docstring), type `Assign` (assignments), `While`
    (while loop with its own body), and finally `Return`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Too much text for you? This graphical representation may make things simpler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1684pt" height="548pt"
    viewBox="0.00 0.00 1684.00 548.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 544)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="282.62" y="-517.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="82" y="-444.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"my_sqrt"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="152.88"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="261.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge5" class="edge"><title>0--5</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="start" x="346.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge10" class="edge"><title>0--10</title></g>
    <g id="node22" class="node"><title>21</title> <text text-anchor="start" x="909.38"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">While</text></g> <g id="edge21" class="edge"><title>0--21</title></g>
    <g id="node59" class="node"><title>58</title> <text text-anchor="start" x="1316.25"
    y="-445.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge58" class="edge"><title>0--58</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="63.62"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="start" x="182.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge6"
    class="edge"><title>5--6</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="285" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Constant</text></g> <g id="edge9" class="edge"><title>5--9</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="middle" x="113"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge7" class="edge"><title>6--7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="201" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge8" class="edge"><title>6--8</title></g>
    <g id="node12" class="node"><title>11</title> <text text-anchor="start" x="354.5"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge11" class="edge"><title>10--11</title></g>
    <g id="node15" class="node"><title>14</title> <text text-anchor="start" x="458.38"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">BinOp</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="285"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"guess"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="369" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Store</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="426.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>14--15</title></g>
    <g id="node19" class="node"><title>18</title> <text text-anchor="middle" x="515"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Div</text></g>
    <g id="edge18" class="edge"><title>14--18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="start" x="568" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge19"
    class="edge"><title>14--19</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"x"</text></g> <g id="edge16" class="edge"><title>15--16</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="443"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge17" class="edge"><title>15--17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="515" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">2</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="start" x="777.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge22" class="edge"><title>21--22</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="956.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge30" class="edge"><title>21--30</title></g>
    <g id="node38" class="node"><title>37</title> <text text-anchor="start" x="1290.25"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Assign</text></g> <g id="edge37" class="edge"><title>21--37</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="start" x="670.5"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge23" class="edge"><title>22--23</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="769"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">NotEq</text></g>
    <g id="edge26" class="edge"><title>22--26</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="start" x="826.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge27"
    class="edge"><title>22--27</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="601" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge24" class="edge"><title>23--24</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="687"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge25" class="edge"><title>23--25</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="769" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge28" class="edge"><title>27--28</title></g>
    <g id="node30" class="node"><title>29</title> <text text-anchor="middle" x="851"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge29" class="edge"><title>27--29</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="start" x="964.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge31"
    class="edge"><title>30--31</title></g> <g id="node35" class="node"><title>34</title>
    <text text-anchor="start" x="1092.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge34"
    class="edge"><title>30--34</title></g> <g id="node33" class="node"><title>32</title>
    <text text-anchor="middle" x="937" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge32" class="edge"><title>31--32</title></g>
    <g id="node34" class="node"><title>33</title> <text text-anchor="middle" x="1025"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge33" class="edge"><title>31--33</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="middle" x="1109" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge35" class="edge"><title>34--35</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="1191"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge36" class="edge"><title>34--36</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="start" x="1298.5" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge38"
    class="edge"><title>37--38</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="start" x="1411.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge41"
    class="edge"><title>37--41</title></g> <g id="node40" class="node"><title>39</title>
    <text text-anchor="middle" x="1273" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"guess"</text></g> <g id="edge39" class="edge"><title>38--39</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1357"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Store</text></g>
    <g id="edge40" class="edge"><title>38--40</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1411.38" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge42"
    class="edge"><title>41--42</title></g> <g id="node56" class="node"><title>55</title>
    <text text-anchor="middle" x="1506" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge55" class="edge"><title>41--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="start" x="1559"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge56" class="edge"><title>41--56</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1343.5"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node47" class="node"><title>46</title> <text text-anchor="middle" x="1432"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Add</text></g>
    <g id="edge46" class="edge"><title>42--46</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1485.38" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">BinOp</text></g> <g id="edge47"
    class="edge"><title>42--47</title></g> <g id="node45" class="node"><title>44</title>
    <text text-anchor="middle" x="1275" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge44" class="edge"><title>43--44</title></g>
    <g id="node46" class="node"><title>45</title> <text text-anchor="middle" x="1361"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge45" class="edge"><title>43--45</title></g> <g id="node49" class="node"><title>48</title>
    <text text-anchor="start" x="1417.5" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge48"
    class="edge"><title>47--48</title></g> <g id="node52" class="node"><title>51</title>
    <text text-anchor="middle" x="1506" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Div</text></g> <g id="edge51" class="edge"><title>47--51</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="start" x="1561.5"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge52" class="edge"><title>47--52</title></g>
    <g id="node50" class="node"><title>49</title> <text text-anchor="middle" x="1376"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"x"</text></g>
    <g id="edge49" class="edge"><title>48--49</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1448" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge50" class="edge"><title>48--50</title></g>
    <g id="node54" class="node"><title>53</title> <text text-anchor="middle" x="1563"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"approx"</text></g>
    <g id="edge53" class="edge"><title>52--53</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="middle" x="1649" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge54" class="edge"><title>52--54</title></g>
    <g id="node58" class="node"><title>57</title> <text text-anchor="middle" x="1592"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">2</text></g>
    <g id="edge57" class="edge"><title>56--57</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="start" x="1503.5" y="-373.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge59"
    class="edge"><title>58--59</title></g> <g id="node61" class="node"><title>60</title>
    <text text-anchor="middle" x="1520" y="-300.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"approx"</text></g> <g id="edge60" class="edge"><title>59--60</title></g>
    <g id="node62" class="node"><title>61</title> <text text-anchor="middle" x="1606"
    y="-300.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge61" class="edge"><title>59--61</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `ast.unparse()` converts such a tree back into the more familiar
    textual Python code representation. Comments are gone, and there may be more parentheses
    than before, but the result has the same semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Annotating Functions with Given Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now go and transform these trees to add type annotations. We start with
    a helper function `parse_type(name)` which parses a type name into an AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: We now define a helper function that actually adds type annotations to a function
    AST. The `TypeTransformer` class builds on the Python standard library `ast.NodeTransformer`
    infrastructure. It would be called as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'to annotate the arguments of `my_sqrt()`: `x` with `int`, and the return type
    with `float`. The returned AST can then be unparsed, compiled or analyzed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The core of `TypeTransformer` is the method `visit_FunctionDef()`, which is
    called for every function definition in the AST. Its argument `node` is the subtree
    of the function definition to be transformed. Our implementation accesses the
    individual arguments and invokes `annotate_args()` on them; it also sets the return
    type in the `returns` attribute of the node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Each argument gets its own annotation, taken from the types originally passed
    to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this work? Let us annotate the AST from `my_sqrt()` with types for the
    arguments and return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'When we unparse the new AST, we see that the annotations actually are present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can annotate the `hello()` function from above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Annotating Functions with Mined Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now annotate functions with types mined at runtime. We start with a
    simple function `type_string()` that determines the appropriate type of a given
    value (as a string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: For composite structures, `type_string()` does not examine element types; hence,
    the type of `[3]` is simply `list` instead of, say, `list[int]`. For now, `list`
    will do fine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '`type_string()` will be used to infer the types of argument values found at
    runtime, as returned by `CallTracker.calls()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `annotate_types()` takes such a list of calls and annotates each
    function listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'For each function, we get the source and its AST and then get to the actual
    annotation in `annotate_function_ast_with_types()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The function `annotate_function_ast_with_types()` invokes the `TypeTransformer`
    with the calls seen, and for each call, iterate over the arguments, determine
    their types, and annotate the AST with these. The universal type `Any` is used
    when we encounter type conflicts, which we will discuss below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Here is `my_sqrt()` annotated with the types recorded usign the tracker, above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: All-in-one Annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us bring all of this together in a single class `TypeAnnotator` that first
    tracks calls of functions and then allows accessing the AST (and the source code
    form) of the tracked functions annotated with types. The method `typed_functions()`
    returns the annotated functions as a string; `typed_functions_ast()` returns their
    AST.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how to use `TypeAnnotator`. We first track a series of calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'After tracking, we can immediately retrieve an annotated version of the functions
    tracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This also works for multiple and diverse functions. One could go and implement
    an automatic type annotator for Python files based on the types seen during execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: A content as above could now be sent to a type checker, which would detect any
    type inconsistency between callers and callees. Likewise, type annotations such
    as the ones above greatly benefit symbolic code analysis (as in the chapter on
    [symbolic fuzzing](SymbolicFuzzer.html)), as they effectively constrain the set
    of values that arguments and variables can take.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now resolve the role of the magic `Any` type in `annotate_function_ast_with_types()`.
    If we see multiple types for the same argument, we set its type to `Any`. For
    `my_sqrt()`, this makes sense, as its arguments can be integers as well as floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function `sum3()` can be called with floating-point numbers as
    arguments, resulting in the parameters getting a `float` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call `sum3()` with integers, though, the arguments get an `int` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can also call `sum3()` with strings, giving the arguments a `str` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have multiple calls, but with different types, `TypeAnnotator()` will
    assign an `Any` type to both arguments and return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: A type `Any` makes it explicit that an object can, indeed, have any type; it
    will not be type-checked at runtime or statically. To some extent, this defeats
    the power of type checking; but it also preserves some of the type flexibility
    that many Python programmers enjoy. Besides `Any`, the `typing` module supports
    several additional ways to define ambiguous types; we will keep this in mind for
    a later exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying and Checking Invariants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides basic data types. we can check several further properties from arguments.
    We can, for instance, whether an argument can be negative, zero, or positive;
    or that one argument should be smaller than the second; or that the result should
    be the sum of two arguments – properties that cannot be expressed in a (Python)
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Such properties are called *invariants*, as they hold across all invocations
    of a function. Specifically, invariants come as *pre*- and *postconditions* – conditions
    that always hold at the beginning and at the end of a function. (There are also
    *data* and *object* invariants that express always-holding properties over the
    state of data or objects, but we do not consider these in this book.)
  prefs: []
  type: TYPE_NORMAL
- en: Annotating Functions with Pre- and Postconditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The classical means to specify pre- and postconditions is via *assertions*,
    which we have introduced in the [chapter on testing](Intro_Testing.html). A precondition
    checks whether the arguments to a function satisfy the expected properties; a
    postcondition does the same for the result. We can express and check both using
    assertions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'A nicer way, however, is to syntactically separate invariants from the function
    at hand. Using appropriate decorators, we could specify pre- and postconditions
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: The decorators `@precondition` and `@postcondition` would run the given functions
    (specified as anonymous `lambda` functions) before and after the decorated function,
    respectively. If the functions return `False`, the condition is violated. `@precondition`
    gets the function arguments as arguments; `@postcondition` additionally gets the
    return value as first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that implementing such decorators is not hard at all. Our implementation
    builds on a [code snippet from StackOverflow](https://stackoverflow.com/questions/12151182/python-precondition-postcondition-for-member-function-how):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can now start decorating `my_sqrt()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'This catches arguments violating the precondition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, we can provide a postcondition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have a buggy implementation of $\sqrt{x}$, this gets caught quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: While checking pre- and postconditions is a great way to catch errors, specifying
    them can be cumbersome. Let us try to see whether we can (again) *mine* some of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Mining Invariants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To *mine* invariants, we can use the same tracking functionality as before;
    instead of saving values for individual variables, though, we now check whether
    the values satisfy specific *properties* or not. For instance, if all values of
    `x` seen satisfy the condition `x > 0`, then we make `x > 0` an invariant of the
    function. If we see positive, zero, and negative values of `x`, though, then there
    is no property of `x` left to talk about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea is thus:'
  prefs: []
  type: TYPE_NORMAL
- en: Check all variable values observed against a set of predefined properties; and
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep only those properties that hold for all runs observed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What precisely do we mean by properties? Here is a small collection of value
    properties that would frequently be used in invariants. All these properties would
    be evaluated with the *metavariables* `X`, `Y`, and `Z` (actually, any upper-case
    identifier) being replaced with the names of function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: When `my_sqrt(x)` is called as, say `my_sqrt(5.0)`, we see that `x = 5.0` holds.
    The above properties would then all be checked for `x`. Only the properties `X
    > 0`, `X >= 0`, and `X != 0` hold for the call seen; and hence `x > 0`, `x >=
    0`, and `x != 0` would make potential preconditions for `my_sqrt(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check for many more properties such as relations between two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Types also can be checked using properties. For any function parameter `X`,
    only one of these will hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check for arithmetic properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s relations over three values, a Python special:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can also check for list or string properties. Again, this is just
    a tiny selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Meta-Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us first introduce a few *helper functions* before we can get to the actual
    mining. `metavars()` extracts the set of meta-variables (`X`, `Y`, `Z`, etc.)
    from a property. To this end, we parse the property as a Python expression and
    then visit the identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To produce a property as invariant, we need to be able to *instantiate* it with
    variable names. The instantiation of `X > 0` with `X` being instantiated to `a`,
    for instance, gets us `a > 0`. To this end, the function `instantiate_prop()`
    takes a property and a collection of variable names and instantiates the meta-variables
    left-to-right with the corresponding variables names in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating Properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To actually *evaluate* properties, we do not need to instantiate them. Instead,
    we simply convert them into a boolean function, using `lambda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Checking Invariants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To extract invariants from an execution, we need to check them on all possible
    instantiations of arguments. If the function to be checked has two arguments `a`
    and `b`, we instantiate the property `X < Y` both as `a < b` and `b < a` and check
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get all combinations, we use the Python `permutations()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The function `true_property_instantiations()` takes a property and a list of
    tuples (`var_name`, `value`). It then produces all instantiations of the property
    with the given values and returns those that evaluate to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example. If `x == -1` and `y == 1`, the property `X < Y` holds for
    `x < y`, but not for `y < x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'The instantiation retrieves the short form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, with values for `x` and `y` as above, the property `X < 0` only holds
    for `x`, but not for `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Invariants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now run the above invariant extraction on function arguments and return
    values as observed during a function execution. To this end, we extend the `CallTracker`
    class into an `InvariantTracker` class, which automatically computes invariants
    for all functions and all calls observed during tracking.
  prefs: []
  type: TYPE_NORMAL
- en: By default, an `InvariantTracker` uses the properties as defined above; however,
    one can specify alternate sets of properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The key method of the `InvariantTracker` is the `invariants()` method. This
    iterates over the calls observed and checks which properties hold. Only the intersection
    of properties – that is, the set of properties that hold for all calls – is preserved,
    and eventually returned. The special variable `return_value` is set to hold the
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Here's an example of how to use `invariants()`. We run the tracker on a small
    set of calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: The `invariants()` method produces a set of properties that hold for the observed
    runs, together with their instantiations over function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, the actual instantiations are easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: We see that the both `x` and the return value have a `float` type. We also see
    that both are always greater than zero. These are properties that may make useful
    pre- and postconditions, notably for symbolic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s also an invariant which does *not* universally hold, namely
    `return_value <= x`, as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, 0.1 > 0.01 holds. This is a case of us not learning from sufficiently
    diverse inputs. As soon as we have a call including `x = 0.1`, though, the invariant
    `return_value <= x` is eliminated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss later how to ensure sufficient diversity in inputs. (Hint:
    This involves test generation.)'
  prefs: []
  type: TYPE_NORMAL
- en: Let us try out our invariant tracker on `sum3()`. We see that all types are
    well-defined; the properties that all arguments are non-zero, however, is specific
    to the calls observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: If we invoke `sum3()` with strings instead, we get different invariants. Notably,
    we obtain the postcondition that the return value starts with the value of `a`
    – a universal postcondition if strings are used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: If we invoke `sum3()` with both strings and numbers (and zeros, too), there
    are no properties left that would hold across all calls. That's the price of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Converting Mined Invariants to Annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with types, above, we would like to have some functionality where we can
    add the mined invariants as annotations to existing functions. To this end, we
    introduce the `InvariantAnnotator` class, extending `InvariantTracker`.
  prefs: []
  type: TYPE_NORMAL
- en: We start with a helper method. `params()` returns a comma-separated list of
    parameter names as observed during calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the actual annotation. `preconditions()` returns the preconditions
    from the mined invariants (i.e., those properties that do not depend on the return
    value) as a string with annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '`postconditions()` does the same for postconditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can take a function and add both pre- and postconditions as
    annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes `function_with_invariants()` in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Quite a lot of invariants, is it? Further below (and in the exercises), we will
    discuss on how to focus on the most relevant properties.
  prefs: []
  type: TYPE_NORMAL
- en: Some Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s another example. `list_length()` recursively computes the length of
    a Python function. Let us see whether we can mine its invariants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Almost all these properties (except for the very first) are relevant. Of course,
    the reason the invariants are so neat is that the return value is equal to `len(L)`
    is that `X == len(Y)` is part of the list of properties to be checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example is a very simple function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: The invariants all capture the relationship between `a`, `b`, and the return
    value as `return_value == a + b` in all its variations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: If we have a function without return value, the return value is `None`, and
    we can only mine preconditions. (Well, we get a "postcondition" that the return
    value is non-zero, which holds for `None`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Checking Specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function with invariants, as above, can be fed into the Python interpreter,
    such that all pre- and postconditions are checked. We create a function `my_sqrt_annotated()`
    which includes all the invariants mined above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'The "annotated" version checks against invalid arguments – or more precisely,
    against arguments with properties that have not been observed yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: 'This is in contrast to the original version, which just hangs on negative values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: If we make changes to the function definition such that the properties of the
    return value change, such *regressions* are caught as violations of the postconditions.
    Let us illustrate this by simply inverting the result, and return $-2$ as square
    root of 4.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'Technically speaking, $-2$ *is* a square root of 4, since $(-2)^2 = 4$ holds.
    Yet, such a change may be unexpected by callers of `my_sqrt()`, and hence, this
    would be caught with the first call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: We see how pre- and postconditions, as well as types, can serve as *oracles*
    during testing. In particular, once we have mined them for a set of functions,
    we can check them again and again with test generators – especially after code
    changes. The more checks we have, and the more specific they are, the more likely
    it is we can detect unwanted effects of changes.
  prefs: []
  type: TYPE_NORMAL
- en: Mining Specifications from Generated Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mined specifications can only be as good as the executions they were mined
    from. If we only see a single call to, say, `sum2()` as defined above, we will
    be faced with several mined pre- and postconditions that *overspecialize* towards
    the values seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: The mined precondition `a == b`, for instance, only holds for the single call
    observed; the same holds for the mined postcondition `return_value == a * b`.
    Yet, `sum2()` can obviously be successfully called with other values that do not
    satisfy these conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get out of this trap, we have to *learn from more and more diverse runs*.
    If we have a few more calls of `sum2()`, we see how the set of invariants quickly
    gets smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: But where to we get such diverse runs from? This is the job of generating software
    tests. A simple grammar for calls of `sum2()` will easily resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: But then, writing tests (or a test driver) just to derive a set of pre- and
    postconditions may possibly be too much effort – in particular, since tests can
    easily be derived from given pre- and postconditions in the first place. Hence,
    it would be wiser to first specify invariants and then let test generators or
    program provers do the job.
  prefs: []
  type: TYPE_NORMAL
- en: Also, an API grammar, such as above, will have to be set up such that it actually
    respects preconditions – in our case, we invoke `sqrt()` with positive numbers
    only, already assuming its precondition. In some way, one thus needs a specification
    (a model, a grammar) to mine another specification – a chicken-and-egg problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one way out of this problem: If one can automatically generate
    tests at the system level, then one has an *infinite source of executions* to
    learn invariants from. In each of these executions, all functions would be called
    with values that satisfy the (implicit) precondition, allowing us to mine invariants
    for these functions. This holds, because at the system level, invalid inputs must
    be rejected by the system in the first place. The meaningful precondition at the
    system level, ensuring that only valid inputs get through, thus gets broken down
    into a multitude of meaningful preconditions (and subsequent postconditions) at
    the function level.'
  prefs: []
  type: TYPE_NORMAL
- en: The big requirement for this, though, is that one needs good test generators
    at the system level. In [the next part](05_Domain-Specific_Fuzzing.ipynb), we
    will discuss how to automatically generate tests for a variety of domains, from
    configuration to graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type annotations and explicit invariants allow for *checking* arguments and
    results for expected data types and other properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can automatically *mine* data types and invariants by observing arguments
    and results at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of mined invariants depends on the diversity of values observed
    during executions; this variety can be increased by generating tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter concludes the [part on semantic fuzzing techniques](04_Semantical_Fuzzing.html).
    In the next part, we will explore [domain-specific fuzzing techniques](05_Domain-Specific_Fuzzing.ipynb)
    from configurations and APIs to graphical user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [DAIKON dynamic invariant detector](https://plse.cs.washington.edu/daikon/)
    can be considered the mother of function specification miners. Continuously maintained
    and extended for more than 20 years, it mines likely invariants in the style of
    this chapter for a variety of languages, including C, C++, C#, Eiffel, F#, Java,
    Perl, and Visual Basic. On top of the functionality discussed above, it holds
    a rich catalog of patterns for likely invariants, supports data invariants, can
    eliminate invariants that are implied by others, and determines statistical confidence
    to disregard unlikely invariants. The corresponding paper [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    is one of the seminal and most-cited papers of Software Engineering. A multitude
    of works have been published based on DAIKON and detecting invariants; see this
    [curated list](http://plse.cs.washington.edu/daikon/pubs/) for details.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction between test generators and invariant detection is already discussed
    in [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)] (incidentally also
    using grammars). The Eclat tool [[Pacheco *et al*, 2005](https://doi.org/10.1007/11531142_22)]
    is a model example of tight interaction between a unit-level test generator and
    DAIKON-style invariant mining, where the mined invariants are used to produce
    oracles and to systematically guide the test generator towards fault-revealing
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Mining specifications is not restricted to pre- and postconditions. The paper
    "Mining Specifications" [[Ammons *et al*, 2002](https://doi.org/10.1145/503272.503275)]
    is another classic in the field, learning state protocols from executions. Grammar
    mining, as described in [our chapter with the same name](GrammarMiner.html) can
    also be seen as a specification mining approach, this time learning specifications
    of input formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it comes to adding type annotations to existing code, the blog post ["The
    state of type hints in Python"](https://www.bernat.tech/the-state-of-type-hints-in-python/)
    gives a great overview on how Python type hints can be used and checked. To add
    type annotations, there are two important tools available that also implement
    our above approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[MonkeyType](https://instagram-engineering.com/let-your-code-type-hint-itself-introducing-open-source-monkeytype-a855c7284881)
    implements the above approach of tracing executions and annotating Python 3 arguments,
    returns, and variables with type hints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyAnnotate](https://github.com/dropbox/pyannotate) does a similar job, focusing
    on code in Python 2\. It does not produce Python 3-style annotations, but instead
    produces annotations as comments that can be processed by static type checkers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools have been created by engineers at Facebook and Dropbox, respectively,
    assisting them in checking millions of lines of code for type issues.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our code for mining types and invariants is in no way complete. There are dozens
    of ways to extend our implementations, some of which we discuss in exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Union Types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Python `typing` module allows expressing that an argument can have multiple
    types. For `my_sqrt(x)`, this allows expressing that `x` can be an `int` or a
    `float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Extend the `TypeAnnotator` such that it supports union types for arguments and
    return values. Use `Optional[X]` as a shorthand for `Union[X, None]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Types for Local Variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Python, one cannot only annotate arguments with types, but actually also
    local and global variables – for instance, `approx` and `guess` in our `my_sqrt()`
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Extend the `TypeAnnotator` such that it also annotates local variables with
    types. Search the function AST for assignments, determine the type of the assigned
    value, and make it an annotation on the left-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Verbose Invariant Checkers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our implementation of invariant checkers does not make it clear for the user
    which pre-/postcondition failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: 'The following implementation adds an optional `doc` keyword argument which
    is printed if the invariant is violated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Extend `InvariantAnnotator` such that it includes the conditions in the generated
    pre- and postconditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Save Initial Values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the value of an argument changes during function execution, this can easily
    confuse our implementation: The values are tracked at the beginning of the function,
    but checked only when it returns. Extend the `InvariantAnnotator` and the infrastructure
    it uses such that'
  prefs: []
  type: TYPE_NORMAL
- en: it saves argument values both at the beginning and at the end of a function
    invocation;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: postconditions can be expressed over both *initial* values of arguments as well
    as the *final* values of arguments;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the mined postconditions refer to both these values as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Implications'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several mined invariant are actually *implied* by others: If `x > 0` holds,
    then this implies `x >= 0` and `x != 0`. Extend the `InvariantAnnotator` such
    that implications between properties are explicitly encoded, and such that implied
    properties are no longer listed as invariants. See [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    for ideas.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Local Variables'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Postconditions may also refer to the values of local variables. Consider extending
    `InvariantAnnotator` and its infrastructure such that the values of local variables
    at the end of the execution are also recorded and made part of the invariant inference
    mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Exploring Invariant Alternatives'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After mining a first set of invariants, have a [concolic fuzzer](ConcolicFuzzer.html)
    generate tests that systematically attempt to invalidate pre- and postconditions.
    How far can you generalize?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: Grammar-Generated Properties'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The larger the set of properties to be checked, the more potential invariants
    can be discovered. Create a *grammar* that systematically produces a large set
    of properties. See [[Ernst *et al*, 2001](https://doi.org/10.1109/32.908957)]
    for possible patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Embedding Invariants as Assertions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than producing invariants as annotations for pre- and postconditions,
    insert them as `assert` statements into the function code, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Such a formulation may make it easier for test generators and symbolic analysis
    to access and interpret pre- and postconditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/DynamicInvariants.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/DynamicInvariants.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Mining Function Specifications](https://www.fuzzingbook.org/html/DynamicInvariants.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/DynamicInvariants.html](https://www.fuzzingbook.org/html/DynamicInvariants.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
