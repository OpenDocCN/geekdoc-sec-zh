- en: Fuzzing APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/APIFuzzer.html](http://www.fuzzingbook.org/html/APIFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So far, we have always generated *system input*, i.e. data that the program
    as a whole obtains via its input channels. However, we can also generate inputs
    that go directly into individual functions, gaining flexibility and speed in the
    process. In this chapter, we explore the use of grammars to synthesize code for
    function calls, which allows you to generate *program code that very efficiently
    invokes functions directly.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You have to know how grammar fuzzing work, e.g. from the [chapter on grammars](Grammars.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make use of *generator functions*, as discussed in the [chapter on fuzzing
    with generators](GeneratorGrammarFuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make use of probabilities, as discussed in the [chapter on fuzzing with probabilities](ProbabilisticGrammarFuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides *grammar constructors* that are useful for generating
    *function calls*.
  prefs: []
  type: TYPE_NORMAL
- en: The grammars are [probabilistic](ProbabilisticGrammarFuzzer.html) and make use
    of [generators](GeneratorGrammarFuzzer.html), so use `ProbabilisticGeneratorGrammarFuzzer`
    as a producer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`INT_GRAMMAR`, `FLOAT_GRAMMAR`, `ASCII_STRING_GRAMMAR` produce integers, floats,
    and strings, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`int_grammar_with_range(start, end)` produces an integer grammar with values
    `N` such that `start <= N <= end`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`float_grammar_with_range(start, end)` produces a floating-number grammar with
    values `N` such that `start <= N <= end`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'All such values can be immediately used for testing function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These grammars can also be composed to form more complex grammars. `list_grammar(object_grammar)`
    returns a grammar that produces lists of objects as defined by `object_grammar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In a similar vein, we can construct arbitrary further data types for testing
    individual functions programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us start with our first problem: How do we fuzz a given function? For an
    interpreted language like Python, this is pretty straight-forward. All we need
    to do is to generate *calls* to the function(s) we want to test. This is something
    we can easily do with a grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the `urlparse()` function from the Python library. `urlparse()`
    takes a URL and decomposes it into its individual components.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You see how the individual elements of the URL – the *scheme* (`"http"`), the
    *network location* (`"www.fuzzingbook.com"`), or the path (`"//html/APIFuzzer.html"`)
    are all properly identified. Other elements (like `params`, `query`, or `fragment`)
    are empty, because they were not part of our input.
  prefs: []
  type: TYPE_NORMAL
- en: To test `urlparse()`, we'd want to feed it a large set of different URLs. We
    can obtain these from the URL grammar we had defined in the ["Grammars"](Grammars.html)
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can easily test any Python function – by setting up a scaffold
    that runs it. How would we proceed, though, if we wanted to have a test that can
    be re-run again and again, without having to generate new calls every time?
  prefs: []
  type: TYPE_NORMAL
- en: Synthesizing Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The "scaffolding" method, as sketched above, has an important downside: It
    couples test generation and test execution into a single unit, disallowing running
    both at different times, or for different languages. To decouple the two, we take
    another approach: Rather than generating inputs and immediately feeding this input
    into a function, we *synthesize code* instead that invokes functions with a given
    input.'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if we generate the string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'we can execute this string as a whole (and thus run the test) at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To systematically generate such calls, we can again use a grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This grammar creates calls in the form `urlparse(<url>)`, where `<url>` comes
    from the "imported" URL grammar. The idea is to create many of these calls and
    to feed them into the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this grammar for fuzzing and synthesizing calls to `urlparse)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as above, we can immediately execute these calls. To better see what is
    happening, we define a small helper function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If `urlparse()` were a C function, for instance, we could embed its call into
    some (also generated) C function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Synthesizing Oracles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our `urlparse()` example, both the Python as well as the C variant only check
    for *generic* errors in `urlparse()`; that is, they only detect fatal errors and
    exceptions. For a full test, we need to set up a specific *oracle* as well that
    checks whether the result is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Our plan is to check whether specific parts of the URL reappear in the result
    – that is, if the scheme is `http:`, then the `ParseResult` returned should also
    contain a `http:` scheme. As discussed in the [chapter on fuzzing with generators](GeneratorGrammarFuzzer.html),
    equalities of strings such as `http:` across two symbols cannot be expressed in
    a context-free grammar. We can, however, use a *generator function* (also introduced
    in the [chapter on fuzzing with generators](GeneratorGrammarFuzzer.html)) to automatically
    enforce such equalities.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example. Invoking `geturl()` on a `urlparse()` result should return
    the URL as originally passed to `urlparse()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we can also check individual components of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of generator functions may feel a bit cumbersome. Indeed, if we uniquely
    stick to Python, we could also create a *unit test* that directly invokes the
    fuzzer to generate individual parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using such a unit test makes it easier to express oracles. However, we lose
    the ability to systematically cover individual URL elements and alternatives as
    with [`GrammarCoverageFuzzer`](GrammarCoverageFuzzer.html) as well as the ability
    to guide generation towards specific elements as with [`ProbabilisticGrammarFuzzer`](ProbabilisticGrammarFuzzer.html).
    Furthermore, a grammar allows us to generate tests for arbitrary programming languages
    and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Synthesizing Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For `urlparse()`, we have used a very specific grammar for creating a very specific
    argument. Many functions take basic data types as (some) arguments, though; we
    therefore define grammars that generate precisely those arguments. Even better,
    we can define functions that *generate* grammars tailored towards our specific
    needs, returning values in a particular range, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We introduce a simple grammar to produce integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need integers in a specific range, we can add a generator function that
    does right that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Floats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The grammar for floating-point values closely resembles the integer grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we introduce a grammar for producing strings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Synthesizing Composite Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From basic data, as discussed above, we can also produce *composite data* in
    data structures such as sets or lists. We illustrate such generation on lists.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Our list generator takes a grammar that produces objects; it then instantiates
    a list grammar with the objects from these grammars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Generators for dictionaries, sets, etc. can be defined in a similar fashion.
    By plugging together grammar generators, we can produce data structures with arbitrary
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fuzz individual functions, one can easily set up grammars that produce function
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing at the API level can be much faster than fuzzing at the system level,
    but brings the risk of false alarms by violating implicit preconditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter was all about manually writing test and controlling which data
    gets generated. [In the next chapter](Carver.html), we will introduce a much higher
    level of automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Carving* automatically records function calls and arguments from program executions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can turn these into *grammars*, allowing to test these functions with various
    combinations of recorded values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these techniques, we automatically obtain grammars that already invoke
    functions in application contexts, making our work of specifying them much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of using generator functions to generate input structures was first
    explored in QuickCheck [[Claessen *et al*, 2000](https://doi.org/10.1145/351240.351266)].
    A very nice implementation for Python is the [hypothesis package](https://hypothesis.readthedocs.io/en/latest/)
    which allows writing and combining data structure generators for testing APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The exercises for this chapter combine the above techniques with fuzzing techniques
    introduced earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Deep Arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the example generating oracles for `urlparse()`, important elements such
    as `authority` or `port` are not checked. Enrich `URLPARSE_ORACLE_GRAMMAR` with
    post-expansion functions that store the generated elements in a symbol table,
    such that they can be accessed when generating the assertions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/APIFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Covering Argument Combinations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the chapter on [configuration testing](ConfigurationFuzzer.html), we also
    discussed *combinatorial testing* – that is, systematic coverage of *sets* of
    configuration elements. Implement a scheme that by changing the grammar, allows
    all *pairs* of argument values to be covered.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/APIFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Mutating Arguments'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To widen the range of arguments to be used during testing, apply the *mutation
    schemes* introduced in [mutation fuzzing](MutationFuzzer.html) – for instance,
    flip individual bytes or delete characters from strings. Apply this either during
    grammar inference or as a separate step when invoking functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/APIFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:05+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/APIFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing APIs](https://www.fuzzingbook.org/html/APIFuzzer.html)". In
    Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler,
    "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/APIFuzzer.html](https://www.fuzzingbook.org/html/APIFuzzer.html).
    Retrieved 2023-11-11 18:18:05+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
