["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('GGb3e5p0HC8') \n```", "```py\n>>> from [fuzzingbook.GrammarCoverageFuzzer](GrammarCoverageFuzzer.html) import <identifier> \n```", "```py\n>>> from [Grammars](Grammars.html) import EXPR_GRAMMAR\n>>> expr_fuzzer = GrammarCoverageFuzzer(EXPR_GRAMMAR)\n>>> expr_fuzzer.fuzz()\n'-(2 + 3) * 4.5 / 6 - 2.0 / +8 + 7 + 3' \n```", "```py\n>>> expr_fuzzer.expansion_coverage()\n{'<digit> -> 0',\n '<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9',\n '<expr> -> <term>',\n '<expr> -> <term> + <expr>',\n '<expr> -> <term> - <expr>',\n '<factor> -> (<expr>)',\n '<factor> -> +<factor>',\n '<factor> -> -<factor>',\n '<factor> -> <integer>',\n '<factor> -> <integer>.<integer>',\n '<integer> -> <digit>',\n '<integer> -> <digit><integer>',\n '<start> -> <expr>',\n '<term> -> <factor>',\n '<term> -> <factor> * <term>',\n '<term> -> <factor> / <term>'} \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import quiz \n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Dict, List, Set, Union, Optional \n```", "```py\nfrom [Grammars](Grammars.html) import EXPR_GRAMMAR, CGI_GRAMMAR, URL_GRAMMAR, START_SYMBOL\nfrom [Grammars](Grammars.html) import is_valid_grammar, extend_grammar, Grammar \n```", "```py\nEXPR_GRAMMAR[\"<factor>\"] \n```", "```py\n['+<factor>', '-<factor>', '(<expr>)', '<integer>.<integer>', '<integer>']\n\n```", "```py\nfrom [Grammars](Grammars.html) import Grammar, Expansion\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer, all_terminals, nonterminals, \\\n    display_tree, DerivationTree \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nclass TrackingGrammarCoverageFuzzer(GrammarFuzzer):\n  \"\"\"Track grammar coverage during production\"\"\"\n\n    def __init__(self, *args, **kwargs) -> None:\n        # invoke superclass __init__(), passing all arguments\n        super().__init__(*args, **kwargs)\n        self.reset_coverage() \n```", "```py\nclass TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):\n    def expansion_coverage(self) -> Set[str]:\n  \"\"\"Return the set of covered expansions as strings SYMBOL -> EXPANSION\"\"\"\n        return self.covered_expansions\n\n    def reset_coverage(self) -> None:\n  \"\"\"Clear coverage info tracked so far\"\"\"\n        self.covered_expansions: Set[str] = set() \n```", "```py\ndef expansion_key(symbol: str, \n                  expansion: Union[Expansion,\n                                   DerivationTree, \n                                   List[DerivationTree]]) -> str:\n  \"\"\"Convert (symbol, `expansion`) into a key \"SYMBOL -> EXPRESSION\". \n `expansion` can be an expansion string, a derivation tree,\n or a list of derivation trees.\"\"\"\n\n    if isinstance(expansion, tuple):\n        # Expansion or single derivation tree\n        expansion, _ = expansion\n\n    if not isinstance(expansion, str):\n        # Derivation tree\n        children = expansion\n        expansion = all_terminals((symbol, children))\n\n    assert isinstance(expansion, str)\n\n    return symbol + \" -> \" + expansion \n```", "```py\nexpansion_key(START_SYMBOL, EXPR_GRAMMAR[START_SYMBOL][0]) \n```", "```py\n'<start> -> <expr>'\n\n```", "```py\nchildren: List[DerivationTree] = [(\"<expr>\", None), (\" + \", []), (\"<term>\", None)]\nexpansion_key(\"<expr>\", children) \n```", "```py\n'<expr> -> <expr> + <term>'\n\n```", "```py\nclass TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):\n    def _max_expansion_coverage(self, symbol: str, \n                                max_depth: Union[int, float]) -> Set[str]:\n        if max_depth <= 0:\n            return set()\n\n        self._symbols_seen.add(symbol)\n\n        expansions = set()\n        for expansion in self.grammar[symbol]:\n            expansions.add(expansion_key(symbol, expansion))\n            for nonterminal in nonterminals(expansion):\n                if nonterminal not in self._symbols_seen:\n                    expansions |= self._max_expansion_coverage(\n                        nonterminal, max_depth - 1)\n\n        return expansions\n\n    def max_expansion_coverage(self, symbol: Optional[str] = None,\n                               max_depth: Union[int, float] = float('inf')) \\\n            -> Set[str]:\n  \"\"\"Return set of all expansions in a grammar \n starting with `symbol` (default: start symbol).\n If `max_depth` is given, expand only to that depth.\"\"\"\n        if symbol is None:\n            symbol = self.start_symbol\n\n        self._symbols_seen: Set[str] = set()\n        cov = self._max_expansion_coverage(symbol, max_depth)\n\n        if symbol == START_SYMBOL:\n            assert len(self._symbols_seen) == len(self.grammar)\n\n        return cov \n```", "```py\nexpr_fuzzer = TrackingGrammarCoverageFuzzer(EXPR_GRAMMAR)\nexpr_fuzzer.max_expansion_coverage() \n```", "```py\n{'<digit> -> 0',\n '<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9',\n '<expr> -> <term>',\n '<expr> -> <term> + <expr>',\n '<expr> -> <term> - <expr>',\n '<factor> -> (<expr>)',\n '<factor> -> +<factor>',\n '<factor> -> -<factor>',\n '<factor> -> <integer>',\n '<factor> -> <integer>.<integer>',\n '<integer> -> <digit>',\n '<integer> -> <digit><integer>',\n '<start> -> <expr>',\n '<term> -> <factor>',\n '<term> -> <factor> * <term>',\n '<term> -> <factor> / <term>'}\n\n```", "```py\nclass TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):\n    def add_coverage(self, symbol: str,\n                     new_child: Union[Expansion, List[DerivationTree]]) -> None:\n        key = expansion_key(symbol, new_child)\n\n        if self.log and key not in self.covered_expansions:\n            print(\"Now covered:\", key)\n        self.covered_expansions.add(key)\n\n    def choose_node_expansion(self, node: DerivationTree,\n                              children_alternatives: \n                              List[List[DerivationTree]]) -> int:\n        (symbol, children) = node\n        index = super().choose_node_expansion(node, children_alternatives)\n        self.add_coverage(symbol, children_alternatives[index])\n        return index \n```", "```py\nclass TrackingGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):\n    def missing_expansion_coverage(self) -> Set[str]:\n  \"\"\"Return expansions not covered yet\"\"\"\n        return self.max_expansion_coverage() - self.expansion_coverage() \n```", "```py\ndigit_fuzzer = TrackingGrammarCoverageFuzzer(\n    EXPR_GRAMMAR, start_symbol=\"<digit>\", log=True)\ndigit_fuzzer.fuzz() \n```", "```py\nTree: <digit>\nExpanding <digit> randomly\nNow covered: <digit> -> 9\nTree: 9\n'9'\n\n```", "```py\n'9'\n\n```", "```py\ndigit_fuzzer.fuzz() \n```", "```py\nTree: <digit>\nExpanding <digit> randomly\nNow covered: <digit> -> 0\nTree: 0\n'0'\n\n```", "```py\n'0'\n\n```", "```py\ndigit_fuzzer.fuzz() \n```", "```py\nTree: <digit>\nExpanding <digit> randomly\nNow covered: <digit> -> 5\nTree: 5\n'5'\n\n```", "```py\n'5'\n\n```", "```py\ndigit_fuzzer.expansion_coverage() \n```", "```py\n{'<digit> -> 0', '<digit> -> 5', '<digit> -> 9'}\n\n```", "```py\ndigit_fuzzer.max_expansion_coverage() \n```", "```py\n{'<digit> -> 0',\n '<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9'}\n\n```", "```py\ndigit_fuzzer.missing_expansion_coverage() \n```", "```py\n{'<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8'}\n\n```", "```py\ndef average_length_until_full_coverage(fuzzer: TrackingGrammarCoverageFuzzer) -> float:\n    trials = 50\n\n    sum = 0\n    for trial in range(trials):\n        # print(trial, end=\" \")\n        fuzzer.reset_coverage()\n        while len(fuzzer.missing_expansion_coverage()) > 0:\n            s = fuzzer.fuzz()\n            sum += len(s)\n\n    return sum / trials \n```", "```py\ndigit_fuzzer.log = False\naverage_length_until_full_coverage(digit_fuzzer) \n```", "```py\n28.4\n\n```", "```py\nexpr_fuzzer = TrackingGrammarCoverageFuzzer(EXPR_GRAMMAR)\naverage_length_until_full_coverage(expr_fuzzer) \n```", "```py\n138.12\n\n```", "```py\nclass SimpleGrammarCoverageFuzzer(TrackingGrammarCoverageFuzzer):\n  \"\"\"When choosing expansions, prefer expansions not covered.\"\"\"\n\n    def choose_node_expansion(self,\n                              node: DerivationTree,\n                              children_alternatives: List[List[DerivationTree]]) -> int:\n  \"\"\"Return index of expansion in `children_alternatives` to be selected.\n Picks uncovered expansions, if any.\"\"\"\n\n        # Prefer uncovered expansions\n        (symbol, children) = node\n        uncovered_children = [c for (i, c) in enumerate(children_alternatives)\n                              if expansion_key(symbol, c)\n                              not in self.covered_expansions]\n        index_map = [i for (i, c) in enumerate(children_alternatives)\n                     if c in uncovered_children]\n\n        if len(uncovered_children) == 0:\n            # All expansions covered - use superclass method\n            return self.choose_covered_node_expansion(node, children_alternatives)\n\n        # Select from uncovered nodes\n        index = self.choose_uncovered_node_expansion(node, uncovered_children)\n\n        return index_map[index] \n```", "```py\nclass SimpleGrammarCoverageFuzzer(SimpleGrammarCoverageFuzzer):\n    def choose_uncovered_node_expansion(self,\n                                        node: DerivationTree,\n                                        children_alternatives: List[List[DerivationTree]]) \\\n            -> int:\n  \"\"\"Return index of expansion in _uncovered_ `children_alternatives`\n to be selected.\n To be overloaded in subclasses.\"\"\"\n        return TrackingGrammarCoverageFuzzer.choose_node_expansion(\n            self, node, children_alternatives)\n\n    def choose_covered_node_expansion(self,\n                                      node: DerivationTree,\n                                      children_alternatives: List[List[DerivationTree]]) \\\n            -> int:\n  \"\"\"Return index of expansion in _covered_ `children_alternatives`\n to be selected.\n To be overloaded in subclasses.\"\"\"\n        return TrackingGrammarCoverageFuzzer.choose_node_expansion(\n            self, node, children_alternatives) \n```", "```py\nf = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR, start_symbol=\"<digit>\")\nf.fuzz() \n```", "```py\n'5'\n\n```", "```py\nf.fuzz() \n```", "```py\n'2'\n\n```", "```py\nf.fuzz() \n```", "```py\n'1'\n\n```", "```py\nf.expansion_coverage() \n```", "```py\n{'<digit> -> 1', '<digit> -> 2', '<digit> -> 5'}\n\n```", "```py\nfor i in range(7):\n    print(f.fuzz(), end=\" \") \n```", "```py\n0 9 7 4 8 3 6 \n\n```", "```py\nf.missing_expansion_coverage() \n```", "```py\nset()\n\n```", "```py\nf = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR)\nfor i in range(10):\n    print(f.fuzz()) \n```", "```py\n+(0.31 / (5) / 9 + 4 * 6 / 3 - 8 - 7) * -2\n+++2 / 87360\n((4) * 0 - 1) / -9.6 + 7 / 6 + 1 * 8 + 7 * 8\n++++26 / -64.45\n(8 / 1 / 6 + 9 + 7 + 8) * 1.1 / 0 * 1\n7.7\n++(3.5 / 3) - (-4 + 3) / (8 / 0) / -4 * 2 / 1\n+(90 / --(28 * 8 / 5 + 5 / (5 / 8))) - +9.36 / 2.5 * (5 * (7 * 6 * 5) / 8)\n9.11 / 7.28\n1 / (9 - 5 * 6) / 6 / 7 / 7 + 1 + 1 - 7 * -3\n\n```", "```py\nf.missing_expansion_coverage() \n```", "```py\nset()\n\n```", "```py\naverage_length_until_full_coverage(SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR)) \n```", "```py\n52.28\n\n```", "```py\nCGI_GRAMMAR \n```", "```py\n{'<start>': ['<string>'],\n '<string>': ['<letter>', '<letter><string>'],\n '<letter>': ['<plus>', '<percent>', '<other>'],\n '<plus>': ['+'],\n '<percent>': ['%<hexdigit><hexdigit>'],\n '<hexdigit>': ['0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f'],\n '<other>': ['0', '1', '2', '3', '4', '5', 'a', 'b', 'c', 'd', 'e', '-', '_']}\n\n```", "```py\nf = SimpleGrammarCoverageFuzzer(CGI_GRAMMAR)\nfor i in range(10):\n    print(f.fuzz()) \n```", "```py\nc\n+%a6++\n+-\n+\n++\n%18%b7\n+e\n_\nd2+%e3\n%d0\n\n```", "```py\nf.missing_expansion_coverage() \n```", "```py\n{'<hexdigit> -> 2',\n '<hexdigit> -> 4',\n '<hexdigit> -> 5',\n '<hexdigit> -> 9',\n '<hexdigit> -> c',\n '<hexdigit> -> f',\n '<other> -> 0',\n '<other> -> 1',\n '<other> -> 3',\n '<other> -> 4',\n '<other> -> 5',\n '<other> -> a',\n '<other> -> b'}\n\n```", "```py\nCGI_GRAMMAR[\"<letter>\"] \n```", "```py\n['<plus>', '<percent>', '<other>']\n\n```", "```py\nf = SimpleGrammarCoverageFuzzer(EXPR_GRAMMAR)\nf.max_expansion_coverage('<integer>') \n```", "```py\n{'<digit> -> 0',\n '<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9',\n '<integer> -> <digit>',\n '<integer> -> <digit><integer>'}\n\n```", "```py\nf.max_expansion_coverage('<digit>') \n```", "```py\n{'<digit> -> 0',\n '<digit> -> 1',\n '<digit> -> 2',\n '<digit> -> 3',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9'}\n\n```", "```py\nclass GrammarCoverageFuzzer(SimpleGrammarCoverageFuzzer):\n  \"\"\"Produce from grammars, aiming for coverage of all expansions.\"\"\"\n\n    def new_child_coverage(self,\n                           symbol: str,\n                           children: List[DerivationTree],\n                           max_depth: Union[int, float] = float('inf')) -> Set[str]:\n  \"\"\"Return new coverage that would be obtained \n by expanding (`symbol`, `children`)\"\"\"\n\n        new_cov = self._new_child_coverage(children, max_depth)\n        new_cov.add(expansion_key(symbol, children))\n        new_cov -= self.expansion_coverage()   # -= is set subtraction\n        return new_cov\n\n    def _new_child_coverage(self, children: List[DerivationTree],\n                            max_depth: Union[int, float]) -> Set[str]:\n        new_cov: Set[str] = set()\n        for (c_symbol, _) in children:\n            if c_symbol in self.grammar:\n                new_cov |= self.max_expansion_coverage(c_symbol, max_depth)\n\n        return new_cov \n```", "```py\nf = GrammarCoverageFuzzer(EXPR_GRAMMAR, start_symbol=\"<digit>\", log=True)\nf.fuzz() \n```", "```py\nTree: <digit>\nExpanding <digit> randomly\nNow covered: <digit> -> 2\nTree: 2\n'2'\n\n```", "```py\n'2'\n\n```", "```py\nf.expansion_coverage() \n```", "```py\n{'<digit> -> 2'}\n\n```", "```py\nf.new_child_coverage(\"<digit>\", [('0', [])]) \n```", "```py\n{'<digit> -> 0'}\n\n```", "```py\nf.new_child_coverage(\"<digit>\", [('2', [])]) \n```", "```py\nset()\n\n```", "```py\nfor expansion in EXPR_GRAMMAR[\"<digit>\"]:\n    children = f.expansion_to_children(expansion)\n    print(expansion, f.new_child_coverage(\"<digit>\", children)) \n```", "```py\n0 {'<digit> -> 0'}\n1 {'<digit> -> 1'}\n2 set()\n3 {'<digit> -> 3'}\n4 {'<digit> -> 4'}\n5 {'<digit> -> 5'}\n6 {'<digit> -> 6'}\n7 {'<digit> -> 7'}\n8 {'<digit> -> 8'}\n9 {'<digit> -> 9'}\n\n```", "```py\nclass GrammarCoverageFuzzer(GrammarCoverageFuzzer):\n    def new_coverages(self, node: DerivationTree,\n                      children_alternatives: List[List[DerivationTree]]) \\\n            -> Optional[List[Set[str]]]:\n  \"\"\"Return coverage to be obtained for each child at minimum depth\"\"\"\n\n        (symbol, children) = node\n        for max_depth in range(len(self.grammar)):\n            new_coverages = [\n                self.new_child_coverage(\n                    symbol, c, max_depth) for c in children_alternatives]\n            max_new_coverage = max(len(new_coverage)\n                                   for new_coverage in new_coverages)\n            if max_new_coverage > 0:\n                # Uncovered node found\n                return new_coverages\n\n        # All covered\n        return None \n```", "```py\nclass GrammarCoverageFuzzer(GrammarCoverageFuzzer):\n    def choose_node_expansion(self, node: DerivationTree,\n                              children_alternatives: List[List[DerivationTree]]) -> int:\n  \"\"\"Choose an expansion of `node` among `children_alternatives`.\n Return `n` such that expanding `children_alternatives[n]`\n yields the highest additional coverage.\"\"\"\n\n        (symbol, children) = node\n        new_coverages = self.new_coverages(node, children_alternatives)\n\n        if new_coverages is None:\n            # All expansions covered - use superclass method\n            return self.choose_covered_node_expansion(node, children_alternatives)\n\n        max_new_coverage = max(len(cov) for cov in new_coverages)\n\n        children_with_max_new_coverage = [c for (i, c) in enumerate(children_alternatives)\n                                          if len(new_coverages[i]) == max_new_coverage]\n        index_map = [i for (i, c) in enumerate(children_alternatives)\n                     if len(new_coverages[i]) == max_new_coverage]\n\n        # Select a random expansion\n        new_children_index = self.choose_uncovered_node_expansion(\n            node, children_with_max_new_coverage)\n        new_children = children_with_max_new_coverage[new_children_index]\n\n        # Save the expansion as covered\n        key = expansion_key(symbol, new_children)\n\n        if self.log:\n            print(\"Now covered:\", key)\n        self.covered_expansions.add(key)\n\n        return index_map[new_children_index] \n```", "```py\nf = GrammarCoverageFuzzer(EXPR_GRAMMAR, min_nonterminals=3)\nf.fuzz() \n```", "```py\n'-4.02 / (1) * +3 + 5.9 / 7 * 8 - 6'\n\n```", "```py\nf.max_expansion_coverage() - f.expansion_coverage() \n```", "```py\nset()\n\n```", "```py\naverage_length_until_full_coverage(GrammarCoverageFuzzer(EXPR_GRAMMAR)) \n```", "```py\n50.74\n\n```", "```py\nf = GrammarCoverageFuzzer(CGI_GRAMMAR, min_nonterminals=5)\nwhile len(f.max_expansion_coverage() - f.expansion_coverage()) > 0:\n    print(f.fuzz()) \n```", "```py\n%18%d03\n%c3%94%7f+cd\n%a6%b5%e2%5e%4c-54e01a2\n%5eb%7cb_ec%a0+\n\n```", "```py\naverage_length_until_full_coverage(TrackingGrammarCoverageFuzzer(CGI_GRAMMAR)) \n```", "```py\n211.34\n\n```", "```py\naverage_length_until_full_coverage(SimpleGrammarCoverageFuzzer(CGI_GRAMMAR)) \n```", "```py\n68.64\n\n```", "```py\naverage_length_until_full_coverage(GrammarCoverageFuzzer(CGI_GRAMMAR)) \n```", "```py\n40.38\n\n```", "```py\nEXPR_GRAMMAR[\"<factor>\"] \n```", "```py\n['+<factor>', '-<factor>', '(<expr>)', '<integer>.<integer>', '<integer>']\n\n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR,\n                                  {\n                                      \"<factor>\": [\"+<factor>\", \"-<factor>\", \"(<expr>)\", \"<integer-1>.<integer-2>\", \"<integer>\"],\n                                      \"<integer-1>\": [\"<digit-1><integer-1>\", \"<digit-1>\"],\n                                      \"<integer-2>\": [\"<digit-2><integer-2>\", \"<digit-2>\"],\n                                      \"<digit-1>\":\n                                      [\"0\", \"1\", \"2\", \"3\", \"4\",\n                                          \"5\", \"6\", \"7\", \"8\", \"9\"],\n                                      \"<digit-2>\":\n                                      [\"0\", \"1\", \"2\", \"3\", \"4\",\n                                          \"5\", \"6\", \"7\", \"8\", \"9\"]\n                                  }\n                                  ) \n```", "```py\nassert is_valid_grammar(dup_expr_grammar) \n```", "```py\nf = GrammarCoverageFuzzer(dup_expr_grammar, start_symbol=\"<factor>\")\nfor i in range(10):\n    print(f.fuzz()) \n```", "```py\n-(43.76 / 8.0 * 5.5 / 6.9 * 6 / 4 + +03)\n(90.1 - 1 * 7.3 * 9 + 5 / 8 / 7)\n2.8\n1.2\n10.4\n2\n4386\n7\n0\n08929.4302\n\n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR)\nduplicate_context(dup_expr_grammar, \"<factor>\", \"<integer>.<integer>\") \n```", "```py\nfrom [Grammars](Grammars.html) import new_symbol, unreachable_nonterminals\nfrom [GrammarFuzzer](GrammarFuzzer.html) import expansion_to_children \n```", "```py\ndef duplicate_context(grammar: Grammar, \n                      symbol: str,\n                      expansion: Optional[Expansion] = None, \n                      depth: Union[float, int] = float('inf')):\n  \"\"\"Duplicate an expansion within a grammar.\n\n In the given grammar, take the given expansion of the given `symbol`\n (if `expansion` is omitted: all symbols), and replace it with a\n new expansion referring to a duplicate of all originally referenced rules.\n\n If `depth` is given, limit duplication to `depth` references\n (default: unlimited)\n \"\"\"\n    orig_grammar = extend_grammar(grammar)\n    _duplicate_context(grammar, orig_grammar, symbol,\n                       expansion, depth, seen={})\n\n    # After duplication, we may have unreachable rules; delete them\n    for nonterminal in unreachable_nonterminals(grammar):\n        del grammar[nonterminal] \n```", "```py\nimport [copy](https://docs.python.org/3/library/copy.html) \n```", "```py\ndef _duplicate_context(grammar: Grammar,\n                       orig_grammar: Grammar,\n                       symbol: str,\n                       expansion: Optional[Expansion],\n                       depth: Union[float, int],\n                       seen: Dict[str, str]) -> None:\n  \"\"\"Helper function for `duplicate_context()`\"\"\"\n\n    for i in range(len(grammar[symbol])):\n        if expansion is None or grammar[symbol][i] == expansion:\n            new_expansion = \"\"\n            for (s, c) in expansion_to_children(grammar[symbol][i]):\n                if s in seen:                 # Duplicated already\n                    new_expansion += seen[s]\n                elif c == [] or depth == 0:   # Terminal symbol or end of recursion\n                    new_expansion += s\n                else:                         # Nonterminal symbol - duplicate\n                    # Add new symbol with copy of rule\n                    new_s = new_symbol(grammar, s)\n                    grammar[new_s] = copy.deepcopy(orig_grammar[s])\n\n                    # Duplicate its expansions recursively\n                    # {**seen, **{s: new_s}} is seen + {s: new_s}\n                    _duplicate_context(grammar, orig_grammar, new_s, expansion=None,\n                                       depth=depth - 1, seen={**seen, **{s: new_s}})\n                    new_expansion += new_s\n\n            grammar[symbol][i] = new_expansion \n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR)\nduplicate_context(dup_expr_grammar, \"<factor>\", \"<integer>.<integer>\")\ndup_expr_grammar \n```", "```py\n{'<start>': ['<expr>'],\n '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],\n '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],\n '<factor>': ['+<factor>',\n  '-<factor>',\n  '(<expr>)',\n  '<integer-1>.<integer-2>',\n  '<integer>'],\n '<integer>': ['<digit><integer>', '<digit>'],\n '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<integer-1>': ['<digit-1><integer-1>', '<digit-2>'],\n '<digit-1>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<digit-2>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<integer-2>': ['<digit-3><integer-2>', '<digit-4>'],\n '<digit-3>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<digit-4>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']}\n\n```", "```py\nf = GrammarCoverageFuzzer(dup_expr_grammar, start_symbol=\"<factor>\")\nfor i in range(10):\n    print(f.fuzz()) \n```", "```py\n(57.5)\n2\n+-(1 / 3 + 6 / 0 - 7 * 59 * 3 + 8 * 4)\n374.88\n5.709\n0.93\n01.1\n892.27\n219.50\n6.636\n\n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR)\nduplicate_context(dup_expr_grammar, \"<factor>\", \"<integer>.<integer>\", depth=1)\ndup_expr_grammar \n```", "```py\n{'<start>': ['<expr>'],\n '<expr>': ['<term> + <expr>', '<term> - <expr>', '<term>'],\n '<term>': ['<factor> * <term>', '<factor> / <term>', '<factor>'],\n '<factor>': ['+<factor>',\n  '-<factor>',\n  '(<expr>)',\n  '<integer-1>.<integer-2>',\n  '<integer>'],\n '<integer>': ['<digit><integer>', '<digit>'],\n '<digit>': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],\n '<integer-1>': ['<digit><integer-1>', '<digit>'],\n '<integer-2>': ['<digit><integer-2>', '<digit>']}\n\n```", "```py\nassert is_valid_grammar(dup_expr_grammar) \n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR)\nduplicate_context(dup_expr_grammar, \"<expr>\") \n```", "```py\nassert is_valid_grammar(dup_expr_grammar)\nlen(dup_expr_grammar) \n```", "```py\n292\n\n```", "```py\nf = GrammarCoverageFuzzer(dup_expr_grammar)\nlen(f.max_expansion_coverage()) \n```", "```py\n1981\n\n```", "```py\ndup_expr_grammar = extend_grammar(EXPR_GRAMMAR)\nduplicate_context(dup_expr_grammar, \"<expr>\")\nduplicate_context(dup_expr_grammar, \"<expr-1>\")\nlen(dup_expr_grammar) \n```", "```py\n594\n\n```", "```py\nf = GrammarCoverageFuzzer(dup_expr_grammar)\nlen(f.max_expansion_coverage()) \n```", "```py\n3994\n\n```", "```py\ndup_expr_grammar[\"<expr>\"] \n```", "```py\n['<term-1> + <expr-4>', '<term-5> - <expr-8>', '<term-9>']\n\n```", "```py\ndup_expr_grammar[\"<term-1-1>\"] \n```", "```py\n['<factor-1-1> * <term-1-1>', '<factor-2-1> / <term-1-1>', '<factor-3-1>']\n\n```", "```py\ndup_expr_grammar[\"<factor-1-1>\"] \n```", "```py\n['+<factor-1-1>',\n '-<factor-1-1>',\n '(<expr-1-1>)',\n '<integer-1-1>.<integer-2-1>',\n '<integer-3-1>']\n\n```", "```py\nfrom [Coverage](Coverage.html) import Coverage, cgi_decode \n```", "```py\nwith Coverage() as cov_max:\n    cgi_decode('+')\n    cgi_decode('%20')\n    cgi_decode('abc')\n    try:\n        cgi_decode('%?a')\n    except:\n        pass \n```", "```py\nf = GrammarCoverageFuzzer(CGI_GRAMMAR, max_nonterminals=2)\ncoverages: Dict[float, List[float]] = {}\n\ntrials = 100\nfor trial in range(trials):\n    f.reset_coverage()\n    overall_cov = set()\n    max_cov = 30\n\n    for i in range(10):\n        s = f.fuzz()\n        with Coverage() as cov:\n            cgi_decode(s)\n        overall_cov |= cov.coverage()\n\n        x = len(f.expansion_coverage()) * 100 / len(f.max_expansion_coverage())\n        y = len(overall_cov) * 100 / len(cov_max.coverage())\n        if x not in coverages:\n            coverages[x] = []\n        coverages[x].append(y) \n```", "```py\nxs = list(coverages.keys())\nys = [sum(coverages[x]) / len(coverages[x]) for x in coverages] \n```", "```py\n%matplotlib inline \n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nimport [matplotlib.ticker](https://matplotlib.org/) as mtick \n```", "```py\nax = plt.axes(label=\"CGI coverage\")\nax.yaxis.set_major_formatter(mtick.PercentFormatter())\nax.xaxis.set_major_formatter(mtick.PercentFormatter())\n\nplt.xlim(0, max(xs))\nplt.ylim(0, max(ys))\n\nplt.title('Coverage of cgi_decode() vs. grammar coverage')\nplt.xlabel('grammar coverage (expansions)')\nplt.ylabel('code coverage (lines)') \n```", "```py\nText(0, 0.5, 'code coverage (lines)')\n\n```", "```py\nimport [numpy](https://numpy.org/) as np \n```", "```py\nnp.corrcoef(xs, ys) \n```", "```py\narray([[1\\.        , 0.81663071],\n       [0.81663071, 1\\.        ]])\n\n```", "```py\nfrom [scipy.stats](https://docs.scipy.org/doc/scipy/reference/) import spearmanr \n```", "```py\nspearmanr(xs, ys) \n```", "```py\nSignificanceResult(statistic=np.float64(0.9477544699285101), pvalue=np.float64(2.2771918715723359e-10))\n\n```", "```py\nfrom [urllib.parse](https://docs.python.org/3/library/urllib.parse.html) import urlparse \n```", "```py\nwith Coverage() as cov_max:\n    urlparse(\"http://foo.bar/path\")\n    urlparse(\"https://foo.bar#fragment\")\n    urlparse(\"ftp://user:password@foo.bar?query=value\")\n    urlparse(\"ftps://127.0.0.1/?x=1&y=2\") \n```", "```py\nf = GrammarCoverageFuzzer(URL_GRAMMAR, max_nonterminals=2)\ncoverages: Dict[float, List[float]] = {}\n\ntrials = 100\nfor trial in range(trials):\n    f.reset_coverage()\n    overall_cov = set()\n\n    for i in range(20):\n        s = f.fuzz()\n        with Coverage() as cov:\n            urlparse(s)\n        overall_cov |= cov.coverage()\n\n        x = len(f.expansion_coverage()) * 100 / len(f.max_expansion_coverage())\n        y = len(overall_cov) * 100 / len(cov_max.coverage())\n        if x not in coverages:\n            coverages[x] = []\n        coverages[x].append(y) \n```", "```py\nxs = list(coverages.keys())\nys = [sum(coverages[x]) / len(coverages[x]) for x in coverages] \n```", "```py\nax = plt.axes(label=\"URL coverage\")\nax.yaxis.set_major_formatter(mtick.PercentFormatter())\nax.xaxis.set_major_formatter(mtick.PercentFormatter())\n\nplt.xlim(0, max(xs))\nplt.ylim(0, max(ys))\n\nplt.title('Coverage of urlparse() vs. grammar coverage')\nplt.xlabel('grammar coverage (expansions)')\nplt.ylabel('code coverage (lines)') \n```", "```py\nText(0, 0.5, 'code coverage (lines)')\n\n```", "```py\nplt.scatter(xs, ys); \n```", "```py\nnp.corrcoef(xs, ys) \n```", "```py\narray([[1\\.       , 0.8819171],\n       [0.8819171, 1\\.       ]])\n\n```", "```py\nspearmanr(xs, ys) \n```", "```py\nSignificanceResult(statistic=np.float64(0.9486832980505139), pvalue=np.float64(0.05131670194948612))\n\n```", "```py\nLS_EBNF_GRAMMAR: Grammar = {\n    '<start>': ['-<options>'],\n    '<options>': ['<option>*'],\n    '<option>': ['1', 'A', '@',\n                 # many more\n                 ]\n} \n```", "```py\nassert is_valid_grammar(LS_EBNF_GRAMMAR) \n```", "```py\n@incollection{fuzzingbook2023:GrammarCoverageFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Grammar Coverage},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html}},\n    note = {Retrieved 2023-11-11 18:18:06+01:00},\n    url = {https://www.fuzzingbook.org/html/GrammarCoverageFuzzer.html},\n    urldate = {2023-11-11 18:18:06+01:00}\n}\n\n```"]