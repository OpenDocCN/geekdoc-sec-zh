- en: Introduction to Software Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件测试简介
- en: 原文：[http://www.fuzzingbook.org/html/Intro_Testing.html](http://www.fuzzingbook.org/html/Intro_Testing.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[http://www.fuzzingbook.org/html/Intro_Testing.html](http://www.fuzzingbook.org/html/Intro_Testing.html)'
- en: Before we get to the central parts of the book, let us introduce essential concepts
    of software testing. Why is it necessary to test software at all? How does one
    test software? How can one tell whether a test has been successful? How does one
    know if one has tested enough? In this chapter, let us recall the most important
    concepts, and at the same time get acquainted with Python and interactive notebooks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本书的核心部分之前，让我们先介绍软件测试的基本概念。为什么需要测试软件呢？一个人该如何测试软件？一个人如何判断一个测试是否成功？一个人如何知道是否测试得足够了？在这一章中，让我们回顾最重要的概念，同时熟悉Python和交互式笔记本。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This chapter (and this book) is not set to replace a textbook on testing; see
    the [Background](#Background) at the end for recommended reads.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章（以及本书）并不打算取代测试方面的教科书；请参阅结尾处的[背景](#Background)，以获取推荐的阅读材料。
- en: Simple Testing
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单测试
- en: Let us start with a simple example. Your co-worker has been asked to implement
    a square root function $\sqrt{x}$. (Let's assume for a moment that the environment
    does not already have one.) After studying the [Newton–Raphson method](https://en.wikipedia.org/wiki/Newton%27s_method),
    she comes up with the following Python code, claiming that, in fact, this `my_sqrt()`
    function computes square roots.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始。你的同事被要求实现一个平方根函数 $\sqrt{x}$。（让我们暂时假设环境中还没有这样的函数。）在研究了[牛顿-拉夫森方法](https://en.wikipedia.org/wiki/Newton%27s_method)之后，她提出了以下Python代码，声称实际上这个`my_sqrt()`函数可以计算平方根。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your job is now to find out whether this function actually does what it claims
    to do.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是找出这个函数是否真的做了它声称要做的事情。
- en: Understanding Python Programs
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解Python程序
- en: 'If you''re new to Python, you might first have to understand what the above
    code does. We very much recommend the [Python tutorial](https://docs.python.org/3/tutorial/)
    to get an idea on how Python works. The most important things for you to understand
    the above code are these three:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始接触Python，你可能首先需要理解上述代码的功能。我们非常推荐阅读[Python教程](https://docs.python.org/3/tutorial/)，以了解Python是如何工作的。理解上述代码最重要的三件事是这些：
- en: Python structures programs through *indentation*, so the function and `while`
    bodies are defined by being indented;
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python通过*缩进*来构建程序结构，因此函数和`while`循环体是通过缩进来定义的；
- en: Python is *dynamically typed*, meaning that the type of variables like `x`,
    `approx`, or `guess` is determined at run-time.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python是*动态类型化的*，这意味着变量如`x`、`approx`或`guess`的类型是在运行时确定的。
- en: Most of Python's syntactic features are inspired by other common languages,
    such as control structures (`while`, `if`), assignments (`=`), or comparisons
    (`==`, `!=`, `<`).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python的大多数语法特性都受到了其他常见语言的影响，例如控制结构（`while`、`if`）、赋值（`=`）或比较（`==`、`!=`、`<`）。
- en: 'With that, you can already understand what the above code does: Starting with
    a `guess` of `x / 2`, it computes better and better approximations in `approx`
    until the value of `approx` no longer changes. This is the value that finally
    is returned.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你就可以理解上述代码的功能了：从一个`guess`值`x / 2`开始，它在`approx`中计算越来越好的近似值，直到`approx`的值不再改变。这就是最终返回的值。
- en: Running a Function
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行一个函数
- en: 'To find out whether `my_sqrt()` works correctly, we can *test* it with a few
    values. For `x = 4`, for instance, it produces the correct value:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出`my_sqrt()`函数是否工作正确，我们可以用几个值来*测试*它。例如，对于`x = 4`，它会产生正确的值：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The upper part above `my_sqrt(4)` (a so-called *cell*) is an input to the Python
    interpreter, which by default *evaluates* it. The lower part (`2.0`) is its output.
    We can see that `my_sqrt(4)` produces the correct value.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`my_sqrt(4)`部分（所谓的*单元*）是Python解释器的输入，默认情况下会*评估*它。下面的部分（`2.0`）是它的输出。我们可以看到`my_sqrt(4)`产生了正确的值。
- en: 'The same holds for `x = 2.0`, apparently, too:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`x = 2.0`，情况似乎也是一样：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Interacting with Notebooks
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与笔记本交互
- en: If you are reading this in the interactive notebook, you can try out `my_sqrt()`
    with other values as well. Click on one of the above cells with invocations of
    `my_sqrt()` and change the value – say, to `my_sqrt(1)`. Press `Shift+Enter` (or
    click on the play symbol) to execute it and see the result. If you get an error
    message, go to the above cell with the definition of `my_sqrt()` and execute this
    first. You can also run *all* cells at once; see the Notebook menu for details.
    (You can actually also change the text by clicking on it, and corect mistaks such
    as in this sentence.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个交互式笔记本中阅读，你可以尝试用其他值来测试`my_sqrt()`。点击上面带有`my_sqrt()`调用的其中一个单元格，并更改其值——比如说，改为`my_sqrt(1)`。按`Shift+Enter`（或点击播放符号）来执行它并查看结果。如果你得到一个错误信息，请转到上面定义`my_sqrt()`的单元格并首先执行这个操作。你也可以一次性运行所有单元格；有关详细信息，请查看笔记本菜单。（实际上，你也可以通过点击来更改文本，并纠正如这句话中的错误。）
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Quiz
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: What does `my_sqrt(16)` produce?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_sqrt(16)`会产生什么结果？'
- en: 'Try it out for yourself by uncommenting and executing the following line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过取消以下行的注释并执行它来亲自尝试：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Executing a single cell does not execute other cells, so if your cell builds
    on a definition in another cell that you have not executed yet, you will get an
    error. You can select `Run all cells above` from the menu to ensure all definitions
    are set.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单个单元格不会执行其他单元格，所以如果你的单元格依赖于另一个单元格中的定义，而你尚未执行该定义，你会得到一个错误。你可以从菜单中选择`运行所有单元格以上`来确保所有定义都已设置。
- en: Also keep in mind that, unless overwritten, all definitions are kept across
    executions. Occasionally, it thus helps to *restart the kernel* (i.e. start the
    Python interpreter from scratch) to get rid of older, superfluous definitions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，除非被覆盖，否则所有定义都会在执行之间保留。有时，因此重启内核（即从头开始启动Python解释器）以消除旧的、多余的定义是有帮助的。
- en: Debugging a Function
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试一个函数
- en: 'To see how `my_sqrt()` operates, a simple strategy is to insert `print()` statements
    in critical places. You can, for instance, log the value of `approx`, to see how
    each loop iteration gets closer to the actual value:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`my_sqrt()`是如何工作的，一个简单的策略是在关键位置插入`print()`语句。例如，你可以记录`approx`的值，以查看每次循环迭代如何逐渐接近实际值：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Interactive notebooks also allow launching an interactive *debugger* – insert
    a "magic line" `%%debug` at the top of a cell and see what happens. Unfortunately,
    interactive debuggers interfere with our dynamic analysis techniques, so we mostly
    use logging and assertions for debugging.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式笔记本还允许启动一个交互式调试器——在单元格顶部插入一个“魔法行”`%%debug`并查看会发生什么。不幸的是，交互式调试器会干扰我们的动态分析技术，所以我们主要使用日志和断言进行调试。
- en: Checking a Function
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查一个函数
- en: 'Let''s get back to testing. We can read and run the code, but are the above
    values of `my_sqrt(2)` actually correct? We can easily verify by exploiting that
    $\sqrt{x}$ squared again has to be $x$, or in other words $\sqrt{x} \times \sqrt{x}
    = x$. Let''s take a look:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到测试。我们可以读取并运行代码，但上述`my_sqrt(2)`的值实际上是否正确？我们可以通过利用$\sqrt{x}$平方再次必须是$x$来轻松验证，换句话说，$\sqrt{x}
    \times \sqrt{x} = x$。让我们看看：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Okay, we do have some rounding error, but otherwise, this seems just fine.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们确实有一些舍入误差，但除此之外，这似乎很正常。
- en: 'What we have done now is that we have *tested* the above program: We have *executed*
    it on a given input and *checked* its result whether it is correct or not. Such
    a test is the bare minimum of quality assurance before a program goes into production.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所做的是测试上述程序：我们在给定的输入上执行它，并检查其结果是否正确。这种测试是在程序投入生产前的质量保证的最基本要求。
- en: Automating Test Execution
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试执行
- en: 'So far, we have tested the above program *manually*, that is, running it by
    hand and checking its results by hand. This is a very flexible way of testing,
    but in the long run, it is rather inefficient:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们都是手动测试上述程序，即手动运行它并手动检查其结果。这是一种非常灵活的测试方式，但从长远来看，它相当低效：
- en: Manually, you can only check a very limited number of executions and their results
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动地，你只能检查非常有限数量的执行及其结果
- en: After any change to the program, you have to repeat the testing process
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对程序进行任何更改后，你必须重复测试过程
- en: This is why it is very useful to *automate* tests. One simple way of doing so
    is to let the computer first do the computation, and then have it check the results.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么自动化测试非常有用。一个简单的方法是让计算机首先进行计算，然后让它检查结果。
- en: 'For instance, this piece of code automatically tests whether $\sqrt{4} = 2$
    holds:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这段代码会自动测试$\sqrt{4} = 2$是否成立：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The nice thing about this test is that we can run it again and again, thus
    ensuring that at least the square root of 4 is computed correctly. But there are
    still a number of issues, though:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的好处是我们可以反复运行它，从而确保至少 4 的平方根被正确计算。但仍然有一些问题：
- en: We need *five lines of code* for a single test
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个测试的单行代码
- en: We do not care for rounding errors
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们并不关心舍入误差
- en: We only check a single input (and a single result)
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只检查单个输入（和单个结果）
- en: Let us address these issues one by one. First, let's make the test a bit more
    compact. Almost all programming languages do have a means to automatically check
    whether a condition holds, and stop execution if it does not. This is called an
    *assertion*, and it is immensely useful for testing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一解决这些问题。首先，让我们使测试更加紧凑。几乎所有的编程语言都有一种方法来自动检查条件是否成立，如果不成立则停止执行。这被称为 *断言*，它在测试中非常有用。
- en: In Python, the `assert` statement takes a condition, and if the condition is
    true, nothing happens. (If everything works as it should, you should not be bothered.)
    If the condition evaluates to false, though, `assert` raises an exception, indicating
    that a test just failed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`assert` 语句接受一个条件，如果条件为真，则不发生任何操作。（如果一切按预期进行，你就不应该被打扰。）但是，如果条件评估为假，则
    `assert` 会引发异常，表明测试刚刚失败。
- en: 'In our example, we can use `assert` to easily check whether `my_sqrt()` yields
    the expected result as above:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们可以使用 `assert` 来轻松检查 `my_sqrt()` 是否产生如上所述的预期结果：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you execute this line of code, nothing happens: We just have shown (or asserted)
    that our implementation indeed produces $\sqrt{4} = 2$.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行这一行代码时，没有任何操作：我们只是展示了（或断言）我们的实现确实产生了 $\sqrt{4} = 2$。
- en: 'Remember, though, that floating-point computations may induce rounding errors.
    So we cannot simply compare two floating-point values with equality; rather, we
    would ensure that the absolute difference between them stays below a certain threshold
    value, typically denoted as $\epsilon$ or `epsilon`. This is how we can do it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，记住，浮点数计算可能会引入舍入误差。因此，我们不能简单地比较两个浮点数的相等性；相反，我们需要确保它们之间的绝对差值保持在某个特定的阈值以下，通常表示为
    $\epsilon$ 或 `epsilon`。这就是我们如何做到这一点：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also introduce a special function for this purpose, and now do more
    tests for concrete values:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为此引入一个特殊函数，并现在对具体值进行更多测试：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Seems to work, right? If we know the expected results of a computation, we can
    use such assertions again and again to ensure our program works correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是有效的，对吧？如果我们知道计算的预期结果，我们可以反复使用这样的断言来确保我们的程序正确工作。
- en: '(Hint: a true Python programmer would use the function [`math.isclose()`](https://docs.python.org/3/library/math.html#math.isclose)
    instead.)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: （提示：真正的 Python 程序员会使用函数 `math.isclose()` 来代替。）
- en: Generating Tests
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成测试
- en: 'Remember that the property $\sqrt{x} \times \sqrt{x} = x$ universally holds?
    We can also explicitly test this with a few values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，性质 $\sqrt{x} \times \sqrt{x} = x$ 在普遍情况下是成立的？我们也可以用几个值显式地测试这一点：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still seems to work, right? Most importantly, though, $\sqrt{x} \times \sqrt{x}
    = x$ is something we can very easily test for thousands of values:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然看起来是有效的，对吧？最重要的是，$\sqrt{x} \times \sqrt{x} = x$ 是我们可以很容易地测试成千上万个值的东西：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How much time does it take to test `my_sqrt()` with 100 values? Let's see.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 100 个值测试 `my_sqrt()` 需要多少时间？让我们看看。
- en: We use our own [`Timer` module](Timer.html) to measure elapsed time. To be able
    to use `Timer`, we first import our own utility module, which allows us to import
    other notebooks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用自己的 `Timer` 模块来测量经过的时间。为了能够使用 `Timer`，我们首先导入我们的实用模块，这允许我们导入其他笔记本。
- en: '[PRE23]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 10,000 values take about a hundredth of a second, so a single execution of `my_sqrt()`
    takes 1/1000000 second, or about 1 microseconds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 10,000 个值大约需要百分之一秒，所以 `my_sqrt()` 的单次执行需要 1/1000000 秒，或者说大约 1 微秒。
- en: 'Let''s repeat this with 10,000 values picked at random. The Python `random.random()`
    function returns a random value between 0.0 and 1.0:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用随机选择的 10,000 个值重复这个过程。Python 的 `random.random()` 函数返回一个介于 0.0 和 1.0 之间的随机值：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Within a second, we have now tested 10,000 random values, and each time, the
    square root was actually computed correctly. We can repeat this test with every
    single change to `my_sqrt()`, each time reinforcing our confidence that `my_sqrt()`
    works as it should. Note, though, that while a random function is *unbiased* in
    producing random values, it is unlikely to generate special values that drastically
    alter program behavior. We will discuss this later below.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在一秒钟内，我们已经测试了10,000个随机值，每次计算平方根都是正确的。我们可以对`my_sqrt()`的每一次更改重复这个测试，每次都增强我们对`my_sqrt()`按预期工作的信心。不过，请注意，虽然随机函数在产生随机值时是*无偏的*，但它不太可能生成会剧烈改变程序行为的特殊值。我们将在下面进一步讨论这个问题。
- en: Run-Time Verification
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时验证
- en: Instead of writing and running tests for `my_sqrt()`, we can also go and *integrate
    the check right into the implementation.* This way, *each and every* invocation
    of `my_sqrt()` will be automatically checked.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以为`my_sqrt()`编写和运行测试，还可以将检查直接*集成到实现中*。这样，*每次*调用`my_sqrt()`都将自动进行检查。
- en: 'Such an *automatic run-time check* is very easy to implement:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的*自动运行时检查*非常容易实现：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, whenever we compute a root with `my_sqrt_checked()`$\dots$
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们用`my_sqrt_checked()`计算根时$\dots$
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '... we already know that the result is correct, and will so for every new successful
    computation.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '...我们已经知道结果是正确的，并且对于每一次新的成功计算也将如此。'
- en: 'Automatic run-time checks, as above, assume two things, though:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自动运行时检查，如上所述，假设了两件事：
- en: One has to be able to *formulate* such run-time checks. Having concrete values
    to check against should always be possible, but formulating desired properties
    in an abstract fashion can be very complex. In practice, you need to decide which
    properties are most crucial, and design appropriate checks for them. Plus, run-time
    checks may depend not only on local properties, but on several properties of the
    program state, which all have to be identified.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够*制定*这样的运行时检查。总是应该有具体的值来检查，但以抽象的方式制定所需属性可能非常复杂。在实践中，你需要决定哪些属性最为关键，并为它们设计适当的检查。此外，运行时检查可能不仅取决于局部属性，还取决于程序状态的多个属性，所有这些属性都必须被识别。
- en: One has to be able to *afford* such run-time checks. In the case of `my_sqrt()`,
    the check is not very expensive; but if we have to check, say, a large data structure
    even after a simple operation, the cost of the check may soon be prohibitive.
    In practice, run-time checks will typically be disabled during production, trading
    reliability for efficiency. On the other hand, a comprehensive suite of run-time
    checks is a great way to find errors and quickly debug them; you need to decide
    how many such capabilities you would still want during production.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须能够*承担*这样的运行时检查。在`my_sqrt()`的情况下，检查并不昂贵；但如果我们必须检查，比如说，在简单操作之后的大型数据结构，检查的成本可能会很快变得难以承受。在实践中，运行时检查通常在生产过程中被禁用，以效率换取可靠性。另一方面，一套全面的运行时检查是发现错误并快速调试它们的极好方式；你需要决定在生产过程中你仍然需要多少这样的功能。
- en: Quiz
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问答
- en: Does run-time checking give a guarantee that there will always be a correct
    result?
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时检查能保证总是会有正确的结果吗？
- en: An important limitation of run-time checks is that they ensure correctness *only
    if there is a result* to be checked - that is, they do *not* guarantee that there
    always will be one. This is an important limitation compared to *symbolic verification
    techniques* and program proofs, which can also guarantee that there is a result
    – at a much higher (often manual) effort, though.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时检查的一个重要限制是，它们只能确保*如果存在结果*需要检查时的正确性——也就是说，它们不能保证总是会有一个结果。与*符号验证技术*和程序证明相比，这是一个重要的限制，后者也可以保证存在结果——尽管需要付出更高的（通常是手动）努力。
- en: System Input vs Function Input
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统输入与函数输入
- en: At this point, we may make `my_sqrt()` available to other programmers, who may
    then embed it in their code. At some point, it will have to process input that
    comes from *third parties*, i.e. is not under control by the programmer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以将`my_sqrt()`提供给其他程序员，他们可以将它嵌入到他们的代码中。在某个时候，它将不得不处理来自*第三方*的输入，即程序员无法控制的输入。
- en: 'Let us simulate this *system input* by assuming a *program* `sqrt_program()`
    whose input is a string under third-party control:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过假设一个*程序* `sqrt_program()` 来模拟这个*系统输入*，其输入是由第三方控制的字符串：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We assume that `sqrt_program` is a program which accepts system input from the
    command line, as in
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设`sqrt_program`是一个程序，它从命令行接受系统输入，如下所示：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can easily invoke `sqrt_program()` with some system input:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地用一些系统输入调用`sqrt_program()`：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What's the problem? Well, the problem is that we do not check external inputs
    for validity. Try invoking `sqrt_program(-1)`, for instance. What happens?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是什么？问题是我们没有检查外部输入的有效性。尝试调用`sqrt_program(-1)`，例如。会发生什么？
- en: Indeed, if you invoke `my_sqrt()` with a negative number, it enters an infinite
    loop. For technical reasons, we cannot have infinite loops in this chapter (unless
    we'd want the code to run forever); so we use a special `with ExpectTimeOut(1)`
    construct to interrupt execution after one second.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果你用一个负数调用`my_sqrt()`，它会进入一个无限循环。由于技术原因，我们在这个章节中不能有无限循环（除非我们想让代码永远运行）；所以我们使用一个特殊的`with
    ExpectTimeOut(1)`结构在一秒后中断执行。
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The above message is an *error message*, indicating that something went wrong.
    It lists the *call stack* of functions and lines that were active at the time
    of the error. The line at the very bottom is the line last executed; the lines
    above represent function invocations – in our case, up to `my_sqrt(x)`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述信息是一个*错误信息*，表示出现了问题。它列出了在错误发生时活跃的函数和行号的*调用栈*。最底部的行是最后执行的行；上面的行代表函数调用——在我们的例子中，直到`my_sqrt(x)`。
- en: 'We don''t want our code terminating with an exception. Consequently, when accepting
    external input, we must ensure that it is properly validated. We may write, for
    instance:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的代码因为异常而终止。因此，在接收外部输入时，我们必须确保它得到了适当的验证。例如，我们可以这样写：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: and then we can be sure that `my_sqrt()` is only invoked according to its specification.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以确信`my_sqrt()`是按照其规范调用的。
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: But wait! What happens if `sqrt_program()` is not invoked with a number?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！如果`sqrt_program()`没有用数字调用会发生什么？
- en: Quiz
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题
- en: What is the result of `sqrt_program('xyzzy')`?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt_program(''xyzzy'')`的结果是什么？'
- en: 'Let''s try this out! When we try to convert a non-number string, this would
    also result in a runtime error:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看！当我们尝试转换一个非数字字符串时，这也会导致运行时错误：
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here''s a version which also checks for bad inputs:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个版本，它也检查了不良输入：
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We have now seen that at the system level, the program must be able to handle
    any kind of input gracefully without ever entering an uncontrolled state. This,
    of course, is a burden for programmers, who must struggle to make their programs
    robust for all circumstances. This burden, however, becomes a *benefit* when generating
    software tests: If a program can handle any kind of input (possibly with well-defined
    error messages), we can also *send it any kind of input*. When calling a function
    with generated values, though, we have to *know* its precise preconditions.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到，在系统层面，程序必须能够优雅地处理任何类型的输入，而不会进入不受控制的状态。这当然给程序员带来了负担，他们必须努力使他们的程序在各种情况下都健壮。然而，当生成软件测试时，这种负担却变成了*好处*：如果一个程序可以处理任何类型的输入（可能带有定义良好的错误信息），我们也可以*发送任何类型的输入*。但是，在用生成的值调用函数时，我们必须*知道*其精确的先决条件。
- en: The Limits of Testing
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试的局限性
- en: Despite our best efforts in testing, keep in mind that you are always checking
    functionality for a *finite* set of inputs. Thus, there may always be *untested*
    inputs for which the function may still fail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在测试中尽了最大努力，但请记住，你总是在检查一个*有限*的输入集的功能。因此，可能始终存在*未测试*的输入，对于这些输入，函数可能仍然会失败。
- en: 'In the case of `my_sqrt()`, for instance, computing $\sqrt{0}$ results in a
    division by zero:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`my_sqrt()`的情况下，例如，计算$\sqrt{0}$会导致除以零：
- en: '[PRE53]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In our tests so far, we have not checked this condition, meaning that a program
    which builds on $\sqrt{0} = 0$ will surprisingly fail. But even if we had set
    up our random generator to produce inputs in the range of 0–1000000 rather than
    1–1000000, the chances of it producing a zero value by chance would still have
    been one in a million. If the behavior of a function is radically different for
    few individual values, plain random testing has few chances to produce these.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止的测试中，我们没有检查这个条件，这意味着基于$\sqrt{0} = 0$的程序会意外地失败。但即使我们将随机生成器的输入范围设置为0–1000000而不是1–1000000，随机产生零值的概率仍然是一百万分之一。如果一个函数对少数几个个别值的行为有根本性的不同，普通的随机测试很少有机会产生这些值。
- en: 'We can, of course, fix the function accordingly, documenting the accepted values
    for `x` and handling the special case `x = 0`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以相应地修复函数，记录`x`接受的值，并处理特殊情况`x = 0`：
- en: '[PRE55]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'With this, we can now correctly compute $\sqrt{0} = 0$:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们现在可以正确地计算$\sqrt{0} = 0$：
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Illegal values now result in an exception:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 非法值现在会导致异常：
- en: '[PRE57]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Still, we have to remember that while extensive testing may give us a high confidence
    into the correctness of a program, it does not provide a guarantee that all future
    executions will be correct. Even run-time verification, which checks every result,
    can only guarantee that *if* it produces a result, the result will be correct;
    but there is no guarantee that future executions may not lead to a failing check.
    As I am writing this, I *believe* that `my_sqrt_fixed(x)` is a correct implementation
    of $\sqrt{x}$ for all finite numbers $x$, but I cannot be certain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须记住，尽管广泛的测试可能会让我们对程序的正确性有很高的信心，但它并不能保证所有未来的执行都将正确。即使是运行时验证，它检查每一个结果，也只能保证如果它产生了结果，那么结果将是正确的；但无法保证未来的执行不会导致失败的检查。当我写这篇文章的时候，我*相信*`my_sqrt_fixed(x)`是所有有限数字$x$的$\sqrt{x}$的正确实现，但我不能确定。
- en: 'With the Newton-Raphson method, we may still have a good chance of actually
    *proving* that the implementation is correct: The implementation is simple, the
    math is well-understood. Alas, this is only the case for few domains. If we do
    not want to go into full-fledged correctness proofs, our best chance with testing
    is to'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用牛顿-拉夫森方法，我们仍然有很好的机会实际上*证明*实现是正确的：实现简单，数学理解得很好。遗憾的是，这种情况只适用于少数领域。如果我们不想进行完整的正确性证明，我们在测试中最好的机会是
- en: Test the program on several, well-chosen inputs; and
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在几个精心选择的输入上测试程序；并且
- en: Check results extensively and automatically.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 详尽且自动地检查结果。
- en: 'This is what we do in the remainder of this course: Devise techniques that
    help us to thoroughly test a program, as well as techniques that help us check
    its state for correctness. Enjoy!'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这门课程的剩余部分要做的：设计帮助我们彻底测试程序的技术，以及帮助我们检查其状态是否正确的技术。享受吧！
- en: Lessons Learned
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: The aim of testing is to execute a program such that we find bugs.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的目标是执行一个程序，以便我们发现错误。
- en: Test execution, test generation, and checking test results can be automated.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试执行、测试生成和检查测试结果可以自动化。
- en: Testing is *incomplete*; it provides no 100% guarantee that the code is free
    of errors.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试是不完整的；它不能提供100%的保证代码没有错误。
- en: Next Steps
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: From here, you can move on how to
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以继续学习如何
- en: '[use *fuzzing* to test programs with random inputs](Fuzzer.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用*fuzzing*测试具有随机输入的程序](Fuzzer.html)'
- en: Enjoy the read!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 享受阅读！
- en: Background
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: There is a large number of works on software testing and analysis.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 关于软件测试与分析有许多研究。
- en: 'An all-new modern, comprehensive, and online textbook on testing is ["Effective
    Software Testing: A Developer''s Guide"](https://www.effective-software-testing.com)
    [[Maurício Aniche, 2022](https://www.effective-software-testing.com)]. Much recommended!'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本全新的现代、全面和在线的测试教科书是["有效的软件测试：开发者指南"](https://www.effective-software-testing.com)
    [[Maurício Aniche，2022](https://www.effective-software-testing.com)]。强烈推荐！
- en: For this book, we are also happy to recommend "Software Testing and Analysis"
    [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)] as an introduction
    to the field; its strong technical focus very well fits our methodology.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这本书，我们也很乐意推荐“软件测试与分析”[[Pezzè *et al*，2008](http://ix.cs.uoregon.edu/~michal/book/)]作为该领域的入门书籍；其强大的技术重点非常适合我们的方法。
- en: Other important must-reads with a comprehensive approach to software testing,
    including psychology and organization, include "The Art of Software Testing" [[Myers
    *et al*, 2004](https://dl.acm.org/citation.cfm?id=983238)] as well as "Software
    Testing Techniques" [[Beizer *et al*, 1990](https://dl.acm.org/citation.cfm?id=79060)].
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一些重要的必读之作，包括心理学和组织，对软件测试有全面的方法，包括“软件测试的艺术”[[Myers *et al*，2004](https://dl.acm.org/citation.cfm?id=983238)]以及“软件测试技术”[[Beizer
    *et al*，1990](https://dl.acm.org/citation.cfm?id=79060)]。
- en: Exercises
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: Get Acquainted with Notebooks and Python'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：熟悉笔记本和Python
- en: Your first exercise in this book is to get acquainted with notebooks and Python,
    such that you can run the code examples in the book – and try out your own. Here
    are a few tasks to get you started.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这本书中的第一个练习是熟悉笔记本和Python，这样你就可以运行书中的代码示例——并尝试你自己的。以下是一些帮助你开始的任务。
- en: 'Beginner Level: Run Notebooks in Your Browser'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初级水平：在浏览器中运行笔记本
- en: The easiest way to get access to the code is to run them in your browser.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 获取代码的最简单方法是在浏览器中运行它们。
- en: From the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html), check
    out the menu at the top. Select `Resources` $\rightarrow$ `Edit as Notebook`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看顶部的菜单。选择`资源` $\rightarrow$
    `作为笔记本编辑`。
- en: After a short waiting time, this will open a Jupyter Notebook right within your
    browser, containing the current chapter as a notebook.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 短暂等待后，这将直接在你的浏览器中打开一个Jupyter Notebook，其中包含当前章节作为笔记本。
- en: You can again scroll through the material, but you click on any code example
    to edit and run its code (by entering `Shift` + `Return`). You can edit the examples
    as you please.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以再次滚动浏览材料，但你可以点击任何代码示例来编辑并运行其代码（通过输入`Shift` + `Return`）。你可以随意编辑示例。
- en: Note that code examples typically depend on earlier code, so be sure to run
    the preceding code first.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，代码示例通常依赖于早期代码，所以请确保先运行前面的代码。
- en: Any changes you make will not be saved (unless you save your notebook to disk).
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你所做的任何更改都不会被保存（除非你将笔记本保存到磁盘）。
- en: For help on Jupyter Notebooks, from the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html),
    check out the `Help` menu.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Jupyter Notebook的帮助，从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看`帮助`菜单。
- en: 'Advanced Level: Run Python Code on Your Machine'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级水平：在你的机器上运行Python代码
- en: This is useful if you want to make greater changes, but do not want to work
    with Jupyter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要做出更大的更改，但不想使用Jupyter，这将很有用。
- en: From the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html), check
    out the menu at the top. Select `Resources` $\rightarrow$ `Download Code`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看顶部的菜单。选择`资源` $\rightarrow$
    `下载代码`。
- en: This will download the Python code of the chapter as a single Python .py file,
    which you can save to your computer.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将下载该章节的Python代码作为一个单独的Python .py文件，你可以将其保存到你的电脑上。
- en: You can then open the file, edit it, and run it in your favorite Python environment
    to re-run the examples.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以打开文件，在你的首选Python环境中编辑并运行它以重新运行示例。
- en: Most importantly, you can [import it](Importing.html) into your own code and
    reuse functions, classes, and other resources.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最重要的是，你可以[导入它](Importing.html)到你的代码中并重用函数、类和其他资源。
- en: For help on Python, from the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html),
    check out the `Help` menu.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Python的帮助，从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看`帮助`菜单。
- en: 'Pro Level: Run Notebooks on Your Machine'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 高级水平：在你的机器上运行笔记本
- en: This is useful if you want to work with Jupyter on your machine. This will allow
    you to also run more complex examples, such as those with graphical output.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的机器上使用Jupyter，这将很有用。这将允许你运行更复杂的示例，例如带有图形输出的示例。
- en: From the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html), check
    out the menu at the top. Select `Resources` $\rightarrow$ `All Notebooks`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看顶部的菜单。选择`资源` $\rightarrow$
    `所有笔记本`。
- en: This will download all Jupyter Notebooks as a collection of `.ipynb` files,
    which you can save to your computer.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将下载所有Jupyter Notebook作为一个`.ipynb`文件的集合，你可以将其保存到你的电脑上。
- en: You can then open the notebooks in Jupyter Notebook or Jupyter Lab, edit them,
    and run them. To navigate across notebooks, open the notebook [`00_Table_of_Contents.ipynb`](00_Table_of_Contents.html).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以在Jupyter Notebook或Jupyter Lab中打开这些笔记本，编辑并运行它们。要导航到其他笔记本，请打开笔记本[`00_目录.ipynb`](00_Table_of_Contents.html)。
- en: You can also download individual notebooks using Select `Resources` $\rightarrow$
    `Download Notebook`. Running these, however, will require that you have the other
    notebooks downloaded already.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用`选择` `资源` $\rightarrow$ `下载笔记本`来下载单个笔记本。但是，运行这些笔记本需要你已经下载了其他笔记本。
- en: For help on Jupyter Notebooks, from the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html),
    check out the `Help` menu.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Jupyter Notebook的帮助，从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看`帮助`菜单。
- en: 'Boss Level: Contribute!'
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 老板级别：做出贡献！
- en: This is useful if you want to contribute to the book with patches or other material.
    It also gives you access to the very latest version of the book.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要通过补丁或其他材料为本书做出贡献，这将很有用。它还让你可以访问本书的最新版本。
- en: From the [Web Page](https://www.fuzzingbook.org/html/Intro_Testing.html), check
    out the menu at the top. Select `Resources` $\rightarrow$ `GitHub Repo`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[网页](https://www.fuzzingbook.org/html/Intro_Testing.html)中，查看顶部的菜单。选择`资源` $\rightarrow$
    `GitHub 仓库`。
- en: This will get you to the GitHub repository which contains all sources of the
    book, including the latest notebooks.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带你去包含本书所有源代码的GitHub仓库，包括最新的笔记本。
- en: You can then *clone* this repository to your disk, such that you get the latest
    and greatest.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以将此仓库克隆到你的磁盘上，这样你就能获得最新和最好的版本。
- en: You can report issues and suggest pull requests on the GitHub page.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在GitHub页面上报告问题并提出拉取请求。
- en: Updating the repository with `git pull` will get you updated.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `git pull` 更新仓库将使您获得更新。
- en: If you want to contribute code or text, check out the [Guide for Authors](Guide_for_Authors.html).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想贡献代码或文本，请查看[作者指南](Guide_for_Authors.html)。
- en: 'Exercise 2: Testing Shellsort'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 2：测试 Shellsort
- en: Consider the following implementation of a [Shellsort](https://en.wikipedia.org/wiki/Shellsort)
    function, taking a list of elements and (presumably) sorting it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 [Shellsort](https://en.wikipedia.org/wiki/Shellsort) 函数的实现，它接受一个元素列表并（可能）对其进行排序。
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A first test indicates that `shellsort()` might actually work:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次测试表明 `shellsort()` 实际上可能工作：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The implementation uses a *list* as argument `elems` (which it copies into
    `sorted_elems`) as well as for the fixed list `gaps`. Lists work like *arrays*
    in other languages:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 实现使用一个 *列表* 作为参数 `elems`（它将其复制到 `sorted_elems`）以及用于固定列表 `gaps`。列表在其他语言中像 *数组*
    一样工作：
- en: '[PRE62]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `range()` function returns an iterable list of elements. It is often used
    in conjunction with `for` loops, as in the above implementation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()` 函数返回一个包含元素的可迭代列表。它通常与 `for` 循环一起使用，如上述实现所示。'
- en: '[PRE64]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Part 1: Manual Test Cases'
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：手动测试用例
- en: Your job is now to thoroughly test `shellsort()` with a variety of inputs.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在的任务是彻底测试 `shellsort()` 的各种输入。
- en: First, set up `assert` statements with a number of manually written test cases.
    Select your test cases such that extreme cases are covered. Use `==` to compare
    two lists.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设置带有多个手动编写的测试用例的 `assert` 语句。选择测试用例以确保覆盖极端情况。使用 `==` 比较两个列表。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Part 2: Random Inputs'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：随机输入
- en: Second, create random lists as arguments to `shellsort()`. Make use of the following
    helper predicates to check whether the result is (a) sorted, and (b) a permutation
    of the original.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次，创建随机列表作为 `shellsort()` 的参数。利用以下辅助谓词来检查结果是否（a）已排序，以及（b）是否是原始列表的排列。
- en: '[PRE66]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Start with a random list generator, using `[]` as the empty list and `elems.append(x)`
    to append an element `x` to the list `elems`. Use the above helper functions to
    assess the results. Generate and test 1,000 lists.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个随机列表生成器开始，使用 `[]` 作为空列表，并使用 `elems.append(x)` 将元素 `x` 添加到列表 `elems` 中。使用上述辅助函数来评估结果。生成并测试
    1,000 个列表。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Exercise 3: Quadratic Solver'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：二次方程求解器
- en: Given an equation $ax^2 + bx + c = 0$, we want to find solutions for $x$ given
    the values of $a$, $b$, and $c$. The following code is supposed to do this, using
    the equation $$ x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个方程 $ax^2 + bx + c = 0$，我们希望找到 $x$ 的解，给定 $a$、$b$ 和 $c$ 的值。以下代码应该完成这个任务，使用方程
    $$ x = \frac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The above implementation is incomplete, though. You can trigger
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现是不完整的。您可以触发
- en: a division by zero; and
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个除以零的错误；并且
- en: violate the precondition of `my_sqrt_fixed()`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 违反 `my_sqrt_fixed()` 的先验条件。
- en: How does one do that, and how can one prevent this?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点，以及如何防止这种情况发生？
- en: 'Part 1: Find bug-triggering inputs'
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：寻找触发错误的输入
- en: For each of the two cases above, identify values for `a`, `b`, `c` that trigger
    the bug.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述两种情况中的每一种，确定 `a`、`b`、`c` 的值以触发错误。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Part 2: Fix the problem'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：修复问题
- en: Extend the code appropriately such that the cases are handled. Return `None`
    for nonexistent values.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 适当地扩展代码以处理这些情况。对于不存在的值返回 `None`。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Part 3: Odds and Ends'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第三部分：其他事项
- en: What are the chances of discovering these conditions with random inputs? Assuming
    one can do a billion tests per second, how long would one have to wait on average
    until a bug gets triggered?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 随机输入下发现这些条件的机会有多大？假设每秒可以进行十亿次测试，平均需要等待多长时间才能触发一个错误？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Exercise 4: To Infinity and Beyond'
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：无限与更远
- en: 'When we say that `my_sqrt_fixed(x)` works for all *finite* numbers $x$: What
    happens if you set $x$ to $\infty$ (infinity)? Try this out!'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`my_sqrt_fixed(x)`对所有*有限*数字$x$都有效时：如果你将$x$设置为$\infty$（无穷大），会发生什么？试一试！
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Intro_Testing.ipynb#Exercises)进行练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:06+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Intro_Testing.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)许可。内容的一部分源代码，以及用于格式化和显示该内容的源代码受[MIT
    许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)许可。最后更改日期：2023-11-11
    18:18:06+01:00。[引用](#citation) [版权信息](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用此作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Introduction to Software Testing](https://www.fuzzingbook.org/html/Intro_Testing.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Intro_Testing.html](https://www.fuzzingbook.org/html/Intro_Testing.html).
    Retrieved 2023-11-11 18:18:06+01:00.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈亚斯·策勒，拉胡尔·戈皮纳特，马塞尔·博hme，戈登·弗莱泽，以及克里斯蒂安·霍勒："[软件测试入门](https://www.fuzzingbook.org/html/Intro_Testing.html)"。在安德烈亚斯·策勒，拉胡尔·戈皮纳特，马塞尔·博hme，戈登·弗莱泽，以及克里斯蒂安·霍勒的《[模糊测试书](https://www.fuzzingbook.org/)[https://www.fuzzingbook.org/html/Intro_Testing.html](https://www.fuzzingbook.org/html/Intro_Testing.html)]中。检索日期：2023-11-11
    18:18:06+01:00。
- en: '[PRE75]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
