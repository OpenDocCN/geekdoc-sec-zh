- en: The Fuzzing Book
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试书籍
- en: 原文：[https://www.fuzzingbook.org/html/00_Table_of_Contents.html](https://www.fuzzingbook.org/html/00_Table_of_Contents.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://www.fuzzingbook.org/html/00_Table_of_Contents.html](https://www.fuzzingbook.org/html/00_Table_of_Contents.html)
- en: Sitemap
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网站地图
- en: 'While the chapters of this book can be read one after the other, there are
    many possible paths through the book. In this graph, an arrow *A* → *B* means
    that chapter *A* is a prerequisite for chapter *B*. You can pick arbitrary paths
    in this graph to get to the topics that interest you most:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这本书的章节可以依次阅读，但书中有许多可能的路径。在这个图中，箭头 *A* → *B* 表示章节 *A* 是章节 *B* 的先决条件。你可以选择任意路径来获取你最感兴趣的主题：
- en: '<svg width="1482pt" height="622pt" viewBox="0.00 0.00 1481.88 622.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 618)"><g
    id="node1" class="node"><title>Fuzzer</title> <g id="a_node1"><a xlink:href="Fuzzer.html"
    xlink:title="Fuzzing: Breaking Things with&nbsp;Random&nbsp;Inputs (Fuzzer)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="1482pt" height="622pt" viewBox="0.00 0.00 1481.88 622.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 618)"><g
    id="node1" class="node"><title>模糊器</title> <g id="a_node1"><a xlink:href="Fuzzer.html"
    xlink:title="模糊测试：使用随机输入破坏事物 (模糊器)
- en: 'In this chapter, we''ll start with one of the simplest test generation techniques.
    &nbsp;The key idea of random text generation, also known as fuzzing, is to feed
    a string of random characters into a program in the hope to uncover failures."><text
    text-anchor="middle" x="910.62" y="-516.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing: Breaking</text> <text text-anchor="middle"
    x="910.62" y="-498.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Things</text> <text text-anchor="middle" x="910.62" y="-480.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">with Random Inputs</text></a></g></g>
    <g id="node2" class="node"><title>Coverage</title> <g id="a_node2"><a xlink:href="Coverage.html"
    xlink:title="Code Coverage (Coverage)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从最简单的测试生成技术开始。随机文本生成，也称为模糊测试，的关键思想是将一串随机字符输入到程序中，希望揭露故障。《模糊测试：破坏》<text
    text-anchor="middle" x="910.62" y="-516.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">模糊测试：破坏</text> <text text-anchor="middle"
    x="910.62" y="-498.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">事物</text> <text text-anchor="middle" x="910.62" y="-480.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">使用随机输入</text></a></g></g>
    <g id="node2" class="node"><title>覆盖率</title> <g id="a_node2"><a xlink:href="Coverage.html"
    xlink:title="代码覆盖率 (Coverage)
- en: In the previous chapter, we introduced basic fuzzing – that is, generating random
    inputs to test programs. &nbsp;How do we measure the effectiveness of these tests?
    &nbsp;One way would be to check the number (and seriousness) of bugs found; but
    if bugs are scarce, we need a proxy for the likelihood of a test to uncover a
    bug. &nbsp;In this chapter, we introduce the concept of code coverage, measuring
    which parts of a program are actually executed during a test run. &nbsp;Measuring
    such coverage is also crucial for test generators that attempt to cover as much
    code as possible."><text text-anchor="middle" x="551.62" y="-329.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Code Coverage</text></a></g></g>
    <g id="edge1" class="edge"><title>Fuzzer->Coverage</title></g> <g id="node3" class="node"><title>SearchBasedFuzzer</title>
    <g id="a_node3"><a xlink:href="SearchBasedFuzzer.html" xlink:title="Search-Based
    Fuzzing (SearchBasedFuzzer)
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了基本的模糊测试——即生成随机输入来测试程序。&nbsp;我们如何衡量这些测试的有效性？&nbsp;一种方法就是检查找到的（数量和严重性）错误；但如果错误很少，我们需要一个代理来衡量测试发现错误的概率。&nbsp;在本章中，我们引入了代码覆盖的概念，测量在测试运行期间程序的实际执行部分。&nbsp;对于试图覆盖尽可能多代码的测试生成器来说，测量这种覆盖率也是至关重要的。《代码覆盖率</text></a></g></g>
    <g id="edge1" class="edge"><title>模糊器->覆盖率</title></g> <g id="node3" class="node"><title>基于搜索的模糊器</title>
    <g id="a_node3"><a xlink:href="SearchBasedFuzzer.html" xlink:title="基于搜索的模糊测试
    (SearchBasedFuzzer)
- en: Sometimes we are not only interested in fuzzing as many as possible diverse
    program inputs, but in deriving specific test inputs that achieve some objective,
    such as reaching specific statements in a program. When we have an idea of what
    we are looking for, then we can search for it. Search algorithms are at the core
    of computer science, but applying classic search algorithms like breadth or depth
    first search to search for tests is unrealistic, because these algorithms potentially
    require us to look at all possible inputs. However, domain-knowledge can be used
    to overcome this problem. For example, if we can estimate which of several program
    inputs is closer to the one we are looking for, then this information can guide
    us to reach the target quicker – this information is known as a heuristic. The
    way heuristics are applied systematically is captured in meta-heuristic search
    algorithms. The &quot;meta&quot; denotes that these algorithms are generic and
    can be instantiated differently to different problems. Meta-heuristics often take
    inspiration from processes observed in nature. For example, there are algorithms
    mimicking evolutionary processes, swarm intelligence, or chemical reactions. In
    general, they are much more efficient than exhaustive search approaches such that
    they can be applied to vast search spaces – search spaces as vast as the domain
    of program inputs are no problem for them."><text text-anchor="middle" x="768.62"
    y="-409.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Search-Based
    Fuzzing</text></a></g></g> <g id="edge2" class="edge"><title>Fuzzer->SearchBasedFuzzer</title></g>
    <g id="node4" class="node"><title>Grammars</title> <g id="a_node4"><a xlink:href="Grammars.html"
    xlink:title="Fuzzing with Grammars (Grammars)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们不仅对模糊测试尽可能多的不同程序输入感兴趣，还希望推导出能够实现某些目标的特定测试输入，例如到达程序中的特定语句。当我们有了我们想要寻找的东西的概念时，我们就可以去寻找它。搜索算法是计算机科学的核心，但将经典搜索算法如广度优先搜索或深度优先搜索应用于测试搜索是不切实际的，因为这些算法可能需要我们查看所有可能的输入。然而，领域知识可以用来克服这个问题。例如，如果我们能够估计几个程序输入中哪一个更接近我们正在寻找的，那么这些信息可以引导我们更快地达到目标——这种信息被称为启发式。启发式系统地应用的方式被元启发式搜索算法所捕捉。"元"表示这些算法是通用的，并且可以根据不同的问题实例化。元启发式通常从自然界观察到的过程中获得灵感。例如，有一些算法模仿进化过程、群体智能或化学反应。总的来说，它们比穷举搜索方法更有效率，因此可以应用于广阔的搜索空间——对于它们来说，程序输入领域的广阔搜索空间不是问题。《基于搜索的模糊测试》</text></a></g></g>
    <g id="edge2" class="edge"><title>Fuzzer->SearchBasedFuzzer</title></g> <g id="node4"
    class="node"><title>语法</title> <g id="a_node4"><a xlink:href="Grammars.html" xlink:title="使用语法进行模糊测试
    (Grammars)
- en: In the chapter on &quot;Mutation-Based Fuzzing&quot;, we have seen how to use
    extra hints – such as sample input files –&nbsp;to speed up test generation. &nbsp;In
    this chapter, we take this idea one step further, by providing a specification
    of the legal inputs to a program. &nbsp;Specifying inputs via a grammar allows
    for very systematic and efficient test generation, in particular for complex input
    formats. &nbsp;Grammars also serve as the base for configuration fuzzing, API
    fuzzing, GUI fuzzing, and many more."><text text-anchor="middle" x="910.62" y="-418.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing
    with</text> <text text-anchor="middle" x="910.62" y="-400.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text></a></g></g>
    <g id="edge3" class="edge"><title>Fuzzer->Grammars</title></g> <g id="node5" class="node"><title>SymbolicFuzzer</title>
    <g id="a_node5"><a xlink:href="SymbolicFuzzer.html" xlink:title="Symbolic Fuzzing
    (SymbolicFuzzer)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在“基于变异的模糊测试”章节中，我们看到了如何使用额外的提示——例如样本输入文件——来加速测试生成。在本章中，我们将这一想法进一步发展，通过提供程序合法输入的规范。通过语法指定输入可以实现非常系统和高效的测试生成，特别是在复杂的输入格式中。语法还作为配置模糊测试、API模糊测试、GUI模糊测试等的基础。《使用语法进行模糊测试》</text></a></g></g>
    <g id="edge3" class="edge"><title>Fuzzer->Grammars</title></g> <g id="node5" class="node"><title>SymbolicFuzzer</title>
    <g id="a_node5"><a xlink:href="SymbolicFuzzer.html" xlink:title="符号模糊测试 (SymbolicFuzzer)
- en: One of the problems with traditional methods of fuzzing is that they fail to
    exercise all the possible behaviors that a system can have, especially when the
    input space is large. Quite often the execution of a specific branch of execution
    may happen only with very specific inputs, which could represent a minimal fraction
    of the input space. The traditional fuzzing methods relies on chance to produce
    inputs they need. However, relying on randomness to generate values that we want
    is a bad idea when the space to be explored is huge. For example, a function that
    accepts a string, even if one only considers the first $10$ characters, already
    has $2^{80}$ possible inputs. If one is looking for a specific string, random
    generation of values will take a few thousand years even in one of the super computers."><text
    text-anchor="middle" x="1038.62" y="-409.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Symbolic Fuzzing</text></a></g></g>
    <g id="edge4" class="edge"><title>Fuzzer->SymbolicFuzzer</title></g> <g id="node6"
    class="node"><title>FuzzingInTheLarge</title> <g id="a_node6"><a xlink:href="FuzzingInTheLarge.html"
    xlink:title="Fuzzing in the Large (FuzzingInTheLarge)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 传统模糊测试方法的一个问题是，它们无法测试系统可能具有的所有可能行为，尤其是在输入空间很大时。很多时候，特定执行分支的执行可能只发生在非常特定的输入下，这可能只占输入空间的一小部分。传统的模糊测试方法依赖于偶然来产生所需的输入。然而，当要探索的空间很大时，依赖于随机生成我们想要的值是一个坏主意。例如，一个接受字符串的函数，即使只考虑前10个字符，也有$2^{80}$种可能的输入。如果寻找特定的字符串，即使在超级计算机上，随机生成值也需要几千年。《符号模糊测试</a></g></g>
    <g id="edge4" class="edge"><title>Fuzzer->SymbolicFuzzer</title></g> <g id="node6"
    class="node"><title>大规模模糊测试</title> <g id="a_node6"><a xlink:href="FuzzingInTheLarge.html"
    xlink:title="大规模模糊测试（FuzzingInTheLarge）
- en: In the past chapters, we have always looked at fuzzing taking place on one machine
    for a few seconds only. &nbsp;In the real world, however, fuzzers are run on dozens
    or even thousands of machines; for hours, days and weeks; for one program or dozens
    of programs. &nbsp;In such contexts, one needs an infrastructure to collect failure
    data from the individual fuzzer runs, and to aggregate such data in a central
    repository. &nbsp;In this chapter, we will examine such an infrastructure, the
    FuzzManager framework from Mozilla."><text text-anchor="middle" x="1188.62" y="-409.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing
    in the Large</text></a></g></g> <g id="edge5" class="edge"><title>Fuzzer->FuzzingInTheLarge</title></g>
    <g id="node8" class="node"><title>MutationFuzzer</title> <g id="a_node8"><a xlink:href="MutationFuzzer.html"
    xlink:title="Mutation-Based Fuzzing (MutationFuzzer)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们总是只关注几秒钟内在一台机器上进行的模糊测试。然而，在现实世界中，模糊测试通常在数十甚至数千台机器上运行；持续数小时、数天甚至数周；针对一个或数十个程序。在这种情况下，需要一个基础设施来收集单个模糊测试运行中的故障数据，并将这些数据汇总到中央存储库中。在本章中，我们将探讨这样一个基础设施，即来自Mozilla的FuzzManager框架。《大规模模糊测试</a></g></g>
    <g id="edge5" class="edge"><title>Fuzzer->FuzzingInTheLarge</title></g> <g id="node8"
    class="node"><title>变异模糊测试器</title> <g id="a_node8"><a xlink:href="MutationFuzzer.html"
    xlink:title="基于变异的模糊测试（变异模糊测试器）
- en: Most randomly generated inputs are syntactically invalid and thus are quickly
    rejected by the processing program. &nbsp;To exercise functionality beyond input
    processing, we must increase chances to obtain valid inputs. &nbsp;One such way
    is so-called mutational fuzzing –&nbsp;that is, introducing small changes to existing
    inputs that may still keep the input valid, yet exercise new behavior. &nbsp;We
    show how to create such mutations, and how to guide them towards yet uncovered
    code, applying central concepts from the popular AFL fuzzer."><text text-anchor="middle"
    x="551.62" y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Mutation-Based</text> <text text-anchor="middle" x="551.62" y="-240.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing</text></a></g></g>
    <g id="edge7" class="edge"><title>Coverage->MutationFuzzer</title></g> <g id="node9"
    class="node"><title>MutationAnalysis</title> <g id="a_node9"><a xlink:href="MutationAnalysis.html"
    xlink:title="Mutation Analysis (MutationAnalysis)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数随机生成的输入在语法上都是无效的，因此很快就会被处理程序拒绝。为了在输入处理之外锻炼功能，我们必须增加获得有效输入的机会。其中一种方法就是所谓的突变模糊测试——也就是说，对现有输入进行微小修改，这些修改可能仍然保持输入的有效性，同时测试新的行为。我们展示了如何创建这样的突变，以及如何引导它们指向尚未发现的代码，应用了流行的AFL模糊器中的核心概念。《基于突变的模糊测试》<text
    text-anchor="middle" x="551.62" y="-258.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Mutation-Based</text> <text text-anchor="middle"
    x="551.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Fuzzing</text></a></g></g> <g id="edge7" class="edge"><title>Coverage->MutationFuzzer</title></g>
    <g id="node9" class="node"><title>MutationAnalysis</title> <g id="a_node9"><a
    xlink:href="MutationAnalysis.html" xlink:title="Mutation Analysis (MutationAnalysis)
- en: 'In the chapter on coverage, we showed how one can identify which parts of the
    program are executed by a program, and hence get a sense of the effectiveness
    of a set of test cases in covering the program structure. &nbsp;However, coverage
    alone may not be the best measure for the effectiveness of a test, as one can
    have great coverage without ever checking a result for correctness. &nbsp;In this
    chapter, we introduce another means for assessing the effectiveness of a test
    suite: After injecting mutations – artificial faults – into the code, we check
    whether a test suite can detect these artificial faults. &nbsp;The idea is that
    if it fails to detect such mutations, it will also miss real bugs."><text text-anchor="middle"
    x="235.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Mutation Analysis</text></a></g></g> <g id="edge8" class="edge"><title>Coverage->MutationAnalysis</title></g>
    <g id="node10" class="node"><title>GrammarCoverageFuzzer</title> <g id="a_node10"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="Grammar Coverage (GrammarCoverageFuzzer)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于覆盖率的章节中，我们展示了如何确定程序中哪些部分被执行，从而了解一组测试用例在覆盖程序结构方面的有效性。然而，覆盖率本身可能不是衡量测试有效性的最佳指标，因为即使没有检查结果是否正确，也可能有很高的覆盖率。在本章中，我们介绍了一种评估测试套件有效性的另一种方法：在代码中注入突变——人工错误后，我们检查测试套件是否能够检测到这些人工错误。其理念是，如果它未能检测到这样的突变，它也会错过真实的错误。《突变分析》<text
    text-anchor="middle" x="235.62" y="-249.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Mutation Analysis</text></a></g></g>
    <g id="edge8" class="edge"><title>Coverage->MutationAnalysis</title></g> <g id="node10"
    class="node"><title>GrammarCoverageFuzzer</title> <g id="a_node10"><a xlink:href="GrammarCoverageFuzzer.html"
    xlink:title="Grammar Coverage (GrammarCoverageFuzzer)
- en: Producing inputs from grammars gives all possible expansions of a rule the same
    likelihood. &nbsp;For producing a comprehensive test suite, however, it makes
    more sense to maximize variety – for instance, by not repeating the same expansions
    over and over again. &nbsp;In this chapter, we explore how to systematically cover
    elements of a grammar such that we maximize variety and do not miss out individual
    elements."><text text-anchor="middle" x="1039.62" y="-249.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammar Coverage</text></a></g></g>
    <g id="edge9" class="edge"><title>Coverage->GrammarCoverageFuzzer</title></g>
    <g id="node11" class="node"><title>ProbabilisticGrammarFuzzer</title> <g id="a_node11"><a
    xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="Probabilistic Grammar
    Fuzzing (ProbabilisticGrammarFuzzer)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从语法中生成输入使得一个规则的每个可能的扩展都有相同的可能性。然而，为了生成一个全面的测试套件，最大化多样性更有意义——例如，通过避免重复相同的扩展。在本章中，我们探讨了如何系统地覆盖语法的元素，以最大化多样性并确保不遗漏任何单个元素。《语法覆盖率》（Grammar
    Coverage）</text> <a xlink:href="GrammarCoverageFuzzer.html" xlink:title="Grammar
    Coverage Fuzzer"><text text-anchor="middle" x="1039.62" y="-249.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">语法覆盖率</text></a></g></g>
    <g id="edge9" class="edge"><title>覆盖率->语法覆盖率模糊测试器</title></g> <g id="node11" class="node"><title>ProbabilisticGrammarFuzzer</title>
    <g id="a_node11"><a xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="概率语法模糊测试
    (ProbabilisticGrammarFuzzer)
- en: Let us give grammars even more power by assigning probabilities to individual
    expansions. &nbsp;This allows us to control how many of each element should be
    produced, and thus allows us to target our generated tests towards specific functionality.
    &nbsp;We also show how to learn such probabilities from given sample inputs, and
    specifically direct our tests towards input features that are uncommon in these
    samples."><text text-anchor="middle" x="409.62" y="-178.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Probabilistic</text>
    <text text-anchor="middle" x="409.62" y="-160.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Grammar Fuzzing</text></a></g></g>
    <g id="edge10" class="edge"><title>Coverage->ProbabilisticGrammarFuzzer</title></g>
    <g id="node12" class="node"><title>ConcolicFuzzer</title> <g id="a_node12"><a
    xlink:href="ConcolicFuzzer.html" xlink:title="Concolic Fuzzing (ConcolicFuzzer)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为单个扩展分配概率来赋予语法更多的能力。这使我们能够控制每种元素应该产生多少，从而允许我们将生成的测试针对特定的功能。我们还展示了如何从给定的样本输入中学习这样的概率，并特别将我们的测试针对这些样本中不常见的输入特征。《概率语法模糊测试》（Probabilistic
    Grammar Fuzzing）</text> <text text-anchor="middle" x="409.62" y="-160.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">概率语法模糊测试</text></a></g></g>
    <g id="edge10" class="edge"><title>覆盖率->概率语法模糊测试器</title></g> <g id="node12" class="node"><title>ConcolicFuzzer</title>
    <g id="a_node12"><a xlink:href="ConcolicFuzzer.html" xlink:title="Concolic Fuzzing
    (ConcolicFuzzer)
- en: In the chapter on information flow, we have seen how one can use dynamic taints
    to produce more intelligent test cases than simply looking for program crashes.
    We have also seen how one can use the taints to update the grammar, and hence
    focus more on the dangerous methods."><text text-anchor="middle" x="892.62" y="-89.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Concolic
    Fuzzing</text></a></g></g> <g id="edge11" class="edge"><title>Coverage->ConcolicFuzzer</title></g>
    <g id="node13" class="node"><title>DynamicInvariants</title> <g id="a_node13"><a
    xlink:href="DynamicInvariants.html" xlink:title="Mining Function Specifications
    (DynamicInvariants)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息流章节中，我们看到了如何使用动态污点来生成比仅仅寻找程序崩溃更智能的测试用例。我们还看到了如何使用污点来更新语法，从而更专注于危险的方法。《动态不变量》（DynamicInvariants）</text>
    <a xlink:href="DynamicInvariants.html" xlink:title="挖掘函数规范 (DynamicInvariants)"><text
    text-anchor="middle" x="892.62" y="-89.7" font-family="Patua One, Helvetica, sans-serif"
    font-size="14.00" fill="#b03a2e">动态不变量</text></a></g></g> <g id="edge11" class="edge"><title>覆盖率->ConcolicFuzzer</title></g>
    <g id="node13" class="node"><title>DynamicInvariants</title> <g id="a_node13"><a
    xlink:href="DynamicInvariants.html" xlink:title="挖掘函数规范 (DynamicInvariants)"><text
    text-anchor="middle" x="1039.62" y="-249.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">动态不变量</text></a></g></g>
- en: When testing a program, one not only needs to cover its several behaviors; one
    also needs to check whether the result is as expected. &nbsp;In this chapter,
    we introduce a technique that allows us to mine function specifications from a
    set of given executions, resulting in abstract and formal descriptions of what
    the function expects and what it delivers."><text text-anchor="middle" x="415.62"
    y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mining
    Function</text> <text text-anchor="middle" x="415.62" y="-240.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Specifications</text></a></g></g>
    <g id="edge12" class="edge"><title>Coverage->DynamicInvariants</title></g> <g
    id="node14" class="node"><title>PythonFuzzer</title> <g id="a_node14"><a xlink:href="PythonFuzzer.html"
    xlink:title="Testing Compilers (PythonFuzzer)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试一个程序时，不仅需要覆盖其多种行为；还需要检查结果是否符合预期。在本章中，我们介绍了一种技术，使我们能够从一组给定的执行中挖掘函数规范，从而得到函数期望和提供的形式化和抽象描述。"><text
    text-anchor="middle" x="415.62" y="-258.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">挖掘函数</text> <text text-anchor="middle"
    x="415.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">规范</text></a></g></g> <g id="edge12" class="edge"><title>Coverage->DynamicInvariants</title></g>
    <g id="node14" class="node"><title>PythonFuzzer</title> <g id="a_node14"><a xlink:href="PythonFuzzer.html"
    xlink:title="测试编译器 (PythonFuzzer)
- en: In this chapter, we will make use of grammars and grammar-based testing to systematically
    generate program code –&nbsp;for instance, to test a compiler or an interpreter.
    Not very surprisingly, we use Python and the Python interpreter as our domain."><text
    text-anchor="middle" x="729.62" y="-249.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Testing Compilers</text></a></g></g>
    <g id="edge13" class="edge"><title>Coverage->PythonFuzzer</title></g> <g id="node15"
    class="node"><title>WhenToStopFuzzing</title> <g id="a_node15"><a xlink:href="WhenToStopFuzzing.html"
    xlink:title="When To Stop Fuzzing (WhenToStopFuzzing)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用语法和基于语法的测试来系统地生成程序代码——例如，用于测试编译器或解释器。不出所料，我们使用Python和Python解释器作为我们的领域。"><text
    text-anchor="middle" x="729.62" y="-249.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">测试编译器</text></a></g></g> <g id="edge13"
    class="edge"><title>Coverage->PythonFuzzer</title></g> <g id="node15" class="node"><title>WhenToStopFuzzing</title>
    <g id="a_node15"><a xlink:href="WhenToStopFuzzing.html" xlink:title="何时停止模糊测试
    (WhenToStopFuzzing)
- en: 'In the past chapters, we have discussed several fuzzing techniques. &nbsp;Knowing
    what to do is important, but it is also important to know when to stop doing things.
    &nbsp;In this chapter, we will learn when to stop fuzzing –&nbsp;and use a prominent
    example for this purpose: The Enigma machine that was used in the second world
    war by the navy of Nazi Germany to encrypt communications, and how Alan Turing
    and I.J. Good used fuzzing techniques to crack ciphers for the Naval Enigma machine."><text
    text-anchor="middle" x="76.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif"
    font-size="14.00" fill="#b03a2e">When To Stop Fuzzing</text></a></g></g> <g id="edge14"
    class="edge"><title>Coverage->WhenToStopFuzzing</title></g> <g id="node18" class="node"><title>GrammarFuzzer</title>
    <g id="a_node18"><a xlink:href="GrammarFuzzer.html" xlink:title="Efficient Grammar
    Fuzzing (GrammarFuzzer)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了几种模糊测试技术。知道该做什么很重要，但知道何时停止做某事也同样重要。在本章中，我们将学习何时停止模糊测试——并为此目的使用一个突出的例子：第二次世界大战中纳粹德国海军使用的恩尼格玛机来加密通信，以及艾伦·图灵和I.J.古德如何使用模糊测试技术破解海军恩尼格玛机的密码。"><text
    text-anchor="middle" x="76.62" y="-249.7" font-family="Patua One, Helvetica, sans-serif"
    font-size="14.00" fill="#b03a2e">何时停止模糊测试</text></a></g></g> <g id="edge14" class="edge"><title>Coverage->WhenToStopFuzzing</title></g>
    <g id="node18" class="node"><title>GrammarFuzzer</title> <g id="a_node18"><a xlink:href="GrammarFuzzer.html"
    xlink:title="高效的语法模糊测试 (GrammarFuzzer)
- en: In the chapter on grammars, we have seen how to use grammars for very effective
    and efficient testing. &nbsp;In this chapter, we refine the previous string-based
    algorithm into a tree-based algorithm, which is much faster and allows for much
    more control over the production of fuzz inputs."><text text-anchor="middle" x="970.62"
    y="-338.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Efficient
    Grammar</text> <text text-anchor="middle" x="970.62" y="-320.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing</text></a></g></g>
    <g id="edge17" class="edge"><title>Grammars->GrammarFuzzer</title></g> <g id="node7"
    class="node"><title>Intro_Testing</title> <g id="a_node7"><a xlink:href="Intro_Testing.html"
    xlink:title="Introduction to Software Testing (Intro_Testing)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于语法的章节中，我们看到了如何使用语法进行非常有效和高效的测试。在本章中，我们将之前基于字符串的算法精炼为基于树的算法，这要快得多，并且允许对模糊输入的生产有更多的控制。"><text
    text-anchor="middle" x="970.62" y="-338.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">高效语法</text> <text text-anchor="middle"
    x="970.62" y="-320.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">模糊测试</text></a></g></g> <g id="edge17" class="edge"><title>Grammars->GrammarFuzzer</title></g>
    <g id="node7" class="node"><title>Intro_Testing</title> <g id="a_node7"><a xlink:href="Intro_Testing.html"
    xlink:title="软件测试入门（Intro_Testing）
- en: Before we get to the central parts of the book, let us introduce essential concepts
    of software testing. &nbsp;Why is it necessary to test software at all? &nbsp;How
    does one test software? &nbsp;How can one tell whether a test has been successful?
    &nbsp;How does one know if one has tested enough? &nbsp;In this chapter, let us
    recall the most important concepts, and at the same time get acquainted with Python
    and interactive notebooks."><text text-anchor="middle" x="910.62" y="-596.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Introduction to</text>
    <text text-anchor="middle" x="910.62" y="-578.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Software Testing</text></a></g></g>
    <g id="edge6" class="edge"><title>Intro_Testing->Fuzzer</title></g> <g id="node16"
    class="node"><title>GreyboxFuzzer</title> <g id="a_node16"><a xlink:href="GreyboxFuzzer.html"
    xlink:title="Greybox Fuzzing (GreyboxFuzzer)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本书的核心部分之前，让我们介绍软件测试的基本概念。为什么需要测试软件？如何测试软件？如何判断测试是否成功？如何知道是否测试得足够？在本章中，让我们回顾最重要的概念，同时熟悉Python和交互式笔记本。"><text
    text-anchor="middle" x="910.62" y="-596.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">软件测试入门</text> <text text-anchor="middle"
    x="910.62" y="-578.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">软件测试</text></a></g></g> <g id="edge6" class="edge"><title>Intro_Testing->Fuzzer</title></g>
    <g id="node16" class="node"><title>GreyboxFuzzer</title> <g id="a_node16"><a xlink:href="GreyboxFuzzer.html"
    xlink:title="灰盒模糊测试（GreyboxFuzzer）
- en: In the previous chapter, we have introduced mutation-based fuzzing, a technique
    that generates fuzz inputs by applying small mutations to given inputs. In this
    chapter, we show how to guide these mutations towards specific goals such as coverage.
    The algorithms in this chapter stem from the popular American Fuzzy Lop (AFL)
    fuzzer, in particular from its AFLFast and AFLGo flavors. We will explore the
    greybox fuzzing algorithm behind AFL and how we can exploit it to solve various
    problems for automated vulnerability detection."><text text-anchor="middle" x="550.62"
    y="-169.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Greybox
    Fuzzing</text></a></g></g> <g id="edge15" class="edge"><title>MutationFuzzer->GreyboxFuzzer</title></g>
    <g id="node24" class="node"><title>GrammarMiner</title> <g id="a_node24"><a xlink:href="GrammarMiner.html"
    xlink:title="Mining Input Grammars (GrammarMiner)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了基于变异的模糊测试技术，这是一种通过在给定输入上应用小变异来生成模糊输入的技术。在本章中，我们展示了如何引导这些变异以实现特定目标，例如覆盖率。本章中的算法源自流行的美国模糊跳蚤（AFL）模糊器，特别是其AFLFast和AFLGo版本。我们将探索AFL背后的灰盒模糊测试算法，以及我们如何利用它来解决自动化漏洞检测的各种问题。《灰盒模糊测试》（Greybox
    Fuzzing）</a></g></g> <g id="edge15" class="edge"><title>MutationFuzzer->GreyboxFuzzer</title></g>
    <g id="node24" class="node"><title>GrammarMiner</title> <g id="a_node24"><a xlink:href="GrammarMiner.html"
    xlink:title="挖掘输入语法（GrammarMiner）
- en: So far, the grammars we have seen have been mostly specified manually – that
    is, you (or the person knowing the input format) had to design and write a grammar
    in the first place. &nbsp;While the grammars we have seen so far have been rather
    simple, creating a grammar for complex inputs can involve quite some effort. &nbsp;In
    this chapter, we therefore introduce techniques that automatically mine grammars
    from programs – by executing the programs and observing how they process which
    parts of the input. &nbsp;In conjunction with a grammar fuzzer, this allows us
    to
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的语法大多是手动指定的——也就是说，你必须（或者知道输入格式的人）首先设计和编写一个语法。虽然我们迄今为止看到的语法相对简单，但为复杂输入创建语法可能需要相当多的努力。因此，在本章中，我们介绍了从程序中自动挖掘语法的技巧——通过执行程序并观察它们如何处理输入的哪些部分。与语法模糊器结合使用，这使我们能够
- en: 1\. take a program,
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 选择一个程序，
- en: 2\. extract its input grammar, and
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 提取其输入语法，
- en: 3\. fuzz it with high efficiency and effectiveness, using the concepts in this
    book."><text text-anchor="middle" x="1050.62" y="-98.7" font-family="Patua One,
    Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Mining Input</text> <text
    text-anchor="middle" x="1050.62" y="-80.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text></a></g></g> <g id="edge25"
    class="edge"><title>GrammarCoverageFuzzer->GrammarMiner</title></g> <g id="node25"
    class="node"><title>ConfigurationFuzzer</title> <g id="a_node25"><a xlink:href="ConfigurationFuzzer.html"
    xlink:title="Testing Configurations (ConfigurationFuzzer)
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本书中的概念以高效率和效果进行模糊处理。"><text text-anchor="middle" x="1050.62" y="-98.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">挖掘输入</text> <text
    text-anchor="middle" x="1050.62" y="-80.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">语法</text></a></g></g> <g id="edge25"
    class="edge"><title>GrammarCoverageFuzzer->GrammarMiner</title></g> <g id="node25"
    class="node"><title>ConfigurationFuzzer</title> <g id="a_node25"><a xlink:href="ConfigurationFuzzer.html"
    xlink:title="测试配置（ConfigurationFuzzer）
- en: The behavior of a program is not only governed by its data. &nbsp;The configuration
    of a program – that is, the settings that govern the execution of a program on
    its (regular) input data, as set by options or configuration files – just as well
    influences behavior, and thus can and should be tested. &nbsp;In this chapter,
    we explore how to systematically test and cover software configurations. &nbsp;By
    automatically inferring configuration options, we can apply these techniques out
    of the box, with no need for writing a grammar. &nbsp;Finally, we show how to
    systematically cover combinations of configuration options, quickly detecting
    unwanted interferences."><text text-anchor="middle" x="1039.62" y="-178.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing</text> <text
    text-anchor="middle" x="1039.62" y="-160.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Configurations</text></a></g></g>
    <g id="edge26" class="edge"><title>GrammarCoverageFuzzer->ConfigurationFuzzer</title></g>
    <g id="node26" class="node"><title>Carver</title> <g id="a_node26"><a xlink:href="Carver.html"
    xlink:title="Carving Unit Tests (Carver)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的行为不仅受其数据控制。程序配置——即控制程序在其（常规）输入数据上执行设置的选项或配置文件——同样会影响行为，因此可以也应该进行测试。在本章中，我们探讨了如何系统地测试和覆盖软件配置。通过自动推断配置选项，我们可以直接应用这些技术，无需编写语法。最后，我们展示了如何系统地覆盖配置选项的组合，快速检测不希望出现的干扰。"><text
    text-anchor="middle" x="1039.62" y="-178.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">测试</text> <text text-anchor="middle"
    x="1039.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">配置</text></a></g></g> <g id="edge26" class="edge"><title>GrammarCoverageFuzzer->ConfigurationFuzzer</title></g>
    <g id="node26" class="node"><title>Carver</title> <g id="a_node26"><a xlink:href="Carver.html"
    xlink:title="切割单元测试（Carver）
- en: So far, we have always generated system input, i.e. data that the program as
    a whole obtains via its input channels. &nbsp;If we are interested in testing
    only a small set of functions, having to go through the system can be very inefficient.
    &nbsp;This chapter introduces a technique known as carving, which, given a system
    test, automatically extracts a set of unit tests that replicate the calls seen
    during the system test. &nbsp;The key idea is to record such calls such that we
    can replay them later –&nbsp;as a whole or selectively. &nbsp;On top, we also
    explore how to synthesize API grammars from carved unit tests; this means that
    we can synthesize API tests without having to write a grammar at all."><text text-anchor="middle"
    x="878.62" y="-13.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Carving Unit Tests</text></a></g></g> <g id="edge27" class="edge"><title>GrammarCoverageFuzzer->Carver</title></g>
    <g id="node27" class="node"><title>GUIFuzzer</title> <g id="a_node27"><a xlink:href="GUIFuzzer.html"
    xlink:title="Testing Graphical User Interfaces (GUIFuzzer)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直生成系统输入，即程序整体通过其输入通道获得的数据。如果我们只对测试一小组函数感兴趣，必须通过系统进行测试可能会非常低效。本章介绍了一种称为雕刻的技术，给定一个系统测试，自动提取一组单元测试，这些测试复制了系统测试期间看到的调用。关键思想是记录这些调用，以便我们可以在以后重新播放它们——整体或选择性地。此外，我们还探讨了如何从雕刻的单元测试中合成API语法；这意味着我们可以合成API测试，而无需编写任何语法。"><text
    text-anchor="middle" x="878.62" y="-13.7" font-family="Patua One, Helvetica, sans-serif"
    font-size="14.00" fill="#b03a2e">雕刻单元测试</text></a></g></g> <g id="edge27" class="edge"><title>语法覆盖率模糊器->雕刻器</title></g>
    <g id="node27" class="node"><title>GUI模糊器</title> <g id="a_node27"><a xlink:href="GUIFuzzer.html"
    xlink:title="测试图形用户界面（GUIFuzzer）
- en: In this chapter, we explore how to generate tests for Graphical User Interfaces
    (GUIs), abstracting from our previous examples on Web testing. &nbsp;Building
    on general means to extract user interface elements and activate them, our techniques
    generalize to arbitrary graphical user interfaces, from rich Web applications
    to mobile apps, and systematically explore user interfaces through forms and navigation
    elements."><text text-anchor="middle" x="1338.62" y="-178.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing Graphical</text>
    <text text-anchor="middle" x="1338.62" y="-160.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">User Interfaces</text></a></g></g>
    <g id="edge28" class="edge"><title>GrammarCoverageFuzzer->GUIFuzzer</title></g>
    <g id="node29" class="node"><title>APIFuzzer</title> <g id="a_node29"><a xlink:href="APIFuzzer.html"
    xlink:title="Fuzzing APIs (APIFuzzer)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨如何为图形用户界面（GUI）生成测试，从我们之前的Web测试示例中抽象出来。基于提取用户界面元素和激活它们的一般方法，我们的技术可以推广到任意图形用户界面，从富Web应用到移动应用，并通过表单和导航元素系统地探索用户界面。"><text
    text-anchor="middle" x="1338.62" y="-178.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">测试图形用户界面</text> <text text-anchor="middle"
    x="1338.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">（Testing Graphical User Interfaces）</text></a></g></g> <g id="edge28"
    class="edge"><title>语法覆盖率模糊器->GUI模糊器</title></g> <g id="node29" class="node"><title>API模糊器</title>
    <g id="a_node29"><a xlink:href="APIFuzzer.html" xlink:title="模糊化API（APIFuzzer）
- en: So far, we have always generated system input, i.e. data that the program as
    a whole obtains via its input channels. &nbsp;However, we can also generate inputs
    that go directly into individual functions, gaining flexibility and speed in the
    process. &nbsp;In this chapter, we explore the use of grammars to synthesize code
    for function calls, which allows you to generate program code that very efficiently
    invokes functions directly."><text text-anchor="middle" x="598.62" y="-89.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing APIs</text></a></g></g>
    <g id="edge32" class="edge"><title>ProbabilisticGrammarFuzzer->APIFuzzer</title></g>
    <g id="node17" class="node"><title>GreyboxGrammarFuzzer</title> <g id="a_node17"><a
    xlink:href="GreyboxGrammarFuzzer.html" xlink:title="Greybox Fuzzing with Grammars
    (GreyboxGrammarFuzzer)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直生成系统输入，即程序整体通过其输入通道获得的数据。然而，我们也可以生成直接进入单个函数的输入，在这个过程中获得灵活性和速度。在本章中，我们探讨使用语法来合成函数调用代码，这使得你可以生成非常高效地直接调用函数的程序代码。"><text
    text-anchor="middle" x="598.62" y="-89.7" font-family="Patua One, Helvetica, sans-serif"
    font-size="14.00" fill="#b03a2e">模糊化API</text></a></g></g> <g id="edge32" class="edge"><title>概率语法模糊器->API模糊器</title></g>
    <g id="node17" class="node"><title>灰盒语法模糊器</title> <g id="a_node17"><a xlink:href="GreyboxGrammarFuzzer.html"
    xlink:title="使用语法进行灰盒模糊化（灰盒语法模糊器）
- en: In this chapter, we introduce important extensions to our syntactic fuzzing
    techniques, all leveraging syntactic parts of existing inputs."><text text-anchor="middle"
    x="739.62" y="-98.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Greybox Fuzzing with</text> <text text-anchor="middle" x="739.62"
    y="-80.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Grammars</text></a></g></g>
    <g id="edge16" class="edge"><title>GreyboxFuzzer->GreyboxGrammarFuzzer</title></g>
    <g id="edge18" class="edge"><title>GrammarFuzzer->GrammarCoverageFuzzer</title></g>
    <g id="edge23" class="edge"><title>GrammarFuzzer->PythonFuzzer</title></g> <g
    id="node19" class="node"><title>Parser</title> <g id="a_node19"><a xlink:href="Parser.html"
    xlink:title="Parsing Inputs (Parser)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了对我们句法模糊技术的重要扩展，所有这些扩展都利用了现有输入的句法部分。"><text text-anchor="middle" x="739.62"
    y="-98.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">使用语法进行灰盒模糊测试</text>
    <text text-anchor="middle" x="739.62" y="-80.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">语法</text></a></g></g> <g id="edge16"
    class="edge"><title>GreyboxFuzzer->GreyboxGrammarFuzzer</title></g> <g id="edge18"
    class="edge"><title>GrammarFuzzer->GrammarCoverageFuzzer</title></g> <g id="edge23"
    class="edge"><title>GrammarFuzzer->PythonFuzzer</title></g> <g id="node19" class="node"><title>Parser</title>
    <g id="a_node19"><a xlink:href="Parser.html" xlink:title="解析输入 (Parser)
- en: In the chapter on Grammars, we discussed how grammars can be
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于语法的章节中，我们讨论了语法如何被
- en: used to represent various languages. We also saw how grammars can be used to
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于表示各种语言。我们还看到了语法如何被用来
- en: generate strings of the corresponding language. Grammars can also perform the
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 生成相应语言的字符串。语法还可以执行
- en: reverse. That is, given a string, one can decompose the string into its
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 反向操作。也就是说，给定一个字符串，可以将字符串分解为其组成部分
- en: constituent parts that correspond to the parts of grammar used to generate it
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成它的语法中使用的语法部分相对应的组成部分
- en: – the derivation tree of that string. These parts (and parts from other similar
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: – 该字符串的推导树。这些部分（以及来自其他类似
- en: strings) can later be recombined using the same grammar to produce new strings."><text
    text-anchor="middle" x="901.62" y="-249.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Parsing Inputs</text></a></g></g>
    <g id="edge19" class="edge"><title>GrammarFuzzer->Parser</title></g> <g id="node20"
    class="node"><title>GeneratorGrammarFuzzer</title> <g id="a_node20"><a xlink:href="GeneratorGrammarFuzzer.html"
    xlink:title="Fuzzing with Generators (GeneratorGrammarFuzzer)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串）可以在以后使用相同的语法重新组合以生成新的字符串。"><text text-anchor="middle" x="901.62" y="-249.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">解析输入</text></a></g></g>
    <g id="edge19" class="edge"><title>GrammarFuzzer->Parser</title></g> <g id="node20"
    class="node"><title>GeneratorGrammarFuzzer</title> <g id="a_node20"><a xlink:href="GeneratorGrammarFuzzer.html"
    xlink:title="使用生成器进行模糊测试 (GeneratorGrammarFuzzer)
- en: In this chapter, we show how to extend grammars with functions –&nbsp;pieces
    of code that get executed during grammar expansion, and that can generate, check,
    or change elements produced. &nbsp;Adding functions to a grammar allows for very
    versatile test generation, bringing together the best of grammar generation and
    programming."><text text-anchor="middle" x="714.62" y="-178.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing with</text>
    <text text-anchor="middle" x="714.62" y="-160.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Generators</text></a></g></g> <g
    id="edge20" class="edge"><title>GrammarFuzzer->GeneratorGrammarFuzzer</title></g>
    <g id="node21" class="node"><title>Reducer</title> <g id="a_node21"><a xlink:href="Reducer.html"
    xlink:title="Reducing Failure-Inducing Inputs (Reducer)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何通过函数扩展语法 –&nbsp;在语法扩展期间执行的代码片段，可以生成、检查或更改生成的元素。 &nbsp;向语法中添加函数允许进行非常灵活的测试生成，将语法生成和编程的最佳之处结合起来。"><text
    text-anchor="middle" x="714.62" y="-178.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">使用</text> <text text-anchor="middle"
    x="714.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">生成器进行模糊测试</text></a></g></g> <g id="edge20" class="edge"><title>GrammarFuzzer->GeneratorGrammarFuzzer</title></g>
    <g id="node21" class="node"><title>Reducer</title> <g id="a_node21"><a xlink:href="Reducer.html"
    xlink:title="减少导致失败的输入 (Reducer)
- en: By construction, fuzzers create inputs that may be hard to read. &nbsp;This
    causes issues during debugging, when a human has to analyze the exact cause of
    the failure. &nbsp;In this chapter, we present techniques that automatically reduce
    and simplify failure-inducing inputs to a minimum in order to ease debugging."><text
    text-anchor="middle" x="1301.62" y="-258.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Reducing Failure-</text> <text text-anchor="middle"
    x="1301.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">Inducing Inputs</text></a></g></g> <g id="edge21" class="edge"><title>GrammarFuzzer->Reducer</title></g>
    <g id="node22" class="node"><title>FuzzingWithConstraints</title> <g id="a_node22"><a
    xlink:href="FuzzingWithConstraints.html" xlink:title="Fuzzing with Constraints
    (FuzzingWithConstraints)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造，模糊器生成的输入可能难以阅读。 &nbsp;这会在调试期间造成问题，当人类需要分析失败的确切原因时。 &nbsp;在本章中，我们介绍了自动将导致失败的输入减少和简化的技术，以便于调试。"><text
    text-anchor="middle" x="1301.62" y="-258.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">减少失败-</text> <text text-anchor="middle"
    x="1301.62" y="-240.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">诱导输入</text></a></g></g> <g id="edge21" class="edge"><title>GrammarFuzzer->Reducer</title></g>
    <g id="node22" class="node"><title>FuzzingWithConstraints</title> <g id="a_node22"><a
    xlink:href="FuzzingWithConstraints.html" xlink:title="使用约束进行模糊测试 (FuzzingWithConstraints)
- en: In previous chapters, we have seen how Grammar-Based Fuzzing allows us to efficiently
    generate myriads of syntactically valid inputs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了基于语法的模糊测试如何使我们能够高效地生成大量的语法有效输入。
- en: However, there are semantic input features that cannot be expressed in a context-free
    grammar, such as"><text text-anchor="middle" x="1173.62" y="-258.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Fuzzing with</text>
    <text text-anchor="middle" x="1173.62" y="-240.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Constraints</text></a></g></g> <g
    id="edge22" class="edge"><title>GrammarFuzzer->FuzzingWithConstraints</title></g>
    <g id="node23" class="node"><title>WebFuzzer</title> <g id="a_node23"><a xlink:href="WebFuzzer.html"
    xlink:title="Testing Web Applications (WebFuzzer)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些语义输入特征无法用上下文无关文法表达，例如"><text text-anchor="middle" x="1173.62" y="-258.7"
    font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">使用</text>
    <text text-anchor="middle" x="1173.62" y="-240.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">约束</text></a></g></g> <g id="edge22"
    class="edge"><title>GrammarFuzzer->FuzzingWithConstraints</title></g> <g id="node23"
    class="node"><title>WebFuzzer</title> <g id="a_node23"><a xlink:href="WebFuzzer.html"
    xlink:title="测试网络应用程序 (WebFuzzer)
- en: In this chapter, we explore how to generate tests for Graphical User Interfaces
    (GUIs), notably on Web interfaces. &nbsp;We set up a (vulnerable) Web server and
    demonstrate how to systematically explore its behavior –&nbsp;first with handwritten
    grammars, then with grammars automatically inferred from the user interface. &nbsp;We
    also show how to conduct systematic attacks on these servers, notably with code
    and SQL injection."><text text-anchor="middle" x="1427.62" y="-258.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Testing Web</text>
    <text text-anchor="middle" x="1427.62" y="-240.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">Applications</text></a></g></g> <g
    id="edge24" class="edge"><title>GrammarFuzzer->WebFuzzer</title></g> <g id="edge29"
    class="edge"><title>Parser->ProbabilisticGrammarFuzzer</title></g> <g id="edge30"
    class="edge"><title>Parser->GreyboxGrammarFuzzer</title></g> <g id="node28" class="node"><title>InformationFlow</title>
    <g id="a_node28"><a xlink:href="InformationFlow.html" xlink:title="Tracking Information
    Flow (InformationFlow)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何为图形用户界面（GUIs），特别是网络界面生成测试。 &nbsp;我们设置了一个（有漏洞的）网络服务器，并展示了如何系统地探索其行为——&nbsp;首先使用手写的语法，然后使用从用户界面自动推断出的语法。
    &nbsp;我们还展示了如何对这些服务器进行系统性的攻击，特别是使用代码和SQL注入。"><text text-anchor="middle" x="1427.62"
    y="-258.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">测试网络</text>
    <text text-anchor="middle" x="1427.62" y="-240.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">应用程序</text></a></g></g> <g id="edge24"
    class="edge"><title>GrammarFuzzer->WebFuzzer</title></g> <g id="edge29" class="edge"><title>解析器->概率语法模糊器</title></g>
    <g id="edge30" class="edge"><title>解析器->灰盒语法模糊器</title></g> <g id="node28" class="node"><title>信息流</title>
    <g id="a_node28"><a xlink:href="InformationFlow.html" xlink:title="跟踪信息流 (InformationFlow)
- en: We have explored how one could generate better inputs that can penetrate deeper
    into the program in question. While doing so, we have relied on program crashes
    to tell us that we have succeeded in finding problems in the program. However,
    that is rather simplistic. What if the behavior of the program is simply incorrect,
    but does not lead to a crash? Can one do better?"><text text-anchor="middle" x="892.62"
    y="-178.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Tracking
    Information</text> <text text-anchor="middle" x="892.62" y="-160.7" font-family="Patua
    One, Helvetica, sans-serif" font-size="14.00" fill="#b03a2e">Flow</text></a></g></g>
    <g id="edge31" class="edge"><title>Parser->InformationFlow</title></g> <g id="edge33"
    class="edge"><title>GeneratorGrammarFuzzer->APIFuzzer</title></g> <g id="edge37"
    class="edge"><title>WebFuzzer->GUIFuzzer</title></g> <g id="edge35" class="edge"><title>InformationFlow->ConcolicFuzzer</title></g>
    <g id="edge34" class="edge"><title>InformationFlow->GrammarMiner</title></g> <g
    id="edge36" class="edge"><title>APIFuzzer->Carver</title></g></g></svg>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何生成更好的输入，这些输入可以深入到所讨论的程序中。在这样做的时候，我们依赖于程序崩溃来告诉我们我们已经成功地在程序中找到了问题。然而，这相当简单。如果程序的行为只是不正确，但不会导致崩溃呢？能否做得更好？"><text
    text-anchor="middle" x="892.62" y="-178.7" font-family="Patua One, Helvetica,
    sans-serif" font-size="14.00" fill="#b03a2e">跟踪信息</text> <text text-anchor="middle"
    x="892.62" y="-160.7" font-family="Patua One, Helvetica, sans-serif" font-size="14.00"
    fill="#b03a2e">流程</text></a></g></g> <g id="edge31" class="edge"><title>解析器->信息流</title></g>
    <g id="edge33" class="edge"><title>生成语法模糊测试器->API模糊测试器</title></g> <g id="edge37"
    class="edge"><title>Web模糊测试器->GUI模糊测试器</title></g> <g id="edge35" class="edge"><title>信息流->Concolic模糊测试器</title></g>
    <g id="edge34" class="edge"><title>信息流->语法挖掘器</title></g> <g id="edge36" class="edge"><title>API模糊测试器->Carver</title></g></g></svg>
- en: '[Table of Contents](index.html)'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[目录](index.html)'
- en: '[Part I: Whetting Your Appetite](01_Intro.html)'
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第一部分：激发你的兴趣](01_Intro.html)'
- en: In this part, we introduce the topics of the book.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们介绍了本书的主题。
- en: '[Tours through the Book](Tours.html)'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[本书之旅](Tours.html)'
- en: This book is *massive*. With more than 20,000 lines of code and 150,000 words
    of text, a printed version would cover more than 1,200 pages of text. Obviously,
    we do not assume that everybody wants to read everything.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书非常庞大。拥有超过20,000行代码和150,000字的文本，印刷版将覆盖超过1,200页的文本。显然，我们并不假设每个人都想阅读所有内容。
- en: '[Introduction to Software Testing](Intro_Testing.html)'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[软件测试简介](Intro_Testing.html)'
- en: Before we get to the central parts of the book, let us introduce essential concepts
    of software testing. Why is it necessary to test software at all? How does one
    test software? How can one tell whether a test has been successful? How does one
    know if one has tested enough? In this chapter, let us recall the most important
    concepts, and at the same time get acquainted with Python and interactive notebooks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入本书的核心部分之前，让我们介绍软件测试的基本概念。为什么需要测试软件？一个人如何测试软件？一个人如何知道测试是否成功？一个人如何知道是否测试得足够？在本章中，让我们回顾最重要的概念，同时熟悉Python和交互式笔记本。
- en: '[Part II: Lexical Fuzzing](02_Lexical_Fuzzing.html)'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第二部分：词汇模糊测试](02_Lexical_Fuzzing.html)'
- en: This part introduces test generation at the *lexical* level, that is, composing
    sequences of characters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分介绍了*词汇级别*的测试生成，即字符序列的组成。
- en: '[Fuzzing: Breaking Things with Random Inputs](Fuzzer.html)'
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[模糊测试：使用随机输入破坏事物](Fuzzer.html)'
- en: In this chapter, we'll start with one of the simplest test generation techniques.
    The key idea of random text generation, also known as *fuzzing*, is to feed a
    *string of random characters* into a program in the hope to uncover failures.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从最简单的测试生成技术开始。随机文本生成的关键思想，也称为*模糊测试*，是将一串*随机字符*输入到程序中，希望揭示出故障。
- en: '[Code Coverage](Coverage.html)'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[代码覆盖率](Coverage.html)'
- en: In the [previous chapter](Fuzzer.html), we introduced *basic fuzzing* – that
    is, generating random inputs to test programs. How do we measure the effectiveness
    of these tests? One way would be to check the number (and seriousness) of bugs
    found; but if bugs are scarce, we need a *proxy for the likelihood of a test to
    uncover a bug.* In this chapter, we introduce the concept of *code coverage*,
    measuring which parts of a program are actually executed during a test run. Measuring
    such coverage is also crucial for test generators that attempt to cover as much
    code as possible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一章](Fuzzer.html)中，我们介绍了*基本模糊测试*——即生成随机输入以测试程序。我们如何衡量这些测试的有效性呢？一种方法就是检查找到的（数量和严重性）错误；但如果错误很少，我们需要一个*测试发现错误的可能性的代理*。在本章中，我们引入了*代码覆盖率*的概念，测量在测试运行期间程序的实际执行部分。测量这种覆盖率对于试图覆盖尽可能多代码的测试生成器来说也是至关重要的。
- en: '[Mutation-Based Fuzzing](MutationFuzzer.html)'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[基于突变的模糊测试](MutationFuzzer.html)'
- en: Most [randomly generated inputs](Fuzzer.html) are syntactically *invalid* and
    thus are quickly rejected by the processing program. To exercise functionality
    beyond input processing, we must increase chances to obtain valid inputs. One
    such way is so-called *mutational fuzzing* – that is, introducing small changes
    to existing inputs that may still keep the input valid, yet exercise new behavior.
    We show how to create such mutations, and how to guide them towards yet uncovered
    code, applying central concepts from the popular AFL fuzzer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数[随机生成的输入](Fuzzer.html)在语法上是*无效的*，因此很快就会被处理程序拒绝。为了测试输入处理之外的功能，我们必须增加获得有效输入的机会。其中一种方法就是所谓的*突变模糊测试*——即对现有输入进行微小更改，这些更改可能仍然保持输入有效，但可以测试新的行为。我们展示了如何创建这样的突变，以及如何引导它们指向尚未发现的代码，应用来自流行的AFL模糊测试器的核心概念。
- en: '[Greybox Fuzzing](GreyboxFuzzer.html)'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[灰盒模糊测试](GreyboxFuzzer.html)'
- en: In the [previous chapter](MutationFuzzer.html), we have introduced *mutation-based
    fuzzing*, a technique that generates fuzz inputs by applying small mutations to
    given inputs. In this chapter, we show how to *guide* these mutations towards
    specific goals such as coverage. The algorithms in this chapter stem from the
    popular [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/) (AFL) fuzzer, in
    particular from its [AFLFast](https://github.com/mboehme/aflfast) and [AFLGo](https://github.com/aflgo/aflgo)
    flavors. We will explore the greybox fuzzing algorithm behind AFL and how we can
    exploit it to solve various problems for automated vulnerability detection.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[上一章](MutationFuzzer.html)中，我们介绍了*基于突变的模糊测试*，这是一种通过在给定输入上应用小突变来生成模糊输入的技术。在本章中，我们展示了如何*引导*这些突变指向特定的目标，如覆盖率。本章中的算法源自流行的[American
    Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)（AFL）模糊测试器，特别是其[AFLFast](https://github.com/mboehme/aflfast)和[AFLGo](https://github.com/aflgo/aflgo)版本。我们将探索AFL背后的灰盒模糊测试算法以及我们如何利用它来解决自动化漏洞检测的各种问题。
- en: '[Search-Based Fuzzing](SearchBasedFuzzer.html)'
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[基于搜索的模糊测试](SearchBasedFuzzer.html)'
- en: Sometimes we are not only interested in fuzzing as many as possible diverse
    program inputs, but in deriving *specific* test inputs that achieve some objective,
    such as reaching specific statements in a program. When we have an idea of what
    we are looking for, then we can *search* for it. Search algorithms are at the
    core of computer science, but applying classic search algorithms like breadth
    or depth first search to search for tests is unrealistic, because these algorithms
    potentially require us to look at all possible inputs. However, domain-knowledge
    can be used to overcome this problem. For example, if we can estimate which of
    several program inputs is closer to the one we are looking for, then this information
    can guide us to reach the target quicker – this information is known as a *heuristic*.
    The way heuristics are applied systematically is captured in *meta-heuristic*
    search algorithms. The "meta" denotes that these algorithms are generic and can
    be instantiated differently to different problems. Meta-heuristics often take
    inspiration from processes observed in nature. For example, there are algorithms
    mimicking evolutionary processes, swarm intelligence, or chemical reactions. In
    general, they are much more efficient than exhaustive search approaches such that
    they can be applied to vast search spaces – search spaces as vast as the domain
    of program inputs are no problem for them.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们不仅对模糊测试尽可能多的不同程序输入感兴趣，还希望推导出*特定*的测试输入，以达到某些目标，例如到达程序中的特定语句。当我们有了我们想要寻找的东西的概念时，我们就可以*搜索*它了。搜索算法是计算机科学的核心，但将经典搜索算法如广度优先搜索或深度优先搜索应用于测试搜索是不切实际的，因为这些算法可能需要我们查看所有可能的输入。然而，领域知识可以用来克服这个问题。例如，如果我们能估计几个程序输入中哪一个更接近我们想要找的，那么这个信息可以引导我们更快地达到目标——这个信息被称为*启发式*。启发式系统地应用的方式被捕获在*元启发式*搜索算法中。"Meta"表示这些算法是通用的，并且可以根据不同的问题实例化。元启发式通常从自然界观察到的过程中获得灵感。例如，有一些算法模仿进化过程、群体智能或化学反应。总的来说，它们比穷举搜索方法更有效率，因此可以应用于广阔的搜索空间——对于它们来说，程序输入领域的广阔搜索空间不是问题。
- en: '[Mutation Analysis](MutationAnalysis.html)'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[突变分析](MutationAnalysis.html)'
- en: 'In the [chapter on coverage](Coverage.html), we showed how one can identify
    which parts of the program are executed by a program, and hence get a sense of
    the effectiveness of a set of test cases in covering the program structure. However,
    coverage alone may not be the best measure for the effectiveness of a test, as
    one can have great coverage without ever checking a result for correctness. In
    this chapter, we introduce another means for assessing the effectiveness of a
    test suite: After injecting *mutations* – *artificial faults* – into the code,
    we check whether a test suite can detect these artificial faults. The idea is
    that if it fails to detect such mutations, it will also miss real bugs.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[关于覆盖率（Coverage）的章节](Coverage.html)中，我们展示了如何确定程序中哪些部分被执行，从而对一组测试用例在覆盖程序结构方面的有效性有一个概念。然而，覆盖率本身可能不是衡量测试有效性的最佳指标，因为一个人可以有很高的覆盖率，但从未检查结果是否正确。在这一章中，我们介绍了一种评估测试套件有效性的另一种方法：在代码中注入*突变*——*人工故障*后，我们检查测试套件是否可以检测到这些人工故障。这个想法是，如果它未能检测到这样的突变，它也会错过真实的错误。
- en: '[Part III: Syntactic Fuzzing](03_Syntactical_Fuzzing.html)'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第三部分：语法模糊测试](03_Syntactical_Fuzzing.html)'
- en: This part introduces test generation at the *syntactical* level, that is, composing
    inputs from language structures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分介绍了*语法*级别的测试生成，即从语言结构中组合输入。
- en: '[Fuzzing with Grammars](Grammars.html)'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[使用语法进行模糊测试](Grammars.html)'
- en: In the chapter on ["Mutation-Based Fuzzing"](MutationFuzzer.html), we have seen
    how to use extra hints – such as sample input files – to speed up test generation.
    In this chapter, we take this idea one step further, by providing a *specification*
    of the legal inputs to a program. Specifying inputs via a *grammar* allows for
    very systematic and efficient test generation, in particular for complex input
    formats. Grammars also serve as the base for configuration fuzzing, API fuzzing,
    GUI fuzzing, and many more.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在["基于突变的模糊测试"（Mutation-Based Fuzzing）](MutationFuzzer.html)这一章中，我们看到了如何使用额外的提示——例如样本输入文件——来加速测试生成。在这一章中，我们更进一步，通过提供程序合法输入的*规范*。通过*语法*指定输入允许非常系统和高效的测试生成，特别是对于复杂的输入格式。语法还作为配置模糊测试、API模糊测试、GUI模糊测试等的基础。
- en: '[Efficient Grammar Fuzzing](GrammarFuzzer.html)'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[高效的语法模糊测试](GrammarFuzzer.html)'
- en: In the [chapter on grammars](Grammars.html), we have seen how to use *grammars*
    for very effective and efficient testing. In this chapter, we refine the previous
    *string-based* algorithm into a *tree-based* algorithm, which is much faster and
    allows for much more control over the production of fuzz inputs.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在[语法](Grammars.html)章节中，我们看到了如何使用*语法*进行非常有效和高效的测试。在本章中，我们将之前的基于*字符串*的算法精炼为基于*树*的算法，这要快得多，并允许对模糊输入的生产有更多的控制。
- en: '[Grammar Coverage](GrammarCoverageFuzzer.html)'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[语法覆盖率](GrammarCoverageFuzzer.html)'
- en: '[Producing inputs from grammars](GrammarFuzzer.html) gives all possible expansions
    of a rule the same likelihood. For producing a comprehensive test suite, however,
    it makes more sense to maximize *variety* – for instance, by not repeating the
    same expansions over and over again. In this chapter, we explore how to systematically
    *cover* elements of a grammar such that we maximize variety and do not miss out
    individual elements.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[从语法生成输入](GrammarFuzzer.html)为规则的每个可能扩展赋予相同的可能性。然而，为了生成全面的测试套件，最大化*多样性*更有意义——例如，不要反复重复相同的扩展。在本章中，我们探讨了如何系统地*覆盖*语法的元素，以最大化多样性，并确保不遗漏单个元素。'
- en: '[Parsing Inputs](Parser.html)'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[解析输入](Parser.html)'
- en: In the chapter on [Grammars](Grammars.html), we discussed how grammars can be
    used to represent various languages. We also saw how grammars can be used to generate
    strings of the corresponding language. Grammars can also perform the reverse.
    That is, given a string, one can decompose the string into its constituent parts
    that correspond to the parts of grammar used to generate it – the *derivation
    tree* of that string. These parts (and parts from other similar strings) can later
    be recombined using the same grammar to produce new strings.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在[语法](Grammars.html)章节中，我们讨论了如何使用语法来表示各种语言。我们还看到了如何使用语法来生成对应语言的字符串。语法还可以执行相反的操作。也就是说，给定一个字符串，可以将该字符串分解为其组成部分，这些组成部分对应于用于生成它的语法的部分——该字符串的*推导树*。这些部分（以及来自其他类似字符串的部分）可以稍后使用相同的语法重新组合，以生成新的字符串。
- en: '[Probabilistic Grammar Fuzzing](ProbabilisticGrammarFuzzer.html)'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[概率语法模糊](ProbabilisticGrammarFuzzer.html)'
- en: Let us give grammars even more power by assigning *probabilities* to individual
    expansions. This allows us to control how many of each element should be produced,
    and thus allows us to *target* our generated tests towards specific functionality.
    We also show how to learn such probabilities from given sample inputs, and specifically
    direct our tests towards input features that are uncommon in these samples.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为单个扩展分配*概率*来赋予语法更多的能力。这允许我们控制应该生成多少个每个元素，从而允许我们将生成的测试针对特定的功能。我们还展示了如何从给定的样本输入中学习这样的概率，并具体地将测试指向这些样本中不常见的输入特征。
- en: '[Fuzzing with Generators](GeneratorGrammarFuzzer.html)'
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[使用生成器进行模糊测试](GeneratorGrammarFuzzer.html)'
- en: In this chapter, we show how to extend grammars with *functions* – pieces of
    code that get executed during grammar expansion, and that can generate, check,
    or change elements produced. Adding functions to a grammar allows for very versatile
    test generation, bringing together the best of grammar generation and programming.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了如何通过*函数*扩展语法——这些代码在语法扩展期间执行，可以生成、检查或更改生成的元素。向语法添加函数允许进行非常灵活的测试生成，结合了语法生成和编程的最佳之处。
- en: '[Greybox Fuzzing with Grammars](GreyboxGrammarFuzzer.html)'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[使用语法进行灰盒模糊测试](GreyboxGrammarFuzzer.html)'
- en: In this chapter, we introduce important extensions to our syntactic fuzzing
    techniques, all leveraging *syntactic* parts of *existing inputs*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了对我们语法模糊技术的重要扩展，所有这些扩展都利用了*现有输入*的*语法*部分。
- en: '[Reducing Failure-Inducing Inputs](Reducer.html)'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[减少导致失败的输入](Reducer.html)'
- en: By construction, fuzzers create inputs that may be hard to read. This causes
    issues during *debugging*, when a human has to analyze the exact cause of the
    failure. In this chapter, we present techniques that *automatically reduce and
    simplify failure-inducing inputs to a minimum* in order to ease debugging.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造，模糊器创建的输入可能难以阅读。这会在*调试*期间造成问题，当人类需要分析失败的确切原因时。在本章中，我们介绍了将导致失败输入自动减少和简化的技术，以简化调试过程。
- en: '[Part IV: Semantic Fuzzing](04_Semantical_Fuzzing.html)'
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第四部分：语义模糊测试](04_Semantical_Fuzzing.html)'
- en: This part introduces test generation techniques that take the *semantics* of
    the input into account, notably the behavior of the program that processes the
    input.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分介绍了考虑输入*语义*的测试生成技术，特别是处理输入的程序的行为。
- en: '[Fuzzing with Constraints](FuzzingWithConstraints.html)'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[约束模糊测试](FuzzingWithConstraints.html)'
- en: In previous chapters, we have seen how [Grammar-Based Fuzzing](GrammarFuzzer.html)
    allows us to efficiently generate myriads of syntactically valid inputs. However,
    there are *semantic* input features that cannot be expressed in a context-free
    grammar, such as
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了[基于语法的模糊测试](GrammarFuzzer.html)如何使我们能够高效地生成大量的语法有效输入。然而，有一些*语义*输入特征无法在上下文无关语法中表达，例如
- en: '[Mining Input Grammars](GrammarMiner.html)'
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[挖掘输入语法](GrammarMiner.html)'
- en: So far, the grammars we have seen have been mostly specified manually – that
    is, you (or the person knowing the input format) had to design and write a grammar
    in the first place. While the grammars we have seen so far have been rather simple,
    creating a grammar for complex inputs can involve quite some effort. In this chapter,
    we therefore introduce techniques that *automatically mine grammars from programs*
    – by executing the programs and observing how they process which parts of the
    input. In conjunction with a grammar fuzzer, this allows us to
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的语法大多是手动指定的——也就是说，你必须（或知道输入格式的人）首先设计和编写一个语法。虽然我们迄今为止看到的语法相当简单，但为复杂输入创建语法可能需要相当多的努力。因此，在这一章中，我们介绍了从程序中*自动挖掘语法*的技术——通过执行程序并观察它们如何处理输入的哪些部分。与语法模糊测试器结合使用，这使我们能够
- en: take a program,
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取一个程序，
- en: extract its input grammar, and
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取其输入语法，并且
- en: 'fuzz it with high efficiency and effectiveness, using the concepts in this
    book. #### [Tracking Information Flow](InformationFlow.html)'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用本书中的概念，以高效率和有效性进行模糊测试。#### [跟踪信息流](InformationFlow.html)
- en: We have explored how one could generate better inputs that can penetrate deeper
    into the program in question. While doing so, we have relied on program crashes
    to tell us that we have succeeded in finding problems in the program. However,
    that is rather simplistic. What if the behavior of the program is simply incorrect,
    but does not lead to a crash? Can one do better?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了如何生成更好的输入，这些输入可以深入到所讨论的程序中。在这样做的时候，我们依赖于程序崩溃来告诉我们我们已经成功地在程序中找到了问题。然而，这相当简单。如果程序的行为只是不正确，但不会导致崩溃呢？能否做得更好？
- en: '[Concolic Fuzzing](ConcolicFuzzer.html)'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[约束模糊测试](FuzzingWithConstraints.html)'
- en: In the [chapter on information flow](InformationFlow.html), we have seen how
    one can use dynamic taints to produce more intelligent test cases than simply
    looking for program crashes. We have also seen how one can use the taints to update
    the grammar, and hence focus more on the dangerous methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[信息流章节](InformationFlow.html)中，我们看到了如何使用动态污点来生成比仅仅寻找程序崩溃更智能的测试用例。我们也看到了如何使用污点来更新语法，从而更专注于危险的方法。
- en: '[Symbolic Fuzzing](SymbolicFuzzer.html)'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[符号模糊测试](SymbolicFuzzer.html)'
- en: One of the problems with traditional methods of fuzzing is that they fail to
    exercise all the possible behaviors that a system can have, especially when the
    input space is large. Quite often the execution of a specific branch of execution
    may happen only with very specific inputs, which could represent a minimal fraction
    of the input space. The traditional fuzzing methods relies on chance to produce
    inputs they need. However, relying on randomness to generate values that we want
    is a bad idea when the space to be explored is huge. For example, a function that
    accepts a string, even if one only considers the first $10$ characters, already
    has $2^{80}$ possible inputs. If one is looking for a specific string, random
    generation of values will take a few thousand years even in one of the super computers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试的传统方法中存在的问题是，它们无法锻炼系统可能具有的所有可能行为，尤其是在输入空间很大时。很多时候，特定执行分支的执行可能只发生在非常特定的输入上，这可能只占输入空间的一小部分。传统的模糊测试方法依赖于机会来生成它们需要的输入。然而，当要探索的空间很大时，依赖于随机性来生成我们想要的值是一个坏主意。例如，一个接受字符串的函数，即使只考虑前10个字符，也有$2^{80}$种可能的输入。如果寻找特定的字符串，即使在超级计算机上，随机生成值也需要几千年。
- en: '[Mining Function Specifications](DynamicInvariants.html)'
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[挖掘函数规范](DynamicInvariants.html)'
- en: When testing a program, one not only needs to cover its several behaviors; one
    also needs to *check* whether the result is as expected. In this chapter, we introduce
    a technique that allows us to *mine* function specifications from a set of given
    executions, resulting in abstract and formal *descriptions* of what the function
    expects and what it delivers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试程序时，不仅需要覆盖其多种行为；还需要*检查*结果是否符合预期。在本章中，我们介绍了一种技术，允许我们从一组给定的执行中挖掘函数规范，从而得到函数期望和提供的抽象和正式*描述*。
- en: '[Part V: Domain-Specific Fuzzing](05_Domain-Specific_Fuzzing.ipynb)'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第五部分：特定领域模糊测试](05_Domain-Specific_Fuzzing.ipynb)'
- en: This part discusses test generation for a number of specific domains. For all
    these domains, we introduce *fuzzers* that generate inputs as well as *miners*
    that analyze the input structure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分讨论了针对多个特定领域的测试生成。对于所有这些领域，我们引入了*模糊器*，用于生成输入，以及*挖掘器*，用于分析输入结构。
- en: '[Testing Configurations](ConfigurationFuzzer.html)'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[测试配置](ConfigurationFuzzer.html)'
- en: The behavior of a program is not only governed by its data. The *configuration*
    of a program – that is, the settings that govern the execution of a program on
    its (regular) input data, as set by options or configuration files – just as well
    influences behavior, and thus can and should be tested. In this chapter, we explore
    how to systematically *test* and *cover* software configurations. By *automatically
    inferring configuration options*, we can apply these techniques out of the box,
    with no need for writing a grammar. Finally, we show how to systematically cover
    *combinations* of configuration options, quickly detecting unwanted interferences.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的行为不仅受其数据控制。程序*配置*——即通过选项或配置文件设置的，控制程序在其（常规）输入数据上执行设置的设置——同样会影响行为，因此可以也应该进行测试。在本章中，我们探讨了如何系统地*测试*和*覆盖*软件配置。通过*自动推断配置选项*，我们可以直接应用这些技术，无需编写语法。最后，我们展示了如何系统地覆盖配置选项的*组合*，快速检测不希望出现的干扰。
- en: '[Fuzzing APIs](APIFuzzer.html)'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[模糊测试API](APIFuzzer.html)'
- en: So far, we have always generated *system input*, i.e. data that the program
    as a whole obtains via its input channels. However, we can also generate inputs
    that go directly into individual functions, gaining flexibility and speed in the
    process. In this chapter, we explore the use of grammars to synthesize code for
    function calls, which allows you to generate *program code that very efficiently
    invokes functions directly.*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们始终生成*系统输入*，即程序整体通过其输入通道获得的数据。然而，我们也可以生成直接进入单个函数的输入，从而在过程中获得灵活性和速度。在本章中，我们探讨了使用语法合成函数调用代码的使用，这允许你生成*非常高效地直接调用函数的程序代码*。
- en: '[Carving Unit Tests](Carver.html)'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[雕刻单元测试](Carver.html)'
- en: So far, we have always generated *system input*, i.e. data that the program
    as a whole obtains via its input channels. If we are interested in testing only
    a small set of functions, having to go through the system can be very inefficient.
    This chapter introduces a technique known as *carving*, which, given a system
    test, automatically extracts a set of *unit tests* that replicate the calls seen
    during the system test. The key idea is to *record* such calls such that we can
    *replay* them later – as a whole or selectively. On top, we also explore how to
    synthesize API grammars from carved unit tests; this means that we can *synthesize
    API tests without having to write a grammar at all.*
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们始终生成*系统输入*，即程序整体通过其输入通道获得的数据。如果我们只对测试一小组函数感兴趣，通过系统进行测试可能非常低效。本章介绍了一种称为*雕刻*的技术，它给定一个系统测试，自动提取一组*单元测试*，这些测试复制了系统测试期间看到的调用。关键思想是*记录*这些调用，以便我们可以在以后*回放*它们——整体或选择性地。此外，我们还探讨了如何从雕刻的单元测试中合成API语法；这意味着我们可以*合成API测试，而无需编写任何语法*。
- en: '[Testing Compilers](PythonFuzzer.html)'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[测试编译器](PythonFuzzer.html)'
- en: In this chapter, we will make use of [grammars and grammar-based testing](Grammars.html)
    to systematically generate *program code* – for instance, to test a compiler or
    an interpreter. Not very surprisingly, we use *Python* and the *Python interpreter*
    as our domain.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用[语法和基于语法的测试](Grammars.html)系统地生成*程序代码*——例如，测试编译器或解释器。不出所料，我们使用*Python*和*Python解释器*作为我们的领域。
- en: '[Testing Web Applications](WebFuzzer.html)'
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[测试Web应用程序](WebFuzzer.html)'
- en: In this chapter, we explore how to generate tests for Graphical User Interfaces
    (GUIs), notably on Web interfaces. We set up a (vulnerable) Web server and demonstrate
    how to systematically explore its behavior – first with handwritten grammars,
    then with grammars automatically inferred from the user interface. We also show
    how to conduct systematic attacks on these servers, notably with code and SQL
    injection.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨如何为图形用户界面（GUI）生成测试，特别是在Web界面。我们设置了一个（有漏洞的）Web服务器，并演示了如何系统地探索其行为——首先使用手写的语法，然后使用从用户界面自动推断出的语法。我们还展示了如何对这些服务器进行系统性的攻击，特别是使用代码和SQL注入。
- en: '[Testing Graphical User Interfaces](GUIFuzzer.html)'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[测试图形用户界面](GUIFuzzer.html)'
- en: In this chapter, we explore how to generate tests for Graphical User Interfaces
    (GUIs), abstracting from our [previous examples on Web testing](WebFuzzer.html).
    Building on general means to extract user interface elements and activate them,
    our techniques generalize to arbitrary graphical user interfaces, from rich Web
    applications to mobile apps, and systematically explore user interfaces through
    forms and navigation elements.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨如何为图形用户界面（GUI）生成测试，从我们之前关于Web测试的[示例](WebFuzzer.html)中抽象出来。基于提取用户界面元素和激活它们的一般方法，我们的技术可以推广到任意图形用户界面，从富Web应用到移动应用，并通过表单和导航元素系统地探索用户界面。
- en: '[Part VI: Managing Fuzzing](06_Managing_Fuzzing.html)'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[第六部分：管理模糊测试](06_Managing_Fuzzing.html)'
- en: This part discusses how to manage fuzzing in the large.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分讨论了如何管理大规模的模糊测试。
- en: '[Fuzzing in the Large](FuzzingInTheLarge.html)'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[大规模模糊测试](FuzzingInTheLarge.html)'
- en: In the past chapters, we have always looked at fuzzing taking place on one machine
    for a few seconds only. In the real world, however, fuzzers are run on dozens
    or even thousands of machines; for hours, days and weeks; for one program or dozens
    of programs. In such contexts, one needs an *infrastructure* to *collect* failure
    data from the individual fuzzer runs, and to *aggregate* such data in a central
    repository. In this chapter, we will examine such an infrastructure, the *FuzzManager*
    framework from Mozilla.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的章节中，我们总是关注仅在一台机器上持续几秒钟的模糊测试。然而，在现实世界中，模糊测试是在数十台甚至数千台机器上运行的；持续数小时、数天甚至数周；针对一个程序或数十个程序。在这种情况下，需要一个*基础设施*来*收集*单个模糊测试运行中的失败数据，并将这些数据*聚合*到一个中央存储库中。在本章中，我们将检查这样一个基础设施，即Mozilla的*FuzzManager*框架。
- en: '[When To Stop Fuzzing](WhenToStopFuzzing.html)'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[何时停止模糊测试](WhenToStopFuzzing.html)'
- en: 'In the past chapters, we have discussed several fuzzing techniques. Knowing
    *what* to do is important, but it is also important to know when to *stop* doing
    things. In this chapter, we will learn when to *stop fuzzing* – and use a prominent
    example for this purpose: The *Enigma* machine that was used in the second world
    war by the navy of Nazi Germany to encrypt communications, and how Alan Turing
    and I.J. Good used *fuzzing techniques* to crack ciphers for the Naval Enigma
    machine.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的章节中，我们讨论了几种模糊测试技术。知道*做什么*很重要，但知道何时*停止*做事情也同样重要。在本章中，我们将学习何时*停止模糊测试*——并使用一个突出的例子来说明这一点：在第二次世界大战中，纳粹德国海军使用的用于加密通信的*恩尼格玛*机器，以及Alan
    Turing和I.J. Good如何使用*模糊测试技术*来破解海军恩尼格玛机的密码。
- en: '[Appendices](99_Appendices.html)'
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[附录](99_Appendices.html)'
- en: This part holds notebooks and modules that support other notebooks.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含支持其他笔记本的笔记本和模块。
- en: '[Academic Prototyping](AcademicPrototyping.html)'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[学术原型设计](AcademicPrototyping.html)'
- en: '*This is the manuscript of Andreas Zeller''s tutorial "Academic Prototyping"
    at the ESEC/FSE 2022 conference.*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是Andreas Zeller在ESEC/FSE 2022会议上发表的“学术原型设计”教程的手稿。*'
- en: '[Prototyping with Python](PrototypingWithPython.html)'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[使用Python进行原型设计](PrototypingWithPython.html)'
- en: '*This is the manuscript of Andreas Zeller''s keynote "Coding Effective Testing
    Tools Within Minutes" at the TAIC PART 2020 conference.*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*这是Andreas Zeller在TAIC PART 2020会议上发表的“几分钟内编写有效的测试工具”主题演讲的手稿。*'
- en: '[Error Handling](ExpectError.html)'
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[错误处理](ExpectError.html)'
- en: The code in this notebook helps with handling errors. Normally, an error in
    notebook code causes the execution of the code to stop; while an infinite loop
    in notebook code causes the notebook to run without end. This notebook provides
    two classes to help address these concerns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个笔记本中的代码有助于处理错误。通常，笔记本代码中的错误会导致代码执行停止；而笔记本代码中的无限循环会导致笔记本无限运行。这个笔记本提供了两个类来帮助解决这些问题。
- en: '[Timer](Timer.html)'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[计时器](Timer.html)'
- en: The code in this notebook helps with measuring time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个笔记本中的代码有助于测量时间。
- en: '[Timeout](Timeout.html)'
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[超时](Timeout.html)'
- en: The code in this notebook helps in interrupting execution after a given time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本笔记本中的代码有助于在给定时间后中断执行。
- en: '[Class Diagrams](ClassDiagram.html)'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[类图](ClassDiagram.html)'
- en: This is a simple viewer for class diagrams. Customized towards the book.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类图查看器。针对本书进行了定制。
- en: '[Railroad Diagrams](RailroadDiagrams.html)'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[铁路图](RailroadDiagrams.html)'
- en: The code in this notebook helps with drawing syntax-diagrams. It is a (slightly
    customized) copy of the [excellent library from Tab Atkins jr.](https://github.com/tabatkins/railroad-diagrams),
    which unfortunately is not available as a Python package.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本笔记本中的代码有助于绘制语法图。它是[Tab Atkins Jr.的优秀库](https://github.com/tabatkins/railroad-diagrams)的一个（略有定制）副本，不幸的是，它不是一个Python包。
- en: '[Control Flow Graph](ControlFlow.html)'
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '[控制流图](ControlFlow.html)'
- en: The code in this notebook helps with obtaining the control flow graph of python
    functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本笔记本中的代码有助于获取Python函数的控制流图。
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-07-01 12:05:22+02:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/00_Table_of_Contents.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内文内容根据[Creative Commons Attribution-NonCommercial-ShareAlike 4.0国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)授权。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，根据[MIT许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)授权。[最后更改：2024-07-01
    12:05:22+02:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/00_Table_of_Contents.ipynb)
    • [引用](#citation) • [版权信息](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用这篇作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[The Fuzzing Book](https://www.fuzzingbook.org/html/00_Table_of_Contents.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/00_Table_of_Contents.html](https://www.fuzzingbook.org/html/00_Table_of_Contents.html).
    Retrieved 2024-07-01 12:05:22+02:00.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing Book](https://www.fuzzingbook.org/html/00_Table_of_Contents.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/00_Table_of_Contents.html](https://www.fuzzingbook.org/html/00_Table_of_Contents.html).
    Retrieved 2024-07-01 12:05:22+02:00.'
- en: '[PRE0]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
