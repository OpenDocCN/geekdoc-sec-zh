- en: Tracking Information Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/InformationFlow.html](http://www.fuzzingbook.org/html/InformationFlow.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We have explored how one could generate better inputs that can penetrate deeper
    into the program in question. While doing so, we have relied on program crashes
    to tell us that we have succeeded in finding problems in the program. However,
    that is rather simplistic. What if the behavior of the program is simply incorrect,
    but does not lead to a crash? Can one do better?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we explore in depth how to track information flows in Python,
    and how these flows can be used to determine whether a program behaved as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should have read the [chapter on coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have read the [chapter on probabilistic fuzzing](ProbabilisticGrammarFuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We first set up our infrastructure so that we can make use of previously defined
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter provides two wrappers to Python *strings* that allow one to track
    various properties. These include information on the security properties of the
    input, and information on originating indexes of the input string.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking String Taints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`tstr` objects are replacements for Python strings that allows tracking and
    checking *taints* – that is, information on from where a string originated. For
    instance, one can mark strings that originate from third party input with a taint
    of "LOW", meaning that they have a low security level. The taint is passed in
    the constructor of a `tstr` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A `tstr` object is fully compatible with original Python strings. For instance,
    we can index it and access substrings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `tstr` object also stores the taint, which can be accessed using
    the `taint` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The neat thing about taints is that they propagate to all strings derived from
    the original tainted string. Indeed, any operation from a `tstr` string that results
    in a string fragment produces another `tstr` object that includes the original
    taint. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`tstr` objects duplicate most `str` methods, as indicated in the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="270pt" height="562pt" viewBox="0.00 0.00 269.62 562.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 558.25)"><g
    id="node1" class="node"><title>tstr</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class tstr:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapper for strings, saving taint information"><text text-anchor="start" x="51.12"
    y="-464.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">tstr</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="tstr"><g id="a_node1_1"><a xlink:href="#" xlink:title="__add__(self,
    *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self+value."><text text-anchor="start" x="8" y="-442.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__add__()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="__format__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a formatted version of the string as described by format_spec."><text
    text-anchor="start" x="8" y="-429.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__format__()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="__getitem__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self[key]."><text text-anchor="start" x="8" y="-416.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__getitem__()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="__init__(self, value: Any, taint:
    Any = None, **kwargs) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is the string value the `tstr` object is to be constructed from.'
  prefs: []
  type: TYPE_NORMAL
- en: '`taint` is an (optional) taint to be propagated to derived strings."><text
    text-anchor="start" x="8" y="-404" font-family="''Fira Mono'', ''Source Code Pro'',
    ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_5"><a xlink:href="#" xlink:title="__mod__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self%value."><text text-anchor="start" x="8" y="-391.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__mod__()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="__mul__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self*value."><text text-anchor="start" x="8" y="-378.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__mul__()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="__new__(cls, value, *args, **kw):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a tstr() instance. Used internally."><text text-anchor="start" x="8"
    y="-365.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">__new__()</text></a></g> <g id="a_node1_8"><a
    xlink:href="#" xlink:title="__radd__(self, value):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return value + self, as a `tstr` object"><text text-anchor="start" x="8" y="-353"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__radd__()</text></a></g> <g id="a_node1_9"><a xlink:href="#"
    xlink:title="__repr__(self) -> tstr:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a representation."><text text-anchor="start" x="8" y="-340.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__repr__()</text></a></g>
    <g id="a_node1_10"><a xlink:href="#" xlink:title="__rmod__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return value%self."><text text-anchor="start" x="8" y="-327.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__rmod__()</text></a></g>
    <g id="a_node1_11"><a xlink:href="#" xlink:title="__rmul__(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return value*self."><text text-anchor="start" x="8" y="-314.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__rmul__()</text></a></g>
    <g id="a_node1_12"><a xlink:href="#" xlink:title="__str__(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert to string"><text text-anchor="start" x="8" y="-302" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__str__()</text></a></g>
    <g id="a_node1_13"><a xlink:href="#" xlink:title="capitalize(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a capitalized version of the string.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, make the first character have upper case and the rest lower
  prefs: []
  type: TYPE_NORMAL
- en: 'case."><text text-anchor="start" x="8" y="-289.25" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">capitalize()</text></a></g>
    <g id="a_node1_14"><a xlink:href="#" xlink:title="casefold(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a version of the string suitable for caseless comparisons."><text text-anchor="start"
    x="8" y="-276.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">casefold()</text></a></g> <g id="a_node1_15"><a
    xlink:href="#" xlink:title="center(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a centered string of length width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is done using the specified fill character (default is a space)."><text
    text-anchor="start" x="8" y="-263.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">center()</text></a></g>
    <g id="a_node1_16"><a xlink:href="#" xlink:title="clear_taint(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove taint"><text text-anchor="start" x="8" y="-251" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">clear_taint()</text></a></g>
    <g id="a_node1_17"><a xlink:href="#" xlink:title="encode(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Encode the string using the codec registered for encoding.
  prefs: []
  type: TYPE_NORMAL
- en: encoding
  prefs: []
  type: TYPE_NORMAL
- en: The encoding in which to encode the string.
  prefs: []
  type: TYPE_NORMAL
- en: errors
  prefs: []
  type: TYPE_NORMAL
- en: The error handling scheme to use for encoding errors.
  prefs: []
  type: TYPE_NORMAL
- en: The default is 'strict' meaning that encoding errors raise a
  prefs: []
  type: TYPE_NORMAL
- en: UnicodeEncodeError. &nbsp;Other possible values are 'ignore', 'replace' and
  prefs: []
  type: TYPE_NORMAL
- en: '''xmlcharrefreplace'' as well as any other name registered with'
  prefs: []
  type: TYPE_NORMAL
- en: 'codecs.register_error that can handle UnicodeEncodeErrors."><text text-anchor="start"
    x="8" y="-238.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">encode()</text></a></g> <g id="a_node1_18"><a
    xlink:href="#" xlink:title="expandtabs(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy where all tab characters are expanded using spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'If tabsize is not given, a tab size of 8 characters is assumed."><text text-anchor="start"
    x="8" y="-225.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">expandtabs()</text></a></g> <g
    id="a_node1_19"><a xlink:href="#" xlink:title="format(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: S.format(*args, **kwargs) -> str
  prefs: []
  type: TYPE_NORMAL
- en: Return a formatted version of S, using substitutions from args and kwargs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The substitutions are identified by braces (''{'' and ''}'')."><text text-anchor="start"
    x="8" y="-212.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">format()</text></a></g> <g id="a_node1_20"><a
    xlink:href="#" xlink:title="format_map(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: S.format_map(mapping) -> str
  prefs: []
  type: TYPE_NORMAL
- en: Return a formatted version of S, using substitutions from mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The substitutions are identified by braces (''{'' and ''}'')."><text text-anchor="start"
    x="8" y="-200" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">format_map()</text></a></g> <g id="a_node1_21"><a
    xlink:href="#" xlink:title="has_taint(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if taint is present"><text text-anchor="start" x="8" y="-187.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">has_taint()</text></a></g>
    <g id="a_node1_22"><a xlink:href="#" xlink:title="join(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate any number of strings.
  prefs: []
  type: TYPE_NORMAL
- en: The string whose method is called is inserted in between each given string.
  prefs: []
  type: TYPE_NORMAL
- en: The result is returned as a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: ''.''.join([''ab'', ''pq'', ''rs'']) -> ''ab.pq.rs''"><text text-anchor="start"
    x="8" y="-174.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">join()</text></a></g> <g id="a_node1_23"><a
    xlink:href="#" xlink:title="ljust(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a left-justified string of length width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is done using the specified fill character (default is a space)."><text
    text-anchor="start" x="8" y="-161.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">ljust()</text></a></g>
    <g id="a_node1_24"><a xlink:href="#" xlink:title="lower(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a copy of the string converted to lowercase."><text text-anchor="start"
    x="8" y="-149" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">lower()</text></a></g> <g id="a_node1_25"><a
    xlink:href="#" xlink:title="lstrip(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with leading whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-136.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">lstrip()</text></a></g>
    <g id="a_node1_26"><a xlink:href="#" xlink:title="make_str_wrapper(fun):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make `fun` (a `str` method) a method in `tstr`"><text text-anchor="start" x="8"
    y="-123.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">make_str_wrapper()</text></a></g> <g id="a_node1_27"><a
    xlink:href="#" xlink:title="replace(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with all occurrences of substring old replaced by new.
  prefs: []
  type: TYPE_NORMAL
- en: count
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of occurrences to replace.
  prefs: []
  type: TYPE_NORMAL
- en: -1 (the default value) means replace all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: If the optional argument count is given, only the first count occurrences are
  prefs: []
  type: TYPE_NORMAL
- en: 'replaced."><text text-anchor="start" x="8" y="-110.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">replace()</text></a></g>
    <g id="a_node1_28"><a xlink:href="#" xlink:title="rjust(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a right-justified string of length width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is done using the specified fill character (default is a space)."><text
    text-anchor="start" x="8" y="-98" font-family="''Fira Mono'', ''Source Code Pro'',
    ''Courier'', monospace" font-weight="bold" font-size="10.00">rjust()</text></a></g>
    <g id="a_node1_29"><a xlink:href="#" xlink:title="rstrip(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with trailing whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-85.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">rstrip()</text></a></g>
    <g id="a_node1_30"><a xlink:href="#" xlink:title="strip(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with leading and trailing whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-72.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">strip()</text></a></g>
    <g id="a_node1_31"><a xlink:href="#" xlink:title="swapcase(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert uppercase characters to lowercase and lowercase characters to uppercase."><text
    text-anchor="start" x="8" y="-59.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">swapcase()</text></a></g>
    <g id="a_node1_32"><a xlink:href="#" xlink:title="title(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a version of the string where each word is titlecased.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, words start with uppercased characters and all remaining
  prefs: []
  type: TYPE_NORMAL
- en: 'cased characters have lower case."><text text-anchor="start" x="8" y="-47"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">title()</text></a></g> <g id="a_node1_33"><a xlink:href="#"
    xlink:title="translate(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Replace each character in the string using the given translation table.
  prefs: []
  type: TYPE_NORMAL
- en: table
  prefs: []
  type: TYPE_NORMAL
- en: Translation table, which must be a mapping of Unicode ordinals to
  prefs: []
  type: TYPE_NORMAL
- en: Unicode ordinals, strings, or None.
  prefs: []
  type: TYPE_NORMAL
- en: The table must implement lookup/indexing via __getitem__, for instance a
  prefs: []
  type: TYPE_NORMAL
- en: dictionary or list. &nbsp;If this operation raises LookupError, the character
    is
  prefs: []
  type: TYPE_NORMAL
- en: 'left untouched. &nbsp;Characters mapped to None are deleted."><text text-anchor="start"
    x="8" y="-34.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">translate()</text></a></g> <g
    id="a_node1_34"><a xlink:href="#" xlink:title="upper(self, *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a copy of the string converted to uppercase."><text text-anchor="start"
    x="8" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">upper()</text></a></g> <g id="a_node1_35"><a
    xlink:href="#" xlink:title="create(self, s)"><text text-anchor="start" x="8" y="-7.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">create()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>str</title> <g id="a_node2"><a xlink:href="builtins.html"
    xlink:title="class str:'
  prefs: []
  type: TYPE_NORMAL
- en: str(object='') -> str
  prefs: []
  type: TYPE_NORMAL
- en: str(bytes_or_buffer[, encoding[, errors]]) -> str
  prefs: []
  type: TYPE_NORMAL
- en: Create a new string object from the given object. If encoding or
  prefs: []
  type: TYPE_NORMAL
- en: errors is specified, then the object must expose a data buffer
  prefs: []
  type: TYPE_NORMAL
- en: that will be decoded using the given encoding and error handler.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, returns the result of object.__str__() (if defined)
  prefs: []
  type: TYPE_NORMAL
- en: or repr(object).
  prefs: []
  type: TYPE_NORMAL
- en: encoding defaults to sys.getdefaultencoding().
  prefs: []
  type: TYPE_NORMAL
- en: errors defaults to 'strict'."><text text-anchor="start" x="53.5" y="-532.45"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">str</text></a></g></g> <g id="edge1" class="edge"><title>tstr->str</title></g>
    <g id="node3" class="node"><title>Legend</title> <text text-anchor="start" x="142.38"
    y="-256.62" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="142.38"
    y="-246.62" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="148.38" y="-246.62" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="142.38" y="-236.62" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="148.38" y="-236.62"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="142.38" y="-226.62" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="148.38" y="-226.62"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="142.38"
    y="-217.57" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Character Origins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ostr` objects extend `tstr` objects by not only tracking a taint, but also
    the originating *indexes* from the input string, This allows you to exactly track
    where individual characters came from. Assume you have a long string, which at
    index 100 contains the password `"joshua1234"`. Then you can save this origin
    information using an `ostr` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `origin` attribute of an `ostr` provides access to a list of indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ostr` objects are compatible with Python strings, except that string operations
    return `ostr` objects (together with the saved origin an index information). An
    index of `-1` indicates that the corresponding character has no origin as supplied
    to the `ostr()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`ostr` objects duplicate most `str` methods, as indicated in the class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="252pt" height="596pt" viewBox="0.00 0.00 251.62 595.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 591.75)"><g
    id="node1" class="node"><title>ostr</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class ostr:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapper for strings, saving taint and origin information"><text text-anchor="start"
    x="41" y="-497.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">ostr</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="ostr"><g id="a_node1_1"><a xlink:href="#" xlink:title="DEFAULT_ORIGIN
    = 0"><text text-anchor="start" x="11" y="-474.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">DEFAULT_ORIGIN</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="UNKNOWN_ORIGIN = -1"><text text-anchor="start"
    x="11" y="-462" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">UNKNOWN_ORIGIN</text></a></g></a></g> <g id="a_node1_3"><a
    xlink:href="#" xlink:title="ostr"><g id="a_node1_4"><a xlink:href="#" xlink:title="__add__(self,
    other):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self+value."><text text-anchor="start" x="8" y="-442.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__add__()</text></a></g>
    <g id="a_node1_5"><a xlink:href="#" xlink:title="__getitem__(self, key):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self[key]."><text text-anchor="start" x="8" y="-429.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__getitem__()</text></a></g>
    <g id="a_node1_6"><a xlink:href="#" xlink:title="__init__(self, value: Any, taint:
    Any = None, origin: Union[int, List[int], NoneType] = None, **kwargs) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`value` is the string value the `ostr` object is to be constructed from.'
  prefs: []
  type: TYPE_NORMAL
- en: '`taint` is an (optional) taint to be propagated to derived strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '`origin` (optional) is either'
  prefs: []
  type: TYPE_NORMAL
- en: '- an integer denoting the index of the first character in `value`, or'
  prefs: []
  type: TYPE_NORMAL
- en: '- a list of integers denoting the origins of the characters in `value`,"><text
    text-anchor="start" x="8" y="-416.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="__iter__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement iter(self)."><text text-anchor="start" x="8" y="-404" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__iter__()</text></a></g>
    <g id="a_node1_8"><a xlink:href="#" xlink:title="__mod__(self, s):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return self%value."><text text-anchor="start" x="8" y="-391.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__mod__()</text></a></g>
    <g id="a_node1_9"><a xlink:href="#" xlink:title="__new__(cls, value, *args, **kw):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an ostr() instance. Used internally."><text text-anchor="start" x="8"
    y="-378.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">__new__()</text></a></g> <g id="a_node1_10"><a
    xlink:href="#" xlink:title="__repr__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return repr(self)."><text text-anchor="start" x="8" y="-365.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__repr__()</text></a></g>
    <g id="a_node1_11"><a xlink:href="#" xlink:title="__rmod__(self, s):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return value%self."><text text-anchor="start" x="8" y="-353" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__rmod__()</text></a></g>
    <g id="a_node1_12"><a xlink:href="#" xlink:title="__str__(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return str(self)."><text text-anchor="start" x="8" y="-340.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__str__()</text></a></g>
    <g id="a_node1_13"><a xlink:href="#" xlink:title="capitalize(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a capitalized version of the string.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, make the first character have upper case and the rest lower
  prefs: []
  type: TYPE_NORMAL
- en: 'case."><text text-anchor="start" x="8" y="-327.5" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">capitalize()</text></a></g>
    <g id="a_node1_14"><a xlink:href="#" xlink:title="expandtabs(self, n=8):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy where all tab characters are expanded using spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'If tabsize is not given, a tab size of 8 characters is assumed."><text text-anchor="start"
    x="8" y="-314.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">expandtabs()</text></a></g> <g
    id="a_node1_15"><a xlink:href="#" xlink:title="join(self, iterable):'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate any number of strings.
  prefs: []
  type: TYPE_NORMAL
- en: The string whose method is called is inserted in between each given string.
  prefs: []
  type: TYPE_NORMAL
- en: The result is returned as a new string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: ''.''.join([''ab'', ''pq'', ''rs'']) -> ''ab.pq.rs''"><text text-anchor="start"
    x="8" y="-302" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">join()</text></a></g> <g id="a_node1_16"><a
    xlink:href="#" xlink:title="ljust(self, width, fillchar='' ''):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a left-justified string of length width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is done using the specified fill character (default is a space)."><text
    text-anchor="start" x="8" y="-289.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">ljust()</text></a></g>
    <g id="a_node1_17"><a xlink:href="#" xlink:title="lower(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a copy of the string converted to lowercase."><text text-anchor="start"
    x="8" y="-276.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">lower()</text></a></g> <g id="a_node1_18"><a
    xlink:href="#" xlink:title="lstrip(self, cl=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with leading whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-263.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">lstrip()</text></a></g>
    <g id="a_node1_19"><a xlink:href="#" xlink:title="partition(self, sep):'
  prefs: []
  type: TYPE_NORMAL
- en: Partition the string into three parts using the given separator.
  prefs: []
  type: TYPE_NORMAL
- en: This will search for the separator in the string. &nbsp;If the separator is
    found,
  prefs: []
  type: TYPE_NORMAL
- en: returns a 3-tuple containing the part before the separator, the separator
  prefs: []
  type: TYPE_NORMAL
- en: itself, and the part after it.
  prefs: []
  type: TYPE_NORMAL
- en: If the separator is not found, returns a 3-tuple containing the original string
  prefs: []
  type: TYPE_NORMAL
- en: 'and two empty strings."><text text-anchor="start" x="8" y="-251" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">partition()</text></a></g>
    <g id="a_node1_20"><a xlink:href="#" xlink:title="replace(self, a, b, n=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy with all occurrences of substring old replaced by new.
  prefs: []
  type: TYPE_NORMAL
- en: count
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of occurrences to replace.
  prefs: []
  type: TYPE_NORMAL
- en: -1 (the default value) means replace all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: If the optional argument count is given, only the first count occurrences are
  prefs: []
  type: TYPE_NORMAL
- en: 'replaced."><text text-anchor="start" x="8" y="-238.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">replace()</text></a></g>
    <g id="a_node1_21"><a xlink:href="#" xlink:title="rjust(self, width, fillchar=''
    ''):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a right-justified string of length width.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding is done using the specified fill character (default is a space)."><text
    text-anchor="start" x="8" y="-225.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">rjust()</text></a></g>
    <g id="a_node1_22"><a xlink:href="#" xlink:title="rpartition(self, sep):'
  prefs: []
  type: TYPE_NORMAL
- en: Partition the string into three parts using the given separator.
  prefs: []
  type: TYPE_NORMAL
- en: This will search for the separator in the string, starting at the end. If
  prefs: []
  type: TYPE_NORMAL
- en: the separator is found, returns a 3-tuple containing the part before the
  prefs: []
  type: TYPE_NORMAL
- en: separator, the separator itself, and the part after it.
  prefs: []
  type: TYPE_NORMAL
- en: If the separator is not found, returns a 3-tuple containing two empty strings
  prefs: []
  type: TYPE_NORMAL
- en: 'and the original string."><text text-anchor="start" x="8" y="-212.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">rpartition()</text></a></g>
    <g id="a_node1_23"><a xlink:href="#" xlink:title="rsplit(self, sep=None, maxsplit=-1):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the substrings in the string, using sep as the separator string.
  prefs: []
  type: TYPE_NORMAL
- en: sep
  prefs: []
  type: TYPE_NORMAL
- en: The separator used to split the string.
  prefs: []
  type: TYPE_NORMAL
- en: When set to None (the default value), will split on any whitespace
  prefs: []
  type: TYPE_NORMAL
- en: character (including \n \r \t \f and spaces) and will discard
  prefs: []
  type: TYPE_NORMAL
- en: empty strings from the result.
  prefs: []
  type: TYPE_NORMAL
- en: maxsplit
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of splits.
  prefs: []
  type: TYPE_NORMAL
- en: -1 (the default value) means no limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Splitting starts at the end of the string and works to the front."><text text-anchor="start"
    x="8" y="-200" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">rsplit()</text></a></g> <g id="a_node1_24"><a
    xlink:href="#" xlink:title="rstrip(self, cl=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with trailing whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-187.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">rstrip()</text></a></g>
    <g id="a_node1_25"><a xlink:href="#" xlink:title="split(self, sep=None, maxsplit=-1):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a list of the substrings in the string, using sep as the separator string.
  prefs: []
  type: TYPE_NORMAL
- en: sep
  prefs: []
  type: TYPE_NORMAL
- en: The separator used to split the string.
  prefs: []
  type: TYPE_NORMAL
- en: When set to None (the default value), will split on any whitespace
  prefs: []
  type: TYPE_NORMAL
- en: character (including \n \r \t \f and spaces) and will discard
  prefs: []
  type: TYPE_NORMAL
- en: empty strings from the result.
  prefs: []
  type: TYPE_NORMAL
- en: maxsplit
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of splits.
  prefs: []
  type: TYPE_NORMAL
- en: -1 (the default value) means no limit.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting starts at the front of the string and works to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Note, str.split() is mainly useful for data that has been intentionally
  prefs: []
  type: TYPE_NORMAL
- en: delimited. &nbsp;With natural text that includes punctuation, consider using
  prefs: []
  type: TYPE_NORMAL
- en: 'the regular expression module."><text text-anchor="start" x="8" y="-174.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">split()</text></a></g> <g id="a_node1_26"><a xlink:href="#"
    xlink:title="strip(self, cl=None):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a copy of the string with leading and trailing whitespace removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If chars is given and not None, remove characters in chars instead."><text
    text-anchor="start" x="8" y="-161.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">strip()</text></a></g>
    <g id="a_node1_27"><a xlink:href="#" xlink:title="swapcase(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert uppercase characters to lowercase and lowercase characters to uppercase."><text
    text-anchor="start" x="8" y="-149" font-family="''Fira Mono'', ''Source Code Pro'',
    ''Courier'', monospace" font-weight="bold" font-size="10.00">swapcase()</text></a></g>
    <g id="a_node1_28"><a xlink:href="#" xlink:title="title(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Return a version of the string where each word is titlecased.
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, words start with uppercased characters and all remaining
  prefs: []
  type: TYPE_NORMAL
- en: 'cased characters have lower case."><text text-anchor="start" x="8" y="-136.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">title()</text></a></g> <g id="a_node1_29"><a xlink:href="#"
    xlink:title="upper(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return a copy of the string converted to uppercase."><text text-anchor="start"
    x="8" y="-123.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">upper()</text></a></g> <g id="a_node1_30"><a
    xlink:href="#" xlink:title="x(self, i=0):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract substring at index/slice `i`"><text text-anchor="start" x="8" y="-110.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">x()</text></a></g> <g id="a_node1_31"><a xlink:href="#" xlink:title="__radd__(self,
    other)"><text text-anchor="start" x="8" y="-97" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">__radd__()</text></a></g>
    <g id="a_node1_32"><a xlink:href="#" xlink:title="_split_helper(self, sep, splitted)"><text
    text-anchor="start" x="8" y="-84.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">_split_helper()</text></a></g>
    <g id="a_node1_33"><a xlink:href="#" xlink:title="_split_space(self, splitted)"><text
    text-anchor="start" x="8" y="-71.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">_split_space()</text></a></g>
    <g id="a_node1_34"><a xlink:href="#" xlink:title="clear_origin(self)"><text text-anchor="start"
    x="8" y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">clear_origin()</text></a></g> <g id="a_node1_35"><a
    xlink:href="#" xlink:title="clear_taint(self)"><text text-anchor="start" x="8"
    y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">clear_taint()</text></a></g> <g id="a_node1_36"><a xlink:href="#"
    xlink:title="create(self, res, origin=None)"><text text-anchor="start" x="8" y="-33.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">create()</text></a></g>
    <g id="a_node1_37"><a xlink:href="#" xlink:title="has_origin(self)"><text text-anchor="start"
    x="8" y="-20.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">has_origin()</text></a></g> <g id="a_node1_38"><a
    xlink:href="#" xlink:title="has_taint(self)"><text text-anchor="start" x="8" y="-7.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">has_taint()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>str</title> <g id="a_node2"><a xlink:href="builtins.html"
    xlink:title="class str:'
  prefs: []
  type: TYPE_NORMAL
- en: str(object='') -> str
  prefs: []
  type: TYPE_NORMAL
- en: str(bytes_or_buffer[, encoding[, errors]]) -> str
  prefs: []
  type: TYPE_NORMAL
- en: Create a new string object from the given object. If encoding or
  prefs: []
  type: TYPE_NORMAL
- en: errors is specified, then the object must expose a data buffer
  prefs: []
  type: TYPE_NORMAL
- en: that will be decoded using the given encoding and error handler.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, returns the result of object.__str__() (if defined)
  prefs: []
  type: TYPE_NORMAL
- en: or repr(object).
  prefs: []
  type: TYPE_NORMAL
- en: encoding defaults to sys.getdefaultencoding().
  prefs: []
  type: TYPE_NORMAL
- en: errors defaults to 'strict'."><text text-anchor="start" x="44.5" y="-565.95"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">str</text></a></g></g> <g id="edge1" class="edge"><title>ostr->str</title></g>
    <g id="node3" class="node"><title>Legend</title> <text text-anchor="start" x="124.38"
    y="-273.38" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="124.38"
    y="-263.38" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="130.38" y="-263.38" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="124.38" y="-253.38" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="130.38" y="-253.38"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="124.38" y="-243.38" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="130.38" y="-243.38"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="124.38"
    y="-234.32" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: A Vulnerable Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Say we want to implement an *in-memory database* service in Python. Here is
    a rather flimsy attempt. We use the following dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our DB is a Python class that parses its arguments and throws `SQLException`
    which is defined below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The database is simply a Python `dict` that is exposed only through SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Representing Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The database contains tables, which are created by a method call `create_table()`.
    Each table data structure is a pair of values. The first one is the meta data
    containing column names and types. The second value is a list of values in the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The table can be retrieved using the name using the `table()` method call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how to use both. We fill a table `inventory` with four
    columns: `year`, `kind`, `company`, and `model`. Initially, our table is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using `table()`, we can retrieve the table definition as well as its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We also define `column()` for retrieving the column definition from a table
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Executing SQL Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sql()` method of `DB` executes SQL statements. It inspects its arguments,
    and dispatches the query based on the kind of SQL statement to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of how to use the `DB` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: However, at this point, the individual methods for handling SQL statements are
    not yet defined. Let us do this in the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-SQL-Statements"><summary>Implementing SQL
    Statements</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Selecting Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `do_select()` method handles SQL `select` statements to retrieve data from
    a table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `expression_clause()` method is used for two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the form `select` $x$, $y$, $z$ `from` $t$, it *evaluates* (and returns)
    the expressions $x$, $y$, $z$ in the contexts of the selected rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a clause `where` $p$ is given, it also evaluates $p$ in the context of the
    rows and includes the rows in the selection only if $p$ holds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To evaluate expressions like $x$, $y$, $z$ or $p$, the method `expression_clause()`
    makes use of the Python `eval()` evaluation function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If `eval()` fails for whatever reason, we raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Note:** Using `eval()` here introduces some important security issues, which
    we will discuss later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's how we can use `sql()` to issue a query. Note that the table is yet empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Inserting Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `do_insert()` method handles SQL `insert` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In SQL, a column can come in any supported data type. To ensure it is stored
    using the type originally declared, we need the ability to convert the values
    to specific types which is provided by `convert()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of how to use the SQL `insert` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'With the database filled, we can also run more complex queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Updating Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Similarly, `do_update()` handles SQL `update` statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example. Let us first fill the database again with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Deleting Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, SQL `delete` statements are handled by `do_delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example. Let us first fill the database again with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can delete data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Our database is now empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Here is how our database can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We first create a table in our database with the correct data types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here is a simple convenience function to update the table using our dataset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Our database now contains the same dataset as `VEHICLES` under `INVENTORY` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here is a sample select statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We can run updates on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It can even do mathematics on the fly!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Adding a new row to our table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Which we then delete.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To verify that everything is OK, let us fuzz. First we define our grammar.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Defining-a-SQL-grammar"><summary>Defining a SQL grammar</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen from the source of our database, the functions always check whether
    the table name is correct. Hence, we modify the grammar to choose our particular
    table so that it will have a better chance of reaching deeper. We will see in
    the later sections how this can be done automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing does not seem to have triggered any crashes. However, are crashes the
    only errors that we should be worried about?
  prefs: []
  type: TYPE_NORMAL
- en: The Evil of Eval
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our database implementation – notably in the `expression_clause()` method
    -, we have made use of `eval()` to evaluate expressions using the Python interpreter.
    This allows us to unleash the full power of Python expressions within our SQL
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: In the above query, the clause `year < 2000` is evaluated using `expression_clause()`
    using Python in the context of each row; hence, `year < 2000` evaluates to either
    `True` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same holds for the expressions being `select`ed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This works because `year - 1900 if year < 2000 else year - 2000` is a valid
    Python expression. (It is not a valid SQL expression, though.)
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the above is that there is *no limitation* to what the Python
    expression can do. What if the user tries the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The above statement effectively reads from the users' file system. Instead of
    `os.popen("pwd").read()`, it could execute arbitrary Python commands – to access
    data, install software, run a background process. This is where "the full power
    of Python expressions" turns back on us.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is to allow our *program* to make full use of its power; yet, the
    *user* (or any third party) should not be entrusted to do the same. Hence, we
    need to differentiate between (trusted) *input from the program* and (untrusted)
    *input from the user*.
  prefs: []
  type: TYPE_NORMAL
- en: One method that allows such differentiation is that of *dynamic taint analysis*.
    The idea is to identify the functions that accept user input as *sources* that
    *taint* any string that comes in through them, and those functions that perform
    dangerous operations as *sinks*. Finally, we bless certain functions as *taint
    sanitizers*. The idea is that an input from the source should never reach the
    sink without undergoing sanitization first. This allows us to use a stronger oracle
    than simply checking for crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking String Taints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various levels of taint tracking that one can perform. The simplest
    is to track that a string fragment originated in a specific environment, and has
    not undergone a taint removal process. For this, we simply need to wrap the original
    string with an environment identifier (the *taint*) with `tstr`, and produce `tstr`
    instances on each operation that results in another string fragment. The attribute
    `taint` holds a label identifying the environment this instance was derived.
  prefs: []
  type: TYPE_NORMAL
- en: A Class for Tainted Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For capturing information flows we need a new string class. The idea is to use
    the new tainted string class `tstr` as a wrapper on the original `str` class.
    However, `str` is an *immutable* class. Hence, it does not call its `__init__()`
    method after being constructed. This means that any subclasses of `str` also will
    not get the `__init__()` method called. If we want to get our initialization routine
    called, we need to [hook into `__new__()`](https://docs.python.org/3/reference/datamodel.html#basic-customization)
    and return an instance of our own class. We combine this with our initialization
    code in `__init__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we wrap `"hello"` in `tstr`, then we should be able to access
    its taint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: By default, when we wrap a string, it is tainted. Hence, we also need a way
    to clear the taint in the string. One way is to simply return a `str` instance
    as above. However, one may sometimes wish to remove the taint from an existing
    instance. This is accomplished with `clear_taint()`. During `clear_taint()`, we
    simply set the taint to `None`. This method comes with a paired method `has_taint()`
    which checks whether a `tstr` instance has a taint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: String Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To propagate the taint, we have to extend string functions, such as operators.
    We can do so in one single big step, overloading all string methods and operators.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new string from an existing tainted string, we propagate its
    taint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The `make_str_wrapper()` function creates a wrapper around an existing string
    method which attaches the taint to the result of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'We do this for all string methods that return a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The one missing operator is `+` with a regular string on the left side and a
    tainted string on the right side. Python supports a `__radd__()` method which
    is invoked if the associated object is used on the right side of an addition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: With this, we are already done. Let us create a string `thello` with a taint
    `LOW`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, any substring will also be tainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'String additions will return a `tstr` object with the taint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `__radd__()` method ensures this also works if the `tstr` occurs on the
    right side of a string addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Other operators such as multiplication also work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Tracking Untrusted Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what can one do with tainted strings? We reconsider the `DB` example. We
    define a "better" `TrustedDB` which only accepts strings tainted as `"TRUSTED"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Feeding a string with an "unknown" (i.e., non-existing) trust level will cause
    `TrustedDB` to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, any user input would be originally tagged with `"UNTRUSTED"`
    as taint. If we place an untrusted string into our better calculator, it will
    also fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Hence, somewhere along the computation, we have to turn the "untrusted" inputs
    into "trusted" strings. This process is called *sanitization*. A simple sanitization
    function for our purposes could ensure that the input consists only of few allowed
    characters (not including letters or quotes); if this is the case, then the input
    gets a new `"TRUSTED"` taint. If not, we turn the string into an (untrusted) empty
    string; other alternatives would be to raise an error or to escape or delete "untrusted"
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now try out our untrusted input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can prevent SQL and code injections discussed in [the chapter
    on Web fuzzing](WebFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Taint Aware Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use tainting to *direct fuzzing to those grammar rules that are
    likely to generate dangerous inputs.* The idea here is to identify inputs generated
    by our fuzzer that lead to untrusted execution. First we define the exception
    to be thrown when a tainted value reaches a dangerous operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: TaintedDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, since `my_eval()` is the most dangerous operation in the `DB` class, we
    define a new class `TaintedDB` that overrides the `my_eval()` to throw an exception
    whenever an untrusted string reaches this part.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: We initialize an instance of `TaintedDB`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Then we start fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: One can see that `insert`, `update`, `select` and `delete` statements on an
    existing table lead to taint exceptions. We can now focus on these specific kinds
    of inputs. However, this is not the only thing we can do. We will see how we can
    identify specific portions of input that reached tainted execution using character
    origins in the later sections. But before that, we explore other uses of taints.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Privacy Leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using taints, we can also ensure that secret information does not leak out.
    We can assign a special taint `"SECRET"` to strings whose information must not
    leak out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing any substring of `secrets` will propagate the taint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the *heartbeat* security leak from [the chapter on Fuzzing](Fuzzer.html),
    in which a server would accidentally reply not only the user input sent to it,
    but also secret memory. If the reply consists only of the user input, there is
    no taint associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'If, however, the reply contains *any* part of the secret, the reply will be
    tainted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The output function of our server would now ensure that the data sent back
    does not contain any secret information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `tstr` solution can help to identify information leaks – but it is by no
    means complete. If we actually take the `heartbeat()` implementation from [the
    chapter on Fuzzing](Fuzzer.html), we will see that *any* reply is marked as `SECRET`
    – even those not even accessing secret memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Why is this? If we look into the implementation of `heartbeat()`, we will see
    that it first builds a long string `memory` from the (non-secret) reply and the
    (secret) memory, before returning the first characters from `memory`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the whole memory still is tainted as `SECRET`, *including* the
    non-secret part from `reply`.
  prefs: []
  type: TYPE_NORMAL
- en: We may be able to circumvent the issue by tagging the `reply` as `PUBLIC` – but
    then, this taint would be in conflict with the `SECRET` tag of `memory`. What
    happens if we compose a string from two differently tainted strings?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: It turns out that in this case, the `__add__()` method takes precedence over
    the `__radd__()` method, which means that the right-hand `"Low"` string is treated
    as a regular (non-tainted) string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'We could set up the `__add__()` and other methods with special handling for
    conflicting taints. However, the way this conflict should be resolved would be
    highly *application-dependent*:'
  prefs: []
  type: TYPE_NORMAL
- en: If we use taints to indicate *privacy levels*, `SECRET` privacy should take
    precedence over `PUBLIC` privacy. Any combination of a `SECRET`-tainted string
    and a `PUBLIC`-tainted string thus should have a `SECRET` taint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use taints to indicate *origins* of information, an `UNTRUSTED` origin
    should take precedence over a `TRUSTED` origin. Any combination of an `UNTRUSTED`-tainted
    string and a `TRUSTED`-tainted string thus should have an `UNTRUSTED` taint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, such conflict resolutions can be implemented. But even so, they will
    not help us in the `heartbeat()` example differentiating secret from non-secret
    output data.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Individual Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, there is a better, more generic way to solve the above problems.
    The key to composition of differently tainted strings is to assign taints not
    only to strings, but actually to every bit of information – in our case, characters.
    If every character has a taint on its own, a new composition of characters will
    simply inherit this very taint *per character*. To this end, we introduce a second
    bit of information named *origin*.
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing various untrusted sources may be accomplished by originating
    each instance as separate instance (called *colors* in dynamic origin research).
    You will see an instance of this technique in the chapter on [Grammar Mining](GrammarMiner.html).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we carry *character level* origins. That is, given a fragment
    that resulted from a portion of the original originated string, one will be able
    to tell which portion of the input string the fragment was taken from. In essence,
    each input character index from an originated source gets its own color.
  prefs: []
  type: TYPE_NORMAL
- en: More complex originating such as *bitmap origins* are possible where a single
    character may result from multiple origined character indexes (such as *checksum*
    operations on strings). We do not consider these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A Class for Tracking Character Origins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us introduce a class `ostr` which, like `tstr`, carries a taint for each
    string, and additionally an *origin* for each character that indicates its source.
    It is a consecutive number in a particular range (by default, starting with zero)
    indicating its *position* within a specific origin.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `tstr`, above, we implement methods for conversion into (regular) Python
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, character origins start with `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: We can also specify the starting origin as below -- `6..10`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '`str()` returns a `str` instance without origin or taint information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '`repr()`, however, keeps the origin information for the original string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with taints, we can clear origins and check whether an origin is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: In the remainder of this section, we re-implement various string methods such
    that they also keep track of origins. If this is too tedious for you, jump right
    [to the next section](#Checking-Origins) which gives a number of usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-String-Methods"><summary>Implementing String
    Methods</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We need to create new substrings that are wrapped in `ostr` objects. However,
    we also want to allow our subclasses to create their own instances. Hence, we
    again provide a `create()` method that produces a new `ostr` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Index
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Python, indexing is provided through `__getitem__()`. Indexing on positive
    integers is simple enough. However, it has two additional wrinkles. The first
    is that, if the index is negative, that many characters are counted from the end
    of the string which lies just after the last character. That is, the last character
    has a negative index `-1`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The other wrinkle is that `__getitem__()` can accept a slice. We discuss this
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Python `slice` operator `[n:m]` relies on the object being an `iterator`.
    Hence, we define the `__iter__()` method, which returns a custom `iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: The `__iter__()` method requires a supporting `iterator` object. The `iterator`
    is used to save the state of the current iteration, which it does by keeping a
    reference to the original `ostr`, and the current index of iteration `_str_idx`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Bringing all these together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Splits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '(Exercise for the reader: handle *partitions*, i.e., splitting a string by
    substrings)'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If two origined strings are concatenated together, it may be desirable to transfer
    the origins from each to the corresponding portion of the resulting string. The
    concatenation of strings is accomplished by overriding `__add__()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: What if a `ostr` is concatenated with a `str`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: One wrinkle here is that when adding a `ostr` and a `str`, the user may place
    the `str` first, in which case, the `__add__()` method will be called on the `str`
    instance. Not on the `ostr` instance. However, Python provides a solution. If
    one defines `__radd__()` on the `ostr` instance, that method will be called rather
    than `str.__add__()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'We test it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'These methods: `slicing` and `concatenation` is sufficient to implement other
    string methods that result in a string, and does not change the character underneath
    (i.e. no case change). Hence, we look at a helper method next.'
  prefs: []
  type: TYPE_NORMAL
- en: Extract Origin String
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given a specific input index, the method `x()` extracts the corresponding originated
    portion from a `ostr`. As a convenience it supports `slices` along with `ints`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: Replace
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `replace()` method replaces a portion of the string with another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Split
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We essentially have to re-implement split operations, and split by space is
    slightly different from other splits.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Strip
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Expand Tabs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Partitions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Justify
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: mod
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: String methods that do not change origin
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: General wrappers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are not strictly needed for operation, but can be useful for tracing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: Methods yet to be translated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These methods generate strings from other strings. However, we do not have the
    right implementations for any of these. Hence these are marked as dangerous until
    we can generate the right translations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: While generating proxy wrappers for string operations can handle most common
    cases of transmission of information flow, some operations involving strings can
    not be overridden. For example, consider the following.</details>
  prefs: []
  type: TYPE_NORMAL
- en: Checking Origins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all this implemented, we now have full-fledged `ostr` strings where we
    can easily check the origin of each and every character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a string originates from another string, we can convert the
    origin to a set and resort to standard set operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Privacy Leaks Revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us apply it to see whether we can come up with a satisfactory solution for
    checking the `heartbeat()` function against information leakage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'We define a "secret" that must not leak out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'Each and every character in `secret` has an origin starting with `SECRET_ORIGIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: If we now invoke `heartbeat()` with a given string, the origin of the reply
    should all be `UNKNOWN_ORIGIN` (from the input), and none of the characters should
    have a `SECRET_ORIGIN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify that the secret did not leak out by formulating appropriate assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: All assertions pass, again confirming that no secret leaked out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now go and exploit `heartbeat()` to reveal its secrets. As `heartbeat()`
    is unchanged, it is as vulnerable as it was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, however, the reply *does* contain secret information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: We can now integrate these assertions into the `heartbeat()` function, causing
    it to fail before leaking information. Additionally (or alternatively?), we can
    also rewrite our output functions not to give out any secret information. We will
    leave these two exercises for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: Taint-Directed Fuzzing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous *Taint Aware Fuzzing* was a bit unsatisfactory in that we could
    not focus on the specific parts of the grammar that led to dangerous operations.
    We fix that with *taint directed fuzzing* using `TrackingDB`.
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is to track the origins of each character that reaches `eval`.
    Then, track it back to the grammar nodes that generated it, and increase the probability
    of using those nodes again.
  prefs: []
  type: TYPE_NORMAL
- en: TrackingDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `TrackingDB` is similar to `TaintedDB`. The difference is that, if we find
    that the execution has reached the `my_eval`, we simply raise the `Tainted`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need a specially crafted fuzzer that preserves the taints.
  prefs: []
  type: TYPE_NORMAL
- en: TaintedGrammarFuzzer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We define a `TaintedGrammarFuzzer` class that ensures that the taints propagate
    to the derivation tree. This is similar to the `GrammarFuzzer` from the [chapter
    on grammar fuzzers](GrammarFuzzer.html) except that the origins and taints are
    preserved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: We use a specially prepared tainted grammar for fuzzing. We mark each individual
    definition, each individual rule, and each individual token with a separate origin
    (we chose a token boundary of 10 here, after inspecting the grammar). This allows
    us to track exactly which parts of the grammar were involved in the operations
    we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: As before, we initialize the `TrackingDB`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to ensure that the taints are preserved, when the tree is converted
    back to a string. For this, we define the `tainted_tree_to_string()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: We define `update_grammar()` that accepts a set of origins that reached the
    dangerous operations and the derivation tree of the original string used for fuzzing
    to update the enhanced grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: With these, we are now ready to fuzz.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: We can now inspect our enhanced grammar to see how many times each rule was
    used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: From here, the idea is to focus on the rules that reached dangerous operations
    more often, and increase the probability of the values of that kind.
  prefs: []
  type: TYPE_NORMAL
- en: The Limits of Taint Tracking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While our framework can detect information leakage, it is by no means perfect.
    There are several ways in which taints can get lost and information thus may still
    leak out.
  prefs: []
  type: TYPE_NORMAL
- en: Conversions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We only track taints and origins through *strings* and *characters*. If we convert
    these to numbers (or other data), the information is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider this function, converting individual characters to
    numbers and back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'The taints and origins will not propagate through the number conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: This issue could be addressed by extending numbers with taints and origins,
    just as we did for strings. At some point, however, this will still break down,
    because as soon as an internal C function in the Python library is reached, the
    taint will not propagate into and across the C function. (Unless one starts implementing
    dynamic taints for these, that is.)
  prefs: []
  type: TYPE_NORMAL
- en: Internal C libraries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we mentioned before, calls to *internal* C libraries do not propagate taints.
    For example, while the following preserves the taints,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: a call to a `join` that should be equivalent will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Implicit Information Flow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even if one could taint all data in a program, there still would be means to
    break information flow – notably by turning explicit flow into *implicit* flow,
    or data flow into *control flow*. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: With such a function, there is no explicit data flow between the characters
    in `s` and the characters in `t`; yet, the strings would be identical. This problem
    frequently occurs in programs that process and manipulate external input.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Tainting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Both, conversions and implicit information flow are one of several possibilities
    how taint and origin information get lost. To address the problem, the best solution
    is to *always assume the worst from untainted strings*:'
  prefs: []
  type: TYPE_NORMAL
- en: As it comes to trust, an untainted string should be treated as *possibly untrusted*,
    and hence not relied upon unless sanitized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it comes to privacy, an untainted string should be treated as *possibly secret*,
    and hence not leaked out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a consequence, your program should always have two kinds of taints: one
    for explicitly trusted (or secret) and one for explicitly untrusted (or non-secret).
    If a taint gets lost along the way, you may have to restore it from its sources
    – not unlike the string methods discussed above. The benefit is a trusted application,
    in which each and every information flow can be checked at runtime, with violations
    quickly discovered through automated tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String-based and character-based taints allow dynamically tracking the information
    flow from input to the internals of a system and back to the output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking taints allows discovering untrusted inputs and information leakage
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data conversions and implicit data flow may strip taint information; the resulting
    untainted strings should be treated as having the worst possible taint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taints can be used in conjunction with fuzzing to provide a more robust indication
    of incorrect behavior than to simply rely on program crashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An even better alternative to our taint-directed fuzzing is to make use of *symbolic*
    techniques that take the semantics of the program under test into account. The
    chapter on [flow fuzzing](FlowFuzzer.html) introduces these symbolic techniques
    for the purpose of exploring information flows; the subsequent chapter on [symbolic
    fuzzing](SymbolicFuzzer.html) then shows how to make full-fledged use of symbolic
    execution for covering code. Similarly, [search based fuzzing](SearchBasedFuzzer.html)
    can often provide a cheaper exploration strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taint analysis on Python using a library approach as we implemented in this
    chapter was discussed by Conti et al. [[Conti *et al*, 2012](https://doi.org/10.1007/978-3-642-27937-9_15)].
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Tainted Numbers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduce a class `tint` (for tainted integer) that, like `tstr`, has a taint
    attribute that gets passed on from `tint` to `tint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: Creation'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implement the `tint` class such that taints are set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/InformationFlow.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Arithmetic expressions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ensure that taints get passed along arithmetic expressions; support addition,
    subtraction, multiplication, and division operators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/InformationFlow.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Passing taints from integers to strings'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting a tainted integer into a string (using `repr()`) should yield a
    tainted string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/InformationFlow.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Passing taints from strings to integers'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting a tainted object (with a `taint` attribute) to an integer should
    pass that taint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/InformationFlow.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Information Flow Testing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generate tests that ensure a *maximum* of information flow, propagating specific
    taints as much as possible. Implement an appropriate fitness function for [search-based
    testing](SearchBasedFuzzer.html) and let the search-based fuzzer search for solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/InformationFlow.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/InformationFlow.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Tracking Information Flow](https://www.fuzzingbook.org/html/InformationFlow.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/InformationFlow.html](https://www.fuzzingbook.org/html/InformationFlow.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
