["```py\n>>> from [fuzzingbook.SearchBasedFuzzer](SearchBasedFuzzer.html) import <identifier> \n```", "```py\n>>> hillclimber()\nInitial value: -67005, 8742 at fitness 84491.0000\nNew value: -67006, 8741 at fitness 84490.0000\nNew value: -67007, 8740 at fitness 84489.0000\nNew value: -67008, 8739 at fitness 84488.0000\nNew value: -67009, 8738 at fitness 84487.0000\nNew value: -67010, 8737 at fitness 84486.0000\nNew value: -67011, 8736 at fitness 84485.0000\nNew value: -67012, 8735 at fitness 84484.0000\nNew value: -67013, 8734 at fitness 84483.0000\nNew value: -67014, 8733 at fitness 84482.0000\nNew value: -67015, 8732 at fitness 84481.0000\nNew value: -67016, 8731 at fitness 84480.0000\nNew value: -67017, 8730 at fitness 84479.0000\nNew value: -67018, 8729 at fitness 84478.0000\nNew value: -67019, 8728 at fitness 84477.0000\nNew value: -67020, 8727 at fitness 84476.0000\nNew value: -67021, 8726 at fitness 84475.0000\nNew value: -67022, 8725 at fitness 84474.0000\nNew value: -67023, 8724 at fitness 84473.0000\nNew value: -67024, 8723 at fitness 84472.0000\nNew value: -67025, 8722 at fitness 84471.0000\n...\nFound optimum after 58743 iterations at -100000, -50001 \n```", "```py\n>>> cgi_decode_instrumented = create_instrumented_function(cgi_decode)\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:15: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  args=[ast.Num(self.branch_num),\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:16: DeprecationWarning: ast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  ast.Str(node.ops[0].__class__.__name__), \n```", "```py\n>>> get_fitness_cgi(\"Foo\")\n5.0 \n```", "```py\n>>> genetic_algorithm()\nBest fitness of initial population: '䫪Ʝ\\uf42b铺뿱ጻ䗷䌮肵篭' - 5.0000000000\nBest fitness at generation 1: '\\u19cdꥁ캖蝻ⅹ\\uf37f功ᰲ\\ued7eᱨ' - 5.00000000\nBest fitness at generation 2: '绑䀕\\u20c5֜적\\udfaeᇒ툧痮Ꮶ' - 5.00000000\nBest fitness at generation 3: '끍碼ߝ䣅쾜\\u0b7b죅ᦜ\\uf1fd䈕' - 5.00000000\nBest fitness at generation 4: '甚ᇆꏭ貰꾵訴྿ꙩᏃด' - 5.00000000\nBest fitness at generation 5: '\\uf644ᇆꏭ貰虀ꎍ\\uf6f9嫛ሎ㺁' - 5.00000000\nBest fitness at generation 6: '빫\\uf61a\\ud85c熆꾵訴ဍꙩᑓ\\ue8e0' - 5.00000000\nBest fitness at generation 7: '닅\\uf307Ɗ\\uefc5筂鐞嚂ᡥ⃫㺤' - 5.00000000\nBest fitness at generation 8: '漻㺅揝䄩薽턫轼\\u0dcc\\udb87胮' - 5.00000000\nBest fitness at generation 9: '甚ᇩ護㿦腄ꑗ\\uf6f9嫛ም凂' - 5.00000000\nBest fitness at generation 10: '끍ᇆ⁔峤羘䶦Ⓛ巖桿\\ue8ac' - 5.00000000\nBest fitness at generation 11: '㞮械ꏭഡ鰴勂ᇒ툧䧱㺡' - 5.00000000\nBest fitness at generation 12: '닅\\uf307Ɗ䣅筂鐮\\uf697媭ም凂' - 5.00000000\nBest fitness at generation 13: '췵㪈쾟⢥筂鐇勨憣并ꓹ' - 5.00000000\nBest fitness at generation 14: '睾\\uf2aaﾒ\\uef8b鰴⥢邹坅櫼砳' - 5.00000000\nBest fitness at generation 15: '盾㩭譂䅎웱勂ᇒ텬䧱㺡' - 5.00000000\nBest fitness at generation 16: '끍ᇆ₩豻畕傞ᅢ툧䧱Ａ' - 5.00000000\nBest fitness at generation 17: '뀳硺ߝ\\uefdb笧勂ᇒ텬桘．' - 5.00000000\nBest fitness at generation 18: '㴄ᅕ큕谉畕傞ᅢ툧䧱Ａ' - 5.00000000\nBest fitness at generation 19: '滴㪈㹮䣻羘䷴⒲嵟\\udc02㺤' - 5.00000000\nBest fitness at generation 20: '矖㪈㺂䢶羘䶦ᇒ䙗뭜탤' - 5.00000000\n...\nBest individual: '쩴篊㬍鍵糄䧱﬩廁\\ude21萇', fitness 5.0000000000 \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nimport [Fuzzer](Fuzzer.html) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import unicode_escape, terminal_escape \n```", "```py\ndef test_me(x, y):\n    if x == 2 * (y + 1):\n        return True\n    else:\n        return False \n```", "```py\ntest_me(0, 0) \n```", "```py\nFalse\n\n```", "```py\ntest_me(4, 2) \n```", "```py\nFalse\n\n```", "```py\ntest_me(22, 10) \n```", "```py\nTrue\n\n```", "```py\nMAX = 1000\nMIN = -MAX \n```", "```py\ndef neighbors(x, y):\n    return [(x + dx, y + dy) for dx in [-1, 0, 1]\n            for dy in [-1, 0, 1]\n            if (dx != 0 or dy != 0)\n            and ((MIN <= x + dx <= MAX)\n                 and (MIN <= y + dy <= MAX))] \n```", "```py\nprint(neighbors(10, 10)) \n```", "```py\n[(9, 9), (9, 10), (9, 11), (10, 9), (10, 11), (11, 9), (11, 10), (11, 11)]\n\n```", "```py\nx = 274\ny = 153\nx, 2 * (y + 1) \n```", "```py\n(274, 308)\n\n```", "```py\ndef calculate_distance(x, y):\n    return abs(x - 2 * (y + 1)) \n```", "```py\ncalculate_distance(274, 153) \n```", "```py\n34\n\n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nimport [numpy](https://numpy.org/) as np \n```", "```py\n%matplotlib inline\n\nxx = np.outer(np.linspace(-10, 10, 30), np.ones(30))\nyy = xx.copy().T\nzz = calculate_distance(xx, yy)\n\nfig = plt.figure()\nax = plt.axes(projection='3d')\n\nax.plot_surface(xx, yy, zz, cmap=plt.cm.jet, rstride=1, cstride=1, linewidth=0); \n```", "```py\ndef test_me_instrumented(x, y):\n    print(\"Instrumentation: Input = (%d, %d), distance = %d\" %\n          (x, y, calculate_distance(x, y)))\n    if x == 2 * (y + 1):\n        return True\n    else:\n        return False \n```", "```py\ntest_me_instrumented(0, 0) \n```", "```py\nInstrumentation: Input = (0, 0), distance = 2\n\n```", "```py\nFalse\n\n```", "```py\ntest_me_instrumented(5, 2) \n```", "```py\nInstrumentation: Input = (5, 2), distance = 1\n\n```", "```py\nFalse\n\n```", "```py\ntest_me_instrumented(22, 10) \n```", "```py\nInstrumentation: Input = (22, 10), distance = 0\n\n```", "```py\nTrue\n\n```", "```py\ndistance = 0 \n```", "```py\ndef test_me_instrumented(x, y):\n    global distance\n    distance = calculate_distance(x, y)\n    if x == 2 * (y + 1):\n        return True\n    else:\n        return False \n```", "```py\ndef get_fitness(x, y):\n    global distance\n    test_me_instrumented(x, y)\n    fitness = distance\n    return fitness \n```", "```py\nget_fitness(0, 0) \n```", "```py\n2\n\n```", "```py\nget_fitness(1, 2) \n```", "```py\n5\n\n```", "```py\nget_fitness(22, 10) \n```", "```py\n0\n\n```", "```py\nx, y = 274, 153\nprint(\"Origin %d, %d has fitness %d\" % (x, y, get_fitness(x, y)))\nfor nx, ny in neighbors(x, y):\n    print(\"neighbor %d, %d has fitness %d\" % (nx, ny, get_fitness(nx, ny))) \n```", "```py\nOrigin 274, 153 has fitness 34\nneighbor 273, 152 has fitness 33\nneighbor 273, 153 has fitness 35\nneighbor 273, 154 has fitness 37\nneighbor 274, 152 has fitness 32\nneighbor 274, 154 has fitness 36\nneighbor 275, 152 has fitness 31\nneighbor 275, 153 has fitness 33\nneighbor 275, 154 has fitness 35\n\n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nLOG_VALUES = 20  # Number of values to log \n```", "```py\ndef hillclimber():\n    # Create and evaluate starting point\n    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)\n    fitness = get_fitness(x, y)\n    print(\"Initial value: %d, %d at fitness %.4f\" % (x, y, fitness))\n    iterations = 0\n    logs = 0\n\n    # Stop once we have found an optimal solution\n    while fitness > 0:\n        iterations += 1\n        # Move to first neighbor with a better fitness\n        for (nextx, nexty) in neighbors(x, y):\n            new_fitness = get_fitness(nextx, nexty)\n\n            # Smaller fitness values are better\n            if new_fitness < fitness:\n                x, y = nextx, nexty\n                fitness = new_fitness\n                if logs < LOG_VALUES:\n                    print(\"New value: %d, %d at fitness %.4f\" % (x, y, fitness))\n                elif logs == LOG_VALUES:\n                    print(\"...\")\n                logs += 1\n                break\n\n    print(\"Found optimum after %d iterations at %d, %d\" % (iterations, x, y)) \n```", "```py\nhillclimber() \n```", "```py\nInitial value: 201, -956 at fitness 2111.0000\nNew value: 200, -956 at fitness 2110.0000\nNew value: 199, -956 at fitness 2109.0000\nNew value: 198, -956 at fitness 2108.0000\nNew value: 197, -956 at fitness 2107.0000\nNew value: 196, -956 at fitness 2106.0000\nNew value: 195, -956 at fitness 2105.0000\nNew value: 194, -956 at fitness 2104.0000\nNew value: 193, -956 at fitness 2103.0000\nNew value: 192, -956 at fitness 2102.0000\nNew value: 191, -956 at fitness 2101.0000\nNew value: 190, -956 at fitness 2100.0000\nNew value: 189, -956 at fitness 2099.0000\nNew value: 188, -956 at fitness 2098.0000\nNew value: 187, -956 at fitness 2097.0000\nNew value: 186, -956 at fitness 2096.0000\nNew value: 185, -956 at fitness 2095.0000\nNew value: 184, -956 at fitness 2094.0000\nNew value: 183, -956 at fitness 2093.0000\nNew value: 182, -956 at fitness 2092.0000\nNew value: 181, -956 at fitness 2091.0000\n...\nFound optimum after 1656 iterations at -1000, -501\n\n```", "```py\ndef steepest_ascent_hillclimber():\n    # Create and evaluate starting point\n    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)\n    fitness = get_fitness(x, y)\n    print(\"Initial value: %d, %d at fitness %.4f\" % (x, y, fitness))\n    iterations = 0\n    logs = 0\n\n    # Stop once we have found an optimal solution\n    while fitness > 0:\n        iterations += 1\n        # Move to first neighbor with a better fitness\n        for (nextx, nexty) in neighbors(x, y):\n            new_fitness = get_fitness(nextx, nexty)\n            if new_fitness < fitness:\n                x, y = nextx, nexty\n                fitness = new_fitness\n                if logs < LOG_VALUES:\n                    print(\"New value: %d, %d at fitness %.4f\" % (x, y, fitness))\n                elif logs == LOG_VALUES:\n                    print(\"...\")\n                logs += 1\n\n    print(\"Found optimum after %d iterations at %d, %d\" % (iterations, x, y)) \n```", "```py\nsteepest_ascent_hillclimber() \n```", "```py\nInitial value: -258, 645 at fitness 1550.0000\nNew value: -259, 644 at fitness 1549.0000\nNew value: -258, 644 at fitness 1548.0000\nNew value: -257, 644 at fitness 1547.0000\nNew value: -258, 643 at fitness 1546.0000\nNew value: -257, 643 at fitness 1545.0000\nNew value: -256, 643 at fitness 1544.0000\nNew value: -257, 642 at fitness 1543.0000\nNew value: -256, 642 at fitness 1542.0000\nNew value: -255, 642 at fitness 1541.0000\nNew value: -256, 641 at fitness 1540.0000\nNew value: -255, 641 at fitness 1539.0000\nNew value: -254, 641 at fitness 1538.0000\nNew value: -255, 640 at fitness 1537.0000\nNew value: -254, 640 at fitness 1536.0000\nNew value: -253, 640 at fitness 1535.0000\nNew value: -254, 639 at fitness 1534.0000\nNew value: -253, 639 at fitness 1533.0000\nNew value: -252, 639 at fitness 1532.0000\nNew value: -253, 638 at fitness 1531.0000\nNew value: -252, 638 at fitness 1530.0000\n...\nFound optimum after 517 iterations at 258, 128\n\n```", "```py\ndef plotting_hillclimber(fitness_function):\n    data = []\n\n    # Create and evaluate starting point\n    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)\n    fitness = fitness_function(x, y)\n    data += [fitness]\n    iterations = 0\n\n    # Stop once we have found an optimal solution\n    while fitness > 0:\n        iterations += 1\n        # Move to first neighbor with a better fitness\n        for (nextx, nexty) in neighbors(x, y):\n            new_fitness = fitness_function(nextx, nexty)\n            if new_fitness < fitness:\n                x, y = nextx, nexty\n                fitness = new_fitness\n                data += [fitness]\n                break\n\n    print(\"Found optimum after %d iterations at %d, %d\" % (iterations, x, y))\n    return data \n```", "```py\ndata = plotting_hillclimber(get_fitness) \n```", "```py\nFound optimum after 429 iterations at -1000, -501\n\n```", "```py\nfig = plt.figure()\nax = plt.axes()\n\nxs = range(len(data))\nax.plot(xs, data); \n```", "```py\ndef test_me2(x, y):\n    if(x * x == y * y * (x % 20)):\n        return True\n    else:\n        return False \n```", "```py\ndef test_me2_instrumented(x, y):\n    global distance\n    distance = abs(x * x - y * y * (x % 20))\n    if(x * x == y * y * (x % 20)):\n        return True\n    else:\n        return False \n```", "```py\ndef bad_fitness(x, y):\n    global distance\n    test_me2_instrumented(x, y)\n    fitness = distance\n    return fitness \n```", "```py\nxx = np.outer(np.linspace(-10, 10, 30), np.ones(30))\nyy = xx.copy().T\nzz = abs(xx * xx - yy * yy * (xx % 20)) \n```", "```py\nfig = plt.figure()\nax = plt.axes(projection='3d')\n\nax.plot_surface(xx, yy, zz, cmap=plt.cm.jet, rstride=1, cstride=1, linewidth=0); \n```", "```py\ndef restarting_hillclimber(fitness_function):\n    data = []\n\n    # Create and evaluate starting point\n    x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)\n    fitness = fitness_function(x, y)\n    data += [fitness]\n    print(\"Initial value: %d, %d at fitness %.4f\" % (x, y, fitness))\n    iterations = 0\n\n    # Stop once we have found an optimal solution\n    while fitness > 0:\n        changed = False\n        iterations += 1\n        # Move to first neighbor with a better fitness\n        for (nextx, nexty) in neighbors(x, y):\n            new_fitness = fitness_function(nextx, nexty)\n            if new_fitness < fitness:\n                x, y = nextx, nexty\n                fitness = new_fitness\n                data += [fitness]\n                changed = True\n                break\n        if not changed:\n            x, y = random.randint(MIN, MAX), random.randint(MIN, MAX)\n            fitness = fitness_function(x, y)\n            data += [fitness]\n\n    print(\"Found optimum after %d iterations at %d, %d\" % (iterations, x, y))\n    return data \n```", "```py\nMAX = 1000\nMIN = -MAX \n```", "```py\ndata = restarting_hillclimber(bad_fitness) \n```", "```py\nInitial value: 333, 231 at fitness 582804.0000\nFound optimum after 165 iterations at 521, 521\n\n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nfig = plt.figure()\nax = plt.axes()\n\nxs = range(len(data))\nax.plot(xs, data); \n```", "```py\nMAX = 100000\nMIN = -MAX \n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\nwith Timer() as t:\n    restarting_hillclimber(get_fitness)\n    print(\"Search time: %.2fs\" % t.elapsed_time()) \n```", "```py\nInitial value: 64543, -55357 at fitness 175255.0000\nFound optimum after 169899 iterations at -100000, -50001\nSearch time: 0.27s\n\n```", "```py\ndef cgi_decode(s):\n  \"\"\"Decode the CGI-encoded string `s`:\n * replace \"+\" by \" \"\n * replace \"%xx\" by the character with hex number xx.\n Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n\n    # Mapping of hex digits to their integer values\n    hex_values = {\n        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n    }\n\n    t = \"\"\n    i = 0\n    while i < len(s):\n        c = s[i]\n        if c == '+':\n            t += ' '\n        elif c == '%':\n            digit_high, digit_low = s[i + 1], s[i + 2]\n            i += 2\n            if digit_high in hex_values and digit_low in hex_values:\n                v = hex_values[digit_high] * 16 + hex_values[digit_low]\n                t += chr(v)\n            else:\n                raise ValueError(\"Invalid encoding\")\n        else:\n            t += c\n        i += 1\n    return t \n```", "```py\ndef neighbor_strings(x):\n    n = []\n    for pos in range(len(x)):\n        c = ord(x[pos])\n        if c < 126:\n            n += [x[:pos] + chr(c + 1) + x[pos + 1:]]\n        if c > 32:\n            n += [x[:pos] + chr(c - 1) + x[pos + 1:]]\n    return n \n```", "```py\nprint(neighbor_strings(\"Hello\")) \n```", "```py\n['Iello', 'Gello', 'Hfllo', 'Hdllo', 'Hemlo', 'Heklo', 'Helmo', 'Helko', 'Hellp', 'Helln']\n\n```", "```py\nimport [sys](https://docs.python.org/3/library/sys.html) \n```", "```py\ndef distance_character(target, values):\n\n    # Initialize with very large value so that any comparison is better\n    minimum = sys.maxsize\n\n    for elem in values:\n        distance = abs(target - elem)\n        if distance < minimum:\n            minimum = distance\n    return minimum \n```", "```py\ndistance_character(10, [1, 5, 12, 100]) \n```", "```py\n2\n\n```", "```py\ndistance_character(10, [0, 50, 80, 200]) \n```", "```py\n10\n\n```", "```py\n distance = abs(x - 2 * foo(y))\n    if x == 2 * foo(y):\n    ...\n```", "```py\n tmp1 = x\n    tmp2 = 2 * foo(y)\n    distance = abs(tmp1 - tmp2)\n    if tmp1 == tmp2:\n    ...\n```", "```py\n if x == 2 * foo(y)\n```", "```py\n if evaluate_condition(0, \"Eq\", x, 2 * foo(y))\n```", "```py\ndef evaluate_condition(num, op, lhs, rhs):\n    distance_true = 0\n    distance_false = 0\n    if op == \"Eq\":\n        if lhs == rhs:\n            distance_false = 1\n        else:\n            distance_true = abs(lhs - rhs)\n\n    # ... code for other types of conditions\n\n    if distance_true == 0:\n        return True\n    else:\n        return False \n```", "```py\nevaluate_condition(1, \"Eq\", 10, 20) \n```", "```py\nFalse\n\n```", "```py\nevaluate_condition(2, \"Eq\", 20, 20) \n```", "```py\nTrue\n\n```", "```py\ndef update_maps(condition_num, d_true, d_false):\n    global distances_true, distances_false\n\n    if condition_num in distances_true.keys():\n        distances_true[condition_num] = min(\n            distances_true[condition_num], d_true)\n    else:\n        distances_true[condition_num] = d_true\n\n    if condition_num in distances_false.keys():\n        distances_false[condition_num] = min(\n            distances_false[condition_num], d_false)\n    else:\n        distances_false[condition_num] = d_false \n```", "```py\ndef evaluate_condition(num, op, lhs, rhs):\n    distance_true = 0\n    distance_false = 0\n\n    # Make sure the distance can be calculated on number and character\n    # comparisons\n    if isinstance(lhs, str):\n        lhs = ord(lhs)\n    if isinstance(rhs, str):\n        rhs = ord(rhs)\n\n    if op == \"Eq\":\n        if lhs == rhs:\n            distance_false = 1\n        else:\n            distance_true = abs(lhs - rhs)\n\n    elif op == \"Lt\":\n        if lhs < rhs:\n            distance_false = rhs - lhs\n        else:\n            distance_true = lhs - rhs + 1\n    # ...\n    # handle other comparison operators\n    # ...\n\n    elif op == \"In\":\n        minimum = sys.maxsize\n        for elem in rhs.keys():\n            distance = abs(lhs - ord(elem))\n            if distance < minimum:\n                minimum = distance\n\n        distance_true = minimum\n        if distance_true == 0:\n            distance_false = 1\n\n    update_maps(num, distance_true, distance_false)\n\n    if distance_true == 0:\n        return True\n    else:\n        return False \n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html) \n```", "```py\nclass BranchTransformer(ast.NodeTransformer):\n\n    branch_num = 0\n\n    def visit_FunctionDef(self, node):\n        node.name = node.name + \"_instrumented\"\n        return self.generic_visit(node)\n\n    def visit_Compare(self, node):\n        if node.ops[0] in [ast.Is, ast.IsNot, ast.In, ast.NotIn]:\n            return node\n\n        self.branch_num += 1\n        return ast.Call(func=ast.Name(\"evaluate_condition\", ast.Load()),\n                        args=[ast.Num(self.branch_num),\n                              ast.Str(node.ops[0].__class__.__name__),\n                              node.left,\n                              node.comparators[0]],\n                        keywords=[],\n                        starargs=None,\n                        kwargs=None) \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html)\nimport [ast](https://docs.python.org/3/library/ast.html) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import print_content \n```", "```py\nsource = inspect.getsource(cgi_decode)\nnode = ast.parse(source)\nBranchTransformer().visit(node)\n\n# Make sure the line numbers are ok before printing\nnode = ast.fix_missing_locations(node)\nprint_content(ast.unparse(node), '.py') \n```", "```py\ndef cgi_decode_instrumented(s):\n  \"\"\"Decode the CGI-encoded string `s`:\n * replace \"+\" by \" \"\n * replace \"%xx\" by the character with hex number xx.\n Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n    hex_values = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15, 'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15}\n    t = ''\n    i = 0\n    while evaluate_condition(1, 'Lt', i, len(s)):\n        c = s[i]\n        if evaluate_condition(2, 'Eq', c, '+'):\n            t += '  '\n        elif evaluate_condition(3, 'Eq', c, '%'):\n            digit_high, digit_low = (s[i + 1], s[i + 2])\n            i += 2\n            if evaluate_condition(4, 'In', digit_high, hex_values) and evaluate_condition(5, 'In', digit_low, hex_values):\n                v = hex_values[digit_high] * 16 + hex_values[digit_low]\n                t += chr(v)\n            else:\n                raise ValueError('Invalid encoding')\n        else:\n            t += c\n        i += 1\n    return t\n\n```", "```py\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:15: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  args=[ast.Num(self.branch_num),\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:16: DeprecationWarning: ast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  ast.Str(node.ops[0].__class__.__name__),\n\n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Dict, cast \n```", "```py\ndef create_instrumented_function(f):\n    source = inspect.getsource(f)\n    node = ast.parse(source)\n    node = BranchTransformer().visit(node)\n\n    # Make sure the line numbers are ok so that it compiles\n    node = ast.fix_missing_locations(node)\n\n    # Compile and add the instrumented function to the current module\n    current_module = sys.modules[__name__]\n    code = compile(cast(ast.Module, node), filename=\"<ast>\", mode=\"exec\")\n    exec(code, current_module.__dict__) \n```", "```py\n# Set up the global maps\ndistances_true: Dict[int, int] = {}\ndistances_false: Dict[int, int] = {} \n```", "```py\n# Create instrumented function\n# cgi_decode_instrumented = \ncreate_instrumented_function(cgi_decode) \n```", "```py\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:15: DeprecationWarning: ast.Num is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  args=[ast.Num(self.branch_num),\n/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_7394/942233608.py:16: DeprecationWarning: ast.Str is deprecated and will be removed in Python 3.14; use ast.Constant instead\n  ast.Str(node.ops[0].__class__.__name__),\n\n```", "```py\nassert cgi_decode(\"Hello+Reader\") == cgi_decode_instrumented(\"Hello+Reader\") \n```", "```py\ncgi_decode_instrumented(\"Hello+Reader\") \n```", "```py\n'Hello Reader'\n\n```", "```py\ndistances_true \n```", "```py\n{1: 0, 2: 0, 3: 35}\n\n```", "```py\ndistances_false \n```", "```py\n{1: 0, 2: 0, 3: 0}\n\n```", "```py\ndef normalize(x):\n    return x / (1.0 + x) \n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nfig = plt.figure()\nax = plt.axes()\n\nxs = range(100)\nys = [value / (value + 1.0) for value in xs]\nax.plot(xs, ys); \n```", "```py\ndef get_fitness_cgi(x):\n    # Reset any distance values from previous executions\n    global distances_true, distances_false\n    distances_true = {}\n    distances_false = {}\n\n    # Run the function under test\n    try:\n        cgi_decode_instrumented(x)\n    except BaseException:\n        pass\n\n    # Sum up branch distances\n    fitness = 0.0\n    for branch in [1, 3, 4, 5]:\n        if branch in distances_true:\n            fitness += normalize(distances_true[branch])\n        else:\n            fitness += 1.0\n\n    for branch in [2]:\n        if branch in distances_false:\n            fitness += normalize(distances_false[branch])\n        else:\n            fitness += 1.0\n\n    return fitness \n```", "```py\n# Empty string does not even enter the loop\nget_fitness_cgi(\"\") \n```", "```py\n4.5\n\n```", "```py\n# String contains no percentage character\nget_fitness_cgi(\"Hello+Reader\") \n```", "```py\n2.9722222222222223\n\n```", "```py\n# String contains a percentage character, but no valid hex char\nget_fitness_cgi(\"%UU\") \n```", "```py\n1.9230769230769231\n\n```", "```py\n# String contains a percentage character, but only one valid hex char\nget_fitness_cgi(\"%AU\") \n```", "```py\n0.9230769230769231\n\n```", "```py\n# String contains a percentage character and two valid hex chars\nget_fitness_cgi(\"%AA\") \n```", "```py\n0.0\n\n```", "```py\ndef random_string(l):\n    s = \"\"\n    for i in range(l):\n        random_character = chr(random.randrange(32, 127))\n        s = s + random_character\n    return s \n```", "```py\ndef hillclimb_cgi():\n    x = random_string(10)\n    fitness = get_fitness_cgi(x)\n    print(\"Initial input: %s at fitness %.4f\" % (x, fitness))\n\n    while fitness > 0:\n        changed = False\n        for (nextx) in neighbor_strings(x):\n            new_fitness = get_fitness_cgi(nextx)\n            if new_fitness < fitness:\n                x = nextx\n                fitness = new_fitness\n                changed = True\n                print(\"New value: %s at fitness %.4f\" % (x, fitness))\n                break\n\n        # Random restart if necessary\n        if not changed:\n            x = random_string(10)\n            fitness = get_fitness_cgi(x)\n\n    print(\"Optimum at %s, fitness %.4f\" % (x, fitness)) \n```", "```py\nhillclimb_cgi() \n```", "```py\nInitial input: o'@[3(rW*M at fitness 2.6667\nNew value: o&@[3(rW*M at fitness 2.5000\nNew value: o%@[3(rW*M at fitness 1.5000\nNew value: o%A[3(rW*M at fitness 0.8571\nNew value: o%A\\3(rW*M at fitness 0.8333\nNew value: o%A]3(rW*M at fitness 0.8000\nNew value: o%A^3(rW*M at fitness 0.7500\nNew value: o%A_3(rW*M at fitness 0.6667\nNew value: o%A`3(rW*M at fitness 0.5000\nNew value: o%Aa3(rW*M at fitness 0.0000\nOptimum at o%Aa3(rW*M, fitness 0.0000\n\n```", "```py\ndef random_unicode_string(l):\n    s = \"\"\n    for i in range(l):\n        # Limits to reflect range of UTF-16\n        random_character = chr(random.randrange(0, 65536))\n        s = s + random_character\n    return s \n```", "```py\ndef unicode_string_neighbors(x):\n    n = []\n    for pos in range(len(x)):\n        c = ord(x[pos])\n        # Limits to reflect range of UTF-16\n        if c < 65536:\n            n += [x[:pos] + chr(c + 1) + x[pos + 1:]]\n        if c > 0:\n            n += [x[:pos] + chr(c - 1) + x[pos + 1:]]\n\n    return n \n```", "```py\ndef terminal_repr(s):\n    return terminal_escape(repr(s)) \n```", "```py\ndef hillclimb_cgi_limited(max_iterations):\n    x = random_unicode_string(10)\n    fitness = get_fitness_cgi(x)\n    print(\"Initial input: %s at fitness %.4f\" % (terminal_repr(x), fitness))\n\n    iteration = 0\n    logs = 0\n    while fitness > 0 and iteration < max_iterations:\n        changed = False\n        for (nextx) in unicode_string_neighbors(x):\n            new_fitness = get_fitness_cgi(nextx)\n            if new_fitness < fitness:\n                x = nextx\n                fitness = new_fitness\n                changed = True\n                if logs < LOG_VALUES:\n                    print(\"New value: %s at fitness %.4f\" %\n                          (terminal_repr(x), fitness))\n                elif logs == LOG_VALUES:\n                    print(\"...\")\n                logs += 1\n                break\n\n        # Random restart if necessary\n        if not changed:\n            x = random_string(10)\n            fitness = get_fitness_cgi(x)\n        iteration += 1\n\n    print(\"Optimum at %s, fitness %.4f\" % (terminal_repr(x), fitness)) \n```", "```py\nhillclimb_cgi_limited(100) \n```", "```py\nInitial input: '埂\\udf19\\uf67c듵騛쁥핡勸\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勷\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勶\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勵\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勴\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勳\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勲\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勱\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勰\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勯\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勮\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勭\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勬\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勫\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勪\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勩\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勨\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勧\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勦\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勥\\uf172싕' at fitness 3.0000\nNew value: '埂\\udf19\\uf67c듵騛쁥핡勤\\uf172싕' at fitness 3.0000\n...\nOptimum at '埂\\udf19\\uf67c듵騛쁥핡劔\\uf172싕', fitness 3.0000\n\n```", "```py\ndef flip_random_character(s):\n    pos = random.randint(0, len(s) - 1)\n    new_c = chr(random.randrange(0, 65536))\n    return s[:pos] + new_c + s[pos + 1:] \n```", "```py\ndef randomized_hillclimb():\n    x = random_unicode_string(10)\n    fitness = get_fitness_cgi(x)\n    print(\"Initial value: %s at fitness %.4f\" %\n          (terminal_repr(x), fitness))\n\n    iterations = 0\n    while fitness > 0:\n        mutated = flip_random_character(x)\n        new_fitness = get_fitness_cgi(mutated)\n        if new_fitness <= fitness:\n            x = mutated\n            fitness = new_fitness\n            #print(\"New value: %s at fitness %.4f\" %(terminal_repr(x), fitness))\n        iterations += 1\n\n    print(\"Optimum at %s after %d iterations\" %\n          (terminal_repr(x), iterations)) \n```", "```py\nrandomized_hillclimb() \n```", "```py\nInitial value: '舨ᑆ\\uec4f\\ue27f羏\\uf314䖗繣厪킨' at fitness 2.9998\nOptimum at 'ጤ〆撟%e5匸㗵暠ᴌ' after 34356 iterations\n\n```", "```py\ndef create_population(size):\n    return [random_unicode_string(10) for i in range(size)] \n```", "```py\ncreate_population(10) \n```", "```py\n['㛇莜戹豔㮝\\ue008力ᒐᱯꊎ',\n '\\ue295쁉陵ꯃ赖蟽⍬꺲緥㲱',\n '\\u2e77騬⊳铁땕\\uf189\\ue663쌯幆艆',\n '龚筓\\uf3a9욀놷䓒隯迌쀐∑',\n '쓛唁뗌蹽\\udcd5偏躝娒鸭赌',\n '蹤⪖ឺ웳ఫ䓻䤷溸ᰒﵘ',\n '㲒혋Ꮘ\\uea95\\udf7b䢶裕㖬눹庑',\n '\\u2d9d鼓咝笩窻ꨔ铺扄\\ueb57\\uf1bf',\n '\\udd26Ч甄ꃢ\\udcb0㼁튰㣋ช봼',\n '닇軬欴鞛㈓Ẫ住畿ꔪ칀']\n\n```", "```py\ndef evaluate_population(population):\n    fitness = [get_fitness_cgi(x) for x in population]\n    return list(zip(population, fitness)) \n```", "```py\npopulation = create_population(10) \n```", "```py\nfor (individual, fitness) in evaluate_population(population):\n    print(\"%s: %.4f\" % (terminal_repr(individual), fitness)) \n```", "```py\n'\\ue46fت팣㘇ธ漅ೇ↪䜭㎮': 2.9994\n'\\ua7e9\\ue9e0\\ue7de턤댪囿厠‐\\ue0c5ﴌ': 2.9999\n'䇯Ꜩ잣\\ua9ce㙦\\uf4aa歿蘸ཎ㫜': 2.9997\n'ⱳ콾哇\\uef1f\\uf6a8⾃䣖坤Ꮾ둰': 2.9998\n'າ伫螉\\ue110㝎겱괼䆵喞\\u18ac': 2.9997\n'ས婎쥤䇉韤\\udd06䕮춵磒露': 2.9997\n'辺緢噑粲\\uf400嚳寬\\x87ꐂ쑹': 2.9899\n'뉫㻑\\u1fd4㈖鬒樼\\u0dcc朏\\ue57eማ': 2.9997\n'얨㐁皭់멄\\ud97b\\ueac9㢂ቅ뮜': 2.9998\n'⒃⍜㈪㊷\\udbdb乑蓍\\udc48鱲뻜': 2.9999\n\n```", "```py\ndef selection(evaluated_population, tournament_size):\n    competition = random.sample(evaluated_population, tournament_size)\n    winner = min(competition, key=lambda individual: individual[1])[0]\n\n    # Return a copy of the selected individual\n    return winner[:] \n```", "```py\npopulation = create_population(10)\nfitness = evaluate_population(population)\nselected = selection(fitness, 10) \n```", "```py\nfor (individual, fitness_value) in fitness:\n    print(\"%s: %.4f\" % (terminal_repr(individual), fitness_value)) \n```", "```py\n'둚䘣蹸붢騒ꋎỺ觉\\ued2a焊': 2.9999\n'닔㶐ꡡ\\udca4贕굇᳆\\ueccd윘赉': 2.9999\n'笁깉ရ豴\\uea60ᛰ滒鶵）Ⰴ': 2.9998\n'㠒㵄\\ue14cᤃᇚ\\udebe\\uf851쿛鏆闊': 2.9998\n'ࠝ\\udd53ᶂ㮍訬廘랦铘뫘출': 2.9995\n'ꡩၔ玤姨乪药汏䗫汔悔': 2.9998\n'\\uef2a潦ﳠ鹉卼㴐Ṭ\\uf4b0˅얓': 2.9985\n'❱\\u0ff7╇塐䲫琭煸ᮤឋ퇃': 2.9998\n'ڮ焈㱉煉ꅿᦗ툍혐خ꧓': 2.9994\n'ἂጋ\\uddcc\\ue3d7粖\\ude2c⮌鮓讃\\ueab6': 2.9998\n\n```", "```py\nprint(\"Winner: %s\" % terminal_repr(selected)) \n```", "```py\nWinner: '\\uef2a潦ﳠ鹉卼㴐Ṭ\\uf4b0˅얓'\n\n```", "```py\ndef crossover(parent1, parent2):\n    pos = random.randint(1, len(parent1))\n\n    offspring1 = parent1[:pos] + parent2[pos:]\n    offspring2 = parent2[:pos] + parent1[pos:]\n\n    return (offspring1, offspring2) \n```", "```py\nparent1 = \"Hello World\"\nparent2 = \"Goodbye Book\"\n\ncrossover(parent1, parent2) \n```", "```py\n('Hello W Book', 'Goodbyeorld')\n\n```", "```py\ndef mutate(chromosome):\n    mutated = chromosome[:]\n    P = 1.0 / len(mutated)\n\n    for pos in range(len(mutated)):\n        if random.random() < P:\n            new_c = chr(int(random.gauss(ord(mutated[pos]), 100) % 65536))\n            mutated = mutated[:pos] + new_c + mutated[pos + 1:]\n    return mutated \n```", "```py\ndef genetic_algorithm():\n    # Generate and evaluate initial population\n    generation = 0\n    population = create_population(100)\n    fitness = evaluate_population(population)\n    best = min(fitness, key=lambda item: item[1])\n    best_individual = best[0]\n    best_fitness = best[1]\n    print(\"Best fitness of initial population: %s - %.10f\" %\n        (terminal_repr(best_individual), best_fitness))\n    logs = 0\n\n    # Stop when optimum found, or we run out of patience\n    while best_fitness > 0 and generation < 1000:\n\n        # The next generation will have the same size as the current one\n        new_population = []\n        while len(new_population) < len(population):\n            # Selection\n            offspring1 = selection(fitness, 10)\n            offspring2 = selection(fitness, 10)\n\n            # Crossover\n            if random.random() < 0.7:\n                (offspring1, offspring2) = crossover(offspring1, offspring2)\n\n            # Mutation\n            offspring1 = mutate(offspring1)\n            offspring2 = mutate(offspring2)\n\n            new_population.append(offspring1)\n            new_population.append(offspring2)\n\n        # Once full, the new population replaces the old one\n        generation += 1\n        population = new_population\n        fitness = evaluate_population(population)\n\n        best = min(fitness, key=lambda item: item[1])\n        best_individual = best[0]\n        best_fitness = best[1]\n        if logs < LOG_VALUES:\n            print(\n                \"Best fitness at generation %d: %s - %.8f\" %\n                (generation, terminal_repr(best_individual), best_fitness))\n        elif logs == LOG_VALUES:\n            print(\"...\")\n        logs += 1\n\n    print(\n        \"Best individual: %s, fitness %.10f\" %\n        (terminal_repr(best_individual), best_fitness)) \n```", "```py\ngenetic_algorithm() \n```", "```py\nBest fitness of initial population: '俴\\x8a辰燄펧䬍缯檒㤢⦡' - 2.9901960784\nBest fitness at generation 1: 'ཬə쫯ὼ酟剺鬈{Ż\\ue313' - 2.98850575\nBest fitness at generation 2: '俴\\x82辰燄酟剺鬢\\x1bŻ\\ue313' - 2.90909091\nBest fitness at generation 3: 'ྂɵ쫕ὼ酟剺鬈%Ŧ\\ue384' - 1.99610895\nBest fitness at generation 4: 'ྂɵ쬆ὼ酟剺鬈%ŋ\\ue384' - 1.99565217\nBest fitness at generation 5: '俴ʐ쫕ἶ酟剺髺%¼\\ue384' - 1.98850575\nBest fitness at generation 6: 'ྂɵ쫪ὼ酟剒鬈%\\x9e\\ue37f' - 1.98245614\nBest fitness at generation 7: '俴̗쪕ἶ酟剺髱%4\\ue378' - 0.99998280\nBest fitness at generation 8: '侪\\x86쪕ἶ酟剺髱%4\\ue378' - 0.99998280\nBest fitness at generation 9: '俆ǫ쪸ἶ醿剺髱%4\\ue2b5' - 0.99998274\nBest fitness at generation 10: '俆ǫ쪸ἶ釘剺髧%4\\ue2b5' - 0.99998274\nBest fitness at generation 11: '俆ɫ쫕Ồ酟剺髱%4\\ue256' - 0.99998271\nBest fitness at generation 12: '侪\\x86쪕ἶ醿剺髱%4\\ue1f9' - 0.99998268\nBest fitness at generation 13: '侪ï쪕ἶ醿剺髱%4\\ue1f9' - 0.99998268\nBest fitness at generation 14: '俆\\x86쪕ἶ醿剺髱%4\\ue1f9' - 0.99998268\nBest fitness at generation 15: '俆Ǩ쪸ἂ醿剺髱%4\\ue150' - 0.99998263\nBest fitness at generation 16: '俴ʓ쫕ớ鄞务髱%e\\ue0f0' - 0.99998260\nBest fitness at generation 17: '侪ï쪵ớ酟刖髱%F\\ue0a9' - 0.99998258\nBest fitness at generation 18: '佺ģ쪵ớ鄞劐髱%e\\ue05c' - 0.99998256\nBest fitness at generation 19: '侪ï쪵ớ酟刖髱%e\\ue05c' - 0.99998256\nBest fitness at generation 20: '侪ï쪵ί酃劐髝%e\\ue00c' - 0.99998253\n...\nBest individual: '予ß쥇᳗轐咆隭%2A', fitness 0.0000000000\n\n```", "```py\n@incollection{fuzzingbook2023:SearchBasedFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Search-Based Fuzzing},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/SearchBasedFuzzer.html}},\n    note = {Retrieved 2023-11-11 18:18:06+01:00},\n    url = {https://www.fuzzingbook.org/html/SearchBasedFuzzer.html},\n    urldate = {2023-11-11 18:18:06+01:00}\n}\n\n```"]