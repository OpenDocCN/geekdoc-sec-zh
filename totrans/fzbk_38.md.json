["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('od3DcJcr0d4') \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Dict, List \n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\nimport [numpy](https://numpy.org/)\nfrom [numpy](https://numpy.org/) import log \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nletters = list(string.ascii_letters[26:])  # upper-case characters\ntrigrams = [str(a + b + c) for a in letters for b in letters for c in letters] \n```", "```py\nrandom.shuffle(trigrams) \n```", "```py\ntrigrams[:10] \n```", "```py\n['TJK', 'NWV', 'LBM', 'AZC', 'GZP', 'ADE', 'DNO', 'OQL', 'FGK', 'IPT']\n\n```", "```py\nk_book = {}  # Kenngruppenbuch\n\nfor i in range(1, len(trigrams) + 1):\n    trigram = trigrams[i - 1]\n    # choose weights according to Benford's law\n    k_book[trigram] = log(1 + 1 / i) / log(26**3 + 1) \n```", "```py\nrandom_trigram = random.choices(list(k_book.keys()), weights=list(k_book.values()))[0]\nrandom_trigram \n```", "```py\n'PSK'\n\n```", "```py\nk_book[random_trigram] \n```", "```py\nnp.float64(0.0008284144853894445)\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import RandomFuzzer\nfrom [Fuzzer](Fuzzer.html) import Runner \n```", "```py\nclass EnigmaMachine(Runner):\n    def __init__(self, k_book):\n        self.k_book = k_book\n        self.reset()\n\n    def reset(self):\n  \"\"\"Resets the key register\"\"\"\n        self.msg2key = {}\n        self.cur_msg = \"\"\n\n    def internal_msg2key(self, message):\n  \"\"\"Internal helper method. \n Returns the trigram for an encoded message.\"\"\"\n        if message not in self.msg2key:\n            # Simulating how an officer chooses a key from the Kenngruppenbuch\n            # to encode the message.\n            self.msg2key[message] = \\\n                random.choices(list(self.k_book.keys()),\n                               weights=list(self.k_book.values()))[0]\n        trigram = self.msg2key[message]\n        return trigram\n\n    def naval_enigma(self, message, key):\n  \"\"\"Returns true if 'message' is encoded with 'key'\"\"\"\n        if key == self.internal_msg2key(message):\n            return True\n        else:\n            return False \n```", "```py\nclass EnigmaMachine(EnigmaMachine):\n    def run(self, tri):\n  \"\"\"PASS if cur_msg is encoded with trigram tri\"\"\"\n        if self.naval_enigma(self.cur_msg, tri):\n            outcome = self.PASS\n        else:\n            outcome = self.FAIL\n\n        return (tri, outcome) \n```", "```py\nenigma = EnigmaMachine(k_book)\nenigma.cur_msg = \"BrEaK mE. L0Lzz\"\nenigma.run(\"AAA\") \n```", "```py\n('AAA', 'FAIL')\n\n```", "```py\nclass BletchleyPark:\n    def __init__(self, enigma):\n        self.enigma = enigma\n        self.enigma.reset()\n        self.enigma_fuzzer = RandomFuzzer(\n            min_length=3,\n            max_length=3,\n            char_start=65,\n            char_range=26)\n\n    def break_message(self, message):\n  \"\"\"Returning the trigram for an encoded message\"\"\"\n        self.enigma.cur_msg = message\n        while True:\n            (trigram, outcome) = self.enigma_fuzzer.run(self.enigma)\n            if outcome == self.enigma.PASS:\n                break\n        return trigram \n```", "```py\nfrom [Timer](Timer.html) import Timer \n```", "```py\nenigma = EnigmaMachine(k_book)\nbletchley = BletchleyPark(enigma)\n\nwith Timer() as t:\n    trigram = bletchley.break_message(\"BrEaK mE. L0Lzz\") \n```", "```py\ntrigram \n```", "```py\n'XQC'\n\n```", "```py\n'%f seconds' % t.elapsed_time() \n```", "```py\n'0.079044 seconds'\n\n```", "```py\n'Bletchley cracks about %d messages per second' % (1/t.elapsed_time()) \n```", "```py\n'Bletchley cracks about 12 messages per second'\n\n```", "```py\nfrom [collections](https://docs.python.org/3/library/collections.html) import defaultdict \n```", "```py\nn = 100  # messages to crack \n```", "```py\nobserved: Dict[str, int] = defaultdict(int)\nfor msg in range(0, n):\n    trigram = bletchley.break_message(msg)\n    observed[trigram] += 1\n\n# list of trigrams that have been observed\ncounts = [k for k, v in observed.items() if int(v) > 0]\n\nt_trigrams = len(k_book)\no_trigrams = len(counts) \n```", "```py\n\"After cracking %d messages, we observed %d out of %d trigrams.\" % (\n    n, o_trigrams, t_trigrams) \n```", "```py\n'After cracking 100 messages, we observed 72 out of 17576 trigrams.'\n\n```", "```py\nsingletons = len([k for k, v in observed.items() if int(v) == 1]) \n```", "```py\n\"From the %d observed trigrams, %d were observed only once.\" % (\n    o_trigrams, singletons) \n```", "```py\n'From the 72 observed trigrams, 63 were observed only once.'\n\n```", "```py\nclass BletchleyPark(BletchleyPark):\n    def break_message(self, message):\n  \"\"\"Returning the trigram for an encoded message\"\"\"\n        # For the following experiment, we want to make it practical\n        #   to break a large number of messages. So, we remove the\n        #   loop and just return the trigram for a message.\n        #\n        # enigma.cur_msg = message\n        # while True:\n        #     (trigram, outcome) = self.enigma_fuzzer.run(self.enigma)\n        #     if outcome == self.enigma.PASS:\n        #         break\n        trigram = enigma.internal_msg2key(message)\n        return trigram\n\n    def break_n_messages(self, n):\n  \"\"\"Returns how often each trigram has been observed, \n and #trigrams discovered for each message.\"\"\"\n        observed = defaultdict(int)\n        timeseries = [0] * n\n\n        # Crack n messages and record #trigrams observed as #messages increases\n        cur_observed = 0\n        for cur_msg in range(0, n):\n            trigram = self.break_message(cur_msg)\n\n            observed[trigram] += 1\n            if (observed[trigram] == 1):\n                cur_observed += 1\n            timeseries[cur_msg] = cur_observed\n\n        return (observed, timeseries) \n```", "```py\nn = 2000        # messages to crack \n```", "```py\nbletchley = BletchleyPark(enigma)\n(observed, timeseries) = bletchley.break_n_messages(n) \n```", "```py\nsingletons = len([k for k, v in observed.items() if int(v) == 1])\ngt = singletons / n\ngt \n```", "```py\n0.401\n\n```", "```py\nrepeats = 1000  # experiment repetitions \n```", "```py\nnewly_discovered = 0\nfor cur_msg in range(n, n + repeats):\n    trigram = bletchley.break_message(cur_msg)\n    if(observed[trigram] == 0):\n        newly_discovered += 1\n\nnewly_discovered / repeats \n```", "```py\n0.412\n\n```", "```py\n1 - gt \n```", "```py\n0.599\n\n```", "```py\n1 / gt \n```", "```py\n2.4937655860349124\n\n```", "```py\n%matplotlib inline \n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nfrequencies = [v for k, v in observed.items() if int(v) > 0]\nfrequencies.sort(reverse=True)\n# Uncomment to see how often each discovered trigram has been observed\n# print(frequencies)\n\n# frequency of rare trigrams\nplt.figure(num=None, figsize=(12, 4), dpi=80, facecolor='w', edgecolor='k')\nplt.subplot(1, 2, 1)\nplt.hist(frequencies, range=[1, 21], bins=numpy.arange(1, 21) - 0.5)\nplt.xticks(range(1, 21))\nplt.xlabel('# of occurrences (e.g., 1 represents singleton trigrams)')\nplt.ylabel('Frequency of occurances')\nplt.title('Figure 1\\. Frequency of Rare Trigrams')\n\n# trigram discovery over time\nplt.subplot(1, 2, 2)\nplt.plot(timeseries)\nplt.xlabel('# of messages cracked')\nplt.ylabel('# of trigrams discovered')\nplt.title('Figure 2\\. Trigram Discovery Over Time'); \n```", "```py\n# Statistics for most and least often observed trigrams\nsingletons = len([v for k, v in observed.items() if int(v) == 1])\ntotal = len(frequencies)\n\nprint(\"%3d of %3d trigrams (%.3f%%) have been observed   1 time (i.e., are singleton trigrams).\"\n      % (singletons, total, singletons * 100 / total))\n\nprint(\"%3d of %3d trigrams ( %.3f%%) have been observed %d times.\"\n      % (1, total, 1 / total, frequencies[0])) \n```", "```py\n802 of 1009 trigrams (79.485%) have been observed   1 time (i.e., are singleton trigrams).\n  1 of 1009 trigrams ( 0.001%) have been observed 152 times.\n\n```", "```py\nprint(\"Trigram : Frequency\")\nfor trigram in sorted(observed, key=observed.get, reverse=True):\n    if observed[trigram] > 10:\n        print(\" %s : %d\" % (trigram, observed[trigram])) \n```", "```py\nTrigram : Frequency\n    TJK : 152\n    LBM : 69\n    NWV : 64\n    AZC : 43\n    GZP : 41\n    ADE : 37\n    DNO : 27\n    OQL : 26\n    TCO : 20\n    BDA : 19\n    ARO : 18\n    IPT : 16\n    FGK : 16\n    MSV : 15\n    ONO : 15\n    EOR : 13\n    JTV : 11\n    IBT : 11\n    PWN : 11\n\n```", "```py\nclass BletchleyPark(BletchleyPark):\n    def __init__(self, enigma):\n        super().__init__(enigma)\n        self.cur_attempts = 0\n        self.cur_observed = 0\n        self.observed = defaultdict(int)\n        self.timeseries = [None] * max_attempts * 2\n\n    def break_message(self, message):\n  \"\"\"Returns the trigram for an encoded message, and\n track #trigrams observed as #attempts increases.\"\"\"\n        self.enigma.cur_msg = message\n        while True:\n            self.cur_attempts += 1                                 # NEW\n            (trigram, outcome) = self.enigma_fuzzer.run(self.enigma)\n            self.timeseries[self.cur_attempts] = self.cur_observed # NEW\n            if outcome == self.enigma.PASS: \n                break\n        return trigram\n\n    def break_max_attempts(self, max_attempts):\n  \"\"\"Returns #messages successfully cracked after a given #attempts.\"\"\"\n        cur_msg = 0\n        n_messages = 0\n\n        while True:\n            trigram = self.break_message(cur_msg)\n\n            # stop when reaching max_attempts\n            if self.cur_attempts >= max_attempts:\n                break\n\n            # update observed trigrams\n            n_messages += 1\n            self.observed[trigram] += 1\n            if (self.observed[trigram] == 1):\n                self.cur_observed += 1\n                self.timeseries[self.cur_attempts] = self.cur_observed\n            cur_msg += 1\n\n        return n_messages \n```", "```py\nmax_attempts = 100000 \n```", "```py\nbletchley = BletchleyPark(enigma)\noriginal = bletchley.break_max_attempts(max_attempts)\noriginal \n```", "```py\n3\n\n```", "```py\nclass BoostedBletchleyPark(BletchleyPark):\n    def __init__(self, enigma, prior):\n        super().__init__(enigma)\n        self.prior = prior\n\n    def break_message(self, message):\n  \"\"\"Returns the trigram for an encoded message, and\n track #trigrams observed as #attempts increases.\"\"\"\n        self.enigma.cur_msg = message\n\n        # boost cracking by trying observed trigrams first\n        for trigram in sorted(self.prior, key=self.prior.get, reverse=True):\n            self.cur_attempts += 1\n            (_, outcome) = self.enigma.run(trigram)\n            self.timeseries[self.cur_attempts] = self.cur_observed\n            if outcome == self.enigma.PASS:\n                return trigram\n\n        # else fall back to normal cracking\n        return super().break_message(message) \n```", "```py\nboostedBletchley = BoostedBletchleyPark(enigma, prior=observed)\nboosted = boostedBletchley.break_max_attempts(max_attempts)\nboosted \n```", "```py\n23\n\n```", "```py\n# print plots\nline_old, = plt.plot(bletchley.timeseries, label=\"Bruteforce Strategy\")\nline_new, = plt.plot(boostedBletchley.timeseries, label=\"Boosted Strategy\")\nplt.legend(handles=[line_old, line_new])\nplt.xlabel('# of cracking attempts')\nplt.ylabel('# of trigrams discovered')\nplt.title('Trigram Discovery Over Time'); \n```", "```py\nfrom [Coverage](Coverage.html) import Coverage, cgi_decode \n```", "```py\nencoded = \"Hello%2c+world%21\"\nwith Coverage() as cov:\n    decoded = cgi_decode(encoded) \n```", "```py\ndecoded \n```", "```py\n'Hello, world!'\n\n```", "```py\nprint(cov.coverage()); \n```", "```py\n{('cgi_decode', 18), ('cgi_decode', 24), ('cgi_decode', 27), ('cgi_decode', 33), ('cgi_decode', 30), ('cgi_decode', 39), ('cgi_decode', 17), ('cgi_decode', 20), ('cgi_decode', 26), ('cgi_decode', 23), ('cgi_decode', 29), ('cgi_decode', 32), ('cgi_decode', 38), ('cgi_decode', 19), ('cgi_decode', 16), ('cgi_decode', 25), ('cgi_decode', 31), ('cgi_decode', 28), ('cgi_decode', 34), ('cgi_decode', 40)}\n\n```", "```py\nimport [pickle](https://docs.python.org/3/library/pickle.html)\nimport [hashlib](https://docs.python.org/3/library/hashlib.html) \n```", "```py\ndef getTraceHash(cov):\n    pickledCov = pickle.dumps(cov.coverage())\n    hashedCov = hashlib.md5(pickledCov).hexdigest()\n    return hashedCov \n```", "```py\ninp1 = \"a+b\"\ninp2 = \"a+b+c\"\ninp3 = \"abc\"\n\nwith Coverage() as cov1:\n    cgi_decode(inp1)\nwith Coverage() as cov2:\n    cgi_decode(inp2)\nwith Coverage() as cov3:\n    cgi_decode(inp3) \n```", "```py\ninp1, inp2 \n```", "```py\n('a+b', 'a+b+c')\n\n```", "```py\ncov1.coverage() - cov2.coverage() \n```", "```py\nset()\n\n```", "```py\ngetTraceHash(cov1) \n```", "```py\n'2b4ac7d0fe0c21a377a594f1a3ec1be2'\n\n```", "```py\ngetTraceHash(cov2) \n```", "```py\n'2b4ac7d0fe0c21a377a594f1a3ec1be2'\n\n```", "```py\nassert getTraceHash(cov1) == getTraceHash(cov2) \n```", "```py\ninp1, inp3 \n```", "```py\n('a+b', 'abc')\n\n```", "```py\ncov1.coverage() - cov3.coverage() \n```", "```py\n{('cgi_decode', 28)}\n\n```", "```py\ngetTraceHash(cov1) \n```", "```py\n'2b4ac7d0fe0c21a377a594f1a3ec1be2'\n\n```", "```py\ngetTraceHash(cov3) \n```", "```py\n'17f0b5cb3f5ca871198dc25635d631f9'\n\n```", "```py\nassert getTraceHash(cov1) != getTraceHash(cov3) \n```", "```py\ndef population_trace_coverage(population, function):\n    cumulative_coverage = []\n    all_coverage = set()\n    cumulative_singletons = []\n    cumulative_doubletons = []\n    singletons = set()\n    doubletons = set()\n\n    for s in population:\n        with Coverage() as cov:\n            try:\n                function(s)\n            except BaseException:\n                pass\n        cur_coverage = set([getTraceHash(cov)])\n\n        # singletons and doubletons -- we will need them later\n        doubletons -= cur_coverage\n        doubletons |= singletons & cur_coverage\n        singletons -= cur_coverage\n        singletons |= cur_coverage - (cur_coverage & all_coverage)\n        cumulative_singletons.append(len(singletons))\n        cumulative_doubletons.append(len(doubletons))\n\n        # all and cumulative coverage\n        all_coverage |= cur_coverage\n        cumulative_coverage.append(len(all_coverage))\n\n    return all_coverage, cumulative_coverage, cumulative_singletons, cumulative_doubletons \n```", "```py\nall_coverage = population_trace_coverage([inp1, inp2, inp3], cgi_decode)[0]\nassert len(all_coverage) == 2 \n```", "```py\nfrom [Coverage](Coverage.html) import population_coverage\nfrom [html.parser](https://docs.python.org/3/library/html.parser.html) import HTMLParser \n```", "```py\ntrials = 50000  # number of random inputs generated \n```", "```py\n# create wrapper function\ndef my_parser(inp):\n    parser = HTMLParser()  # resets the HTMLParser object for every fuzz input\n    parser.feed(inp) \n```", "```py\n# create random fuzzer\nfuzzer = RandomFuzzer(min_length=1, max_length=100,\n                      char_start=32, char_range=94)\n\n# create population of fuzz inputs\npopulation = []\nfor i in range(trials):\n    population.append(fuzzer.fuzz())\n\n# execute and measure trace coverage\ntrace_timeseries = population_trace_coverage(population, my_parser)[1]\n\n# execute and measure code coverage\ncode_timeseries = population_coverage(population, my_parser)[1]\n\n# plot trace coverage over time\nplt.figure(num=None, figsize=(12, 4), dpi=80, facecolor='w', edgecolor='k')\nplt.subplot(1, 2, 1)\nplt.plot(trace_timeseries)\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('# of traces exercised')\nplt.title('Trace Coverage Over Time')\n\n# plot code coverage over time\nplt.subplot(1, 2, 2)\nplt.plot(code_timeseries)\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('# of statements covered')\nplt.title('Code Coverage Over Time'); \n```", "```py\nrepeats = 500      # experiment repetitions\nmeasurements = 100  # experiment measurements \n```", "```py\nemp_timeseries = []\nall_coverage = set()\nstep = int(trials / measurements)\n\nfor i in range(0, trials, step):\n    if i - step >= 0:\n        for j in range(step):\n            inp = population[i - j]\n            with Coverage() as cov:\n                try:\n                    my_parser(inp)\n                except BaseException:\n                    pass\n            all_coverage |= set([getTraceHash(cov)])\n\n    discoveries = 0\n    for _ in range(repeats):\n        inp = fuzzer.fuzz()\n        with Coverage() as cov:\n            try:\n                my_parser(inp)\n            except BaseException:\n                pass\n        if getTraceHash(cov) not in all_coverage:\n            discoveries += 1\n    emp_timeseries.append(discoveries / repeats) \n```", "```py\ngt_timeseries = []\nsingleton_timeseries = population_trace_coverage(population, my_parser)[2]\nfor i in range(1, trials + 1, step):\n    gt_timeseries.append(singleton_timeseries[i - 1] / i) \n```", "```py\nline_emp, = plt.semilogy(emp_timeseries, label=\"Empirical\")\nline_gt, = plt.semilogy(gt_timeseries, label=\"Good-Turing\")\nplt.legend(handles=[line_emp, line_gt])\nplt.xticks(range(0, measurements + 1, int(measurements / 5)),\n           range(0, trials + 1, int(trials / 5)))\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('discovery probability')\nplt.title('Discovery Probability Over Time'); \n```", "```py\ntrials = 400000\nfuzzer = RandomFuzzer(min_length=2, max_length=4,\n                      char_start=32, char_range=32)\npopulation = []\nfor i in range(trials):\n    population.append(fuzzer.fuzz())\n\n_, trace_ts, f1_ts, f2_ts = population_trace_coverage(population, my_parser) \n```", "```py\ntime = int(trials / 2)\ntime \n```", "```py\n200000\n\n```", "```py\nf1 = f1_ts[time]\nf2 = f2_ts[time]\nSn = trace_ts[time]\nif f2 > 0:\n    hat_S = Sn + f1 * f1 / (2 * f2)\nelse:\n    hat_S = Sn + f1 * (f1 - 1) / 2 \n```", "```py\ntime \n```", "```py\n200000\n\n```", "```py\nSn \n```", "```py\n61\n\n```", "```py\nhat_S \n```", "```py\n65.5\n\n```", "```py\n100 * Sn / hat_S \n```", "```py\n93.12977099236642\n\n```", "```py\ntrials \n```", "```py\n400000\n\n```", "```py\ntrace_ts[trials - 1] \n```", "```py\n67\n\n```", "```py\nprediction_ts: List[float] = [None] * time\nf0 = hat_S - Sn\n\nfor m in range(trials - time):\n    assert (time * f0 + f1) != 0 , 'time:%s f0:%s f1:%s' % (time, f0,f1)\n    prediction_ts.append(Sn + f0 * (1 - (1 - f1 / (time * f0 + f1)) ** m)) \n```", "```py\nplt.figure(num=None, figsize=(12, 3), dpi=80, facecolor='w', edgecolor='k')\nplt.subplot(1, 3, 1)\nplt.plot(trace_ts, color='white')\nplt.plot(trace_ts[:time])\nplt.xticks(range(0, trials + 1, int(time)))\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('# of traces exercised')\n\nplt.subplot(1, 3, 2)\nline_cur, = plt.plot(trace_ts[:time], label=\"Ongoing fuzzing campaign\")\nline_pred, = plt.plot(prediction_ts, linestyle='--',\n                      color='black', label=\"Predicted progress\")\nplt.legend(handles=[line_cur, line_pred])\nplt.xticks(range(0, trials + 1, int(time)))\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('# of traces exercised')\n\nplt.subplot(1, 3, 3)\nline_emp, = plt.plot(trace_ts, color='grey', label=\"Actual progress\")\nline_cur, = plt.plot(trace_ts[:time], label=\"Ongoing fuzzing campaign\")\nline_pred, = plt.plot(prediction_ts, linestyle='--',\n                      color='black', label=\"Predicted progress\")\nplt.legend(handles=[line_emp, line_cur, line_pred])\nplt.xticks(range(0, trials + 1, int(time)))\nplt.xlabel('# of fuzz inputs')\nplt.ylabel('# of traces exercised'); \n```", "```py\nfrom [Coverage](Coverage.html) import population_coverage\n... \n```", "```py\nfrom [Fuzzer](Fuzzer.html) import RandomFuzzer\nfrom [html.parser](https://docs.python.org/3/library/html.parser.html) import HTMLParser\n...; \n```", "```py\n@incollection{fuzzingbook2024:WhenToStopFuzzing,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {When To Stop Fuzzing},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/WhenToStopFuzzing.html}},\n    note = {Retrieved 2024-11-09 17:07:29+01:00},\n    url = {https://www.fuzzingbook.org/html/WhenToStopFuzzing.html},\n    urldate = {2024-11-09 17:07:29+01:00}\n}\n\n```"]