- en: Testing Configurations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试配置
- en: 原文：[http://www.fuzzingbook.org/html/ConfigurationFuzzer.html](http://www.fuzzingbook.org/html/ConfigurationFuzzer.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/ConfigurationFuzzer.html](http://www.fuzzingbook.org/html/ConfigurationFuzzer.html)
- en: The behavior of a program is not only governed by its data. The *configuration*
    of a program – that is, the settings that govern the execution of a program on
    its (regular) input data, as set by options or configuration files – just as well
    influences behavior, and thus can and should be tested. In this chapter, we explore
    how to systematically *test* and *cover* software configurations. By *automatically
    inferring configuration options*, we can apply these techniques out of the box,
    with no need for writing a grammar. Finally, we show how to systematically cover
    *combinations* of configuration options, quickly detecting unwanted interferences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的行为不仅受其数据控制。程序的 *配置* – 即通过选项或配置文件设置的，控制程序在其（常规）输入数据上执行设置的设置 – 同样会影响行为，因此可以也应该进行测试。在本章中，我们探讨了如何系统地
    *测试* 和 *覆盖* 软件配置。通过 *自动推断配置选项*，我们可以直接应用这些技术，无需编写语法。最后，我们展示了如何系统地覆盖配置选项的 *组合*，快速检测不希望出现的干扰。
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should have read the [chapter on grammars](Grammars.html).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该已经阅读了关于语法的[章节](Grammars.html)。
- en: You should have read the [chapter on grammar coverage](GrammarCoverageFuzzer.html).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该已经阅读了关于语法覆盖的[章节](GrammarCoverageFuzzer.html)。
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Synopsis
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章提供的代码（Importing.html），请编写
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and then make use of the following features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter provides two classes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了两个类：
- en: '`OptionRunner` automatically extract command-line options from a Python program;'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OptionRunner` 自动从 Python 程序中提取命令行选项；'
- en: '`OptionFuzzer` uses these to automatically test a Python program with a large
    variety of options.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OptionFuzzer` 使用这些功能自动测试具有大量选项的 Python 程序。'
- en: '`OptionRunner` runs a program up to the point where it parses its arguments,
    and then extracts a grammar that describes its invocations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionRunner` 运行程序直到它解析其参数，然后提取一个描述其调用的语法：'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The grammar can be extracted via the method `ebnf_grammar()`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可以通过 `ebnf_grammar()` 方法提取：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The grammar can be immediately used for fuzzing. A `GrammarCoverageFuzzer`
    will ensure all options are covered:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 语法可以立即用于模糊测试。`GrammarCoverageFuzzer` 将确保所有选项都被覆盖：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OptionFuzzer` class summarizes these steps. Its constructor takes an `OptionRunner`
    to automatically extract the grammar; it does the necessary steps to extract the
    grammar and fuzz with it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionFuzzer` 类总结了这些步骤。其构造函数接受一个 `OptionRunner` 以自动提取语法；它执行必要的步骤来提取语法并对其进行模糊测试。'
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The final step in testing would now to invoke the program with these arguments.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一步现在是将这些参数调用程序。
- en: 'Note that `OptionRunner` is experimental: It assumes that the Python program
    in question uses the `argparse` module; and not all `argparse` features are supported.
    Still, it does a pretty good job even on nontrivial programs.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`OptionRunner` 是实验性的：它假设相关的 Python 程序使用了 `argparse` 模块；并且并非所有 `argparse`
    功能都得到支持。尽管如此，它即使在非平凡程序上也能做得相当不错。
- en: The `OptionRunner` constructor accepts an additional `miner` keyword parameter,
    which takes the class of the argument grammar miner to be used. By default, this
    is `OptionGrammarMiner` – a helper class that can be used (and extended) to create
    own option grammar miners.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionRunner` 构造函数接受一个额外的 `miner` 关键字参数，该参数接受要使用的参数语法挖掘器的类。默认情况下，这是 `OptionGrammarMiner`
    – 一个辅助类，可以用来（并扩展）创建自己的选项语法挖掘器。'
- en: '<svg width="586pt" height="771pt" viewBox="0.00 0.00 586.12 771.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 767)"><g
    id="node1" class="node"><title>OptionRunner</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class OptionRunner:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="586pt" height="771pt" viewBox="0.00 0.00 586.12 771.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 767)"><g
    id="node1" class="node"><title>OptionRunner</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class OptionRunner:'
- en: 'Run a program while determining its option grammar"><text text-anchor="start"
    x="14" y="-168.82" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">OptionRunner</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="OptionRunner"><g id="a_node1_1"><a xlink:href="#" xlink:title="__init__(self,
    program: Union[str, List[str]], arguments: Optional[str] = None, *, log: bool
    = False, miner_class: Optional[Type[OptionGrammarMiner]] = None):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '在确定其选项语法的同时运行程序"><text text-anchor="start" x="14" y="-168.82" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">OptionRunner</text>
    <g id="a_node1_0"><a xlink:href="#" xlink:title="OptionRunner"><g id="a_node1_1"><a
    xlink:href="#" xlink:title="__init__(self, program: Union[str, List[str]], arguments:
    Optional[str] = None, *, log: bool = False, miner_class: Optional[Type[OptionGrammarMiner]]
    = None):'
- en: Constructor.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数。
- en: '`program` - the (Python) program to be executed'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`program` - 要执行的（Python）程序'
- en: '`arguments` - an (optional) string with arguments for `program`'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` - 一个可选的字符串，包含用于`program`的参数'
- en: '`log` - if True, enable logging in miner'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` - 如果为True，在挖掘器中启用日志记录'
- en: '`miner_class` - the `OptionGrammarMiner` class to be used'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`miner_class` - 要使用的`OptionGrammarMiner`类'
- en: '(default: `OptionGrammarMiner`)"><text text-anchor="start" x="9.5" y="-146.62"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a
    xlink:href="#" xlink:title="ebnf_grammar(self):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '(默认: `OptionGrammarMiner`)"><text text-anchor="start" x="9.5" y="-146.62" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a xlink:href="#"
    xlink:title="ebnf_grammar(self):'
- en: 'Return extracted grammar in EBNF form"><text text-anchor="start" x="9.5" y="-133.88"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">ebnf_grammar()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="grammar(self):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '返回以EBNF形式提取的语法"><text text-anchor="start" x="9.5" y="-133.88" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">ebnf_grammar()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="grammar(self):'
- en: 'Return extracted grammar in BNF form"><text text-anchor="start" x="9.5" y="-121.12"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">grammar()</text></a></g> <g id="a_node1_4"><a xlink:href="#"
    xlink:title="executable(self)"><text text-anchor="start" x="9.5" y="-107.38" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">executable()</text></a></g>
    <g id="a_node1_5"><a xlink:href="#" xlink:title="find_contents(self)"><text text-anchor="start"
    x="9.5" y="-94.62" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">find_contents()</text></a></g> <g id="a_node1_6"><a
    xlink:href="#" xlink:title="find_grammar(self)"><text text-anchor="start" x="9.5"
    y="-81.88" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">find_grammar()</text></a></g> <g id="a_node1_7"><a xlink:href="#"
    xlink:title="invoker(self)"><text text-anchor="start" x="9.5" y="-69.12" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">invoker()</text></a></g>
    <g id="a_node1_8"><a xlink:href="#" xlink:title="set_arguments(self, args)"><text
    text-anchor="start" x="9.5" y="-56.38" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">set_arguments()</text></a></g>
    <g id="a_node1_9"><a xlink:href="#" xlink:title="set_invocation(self, program)"><text
    text-anchor="start" x="9.5" y="-43.62" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">set_invocation()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>ProgramRunner</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class ProgramRunner:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '返回以 BNF 形式提取的语法"><text text-anchor="start" x="9.5" y="-121.12" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">grammar()</text></a></g>
    <g id="a_node1_4"><a xlink:href="#" xlink:title="executable(self)"><text text-anchor="start"
    x="9.5" y="-107.38" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">executable()</text></a></g> <g id="a_node1_5"><a
    xlink:href="#" xlink:title="find_contents(self)"><text text-anchor="start" x="9.5"
    y="-94.62" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">find_contents()</text></a></g> <g id="a_node1_6"><a xlink:href="#"
    xlink:title="find_grammar(self)"><text text-anchor="start" x="9.5" y="-81.88"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">find_grammar()</text></a></g>
    <g id="a_node1_7"><a xlink:href="#" xlink:title="invoker(self)"><text text-anchor="start"
    x="9.5" y="-69.12" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">invoker()</text></a></g> <g id="a_node1_8"><a xlink:href="#"
    xlink:title="set_arguments(self, args)"><text text-anchor="start" x="9.5" y="-56.38"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">set_arguments()</text></a></g>
    <g id="a_node1_9"><a xlink:href="#" xlink:title="set_invocation(self, program)"><text
    text-anchor="start" x="9.5" y="-43.62" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">set_invocation()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>ProgramRunner</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class ProgramRunner:'
- en: 'Test a program with inputs."><text text-anchor="start" x="8" y="-288.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProgramRunner</text>
    <g id="a_node2_10"><a xlink:href="#" xlink:title="ProgramRunner"><g id="a_node2_11"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self, program: Union[str, List[str]])
    -> None:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '使用输入测试程序。<text text-anchor="start" x="8" y="-288.45" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProgramRunner</text>
    <g id="a_node2_10"><a xlink:href="#" xlink:title="ProgramRunner"><g id="a_node2_11"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self, program: Union[str, List[str]])
    -> None:'
- en: Initialize.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化。
- en: '`program` is a program spec as passed to `subprocess.run()`"><text text-anchor="start"
    x="27.5" y="-266.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>OptionRunner->ProgramRunner</title></g> <g id="node3"
    class="node"><title>Runner</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Runner:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`program` 是传递给 `subprocess.run()` 的程序规范 `<text text-anchor="start" x="27.5"
    y="-266.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>OptionRunner->ProgramRunner</title></g> <g id="node3"
    class="node"><title>Runner</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Runner:'
- en: 'Base class for testing inputs."><text text-anchor="start" x="34.62" y="-431.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">Runner</text> <g id="a_node3_12"><a xlink:href="#" xlink:title="Runner"><g
    id="a_node3_13"><a xlink:href="Fuzzer.html" xlink:title="FAIL = ''FAIL''"><text
    text-anchor="start" x="27.5" y="-408" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">FAIL</text></a></g> <g id="a_node3_14"><a
    xlink:href="Fuzzer.html" xlink:title="PASS = ''PASS''"><text text-anchor="start"
    x="27.5" y="-395.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">PASS</text></a></g> <g id="a_node3_15"><a xlink:href="Fuzzer.html"
    xlink:title="UNRESOLVED = ''UNRESOLVED''"><text text-anchor="start" x="27.5" y="-382.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="Runner"><g id="a_node3_17"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '测试输入的基本类。"><text text-anchor="start" x="34.62" y="-431.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Runner</text>
    <g id="a_node3_12"><a xlink:href="#" xlink:title="Runner"><g id="a_node3_13"><a
    xlink:href="Fuzzer.html" xlink:title="FAIL = ''FAIL''"><text text-anchor="start"
    x="27.5" y="-408" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">FAIL</text></a></g> <g id="a_node3_14"><a xlink:href="Fuzzer.html"
    xlink:title="PASS = ''PASS''"><text text-anchor="start" x="27.5" y="-395.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">PASS</text></a></g>
    <g id="a_node3_15"><a xlink:href="Fuzzer.html" xlink:title="UNRESOLVED = ''UNRESOLVED''"><text
    text-anchor="start" x="27.5" y="-382.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="Runner"><g id="a_node3_17"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
- en: 'Initialize"><text text-anchor="start" x="27.5" y="-362.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_18"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, inp: str) -> Any:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '初始化"><text text-anchor="start" x="27.5" y="-362.75" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_18"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, inp: str) -> Any:'
- en: 'Run the runner with the given input"><text text-anchor="start" x="27.5" y="-350"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="edge2" class="edge"><title>ProgramRunner->Runner</title></g> <g id="node4"
    class="node"><title>OptionFuzzer</title> <g id="a_node4"><a xlink:href="#" xlink:title="class
    OptionFuzzer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '使用给定的输入运行 runner"><text text-anchor="start" x="27.5" y="-350" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>ProgramRunner->Runner</title></g>
    <g id="node4" class="node"><title>OptionFuzzer</title> <g id="a_node4"><a xlink:href="#"
    xlink:title="class OptionFuzzer:'
- en: 'Fuzz a (Python) program using its arguments"><text text-anchor="start" x="179.25"
    y="-124.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">OptionFuzzer</text> <g id="a_node4_19"><a xlink:href="#" xlink:title="OptionFuzzer"><g
    id="a_node4_20"><a xlink:href="#" xlink:title="__init__(self, runner: OptionRunner,
    *args, **kwargs):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '使用程序的参数对 (Python) 程序进行模糊测试"><text text-anchor="start" x="179.25" y="-124.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">OptionFuzzer</text> <g id="a_node4_19"><a xlink:href="#" xlink:title="OptionFuzzer"><g
    id="a_node4_20"><a xlink:href="#" xlink:title="__init__(self, runner: OptionRunner,
    *args, **kwargs):'
- en: 'Constructor. `runner` is an OptionRunner."><text text-anchor="start" x="190.5"
    y="-102" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node4_21"><a xlink:href="#" xlink:title="run(self, runner=None, inp=''''):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数。`runner` 是一个 OptionRunner。"><text text-anchor="start" x="190.5" y="-102"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">__init__()</text></a></g> <g id="a_node4_21"><a
    xlink:href="#" xlink:title="run(self, runner=None, inp=''''):'
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="190.5" y="-89.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="node5" class="node"><title>GrammarCoverageFuzzer</title> <g id="a_node5"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class GrammarCoverageFuzzer:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 `runner` 并使用模糊输入"><text text-anchor="start" x="190.5" y="-89.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g></a></g></a></g></g> <g id="node5" class="node"><title>GrammarCoverageFuzzer</title>
    <g id="a_node5"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="class
    GrammarCoverageFuzzer:'
- en: 'Produce from grammars, aiming for coverage of all expansions."><text text-anchor="start"
    x="141.75" y="-278.07" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text></a></g></g> <g id="edge3"
    class="edge"><title>OptionFuzzer->GrammarCoverageFuzzer</title></g> <g id="node6"
    class="node"><title>SimpleGrammarCoverageFuzzer</title> <g id="a_node6"><a xlink:href="GrammarCoverageFuzzer.html"
    xlink:title="class SimpleGrammarCoverageFuzzer:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法生成字符串，旨在覆盖所有扩展。"><text text-anchor="start" x="141.75" y="-278.07" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text></a></g></g>
    <g id="edge3" class="edge"><title>OptionFuzzer->GrammarCoverageFuzzer</title></g>
    <g id="node6" class="node"><title>SimpleGrammarCoverageFuzzer</title> <g id="a_node6"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class SimpleGrammarCoverageFuzzer:'
- en: 'When choosing expansions, prefer expansions not covered."><text text-anchor="start"
    x="121.12" y="-391.32" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text></a></g></g>
    <g id="edge4" class="edge"><title>GrammarCoverageFuzzer->SimpleGrammarCoverageFuzzer</title></g>
    <g id="node7" class="node"><title>TrackingGrammarCoverageFuzzer</title> <g id="a_node7"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class TrackingGrammarCoverageFuzzer:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在选择扩展时，优先选择未被覆盖的扩展。"><text text-anchor="start" x="121.12" y="-391.32" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text></a></g></g>
    <g id="edge4" class="edge"><title>GrammarCoverageFuzzer->SimpleGrammarCoverageFuzzer</title></g>
    <g id="node7" class="node"><title>TrackingGrammarCoverageFuzzer</title> <g id="a_node7"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class TrackingGrammarCoverageFuzzer:'
- en: 'Track grammar coverage during production"><text text-anchor="start" x="114.38"
    y="-514.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text> <g id="a_node7_22"><a
    xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer"><g id="a_node7_23"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="__init__(self, *args, **kwargs)
    -> None:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法生成字符串，旨在覆盖所有扩展。"><text text-anchor="start" x="114.38" y="-514.95" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text>
    <g id="a_node7_22"><a xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer"><g
    id="a_node7_23"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="__init__(self,
    *args, **kwargs) -> None:'
- en: Produce strings from `grammar`, starting with `start_symbol`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `grammar` 生成字符串，以 `start_symbol` 为起点。
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了 `disp`，则显示中间推导树。
- en: for the number of nonterminals produced.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '在生成过程中跟踪语法覆盖率。"><text text-anchor="start" x="170.62" y="-624.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
    <g id="a_node8_24"><a xlink:href="#" xlink:title="GrammarFuzzer"><g id="a_node8_25"><a
    xlink:href="GrammarFuzzer.html" xlink:title="__init__(self, grammar: Dict[str,
    List[Expansion]], start_symbol: str = ''<start>'', min_nonterminals: int = 0,
    max_nonterminals: int = 10, disp: bool = False, log: Union[bool, int] = False)
    -> None:'
- en: If `disp` is set, display the intermediate derivation trees.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 生成从 `grammar` 开始的字符串，以 `start_symbol` 为起点。
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="190.5" y="-492.75" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge5" class="edge"><title>SimpleGrammarCoverageFuzzer->TrackingGrammarCoverageFuzzer</title></g>
    <g id="node8" class="node"><title>GrammarFuzzer</title> <g id="a_node8"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '如果设置了 `log`，则将中间步骤作为文本输出到标准输出。"><text text-anchor="start" x="190.5" y="-492.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge5" class="edge"><title>SimpleGrammarCoverageFuzzer->TrackingGrammarCoverageFuzzer</title></g>
    <g id="node8" class="node"><title>GrammarFuzzer</title> <g id="a_node8"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="170.62" y="-624.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarFuzzer</text> <g id="a_node8_24"><a xlink:href="#"
    xlink:title="GrammarFuzzer"><g id="a_node8_25"><a xlink:href="GrammarFuzzer.html"
    xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol:
    str = ''<start>'', min_nonterminals: int = 0, max_nonterminals: int = 10, disp:
    bool = False, log: Union[bool, int] = False) -> None:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成从 `grammar` 开始的字符串，以 `start_symbol` 为起点。
- en: Produce strings from `grammar`, starting with `start_symbol`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `grammar` 生成字符串，以 `start_symbol` 为起点。
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了 `min_nonterminals` 或 `max_nonterminals`，则使用它们作为限制。
- en: for the number of nonterminals produced.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于产生的非终结符数量。
- en: If `disp` is set, display the intermediate derivation trees.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`disp`被设置，显示中间推导树。
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="187.5" y="-602" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node8_26"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '如果`log`被设置，将中间步骤以文本形式显示在标准输出上。"><text text-anchor="start" x="187.5" y="-602"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">__init__()</text></a></g> <g id="a_node8_26"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self) -> str:'
- en: 'Produce a string from the grammar."><text text-anchor="start" x="187.5" y="-589.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node8_27"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -> DerivationTree:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法中生成一个字符串。"><text text-anchor="start" x="187.5" y="-589.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node8_27"><a xlink:href="GrammarFuzzer.html"
    xlink:title="fuzz_tree(self) -> DerivationTree:'
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="187.5"
    y="-576.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g></a></g></a></g></g>
    <g id="edge6" class="edge"><title>TrackingGrammarCoverageFuzzer->GrammarFuzzer</title></g>
    <g id="node9" class="node"><title>Fuzzer</title> <g id="a_node9"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '从语法中生成一个推导树。"><text text-anchor="start" x="187.5" y="-576.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g></a></g></a></g></g>
    <g id="edge6" class="edge"><title>TrackingGrammarCoverageFuzzer->GrammarFuzzer</title></g>
    <g id="node9" class="node"><title>Fuzzer</title> <g id="a_node9"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
- en: 'Base class for fuzzers."><text text-anchor="start" x="199.88" y="-746.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node9_28"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node9_29"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '模糊器的基类。"><text text-anchor="start" x="199.88" y="-746.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node9_28"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node9_29"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
- en: 'Constructor"><text text-anchor="start" x="190.5" y="-724" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node9_30"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '构造函数"><text text-anchor="start" x="190.5" y="-724" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node9_30"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
- en: 'Return fuzz input"><text text-anchor="start" x="190.5" y="-711.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node9_31"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '返回模糊输入"><text text-anchor="start" x="190.5" y="-711.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node9_31"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="190.5" y="-698.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g> <g id="a_node9_32"><a
    xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '使用模糊输入运行`runner`"><text text-anchor="start" x="190.5" y="-698.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">run()</text></a></g> <g id="a_node9_32"><a xlink:href="Fuzzer.html"
    xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner object>, trials:
    int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
- en: 'Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="190.5"
    y="-685.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge7" class="edge"><title>GrammarFuzzer->Fuzzer</title></g> <g id="node10"
    class="node"><title>OptionGrammarMiner</title> <g id="a_node10"><a xlink:href="#"
    xlink:title="class OptionGrammarMiner:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '运行 `runner`，使用模糊输入，`trials` 次数"><text text-anchor="start" x="190.5" y="-685.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">runs()</text></a></g></a></g></a></g></g> <g id="edge7" class="edge"><title>GrammarFuzzer->Fuzzer</title></g>
    <g id="node10" class="node"><title>OptionGrammarMiner</title> <g id="a_node10"><a
    xlink:href="#" xlink:title="class OptionGrammarMiner:'
- en: 'Helper class for extracting option grammars"><text text-anchor="start" x="296.25"
    y="-204.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">OptionGrammarMiner</text> <g id="a_node10_33"><a xlink:href="#"
    xlink:title="OptionGrammarMiner"><g id="a_node10_34"><a xlink:href="#" xlink:title="ARGUMENTS_SYMBOL
    = ''<arguments>''"><text text-anchor="start" x="316.5" y="-181.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">ARGUMENTS_SYMBOL</text></a></g>
    <g id="a_node10_35"><a xlink:href="#" xlink:title="OPTION_SYMBOL = ''<option>''"><text
    text-anchor="start" x="316.5" y="-168.75" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">OPTION_SYMBOL</text></a></g></a></g>
    <g id="a_node10_36"><a xlink:href="#" xlink:title="OptionGrammarMiner"><g id="a_node10_37"><a
    xlink:href="#" xlink:title="__init__(self, function: Callable, log: bool = False):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '用于提取选项语法的辅助类"><text text-anchor="start" x="296.25" y="-204.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">OptionGrammarMiner</text>
    <g id="a_node10_33"><a xlink:href="#" xlink:title="OptionGrammarMiner"><g id="a_node10_34"><a
    xlink:href="#" xlink:title="ARGUMENTS_SYMBOL = ''<arguments>''"><text text-anchor="start"
    x="316.5" y="-181.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">ARGUMENTS_SYMBOL</text></a></g> <g id="a_node10_35"><a
    xlink:href="#" xlink:title="OPTION_SYMBOL = ''<option>''"><text text-anchor="start"
    x="316.5" y="-168.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">OPTION_SYMBOL</text></a></g></a></g> <g id="a_node10_36"><a
    xlink:href="#" xlink:title="OptionGrammarMiner"><g id="a_node10_37"><a xlink:href="#"
    xlink:title="__init__(self, function: Callable, log: bool = False):'
- en: Constructor.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数。
- en: '`function` - a function processing arguments using argparse()'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`function` - 使用 argparse() 处理参数的函数'
- en: '`log` - output diagnostics if True"><text text-anchor="start" x="307.5" y="-149"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__init__()</text></a></g> <g id="a_node10_38"><a xlink:href="#"
    xlink:title="mine_ebnf_grammar(self):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` - 如果为 True，则输出诊断信息"><text text-anchor="start" x="307.5" y="-149" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node10_38"><a xlink:href="#" xlink:title="mine_ebnf_grammar(self):'
- en: 'Extract EBNF option grammar"><text text-anchor="start" x="307.5" y="-136.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">mine_ebnf_grammar()</text></a></g> <g id="a_node10_39"><a xlink:href="#"
    xlink:title="mine_grammar(self):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '提取 EBNF 选项语法"><text text-anchor="start" x="307.5" y="-136.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">mine_ebnf_grammar()</text></a></g>
    <g id="a_node10_39"><a xlink:href="#" xlink:title="mine_grammar(self):'
- en: Extract BNF option grammar"><text text-anchor="start" x="307.5" y="-123.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">mine_grammar()</text></a></g>
    <g id="a_node10_40"><a xlink:href="#" xlink:title="add_group(self, locals, exclusive)"><text
    text-anchor="start" x="307.5" y="-109.75" font-family="'Fira Mono', 'Source Code
    Pro', 'Courier', monospace" font-size="10.00">add_group()</text></a></g> <g id="a_node10_41"><a
    xlink:href="#" xlink:title="add_int_rule(self)"><text text-anchor="start" x="307.5"
    y="-97" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_int_rule()</text></a></g>
    <g id="a_node10_42"><a xlink:href="#" xlink:title="add_metavar_rule(self, metavar,
    type_)"><text text-anchor="start" x="307.5" y="-84.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_metavar_rule()</text></a></g>
    <g id="a_node10_43"><a xlink:href="#" xlink:title="add_parameter(self, kwargs,
    metavar)"><text text-anchor="start" x="307.5" y="-71.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_parameter()</text></a></g>
    <g id="a_node10_44"><a xlink:href="#" xlink:title="add_str_rule(self)"><text text-anchor="start"
    x="307.5" y="-58.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">add_str_rule()</text></a></g> <g id="a_node10_45"><a xlink:href="#"
    xlink:title="add_type_rule(self, type_)"><text text-anchor="start" x="307.5" y="-46"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_type_rule()</text></a></g>
    <g id="a_node10_46"><a xlink:href="#" xlink:title="process_arg(self, arg, in_group,
    kwargs)"><text text-anchor="start" x="307.5" y="-33.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_arg()</text></a></g>
    <g id="a_node10_47"><a xlink:href="#" xlink:title="process_argument(self, locals,
    in_group)"><text text-anchor="start" x="307.5" y="-20.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_argument()</text></a></g>
    <g id="a_node10_48"><a xlink:href="#" xlink:title="traceit(self, frame, event,
    arg)"><text text-anchor="start" x="307.5" y="-7.75" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node11" class="node"><title>Legend</title> <text text-anchor="start" x="458.88"
    y="-126.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="458.88"
    y="-116.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="464.88" y="-116.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="458.88" y="-106.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-106.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="458.88" y="-96.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-96.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="458.88"
    y="-87.7" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提取 BNF 选项语法"><text text-anchor="start" x="307.5" y="-123.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">mine_grammar()</text></a></g>
    <g id="a_node10_40"><a xlink:href="#" xlink:title="add_group(self, locals, exclusive)"><text
    text-anchor="start" x="307.5" y="-109.75" font-family="'Fira Mono', 'Source Code
    Pro', 'Courier', monospace" font-size="10.00">add_group()</text></a></g> <g id="a_node10_41"><a
    xlink:href="#" xlink:title="add_int_rule(self)"><text text-anchor="start" x="307.5"
    y="-97" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_int_rule()</text></a></g>
    <g id="a_node10_42"><a xlink:href="#" xlink:title="add_metavar_rule(self, metavar,
    type_)"><text text-anchor="start" x="307.5" y="-84.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_metavar_rule()</text></a></g>
    <g id="a_node10_43"><a xlink:href="#" xlink:title="add_parameter(self, kwargs,
    metavar)"><text text-anchor="start" x="307.5" y="-71.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_parameter()</text></a></g>
    <g id="a_node10_44"><a xlink:href="#" xlink:title="add_str_rule(self)"><text text-anchor="start"
    x="307.5" y="-58.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">add_str_rule()</text></a></g> <g id="a_node10_45"><a xlink:href="#"
    xlink:title="add_type_rule(self, type_)"><text text-anchor="start" x="307.5" y="-46"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_type_rule()</text></a></g>
    <g id="a_node10_46"><a xlink:href="#" xlink:title="process_arg(self, arg, in_group,
    kwargs)"><text text-anchor="start" x="307.5" y="-33.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_arg()</text></a></g>
    <g id="a_node10_47"><a xlink:href="#" xlink:title="process_argument(self, locals,
    in_group)"><text text-anchor="start" x="307.5" y="-20.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_argument()</text></a></g>
    <g id="a_node10_48"><a xlink:href="#" xlink:title="traceit(self, frame, event,
    arg)"><text text-anchor="start" x="307.5" y="-7.75" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node11" class="node"><title>图例</title> <text text-anchor="start" x="458.88"
    y="-126.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">图例</text> <text text-anchor="start" x="458.88"
    y="-116.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="464.88" y="-116.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">公共方法()</text>
    <text text-anchor="start" x="458.88" y="-106.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-106.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">私有方法()</text>
    <text text-anchor="start" x="458.88" y="-96.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-96.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">重载方法()</text> <text text-anchor="start" x="458.88" y="-87.7"
    font-family="Helvetica,sans-Serif" font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: Configuration Options
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置选项
- en: When we talk about the input to a program, we usually think of the *data* it
    processes. This is also what we have been fuzzing in the past chapters – be it
    with [random input](Fuzzer.html), [mutation-based fuzzing](MutationFuzzer.html),
    or [grammar-based fuzzing](GrammarFuzzer.html). However, programs typically have
    several input sources, all of which can and should be tested – and included in
    test generation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论程序的输入时，我们通常想到的是它处理的*数据*。这也是我们在过去章节中模糊测试的内容——无论是使用[随机输入](Fuzzer.html)、[基于变异的模糊测试](MutationFuzzer.html)还是[基于语法的模糊测试](GrammarFuzzer.html)。然而，程序通常有几个输入来源，所有这些都可以也应该被测试——并包含在测试生成中。
- en: One important source of input is the program's *configuration* – that is, a
    set of inputs that typically is set once when beginning to process data and then
    stays constant while processing data, while the program is running, or even while
    the program is deployed. Such a configuration is frequently set in *configuration
    files* (for instance, as key/value pairs); the most ubiquitous method for command-line
    tools, though, are *configuration options* on the command line.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的输入来源是程序的*配置*——也就是说，一组输入，通常在开始处理数据时设置一次，然后在程序运行时保持不变，甚至在程序部署时保持不变。此类配置通常在*配置文件*中设置（例如，作为键/值对）；然而，对于命令行工具来说，最普遍的方法是在命令行上的*配置选项*。
- en: 'As an example, consider the `grep` utility to find textual patterns in files.
    The exact mode by which `grep` works is governed by a multitude of options, which
    can be listed by providing a `--help` option:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`grep`实用程序在文件中查找文本模式。`grep`工作的确切模式由大量选项控制，可以通过提供`--help`选项来列出：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All these options need to be tested for whether they operate correctly. In security
    testing, any such option may also trigger a yet unknown vulnerability. Hence,
    such options can become *fuzz targets* on their own. In this chapter, we analyze
    how to systematically test such options – and better yet, how to extract possible
    configurations right out of given program files, such that we do not have to specify
    anything.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都需要测试它们是否正确操作。在安全测试中，任何此类选项也可能触发尚未知的漏洞。因此，此类选项可以成为自己的*模糊目标*。在本章中，我们分析如何系统地测试此类选项——而且更好的是，如何从给定的程序文件中提取可能的配置，这样我们就不需要指定任何内容。
- en: Options in Python
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的选项
- en: Let us stick to our common programming language here and examine how options
    are processed in Python. The `argparse` module provides a parser for command-line
    arguments (and options) with great functionality – and great complexity. You start
    by defining a parser (`argparse.ArgumentParser()`) to which individual arguments
    with various features are added, one after another. Additional parameters for
    each argument can specify the type (`type`) of the argument (say, integers or
    strings), or the number of arguments (`nargs`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用我们共同的编程语言，并检查在 Python 中如何处理选项。`argparse` 模块提供了一个具有强大功能——以及复杂性的命令行参数（和选项）解析器。你首先定义一个解析器（`argparse.ArgumentParser()`），然后逐个添加具有各种特性的单个参数。每个参数的附加参数可以指定参数的类型（`type`）（例如，整数或字符串），或参数的数量（`nargs`）。
- en: 'By default, arguments are stored under their name in the `args` object coming
    from `parse_args()` – thus, `args.integers` holds the `integer` arguments added
    earlier. Special actions (`actions`) allow storing specific values in given variables;
    the `store_const` action stores the given `const` in the attribute named by `dest`.
    The following example takes a number of integer arguments (`integers`) as well
    as an operator (`--sum`, `--min`, or `--max`) to be applied on these integers.
    The operators all store a function reference in the `accumulate` attribute, which
    is finally invoked on the integers parsed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，参数存储在`parse_args()`返回的`args`对象中，其名称下——因此，`args.integers`包含之前添加的`integer`参数。特殊操作（`actions`）允许在给定的变量中存储特定值；`store_const`操作将给定的`const`存储在由`dest`命名的属性中。以下示例接受多个整数参数（`integers`）以及要应用于这些整数的操作符（`--sum`、`--min`或`--max`）。所有操作符都将函数引用存储在`accumulate`属性中，最终在解析的整数上调用：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how `process_numbers()` works. We can, for instance, invoke the `--min`
    option on the given arguments to compute the minimum:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何`process_numbers()`工作的。例如，我们可以对给定的参数调用`--min`选项来计算最小值：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Or compute the sum of three numbers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或者计算三个数字的总和：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When defined via `add_mutually_exclusive_group()` (as above), options are mutually
    exclusive. Consequently, we can have only one operator:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过`add_mutually_exclusive_group()`（如上所示）定义时，选项是互斥的。因此，我们只能有一个操作符：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A Grammar for Configurations
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置的语法
- en: 'How can we test a system with several options? The easiest answer is to write
    a grammar for it. The grammar `PROCESS_NUMBERS_EBNF_GRAMMAR` reflects the possible
    combinations of options and arguments:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如何测试具有多个选项的系统？最简单的答案是为它编写一个语法。`PROCESS_NUMBERS_EBNF_GRAMMAR`语法反映了选项和参数的可能组合：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can feed this grammar into our [grammar coverage fuzzer](GrammarCoverageFuzzer.html)
    and have it cover one option after another:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个语法输入到我们的[语法覆盖率模糊测试工具](GrammarCoverageFuzzer.html)中，并让它逐个覆盖选项：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, we can also invoke `process_numbers()` with these very arguments.
    To this end, we need to convert the string produced by the grammar back into a
    list of individual arguments, using `split()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以使用这些参数调用`process_numbers()`。为此，我们需要使用`split()`将语法产生的字符串转换回一个包含单个参数的列表：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Similarly, we can define grammars for any program to be tested; as well as
    define grammars for, say, configuration files. Yet, the grammar has to be updated
    with every change to the program, which creates a maintenance burden. Given that
    the information required for the grammar is already all encoded in the program,
    the question arises: *Can''t we go and extract configuration options right out
    of the program in the first place?*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以为任何要测试的程序定义语法；以及为配置文件定义语法。然而，每当程序发生变化时，都需要更新语法，这会带来维护负担。鉴于语法所需的信息已经全部编码在程序中，问题随之而来：*我们为什么不能一开始就从程序中提取配置选项呢？*
- en: Mining Configuration Options
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挖掘配置选项
- en: In this section, we try to extract option and argument information right out
    of a program, such that we do not have to specify a configuration grammar. The
    aim is to have a configuration fuzzer that works on the options and arguments
    of an arbitrary program, as long as it follows specific conventions for processing
    its arguments. In the case of Python programs, this means using the `argparse`
    module.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们尝试直接从程序中提取选项和参数信息，这样我们就不需要指定配置语法。目标是拥有一个能够处理任意程序选项和参数的配置模糊测试工具，只要它遵循特定的参数处理约定。对于Python程序来说，这意味着使用`argparse`模块。
- en: 'Our idea is as follows: We execute the given program up to the point where
    the arguments are actually parsed – that is, `argparse.parse_args()` is invoked.
    Up to this point, we track all calls into the argument parser, notably those calls
    that define arguments and options (`add_argument()`). From these, we construct
    the grammar.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的思路如下：我们执行给定的程序，直到实际解析参数为止——即调用`argparse.parse_args()`。在此之前的所有调用，特别是定义参数和选项的调用（`add_argument()`），我们都会进行跟踪。从这些调用中，我们构建语法。
- en: Tracking Arguments
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪参数
- en: 'Let us illustrate this approach with a simple experiment: We define a trace
    function (see [our chapter on coverage](Coverage.html) for details) that is active
    while `process_numbers` is invoked. If we have a call to a method `add_argument`,
    we access and print out the local variables (which at this point are the arguments
    to the method).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简单的实验来说明这种方法：我们定义一个跟踪函数（有关详细信息，请参阅[我们的覆盖率章节](Coverage.html)），在调用`process_numbers`时处于活动状态。如果我们有一个调用`add_argument`的方法，我们将访问并打印出局部变量（此时是方法的参数）。
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What we get is a list of all calls to `add_argument()`, together with the method
    arguments passed:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的是所有`add_argument()`调用的列表，以及传递给方法的参数：
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'From the `args` argument, we can access the individual options and arguments
    to be defined:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从`args`参数中，我们可以访问要定义的各个选项和参数：
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We see that each argument comes as a tuple with one (say, `integers` or `--sum`)
    or two members (`-h` and `--help`), which denote alternate forms for the same
    option. Our job will be to go through the arguments of `add_arguments()` and detect
    not only the names of options and arguments, but also whether they accept additional
    parameters, as well as the type of the parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，每个参数都是一个包含一个成员（例如，`integers`或`--sum`）或两个成员（`-h`和`--help`）的元组，这表示同一选项的替代形式。我们的任务将是遍历`add_arguments()`的参数，不仅检测选项和参数的名称，还要检测它们是否接受额外的参数，以及参数的类型。
- en: A Grammar Miner for Options and Arguments
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项和参数的语法挖掘器
- en: Let us now build a class that gathers all this information to create a grammar.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在构建一个类，它收集所有这些信息以创建一个语法。
- en: 'We use the `ParseInterrupt` exception to interrupt program execution after
    gathering all arguments and options:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ParseInterrupt`异常在收集所有参数和选项后中断程序执行：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The class `OptionGrammarMiner` takes an executable function for which the grammar
    of options and arguments is to be mined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionGrammarMiner` 类接受一个可执行函数，用于从中挖掘选项和参数的语法：'
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The method `mine_ebnf_grammar()` is where everything happens. It creates a grammar
    of the form
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mine_ebnf_grammar()` 方法是所有事情发生的地方。它创建一个形式的语法'
- en: '[PRE38]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: in which the options and arguments will be collected. It then sets a trace function
    (see [our chapter on coverage](Coverage.html) for details) that is active while
    the previously defined `function` is invoked. Raising `ParseInterrupt` (when `parse_args()`
    is invoked) ends execution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中将收集选项和参数。然后它设置一个跟踪函数（有关详细信息，请参阅[我们的覆盖率章节](Coverage.html)），在之前定义的 `function`
    被调用时处于活动状态。当调用 `parse_args()` 时引发 `ParseInterrupt` 将结束执行。
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The trace function checks for four methods: `add_argument()` is the most important
    function, resulting in processing arguments; `frame.f_locals` again is the set
    of local variables, which at this point is mostly the arguments to `add_argument()`.
    Since mutually exclusive groups also have a method `add_argument()`, we set the
    flag `in_group` to differentiate.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪函数检查四个方法：`add_argument()` 是最重要的函数，它会导致处理参数；`frame.f_locals` 再次是局部变量的集合，此时主要是
    `add_argument()` 的参数。由于互斥组也有 `add_argument()` 方法，我们设置 `in_group` 标志以区分。
- en: Note that we make no specific efforts to differentiate between multiple parsers
    or groups; we simply assume that there is one parser, and at any point at most
    one mutually exclusive group.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有做出任何具体努力来区分多个解析器或组；我们只是假设存在一个解析器，并且在任何时刻最多只有一个互斥组。
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `process_arguments()` now analyzes the arguments passed and adds them to
    the grammar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`process_arguments()` 现在分析传递的参数并将它们添加到语法中：'
- en: If the argument starts with `-`, it gets added as an optional element to the
    `<option>` list
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数以 `-` 开头，它会被添加到 `<option>` 列表中的可选元素。
- en: Otherwise, it gets added to the `<argument>` list.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它会被添加到 `<argument>` 列表中。
- en: The optional `nargs` argument specifies how many arguments can follow. If it
    is a number, we add the appropriate number of elements to the grammar; if it is
    an abstract specifier (say, `+` or `*`), we use it directly as EBNF operator.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 `nargs` 参数指定可以跟随多少个参数。如果它是一个数字，我们就在语法中添加相应数量的元素；如果它是一个抽象指定符（例如，`+` 或 `*`），我们就直接将其用作
    EBNF 操作符。
- en: Given the large number of parameters and optional behavior, this is a somewhat
    messy function, but it does the job.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于参数数量众多且具有可选行为，这是一个相当混乱的函数，但它确实完成了工作。
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The method `add_parameter()` handles possible parameters of options. If the
    argument has an `action` defined, it takes no parameter. Otherwise, we identify
    the type of the parameter (as `int` or `str`) and augment the grammar with an
    appropriate rule.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_parameter()` 方法处理选项的可能参数。如果参数定义了 `action`，则它不取任何参数。否则，我们识别参数的类型（如 `int`
    或 `str`）并使用适当的规则增强语法。'
- en: '[PRE43]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The method `add_type_rule()` adds a rule for parameter types to the grammar.
    If the parameter is identified by a meta-variable (say, `N`), we add a rule for
    this as well to improve legibility.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_type_rule()` 方法将参数类型的规则添加到语法中。如果参数由元变量（例如，`N`）标识，我们也会添加一个规则以提高可读性。'
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The method `add_group()` adds a new mutually exclusive group to the grammar.
    We define a new symbol (say, `<group>`) for the options added to the group, and
    use the `required` and `exclusive` flags to define an appropriate expansion operator.
    The group is then prefixed to the grammar, as in
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_group()` 方法将一个新的互斥组添加到语法中。我们为添加到组中的选项定义了一个新符号（例如，`<group>`），并使用 `required`
    和 `exclusive` 标志定义适当的扩展操作符。然后，该组被作为前缀添加到语法中，如下所示：'
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: and filled with the next calls to `add_argument()` within the group.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过在组内调用 `add_argument()` 的下一个调用填充。
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's it! With this, we can now extract the grammar from our `process_numbers()`
    program. Turning on logging again reveals the variables we draw upon.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！有了这个，我们现在可以从我们的 `process_numbers()` 程序中提取语法。再次打开日志可以揭示我们使用的变量。
- en: '[PRE48]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here is the extracted grammar:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是提取的语法：
- en: '[PRE50]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The grammar properly identifies the group found:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 语法正确地识别了找到的组：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It also identifies a `--help` option provided not by us, but by the `argparse`
    module:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它还标识了一个由我们提供的 `argparse` 模块提供的 `--help` 选项：
- en: '[PRE56]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The grammar also correctly identifies the types of the arguments:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 语法也正确地识别了参数的类型：
- en: '[PRE58]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The rules for `int` are set as defined by `add_int_rule()`
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 的规则设置为 `add_int_rule()` 所定义的。'
- en: '[PRE62]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can take this grammar and convert it to BNF, such that we can fuzz with
    it right away:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个语法转换为 BNF，这样我们就可以立即使用它进行模糊测试：
- en: '[PRE64]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Each and every invocation adheres to the rules as set forth in the `argparse`
    calls. By mining options and arguments from existing programs, we can now fuzz
    these options out of the box – without having to specify a grammar.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用都遵循在 `argparse` 调用中设定的规则。通过从现有程序中挖掘选项和参数，我们现在可以立即模糊这些选项——而无需指定语法。
- en: Testing Autopep8
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 Autopep8
- en: 'Let us try out the option grammar miner on real-world Python programs. `autopep8`
    is a tool that automatically converts Python code to the [PEP 8 Style Guide for
    Python Code](https://www.python.org/dev/peps/pep-0008/). (Actually, all Python
    code in this book runs through `autopep8` during production.) `autopep8` offers
    a wide range of options, as can be seen by invoking it with `--help`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在现实世界的 Python 程序上使用选项语法挖掘器。`autopep8` 是一个将 Python 代码自动转换为 [Python 代码 PEP
    8 风格指南](https://www.python.org/dev/peps/pep-0008/)的工具。（实际上，本书中的所有 Python 代码在生产过程中都通过
    `autopep8` 运行。）`autopep8` 提供了广泛的功能，可以通过使用 `--help` 来查看：
- en: '[PRE68]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Autopep8 Setup
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Autopep8 设置
- en: 'We want to systematically test these options. In order to deploy our configuration
    grammar miner, we need to find the source code of the executable:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想系统地测试这些选项。为了部署我们的配置语法挖掘器，我们需要找到可执行文件源代码：
- en: '[PRE70]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Next, we build a function that reads the contents of the file and executes it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建一个函数，该函数读取文件内容并执行它。
- en: '[PRE74]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Mining an Autopep8 Grammar
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挖掘 Autopep8 语法
- en: 'We can use the `autopep8()` function in our grammar miner:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的语法挖掘器中使用 `autopep8()` 函数：
- en: '[PRE75]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'and extract a grammar for it:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 并从中提取语法：
- en: '[PRE76]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This works because here, `autopep8` is not a separate process (and a separate
    Python interpreter), but we run the `autopep8()` function (and the `autopep8`
    code) in our current Python interpreter – up to the call to `parse_args()`, where
    we interrupt execution again. At this point, the `autopep8` code has done nothing
    but setting up the argument parser – which is what we are interested in.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以有效，是因为在这里，`autopep8` 不是一个单独的过程（也不是一个单独的 Python 解释器），我们是在当前的 Python 解释器中运行
    `autopep8()` 函数（以及 `autopep8` 代码）——直到调用 `parse_args()`，在那里我们再次中断执行。此时，`autopep8`
    代码除了设置参数解析器之外没有做任何事情——这正是我们所感兴趣的。
- en: 'The grammar options mined reflect precisely the options seen when providing
    `--help`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 挖掘出的语法选项精确地反映了提供 `--help` 时看到的选项：
- en: '[PRE77]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Metavariables like `<n>` or `<line>` are placeholders for integers. We assume
    all metavariables of the same name have the same type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 元变量如 `<n>` 或 `<line>` 是整数的占位符。我们假设所有同名元变量具有相同的类型：
- en: '[PRE79]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The grammar miner has inferred that the argument to `autopep8` is a list of
    files:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 语法挖掘器推断出 `autopep8` 的参数是一系列文件：
- en: '[PRE81]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'which in turn all are strings:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项反过来都是字符串：
- en: '[PRE83]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As we are only interested in testing options, not arguments, we fix the arguments
    to a single mandatory input. (Otherwise, we'd have plenty of random file names
    generated.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只对测试选项感兴趣，而不是参数，我们将参数固定为一个必填输入。 （否则，我们会生成大量的随机文件名。）
- en: '[PRE85]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Creating Autopep8 Options
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Autopep8 选项
- en: 'Let us now use the inferred grammar for fuzzing. Again, we convert the EBNF
    grammar into a regular BNF grammar:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用推断出的语法进行模糊测试。同样，我们将 EBNF 语法转换为正则 BNF 语法：
- en: '[PRE86]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And we can use the grammar for fuzzing all options:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用语法来模糊所有选项：
- en: '[PRE87]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let us apply these options on the actual program. We need a file `foo.py` that
    will serve as input: (Note that the following commands will overwrite the file
    `foo.py`, if it already exists in the current working directory. Be aware of this,
    if you downloaded the notebooks and are working locally.)'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些选项应用到实际程序上。我们需要一个名为 `foo.py` 的文件作为输入： （注意，以下命令将覆盖当前工作目录中已存在的 `foo.py`
    文件。如果您下载了笔记本并在本地工作，请注意这一点。）
- en: '[PRE89]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We see how `autopep8` fixes the spacing:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到 `autopep8` 如何修复间距：
- en: '[PRE93]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Let us now put things together. We define a `ProgramRunner` that will run the
    `autopep8` executable with arguments coming from the mined `autopep8` grammar.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些事情组合起来。我们定义一个 `ProgramRunner`，它将使用从挖掘的 `autopep8` 语法中获得的参数来运行 `autopep8`
    可执行文件。
- en: '[PRE95]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Running `autopep8` with the mined options reveals a surprisingly high number
    of passing runs. (We see that some options depend on each other or are mutually
    exclusive, but this is handled by the program logic, not the argument parser,
    and hence out of our scope.) The `GrammarCoverageFuzzer` ensures that each option
    is tested at least once. (Digits and letters, too, by the way.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用挖掘的选项运行 `autopep8` 显示了令人惊讶的高通过率。 （我们注意到一些选项相互依赖或互斥，但这由程序逻辑处理，而不是参数解析器，因此超出了我们的范围。）`GrammarCoverageFuzzer`
    确保每个选项至少测试一次。（顺便说一句，数字和字母也是如此。）
- en: '[PRE96]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Our `foo.py` file now has been formatted in place a number of times:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `foo.py` 文件现在已经多次进行了格式化：
- en: '[PRE98]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We don''t need it anymore, so we clean up things:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要它了，所以我们需要清理一下：
- en: '[PRE100]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Classes for Fuzzing Configuration Options
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于模糊配置选项的类
- en: Let us now create reusable classes that we can use for testing arbitrary programs.
    (Okay, make that "arbitrary programs that are written in Python and use the `argparse`
    module to process command-line arguments.")
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在创建可重用的类，我们可以用于测试任意程序。（好吧，让我们说“任意用 Python 编写并使用 `argparse` 模块处理命令行参数的程序。”）
- en: The class `OptionRunner` is a subclass of `ProgramRunner` that takes care of
    automatically determining the grammar, using the same steps we used for `autopep8`,
    above.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 类 `OptionRunner` 是 `ProgramRunner` 的子类，负责自动确定语法，使用与上面 `autopep8` 相同的步骤。
- en: '[PRE102]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'First, we find the contents of the Python executable:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们找到 Python 可执行文件的内容：
- en: '[PRE104]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Next, we determine the grammar using the `OptionGrammarMiner` class:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `OptionGrammarMiner` 类确定语法：
- en: '[PRE105]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The two service methods `set_arguments()` and `set_invocation()` help us to
    change the arguments and program, respectively.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 两个服务方法 `set_arguments()` 和 `set_invocation()` 帮助我们更改参数和程序，分别。
- en: '[PRE106]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can instantiate the class on `autopep8` and immediately get the grammar:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `autopep8` 上实例化该类并立即获取语法：
- en: '[PRE107]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: An `OptionFuzzer` interacts with the given `OptionRunner` to obtain its grammar,
    which is then passed to its `GrammarCoverageFuzzer` superclass.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionFuzzer` 与给定的 `OptionRunner` 交互以获取其语法，然后将其传递给其 `GrammarCoverageFuzzer`
    超类。'
- en: '[PRE110]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: When invoking `run()`, the `OptionFuzzer` creates a new invocation (using `fuzz()`
    from its grammar) and runs the now given (or previously set) runner with the arguments
    from the grammar. Note that the runner specified in `run()` can differ from the
    one set during initialization; this allows for mining options from one program
    and applying it in another context.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `run()` 时，`OptionFuzzer` 使用其语法的 `fuzz()` 创建一个新的调用，并使用语法中的参数运行现在给定（或之前设置的）运行器。请注意，`run()`
    中指定的运行器可以与初始化期间设置的运行器不同；这允许从程序中挖掘选项并在另一个上下文中应用。
- en: '[PRE111]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Example: Autopep8'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：Autopep8
- en: 'Let us apply our newly defined classes on the `autopep8` runner:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新定义的类应用于 `autopep8` 运行器：
- en: '[PRE112]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We can now systematically test `autopep8` with these classes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以系统地使用这些类测试 `autopep8`：
- en: '[PRE115]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Example: MyPy'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：MyPy
- en: 'We can extract options for the `mypy` static type checker for Python:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以提取用于 Python 的 `mypy` 静态类型检查器的选项：
- en: '[PRE117]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Example: Notedown'
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：Notedown
- en: 'Here''s the configuration options for the `notedown` Notebook to Markdown converter:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `notedown` 笔记本到 Markdown 转换器的配置选项：
- en: '[PRE122]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Combinatorial Testing
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合测试
- en: Our `CoverageGrammarFuzzer` does a good job in covering each and every option
    at least once, which is great for systematic testing. However, as we also can
    see in our examples above, some options require each other, while others interfere
    with each other. What we should do as good testers is not only to cover every
    option individually, but also *combinations* of options.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `CoverageGrammarFuzzer` 在至少覆盖每个选项一次方面做得很好，这对于系统测试来说很棒。然而，正如我们上面的例子所看到的，一些选项需要彼此，而其他选项则相互干扰。作为优秀的测试人员，我们不仅要单独覆盖每个选项，还要覆盖选项的组合。
- en: The Python `itertools` module gives us means to create combinations from lists.
    We can, for instance, take the `notedown` options and create a list of all pairs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `itertools` 模块为我们提供了从列表中创建组合的方法。例如，我们可以获取 `notedown` 选项并创建所有对的列表。
- en: '[PRE129]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'There''s quite a number of pairs:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多对：
- en: '[PRE131]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Testing every such pair of options frequently suffices to cover all interferences
    between options. (Programs rarely have conditions involving three or more configuration
    settings.) To this end, we *change* the grammar from having a list of options
    to having a list of *option pairs*, such that covering these will automatically
    cover all pairs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 经常测试每一对这样的选项就足以覆盖所有选项之间的干扰。（程序很少涉及三个或更多配置设置的条件。）为此，我们将语法从具有选项列表更改为具有选项对列表，这样覆盖这些选项将自动覆盖所有对。
- en: We create a function `pairwise()` that takes a list of options as occurring
    in our grammar and returns a list of *pairwise options* – that is, our original
    options, but concatenated.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `pairwise()` 的函数，它接受语法中出现的选项列表，并返回一个包含成对选项的列表——也就是说，我们的原始选项，但已连接。
- en: '[PRE135]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Here''s the first 20 pairs:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是前20对：
- en: '[PRE136]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: The new grammar `pairwise_notedown_grammar` is a copy of the `notedown` grammar,
    but with the list of options replaced with the above pairwise option list.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语法`pairwise_notedown_grammar`是`notedown`语法的副本，但将选项列表替换为上述成对选项列表。
- en: '[PRE138]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Using the "pairwise" grammar to fuzz now covers one pair after another:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“成对”语法进行模糊测试现在可以一对一对地覆盖：
- en: '[PRE139]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Can we actually test all combinations of options? Not in practice, as the number
    of combinations quickly grows as the length increases. It decreases again as the
    number of options reaches the maximum (with 20 options, there is only 1 combination
    involving *all* options), but the absolute numbers are still staggering:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上能测试所有选项的组合吗？实际上不行，因为随着长度的增加，组合的数量会迅速增长。当选项数量达到最大值时（有20个选项时，只有1个涉及*所有*选项的组合），它会再次减少，但绝对数字仍然令人震惊：
- en: '[PRE142]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Formally, the number of combinations of length $k$ in a set of options of length
    $n$ is the binomial coefficient $$ {n \choose k} = \frac{n!}{k!(n - k)!} $$
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 形式上，在长度为$n$的选项集中，长度为$k$的组合数是二项式系数 $$ {n \choose k} = \frac{n!}{k!(n - k)!} $$
- en: which for $k = 2$ (all pairs) gives us
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于$k = 2$（所有配对）给出的是
- en: $$ {n \choose 2} = \frac{n!}{2(n - 2)!} = \frac{n (n - 1)}{2} $$
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: $$ {n \choose 2} = \frac{n!}{2(n - 2)!} = \frac{n (n - 1)}{2} $$
- en: For `autopep8` with its 30 options...
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有30个选项的`autopep8`...
- en: '[PRE144]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '... we thus need 870 tests to cover all pairs:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '...因此，我们需要870个测试来覆盖所有配对：'
- en: '[PRE146]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For `mypy` with its 140+ options, though, we already end up with 20,000+ tests
    to be conducted:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有140多个选项的`mypy`，我们最终需要进行20,000多个测试：
- en: '[PRE148]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Even if each pair takes a second to run, we'd still be done in three hours of
    testing, though.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 即使每一对运行需要一秒钟，我们测试完成也需要三个小时。
- en: If your program has more options that you all want to get covered in combinations,
    it is advisable that you limit the number of configurations further – for instance
    by limiting combinatorial testing to those combinations that possibly can interact
    with each other; and covering all other (presumably orthogonal) options individually.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序有更多选项，你希望它们在组合中都被覆盖，建议进一步限制配置的数量——例如，通过将组合测试限制到可能相互交互的组合；并单独覆盖所有其他（可能是正交的）选项。
- en: This mechanism of creating configurations by extending grammars can be easily
    extended to other configuration targets. One may want to explore a greater number
    of configurations, or expansions in specific contexts. The [exercises](#Exercises),
    below, have a number of options ready for you.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展语法创建配置的这种机制可以很容易地扩展到其他配置目标。可能想要探索更多的配置，或在特定上下文中的扩展。下面的[练习](#Exercises)为你准备了一些选项。
- en: Lessons Learned
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Besides regular input data, program *configurations* make an important testing
    target.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了常规输入数据外，程序*配置*也是一个重要的测试目标。
- en: For a given program using a standard library to parse command-line options and
    arguments, one can automatically extract these and convert them into a grammar.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于使用标准库解析命令行选项和参数的给定程序，可以自动提取这些并将其转换为语法。
- en: To cover not only single options, but combinations of options, one can expand
    the grammar to cover all pairs, or come up with even more ambitious targets.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要覆盖不仅单个选项，还包括选项的组合，可以扩展语法以覆盖所有配对，或者提出更加雄心勃勃的目标。
- en: Next Steps
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: 'If you liked the idea of mining a grammar from a program, do not miss:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢从程序中挖掘语法的想法，不要错过：
- en: '[how to mine grammars for input data](GrammarMiner.html)'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何从输入数据中挖掘语法](GrammarMiner.html)'
- en: 'Our next steps in the book focus on:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中的下一步将专注于：
- en: '[how to parse and recombine inputs](Parser.html)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何解析和重新组合输入](Parser.html)'
- en: '[how to assign weights and probabilities to specific productions](ProbabilisticGrammarFuzzer.html)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何为特定生成项分配权重和概率](ProbabilisticGrammarFuzzer.html)'
- en: '[how to simplify inputs that cause a failure](Reducer.html)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何简化导致失败的输入](Reducer.html)'
- en: Background
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Although configuration data is just as likely to cause failures as other input
    data, it has received relatively little attention in test generation – possibly
    because, unlike "regular" input data, configuration data is not so much under
    control of external parties, and because, again unlike regular data, there is
    little variance in configurations. Creating models for software configurations
    and using these models for testing is commonplace, as is the idea of pairwise
    testing. For an overview, see [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)];
    for a discussion and comparison of state-of-the-art techniques, see [[J. Petke
    *et al*, 2015](https://doi.org/10.1109/TSE.2015.2421279)].
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管配置数据与其他输入数据一样可能导致故障，但在测试生成中它却得到了相对较少的关注——可能是因为，与“常规”输入数据不同，配置数据并不那么受外部方的控制，而且，与常规数据不同，配置的变异性很小。为软件配置创建模型并使用这些模型进行测试是常见的，对偶测试的想法也是如此。有关概述，请参阅[[Pezzè
    等人，2008](http://ix.cs.uoregon.edu/~michal/book/)]；有关对最先进技术的讨论和比较，请参阅[[J. Petke
    等人，2015](https://doi.org/10.1109/TSE.2015.2421279)]。
- en: More specifically, [[Sutton *et al*, 2007](http://www.fuzzing.org/)] also discuss
    techniques to systematically cover command-line options. Dai et al. [[Dai *et
    al*, 2010](https://doi.org/10.4018/jsse.2010070103)] apply configuration fuzzing
    by changing variables associated with configuration files.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，[[Sutton 等人，2007](http://www.fuzzing.org/)]还讨论了系统性地覆盖命令行选项的技术。Dai等人[[Dai
    等人，2010](https://doi.org/10.4018/jsse.2010070103)]通过更改与配置文件相关的变量来应用配置模糊测试。
- en: Exercises
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: #ifdef Configuration Fuzzing'
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：#ifdef配置模糊测试
- en: In C programs, the *C preprocessor* can be used to choose which code parts should
    be compiled and which ones should not. As an example, in the C code
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在C程序中，可以使用*C预处理器*来选择哪些代码部分应该被编译，哪些不应该被编译。例如，在C代码
- en: '[PRE152]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: the compiler will compile the function `foo()` with return type`long` if the
    *preprocessor variable* `LONG_FOO` is defined, and with return type `int` if not.
    Such preprocessor variables are either set in the source files (using `#define`,
    as in `#define LONG_FOO`) or on the C compiler command line (using `-D<variable>`
    or `-D<variable>=<value>`, as in `-DLONG_FOO`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了预处理器变量`LONG_FOO`，编译器将以`long`类型编译函数`foo()`，如果没有定义，则以`int`类型编译。此类预处理器变量要么在源文件中设置（使用`#define`，如`#define
    LONG_FOO`），要么在C编译器命令行上设置（使用`-D<variable>`或`-D<variable>=<value>`，如`-DLONG_FOO`）。
- en: 'Such *conditional compilation* is used to configure C programs towards their
    environment. System-specific code can contain lots of conditional compilation.
    As an example, consider this excerpt of `xmlparse.c`, the XML parser that is part
    of the Python runtime library:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*条件编译*用于将C程序配置到其环境中。特定于系统的代码可以包含大量的条件编译。例如，考虑`xmlparse.c`的摘录，它是Python运行时库的一部分的XML解析器：
- en: '[PRE153]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: A typical configuration for the C preprocessor on the above code could be `cc
    -c -D_WIN32 -DXML_POOR_ENTROPY -DXML_UNICODE_WCHAR_T xmlparse.c`, defining the
    given preprocessor variables and selecting the appropriate code fragments.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述代码中的C预处理器的一个典型配置可能是`cc -c -D_WIN32 -DXML_POOR_ENTROPY -DXML_UNICODE_WCHAR_T
    xmlparse.c`，定义了给定的预处理器变量并选择了适当的代码片段。
- en: Since the compiler can only compile one configuration at a time (implying that
    we can also only *test* one resulting executable at a time), your task is to find
    out which of these configurations actually compile. To this end, proceed in three
    steps.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器一次只能编译一个配置（这意味着我们一次也只能测试一个生成的可执行文件），因此你的任务是找出这些配置中哪些实际上可以编译。为此，分三步进行。
- en: 'Part 1: Extract Preprocessor Variables'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1部分：提取预处理器变量
- en: Write a *function* `cpp_identifiers()` that, given a set of lines (say, from
    `open(filename).readlines()`), extracts all preprocessor variables referenced
    in `#if` or `#ifdef` preprocessor instructions. Apply `ifdef_identifiers()` on
    the sample C input above, such that
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个`cpp_identifiers()`函数，该函数给定一组行（例如，从`open(filename).readlines()`读取），提取在`#if`或`#ifdef`预处理器指令中引用的所有预处理器变量。在上述示例C输入上应用`ifdef_identifiers()`，以便
- en: '[PRE154]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: returns the set
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回集合
- en: '[PRE155]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Part 2: Derive an Option Grammar'
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2部分：推导选项语法
- en: With the help of `cpp_identifiers()`, create a grammar which has C compiler
    invocations with a list of options, where each option takes the form `-D<variable>`
    for a preprocessor variable `<variable>`. Using this grammar `cpp_grammar`, a
    fuzzer
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`cpp_identifiers()`的帮助，创建一个语法，该语法具有带有选项列表的C编译器调用，其中每个选项的形式为`-D<变量>`，用于预处理器变量`<变量>`。使用此语法`cpp_grammar`，一个模糊测试器
- en: '[PRE156]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: would create C compiler invocations such as
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建C编译器调用，例如
- en: '[PRE157]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Part 3: C Preprocessor Configuration Fuzzing'
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第3部分：C预处理器配置模糊测试
- en: Using the grammar just produced, use a `GrammarCoverageFuzzer` to
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 使用刚刚生成的语法，使用`GrammarCoverageFuzzer`进行模糊测试
- en: Test each processor variable individually
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别测试每个处理器变量
- en: Test each pair of processor variables, using `pairwise()`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pairwise()`分别测试处理器变量的每一对。
- en: What happens if you actually run the invocations?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您实际运行这些调用会发生什么？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: '[PRE158]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: '[PRE159]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'Exercise 2: .ini Configuration Fuzzing'
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：.ini配置模糊测试
- en: Besides command-line options, *configuration files* are another important source
    of configurations. In this exercise, we will consider the very simple configuration
    language provided by the Python `ConfigParser` module, which is very similar to
    what is found in Microsoft Windows *.ini* files.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 除了命令行选项之外，*配置文件*也是配置的重要来源之一。在这个练习中，我们将考虑Python `ConfigParser`模块提供的非常简单的配置语言，它与Microsoft
    Windows *.ini*文件中找到的内容非常相似。
- en: 'The following example for a `ConfigParser` input file stems right from [the
    ConfigParser documentation](https://docs.python.org/3/library/configparser.html):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`ConfigParser`输入文件的示例直接来自[ConfigParser文档](https://docs.python.org/3/library/configparser.html)：
- en: '[PRE160]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The above `ConfigParser` file can be created programmatically:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`ConfigParser`文件可以编程创建：
- en: '[PRE161]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'and be read in again:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 并再次读取：
- en: '[PRE164]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Part 1: Read Configuration'
  id: totrans-380
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第1部分：读取配置
- en: Using `configparser`, create a program reading in the above configuration file
    and accessing the individual elements.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`configparser`创建一个程序，读取上述配置文件并访问单个元素。
- en: 'Part 2: Create a Configuration Grammar'
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第2部分：创建配置语法
- en: Design a grammar that will automatically create configuration files suitable
    for your above program. Fuzz your program with it.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个语法，该语法将自动创建适合您上述程序的配置文件。用它来模糊测试您的程序。
- en: 'Part 3: Mine a Configuration Grammar'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第3部分：挖掘配置语法
- en: 'By dynamically tracking the individual accesses to configuration elements,
    you can again extract a basic grammar from the execution. To this end, create
    a subclass of `ConfigParser` with a special method `__getitem__`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 通过动态跟踪对配置元素的单独访问，您可以从执行中再次提取一个基本语法。为此，创建一个具有特殊方法`__getitem__`的`ConfigParser`子类：
- en: '[PRE166]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)进行练习并查看解决方案。'
- en: 'For a `TrackingConfigParser` object `p`, `p.__getitem__(key)` will be invoked
    whenever `p[key]` is accessed:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TrackingConfigParser`对象`p`，`p.__getitem__(key)`将在访问`p[key]`时被调用：
- en: '[PRE167]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Using `__getitem__()`, as above, implement a tracking mechanism that, while
    your program accesses the read configuration, automatically saves options accessed
    and values read. Create a prototype grammar from these values; use it for fuzzing.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__getitem__()`，如上所述，实现一个跟踪机制，在您的程序访问读取的配置时，自动保存访问的选项和读取的值。从这些值创建一个原型语法；用于模糊测试。
- en: 'At the end, don''t forget to clean up:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，别忘了清理：
- en: '[PRE169]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 3: Extracting and Fuzzing C Command-Line Options'
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 3：提取和模糊测试 C 命令行选项
- en: In C programs, the `getopt()` function are frequently used to process configuration
    options. A call
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 程序中，`getopt()` 函数经常用于处理配置选项。一个调用
- en: '[PRE171]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: indicates that the program accepts two options `-b` and `-f`, with `-f` taking
    an argument (as indicated by the following colon).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 表示程序接受两个选项 `-b` 和 `-f`，其中 `-f` 接受一个参数（如下面的冒号所示）。
- en: 'Part 1: Getopt Fuzzing'
  id: totrans-400
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：Getopt 模糊测试
- en: 'Write a framework which, for a given C program, automatically extracts the
    argument to `getopt()` and derives a fuzzing grammar for it. There are multiple
    ways to achieve this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个框架，该框架对于给定的 C 程序，可以自动提取 `getopt()` 的参数并为其推导出一个模糊测试语法。实现这一目标有多种方法：
- en: Scan the program source code for occurrences of `getopt()` and return the string
    passed. (Crude, but should frequently work.)
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序源代码中扫描 `getopt()` 的出现，并返回传递的字符串。（粗略，但应该经常有效。）
- en: Insert your own implementation of `getopt()` into the source code (effectively
    replacing `getopt()` from the runtime library), which outputs the `getopt()` argument
    and exits the program. Recompile and run.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将自己的 `getopt()` 实现插入到源代码中（实际上替换了运行时库中的 `getopt()`），该实现输出 `getopt()` 参数并退出程序。重新编译并运行。
- en: (Advanced.) As above, but instead of changing the source code, hook into the
    *dynamic linker* which at runtime links the program with the C runtime library.
    Set the library loading path (on Linux and Unix, this is the `LD_LIBRARY_PATH`
    environment variable) such that your own version of `getopt()` is linked first,
    and the regular libraries later. Executing the program (without recompiling) should
    yield the desired result.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （高级。）与上述方法相同，但不是更改源代码，而是挂钩到 *动态链接器*，该链接器在运行时将程序与 C 运行时库链接。设置库加载路径（在 Linux 和
    Unix 上，这是 `LD_LIBRARY_PATH` 环境变量），以便首先链接自己的 `getopt()` 版本，然后是常规库。执行程序（无需重新编译）应产生所需的结果。
- en: Apply this on `grep` and `ls`; report the resulting grammars and results.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用于 `grep` 和 `ls`；报告生成的语法和结果。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Part 2: Fuzzing Long Options in C'
  id: totrans-407
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：模糊测试 C 中的长选项
- en: Same as Part 1, but also hook into the GNU variant `getopt_long()`, which accepts
    "long" arguments with double dashes such as `--help`. Note that method 1, above,
    will not work here, since the "long" options are defined in a separately defined
    structure.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一部分相同，但还挂钩到 GNU 变体 `getopt_long()`，它接受带有双短横线的“长”参数，例如 `--help`。请注意，上述方法 1
    在这里将不起作用，因为“长”选项是在单独定义的结构中定义的。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 4: Expansions in Context'
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 4：上下文中的扩展
- en: 'In our above option configurations, we have multiple symbols which all expand
    to the same integer. For instance, the `--line-range` option of `autopep8` takes
    two `<line>` parameters which both expand into the same `<int>` symbol:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上述选项配置中，我们有许多符号都扩展到相同的整数。例如，`autopep8` 的 `--line-range` 选项接受两个 `<line>` 参数，这两个参数都扩展到相同的
    `<int>` 符号：
- en: '[PRE172]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Once the `GrammarCoverageFuzzer` has covered all variations of `<int>` (especially
    by covering all digits) for *one* option, though, it will no longer strive to
    achieve such coverage for the next option. Yet, it could be desirable to achieve
    such coverage for each option separately.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦 `GrammarCoverageFuzzer` 覆盖了 `<int>` 的所有变体（特别是通过覆盖所有数字）对于 *一个* 选项，它将不再努力为下一个选项实现此类覆盖。尽管如此，可能希望为每个选项单独实现此类覆盖。
- en: One way to achieve this with our existing `GrammarCoverageFuzzer` is again to
    change the grammar accordingly. The idea is to *duplicate* expansions – that is,
    to replace an expansion of a symbol $s$ with a new symbol $s'$ whose definition
    is duplicated from $s$. This way, $s'$ and $s$ are separate symbols from a coverage
    point of view and would be independently covered.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们现有的 `GrammarCoverageFuzzer` 实现这一点的另一种方法是相应地更改语法。想法是*复制*扩展——也就是说，用一个新符号 $s'$
    的定义来替换符号 $s$ 的扩展，这个定义是从 $s$ 复制的。这样，从覆盖的角度来看，$s'$ 和 $s$ 是独立的符号，并且将独立覆盖。
- en: 'As an example, consider again the above `--line-range` option. If we want our
    tests to independently cover all elements of the two `<line>` parameters, we can
    duplicate the second `<line>` expansion into a new symbol `<line''>` with subsequent
    duplicated expansions:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，再次考虑上述 `--line-range` 选项。如果我们希望我们的测试独立覆盖两个 `<line>` 参数的所有元素，我们可以将第二个 `<line>`
    扩展复制到一个新的符号 `<line'>` 中，并随后的复制扩展：
- en: '[PRE179]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Design a function `inline(grammar, symbol)` that returns a duplicate of `grammar`
    in which every occurrence of `<symbol>` and its expansions become separate copies.
    The above grammar could be a result of `inline(autopep8_runner.ebnf_grammar(),
    "<line>")`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个函数 `inline(grammar, symbol)`，它返回一个 `grammar` 的副本，其中 `<symbol>` 及其扩展的每个出现都成为单独的副本。上述语法可能是
    `inline(autopep8_runner.ebnf_grammar(), "<line>")` 的结果。
- en: When copying, expansions in the copy should also refer to symbols in the copy.
    Hence, when expanding `<int>` in
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制时，复制中的扩展也应参考复制中的符号。因此，当在
- en: '`<int> ::= <int><digit>`'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`<int> ::= <int><digit>`'
- en: make that
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: make that
- en: '[PRE180]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: (and not `<int'> ::= <int><digit'>` or `<int'> ::= <int><digit>`).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: (而不是 `<int'> ::= <int><digit'>` 或 `<int'> ::= <int><digit>`).
- en: Be sure to add precisely one new set of symbols for each occurrence in the original
    grammar, and not to expand further in the presence of recursion.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为原始语法中的每个出现精确地添加一组新符号，并且不要在递归存在的情况下进一步扩展。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    中展开 `<int>` 来进行练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:05+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/ConfigurationFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受 [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 国际许可协议](https://creativecommons.org/licenses/by-nc-sa/4.0/)
    的许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，受 [MIT 许可协议](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)
    的许可。 [最后更改：2023-11-11 18:18:05+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/ConfigurationFuzzer.ipynb)
    • [引用](#citation) • [印记](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Testing Configurations](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/ConfigurationFuzzer.html](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html).
    Retrieved 2023-11-11 18:18:05+01:00.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler:
    "[测试配置](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html)"。在 Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, 和 Christian Holler 的 "[模糊测试书籍](https://www.fuzzingbook.org/)"
    中，[https://www.fuzzingbook.org/html/ConfigurationFuzzer.html](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html)。检索日期：2023-11-11
    18:18:05+01:00。'
- en: '[PRE181]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
