- en: Testing Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/ConfigurationFuzzer.html](http://www.fuzzingbook.org/html/ConfigurationFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The behavior of a program is not only governed by its data. The *configuration*
    of a program – that is, the settings that govern the execution of a program on
    its (regular) input data, as set by options or configuration files – just as well
    influences behavior, and thus can and should be tested. In this chapter, we explore
    how to systematically *test* and *cover* software configurations. By *automatically
    inferring configuration options*, we can apply these techniques out of the box,
    with no need for writing a grammar. Finally, we show how to systematically cover
    *combinations* of configuration options, quickly detecting unwanted interferences.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should have read the [chapter on grammars](Grammars.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should have read the [chapter on grammar coverage](GrammarCoverageFuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter provides two classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OptionRunner` automatically extract command-line options from a Python program;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OptionFuzzer` uses these to automatically test a Python program with a large
    variety of options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OptionRunner` runs a program up to the point where it parses its arguments,
    and then extracts a grammar that describes its invocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The grammar can be extracted via the method `ebnf_grammar()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The grammar can be immediately used for fuzzing. A `GrammarCoverageFuzzer`
    will ensure all options are covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `OptionFuzzer` class summarizes these steps. Its constructor takes an `OptionRunner`
    to automatically extract the grammar; it does the necessary steps to extract the
    grammar and fuzz with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The final step in testing would now to invoke the program with these arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `OptionRunner` is experimental: It assumes that the Python program
    in question uses the `argparse` module; and not all `argparse` features are supported.
    Still, it does a pretty good job even on nontrivial programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The `OptionRunner` constructor accepts an additional `miner` keyword parameter,
    which takes the class of the argument grammar miner to be used. By default, this
    is `OptionGrammarMiner` – a helper class that can be used (and extended) to create
    own option grammar miners.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="586pt" height="771pt" viewBox="0.00 0.00 586.12 771.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 767)"><g
    id="node1" class="node"><title>OptionRunner</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class OptionRunner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a program while determining its option grammar"><text text-anchor="start"
    x="14" y="-168.82" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">OptionRunner</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="OptionRunner"><g id="a_node1_1"><a xlink:href="#" xlink:title="__init__(self,
    program: Union[str, List[str]], arguments: Optional[str] = None, *, log: bool
    = False, miner_class: Optional[Type[OptionGrammarMiner]] = None):'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`program` - the (Python) program to be executed'
  prefs: []
  type: TYPE_NORMAL
- en: '`arguments` - an (optional) string with arguments for `program`'
  prefs: []
  type: TYPE_NORMAL
- en: '`log` - if True, enable logging in miner'
  prefs: []
  type: TYPE_NORMAL
- en: '`miner_class` - the `OptionGrammarMiner` class to be used'
  prefs: []
  type: TYPE_NORMAL
- en: '(default: `OptionGrammarMiner`)"><text text-anchor="start" x="9.5" y="-146.62"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">__init__()</text></a></g> <g id="a_node1_2"><a
    xlink:href="#" xlink:title="ebnf_grammar(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return extracted grammar in EBNF form"><text text-anchor="start" x="9.5" y="-133.88"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">ebnf_grammar()</text></a></g> <g id="a_node1_3"><a xlink:href="#"
    xlink:title="grammar(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return extracted grammar in BNF form"><text text-anchor="start" x="9.5" y="-121.12"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">grammar()</text></a></g> <g id="a_node1_4"><a xlink:href="#"
    xlink:title="executable(self)"><text text-anchor="start" x="9.5" y="-107.38" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">executable()</text></a></g>
    <g id="a_node1_5"><a xlink:href="#" xlink:title="find_contents(self)"><text text-anchor="start"
    x="9.5" y="-94.62" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">find_contents()</text></a></g> <g id="a_node1_6"><a
    xlink:href="#" xlink:title="find_grammar(self)"><text text-anchor="start" x="9.5"
    y="-81.88" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">find_grammar()</text></a></g> <g id="a_node1_7"><a xlink:href="#"
    xlink:title="invoker(self)"><text text-anchor="start" x="9.5" y="-69.12" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">invoker()</text></a></g>
    <g id="a_node1_8"><a xlink:href="#" xlink:title="set_arguments(self, args)"><text
    text-anchor="start" x="9.5" y="-56.38" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">set_arguments()</text></a></g>
    <g id="a_node1_9"><a xlink:href="#" xlink:title="set_invocation(self, program)"><text
    text-anchor="start" x="9.5" y="-43.62" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">set_invocation()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>ProgramRunner</title> <g id="a_node2"><a xlink:href="Fuzzer.html"
    xlink:title="class ProgramRunner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Test a program with inputs."><text text-anchor="start" x="8" y="-288.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProgramRunner</text>
    <g id="a_node2_10"><a xlink:href="#" xlink:title="ProgramRunner"><g id="a_node2_11"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self, program: Union[str, List[str]])
    -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize.
  prefs: []
  type: TYPE_NORMAL
- en: '`program` is a program spec as passed to `subprocess.run()`"><text text-anchor="start"
    x="27.5" y="-266.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>OptionRunner->ProgramRunner</title></g> <g id="node3"
    class="node"><title>Runner</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Runner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for testing inputs."><text text-anchor="start" x="34.62" y="-431.2"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">Runner</text> <g id="a_node3_12"><a xlink:href="#" xlink:title="Runner"><g
    id="a_node3_13"><a xlink:href="Fuzzer.html" xlink:title="FAIL = ''FAIL''"><text
    text-anchor="start" x="27.5" y="-408" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">FAIL</text></a></g> <g id="a_node3_14"><a
    xlink:href="Fuzzer.html" xlink:title="PASS = ''PASS''"><text text-anchor="start"
    x="27.5" y="-395.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">PASS</text></a></g> <g id="a_node3_15"><a xlink:href="Fuzzer.html"
    xlink:title="UNRESOLVED = ''UNRESOLVED''"><text text-anchor="start" x="27.5" y="-382.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">UNRESOLVED</text></a></g></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="Runner"><g id="a_node3_17"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize"><text text-anchor="start" x="27.5" y="-362.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_18"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, inp: str) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the runner with the given input"><text text-anchor="start" x="27.5" y="-350"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="edge2" class="edge"><title>ProgramRunner->Runner</title></g> <g id="node4"
    class="node"><title>OptionFuzzer</title> <g id="a_node4"><a xlink:href="#" xlink:title="class
    OptionFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fuzz a (Python) program using its arguments"><text text-anchor="start" x="179.25"
    y="-124.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">OptionFuzzer</text> <g id="a_node4_19"><a xlink:href="#" xlink:title="OptionFuzzer"><g
    id="a_node4_20"><a xlink:href="#" xlink:title="__init__(self, runner: OptionRunner,
    *args, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor. `runner` is an OptionRunner."><text text-anchor="start" x="190.5"
    y="-102" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node4_21"><a xlink:href="#" xlink:title="run(self, runner=None, inp=''''):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="190.5" y="-89.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g></a></g></a></g></g>
    <g id="node5" class="node"><title>GrammarCoverageFuzzer</title> <g id="a_node5"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class GrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce from grammars, aiming for coverage of all expansions."><text text-anchor="start"
    x="141.75" y="-278.07" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text></a></g></g> <g id="edge3"
    class="edge"><title>OptionFuzzer->GrammarCoverageFuzzer</title></g> <g id="node6"
    class="node"><title>SimpleGrammarCoverageFuzzer</title> <g id="a_node6"><a xlink:href="GrammarCoverageFuzzer.html"
    xlink:title="class SimpleGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When choosing expansions, prefer expansions not covered."><text text-anchor="start"
    x="121.12" y="-391.32" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text></a></g></g>
    <g id="edge4" class="edge"><title>GrammarCoverageFuzzer->SimpleGrammarCoverageFuzzer</title></g>
    <g id="node7" class="node"><title>TrackingGrammarCoverageFuzzer</title> <g id="a_node7"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="class TrackingGrammarCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Track grammar coverage during production"><text text-anchor="start" x="114.38"
    y="-514.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text> <g id="a_node7_22"><a
    xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer"><g id="a_node7_23"><a
    xlink:href="GrammarCoverageFuzzer.html" xlink:title="__init__(self, *args, **kwargs)
    -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="190.5" y="-492.75" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g></a></g></a></g></g>
    <g id="edge5" class="edge"><title>SimpleGrammarCoverageFuzzer->TrackingGrammarCoverageFuzzer</title></g>
    <g id="node8" class="node"><title>GrammarFuzzer</title> <g id="a_node8"><a xlink:href="GrammarFuzzer.html"
    xlink:title="class GrammarFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce strings from grammars efficiently, using derivation trees."><text text-anchor="start"
    x="170.62" y="-624.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">GrammarFuzzer</text> <g id="a_node8_24"><a xlink:href="#"
    xlink:title="GrammarFuzzer"><g id="a_node8_25"><a xlink:href="GrammarFuzzer.html"
    xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol:
    str = ''<start>'', min_nonterminals: int = 0, max_nonterminals: int = 10, disp:
    bool = False, log: Union[bool, int] = False) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Produce strings from `grammar`, starting with `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: If `min_nonterminals` or `max_nonterminals` is given, use them as limits
  prefs: []
  type: TYPE_NORMAL
- en: for the number of nonterminals produced.
  prefs: []
  type: TYPE_NORMAL
- en: If `disp` is set, display the intermediate derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `log` is set, show intermediate steps as text on standard output."><text
    text-anchor="start" x="187.5" y="-602" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node8_26"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self)
    -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a string from the grammar."><text text-anchor="start" x="187.5" y="-589.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">fuzz()</text></a></g> <g id="a_node8_27"><a
    xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -> DerivationTree:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Produce a derivation tree from the grammar."><text text-anchor="start" x="187.5"
    y="-576.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">fuzz_tree()</text></a></g></a></g></a></g></g>
    <g id="edge6" class="edge"><title>TrackingGrammarCoverageFuzzer->GrammarFuzzer</title></g>
    <g id="node9" class="node"><title>Fuzzer</title> <g id="a_node9"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="199.88" y="-746.2" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node9_28"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node9_29"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="190.5" y="-724" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node9_30"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="190.5" y="-711.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node9_31"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="190.5" y="-698.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g> <g id="a_node9_32"><a
    xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="190.5"
    y="-685.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-weight="bold" font-size="10.00">runs()</text></a></g></a></g></a></g></g>
    <g id="edge7" class="edge"><title>GrammarFuzzer->Fuzzer</title></g> <g id="node10"
    class="node"><title>OptionGrammarMiner</title> <g id="a_node10"><a xlink:href="#"
    xlink:title="class OptionGrammarMiner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Helper class for extracting option grammars"><text text-anchor="start" x="296.25"
    y="-204.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">OptionGrammarMiner</text> <g id="a_node10_33"><a xlink:href="#"
    xlink:title="OptionGrammarMiner"><g id="a_node10_34"><a xlink:href="#" xlink:title="ARGUMENTS_SYMBOL
    = ''<arguments>''"><text text-anchor="start" x="316.5" y="-181.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">ARGUMENTS_SYMBOL</text></a></g>
    <g id="a_node10_35"><a xlink:href="#" xlink:title="OPTION_SYMBOL = ''<option>''"><text
    text-anchor="start" x="316.5" y="-168.75" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">OPTION_SYMBOL</text></a></g></a></g>
    <g id="a_node10_36"><a xlink:href="#" xlink:title="OptionGrammarMiner"><g id="a_node10_37"><a
    xlink:href="#" xlink:title="__init__(self, function: Callable, log: bool = False):'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`function` - a function processing arguments using argparse()'
  prefs: []
  type: TYPE_NORMAL
- en: '`log` - output diagnostics if True"><text text-anchor="start" x="307.5" y="-149"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">__init__()</text></a></g> <g id="a_node10_38"><a xlink:href="#"
    xlink:title="mine_ebnf_grammar(self):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract EBNF option grammar"><text text-anchor="start" x="307.5" y="-136.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">mine_ebnf_grammar()</text></a></g> <g id="a_node10_39"><a xlink:href="#"
    xlink:title="mine_grammar(self):'
  prefs: []
  type: TYPE_NORMAL
- en: Extract BNF option grammar"><text text-anchor="start" x="307.5" y="-123.5" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">mine_grammar()</text></a></g>
    <g id="a_node10_40"><a xlink:href="#" xlink:title="add_group(self, locals, exclusive)"><text
    text-anchor="start" x="307.5" y="-109.75" font-family="'Fira Mono', 'Source Code
    Pro', 'Courier', monospace" font-size="10.00">add_group()</text></a></g> <g id="a_node10_41"><a
    xlink:href="#" xlink:title="add_int_rule(self)"><text text-anchor="start" x="307.5"
    y="-97" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_int_rule()</text></a></g>
    <g id="a_node10_42"><a xlink:href="#" xlink:title="add_metavar_rule(self, metavar,
    type_)"><text text-anchor="start" x="307.5" y="-84.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_metavar_rule()</text></a></g>
    <g id="a_node10_43"><a xlink:href="#" xlink:title="add_parameter(self, kwargs,
    metavar)"><text text-anchor="start" x="307.5" y="-71.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">add_parameter()</text></a></g>
    <g id="a_node10_44"><a xlink:href="#" xlink:title="add_str_rule(self)"><text text-anchor="start"
    x="307.5" y="-58.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">add_str_rule()</text></a></g> <g id="a_node10_45"><a xlink:href="#"
    xlink:title="add_type_rule(self, type_)"><text text-anchor="start" x="307.5" y="-46"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_type_rule()</text></a></g>
    <g id="a_node10_46"><a xlink:href="#" xlink:title="process_arg(self, arg, in_group,
    kwargs)"><text text-anchor="start" x="307.5" y="-33.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_arg()</text></a></g>
    <g id="a_node10_47"><a xlink:href="#" xlink:title="process_argument(self, locals,
    in_group)"><text text-anchor="start" x="307.5" y="-20.5" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">process_argument()</text></a></g>
    <g id="a_node10_48"><a xlink:href="#" xlink:title="traceit(self, frame, event,
    arg)"><text text-anchor="start" x="307.5" y="-7.75" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-size="10.00">traceit()</text></a></g></a></g></a></g></g>
    <g id="node11" class="node"><title>Legend</title> <text text-anchor="start" x="458.88"
    y="-126.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="458.88"
    y="-116.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="464.88" y="-116.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="458.88" y="-106.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-106.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="458.88" y="-96.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="464.88" y="-96.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="458.88"
    y="-87.7" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about the input to a program, we usually think of the *data* it
    processes. This is also what we have been fuzzing in the past chapters – be it
    with [random input](Fuzzer.html), [mutation-based fuzzing](MutationFuzzer.html),
    or [grammar-based fuzzing](GrammarFuzzer.html). However, programs typically have
    several input sources, all of which can and should be tested – and included in
    test generation.
  prefs: []
  type: TYPE_NORMAL
- en: One important source of input is the program's *configuration* – that is, a
    set of inputs that typically is set once when beginning to process data and then
    stays constant while processing data, while the program is running, or even while
    the program is deployed. Such a configuration is frequently set in *configuration
    files* (for instance, as key/value pairs); the most ubiquitous method for command-line
    tools, though, are *configuration options* on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the `grep` utility to find textual patterns in files.
    The exact mode by which `grep` works is governed by a multitude of options, which
    can be listed by providing a `--help` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All these options need to be tested for whether they operate correctly. In security
    testing, any such option may also trigger a yet unknown vulnerability. Hence,
    such options can become *fuzz targets* on their own. In this chapter, we analyze
    how to systematically test such options – and better yet, how to extract possible
    configurations right out of given program files, such that we do not have to specify
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Options in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us stick to our common programming language here and examine how options
    are processed in Python. The `argparse` module provides a parser for command-line
    arguments (and options) with great functionality – and great complexity. You start
    by defining a parser (`argparse.ArgumentParser()`) to which individual arguments
    with various features are added, one after another. Additional parameters for
    each argument can specify the type (`type`) of the argument (say, integers or
    strings), or the number of arguments (`nargs`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, arguments are stored under their name in the `args` object coming
    from `parse_args()` – thus, `args.integers` holds the `integer` arguments added
    earlier. Special actions (`actions`) allow storing specific values in given variables;
    the `store_const` action stores the given `const` in the attribute named by `dest`.
    The following example takes a number of integer arguments (`integers`) as well
    as an operator (`--sum`, `--min`, or `--max`) to be applied on these integers.
    The operators all store a function reference in the `accumulate` attribute, which
    is finally invoked on the integers parsed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how `process_numbers()` works. We can, for instance, invoke the `--min`
    option on the given arguments to compute the minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or compute the sum of three numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When defined via `add_mutually_exclusive_group()` (as above), options are mutually
    exclusive. Consequently, we can have only one operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A Grammar for Configurations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How can we test a system with several options? The easiest answer is to write
    a grammar for it. The grammar `PROCESS_NUMBERS_EBNF_GRAMMAR` reflects the possible
    combinations of options and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can feed this grammar into our [grammar coverage fuzzer](GrammarCoverageFuzzer.html)
    and have it cover one option after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also invoke `process_numbers()` with these very arguments.
    To this end, we need to convert the string produced by the grammar back into a
    list of individual arguments, using `split()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can define grammars for any program to be tested; as well as
    define grammars for, say, configuration files. Yet, the grammar has to be updated
    with every change to the program, which creates a maintenance burden. Given that
    the information required for the grammar is already all encoded in the program,
    the question arises: *Can''t we go and extract configuration options right out
    of the program in the first place?*'
  prefs: []
  type: TYPE_NORMAL
- en: Mining Configuration Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we try to extract option and argument information right out
    of a program, such that we do not have to specify a configuration grammar. The
    aim is to have a configuration fuzzer that works on the options and arguments
    of an arbitrary program, as long as it follows specific conventions for processing
    its arguments. In the case of Python programs, this means using the `argparse`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our idea is as follows: We execute the given program up to the point where
    the arguments are actually parsed – that is, `argparse.parse_args()` is invoked.
    Up to this point, we track all calls into the argument parser, notably those calls
    that define arguments and options (`add_argument()`). From these, we construct
    the grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us illustrate this approach with a simple experiment: We define a trace
    function (see [our chapter on coverage](Coverage.html) for details) that is active
    while `process_numbers` is invoked. If we have a call to a method `add_argument`,
    we access and print out the local variables (which at this point are the arguments
    to the method).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'What we get is a list of all calls to `add_argument()`, together with the method
    arguments passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `args` argument, we can access the individual options and arguments
    to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We see that each argument comes as a tuple with one (say, `integers` or `--sum`)
    or two members (`-h` and `--help`), which denote alternate forms for the same
    option. Our job will be to go through the arguments of `add_arguments()` and detect
    not only the names of options and arguments, but also whether they accept additional
    parameters, as well as the type of the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: A Grammar Miner for Options and Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let us now build a class that gathers all this information to create a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `ParseInterrupt` exception to interrupt program execution after
    gathering all arguments and options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The class `OptionGrammarMiner` takes an executable function for which the grammar
    of options and arguments is to be mined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The method `mine_ebnf_grammar()` is where everything happens. It creates a grammar
    of the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: in which the options and arguments will be collected. It then sets a trace function
    (see [our chapter on coverage](Coverage.html) for details) that is active while
    the previously defined `function` is invoked. Raising `ParseInterrupt` (when `parse_args()`
    is invoked) ends execution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The trace function checks for four methods: `add_argument()` is the most important
    function, resulting in processing arguments; `frame.f_locals` again is the set
    of local variables, which at this point is mostly the arguments to `add_argument()`.
    Since mutually exclusive groups also have a method `add_argument()`, we set the
    flag `in_group` to differentiate.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that we make no specific efforts to differentiate between multiple parsers
    or groups; we simply assume that there is one parser, and at any point at most
    one mutually exclusive group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process_arguments()` now analyzes the arguments passed and adds them to
    the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: If the argument starts with `-`, it gets added as an optional element to the
    `<option>` list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it gets added to the `<argument>` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional `nargs` argument specifies how many arguments can follow. If it
    is a number, we add the appropriate number of elements to the grammar; if it is
    an abstract specifier (say, `+` or `*`), we use it directly as EBNF operator.
  prefs: []
  type: TYPE_NORMAL
- en: Given the large number of parameters and optional behavior, this is a somewhat
    messy function, but it does the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The method `add_parameter()` handles possible parameters of options. If the
    argument has an `action` defined, it takes no parameter. Otherwise, we identify
    the type of the parameter (as `int` or `str`) and augment the grammar with an
    appropriate rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The method `add_type_rule()` adds a rule for parameter types to the grammar.
    If the parameter is identified by a meta-variable (say, `N`), we add a rule for
    this as well to improve legibility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The method `add_group()` adds a new mutually exclusive group to the grammar.
    We define a new symbol (say, `<group>`) for the options added to the group, and
    use the `required` and `exclusive` flags to define an appropriate expansion operator.
    The group is then prefixed to the grammar, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: and filled with the next calls to `add_argument()` within the group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That's it! With this, we can now extract the grammar from our `process_numbers()`
    program. Turning on logging again reveals the variables we draw upon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the extracted grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The grammar properly identifies the group found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It also identifies a `--help` option provided not by us, but by the `argparse`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The grammar also correctly identifies the types of the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The rules for `int` are set as defined by `add_int_rule()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take this grammar and convert it to BNF, such that we can fuzz with
    it right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Each and every invocation adheres to the rules as set forth in the `argparse`
    calls. By mining options and arguments from existing programs, we can now fuzz
    these options out of the box – without having to specify a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Autopep8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us try out the option grammar miner on real-world Python programs. `autopep8`
    is a tool that automatically converts Python code to the [PEP 8 Style Guide for
    Python Code](https://www.python.org/dev/peps/pep-0008/). (Actually, all Python
    code in this book runs through `autopep8` during production.) `autopep8` offers
    a wide range of options, as can be seen by invoking it with `--help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Autopep8 Setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We want to systematically test these options. In order to deploy our configuration
    grammar miner, we need to find the source code of the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Next, we build a function that reads the contents of the file and executes it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Mining an Autopep8 Grammar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the `autopep8()` function in our grammar miner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'and extract a grammar for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This works because here, `autopep8` is not a separate process (and a separate
    Python interpreter), but we run the `autopep8()` function (and the `autopep8`
    code) in our current Python interpreter – up to the call to `parse_args()`, where
    we interrupt execution again. At this point, the `autopep8` code has done nothing
    but setting up the argument parser – which is what we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The grammar options mined reflect precisely the options seen when providing
    `--help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Metavariables like `<n>` or `<line>` are placeholders for integers. We assume
    all metavariables of the same name have the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The grammar miner has inferred that the argument to `autopep8` is a list of
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'which in turn all are strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As we are only interested in testing options, not arguments, we fix the arguments
    to a single mandatory input. (Otherwise, we'd have plenty of random file names
    generated.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Creating Autopep8 Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us now use the inferred grammar for fuzzing. Again, we convert the EBNF
    grammar into a regular BNF grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use the grammar for fuzzing all options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us apply these options on the actual program. We need a file `foo.py` that
    will serve as input: (Note that the following commands will overwrite the file
    `foo.py`, if it already exists in the current working directory. Be aware of this,
    if you downloaded the notebooks and are working locally.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We see how `autopep8` fixes the spacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Let us now put things together. We define a `ProgramRunner` that will run the
    `autopep8` executable with arguments coming from the mined `autopep8` grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Running `autopep8` with the mined options reveals a surprisingly high number
    of passing runs. (We see that some options depend on each other or are mutually
    exclusive, but this is handled by the program logic, not the argument parser,
    and hence out of our scope.) The `GrammarCoverageFuzzer` ensures that each option
    is tested at least once. (Digits and letters, too, by the way.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `foo.py` file now has been formatted in place a number of times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t need it anymore, so we clean up things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Classes for Fuzzing Configuration Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now create reusable classes that we can use for testing arbitrary programs.
    (Okay, make that "arbitrary programs that are written in Python and use the `argparse`
    module to process command-line arguments.")
  prefs: []
  type: TYPE_NORMAL
- en: The class `OptionRunner` is a subclass of `ProgramRunner` that takes care of
    automatically determining the grammar, using the same steps we used for `autopep8`,
    above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we find the contents of the Python executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we determine the grammar using the `OptionGrammarMiner` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The two service methods `set_arguments()` and `set_invocation()` help us to
    change the arguments and program, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the class on `autopep8` and immediately get the grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: An `OptionFuzzer` interacts with the given `OptionRunner` to obtain its grammar,
    which is then passed to its `GrammarCoverageFuzzer` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: When invoking `run()`, the `OptionFuzzer` creates a new invocation (using `fuzz()`
    from its grammar) and runs the now given (or previously set) runner with the arguments
    from the grammar. Note that the runner specified in `run()` can differ from the
    one set during initialization; this allows for mining options from one program
    and applying it in another context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Autopep8'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us apply our newly defined classes on the `autopep8` runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now systematically test `autopep8` with these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: MyPy'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can extract options for the `mypy` static type checker for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Example: Notedown'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s the configuration options for the `notedown` Notebook to Markdown converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Combinatorial Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `CoverageGrammarFuzzer` does a good job in covering each and every option
    at least once, which is great for systematic testing. However, as we also can
    see in our examples above, some options require each other, while others interfere
    with each other. What we should do as good testers is not only to cover every
    option individually, but also *combinations* of options.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `itertools` module gives us means to create combinations from lists.
    We can, for instance, take the `notedown` options and create a list of all pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s quite a number of pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Testing every such pair of options frequently suffices to cover all interferences
    between options. (Programs rarely have conditions involving three or more configuration
    settings.) To this end, we *change* the grammar from having a list of options
    to having a list of *option pairs*, such that covering these will automatically
    cover all pairs.
  prefs: []
  type: TYPE_NORMAL
- en: We create a function `pairwise()` that takes a list of options as occurring
    in our grammar and returns a list of *pairwise options* – that is, our original
    options, but concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the first 20 pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The new grammar `pairwise_notedown_grammar` is a copy of the `notedown` grammar,
    but with the list of options replaced with the above pairwise option list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the "pairwise" grammar to fuzz now covers one pair after another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we actually test all combinations of options? Not in practice, as the number
    of combinations quickly grows as the length increases. It decreases again as the
    number of options reaches the maximum (with 20 options, there is only 1 combination
    involving *all* options), but the absolute numbers are still staggering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Formally, the number of combinations of length $k$ in a set of options of length
    $n$ is the binomial coefficient $$ {n \choose k} = \frac{n!}{k!(n - k)!} $$
  prefs: []
  type: TYPE_NORMAL
- en: which for $k = 2$ (all pairs) gives us
  prefs: []
  type: TYPE_NORMAL
- en: $$ {n \choose 2} = \frac{n!}{2(n - 2)!} = \frac{n (n - 1)}{2} $$
  prefs: []
  type: TYPE_NORMAL
- en: For `autopep8` with its 30 options...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '... we thus need 870 tests to cover all pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'For `mypy` with its 140+ options, though, we already end up with 20,000+ tests
    to be conducted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Even if each pair takes a second to run, we'd still be done in three hours of
    testing, though.
  prefs: []
  type: TYPE_NORMAL
- en: If your program has more options that you all want to get covered in combinations,
    it is advisable that you limit the number of configurations further – for instance
    by limiting combinatorial testing to those combinations that possibly can interact
    with each other; and covering all other (presumably orthogonal) options individually.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism of creating configurations by extending grammars can be easily
    extended to other configuration targets. One may want to explore a greater number
    of configurations, or expansions in specific contexts. The [exercises](#Exercises),
    below, have a number of options ready for you.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides regular input data, program *configurations* make an important testing
    target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a given program using a standard library to parse command-line options and
    arguments, one can automatically extract these and convert them into a grammar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To cover not only single options, but combinations of options, one can expand
    the grammar to cover all pairs, or come up with even more ambitious targets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you liked the idea of mining a grammar from a program, do not miss:'
  prefs: []
  type: TYPE_NORMAL
- en: '[how to mine grammars for input data](GrammarMiner.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our next steps in the book focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[how to parse and recombine inputs](Parser.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[how to assign weights and probabilities to specific productions](ProbabilisticGrammarFuzzer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[how to simplify inputs that cause a failure](Reducer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although configuration data is just as likely to cause failures as other input
    data, it has received relatively little attention in test generation – possibly
    because, unlike "regular" input data, configuration data is not so much under
    control of external parties, and because, again unlike regular data, there is
    little variance in configurations. Creating models for software configurations
    and using these models for testing is commonplace, as is the idea of pairwise
    testing. For an overview, see [[Pezzè *et al*, 2008](http://ix.cs.uoregon.edu/~michal/book/)];
    for a discussion and comparison of state-of-the-art techniques, see [[J. Petke
    *et al*, 2015](https://doi.org/10.1109/TSE.2015.2421279)].
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, [[Sutton *et al*, 2007](http://www.fuzzing.org/)] also discuss
    techniques to systematically cover command-line options. Dai et al. [[Dai *et
    al*, 2010](https://doi.org/10.4018/jsse.2010070103)] apply configuration fuzzing
    by changing variables associated with configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: #ifdef Configuration Fuzzing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C programs, the *C preprocessor* can be used to choose which code parts should
    be compiled and which ones should not. As an example, in the C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: the compiler will compile the function `foo()` with return type`long` if the
    *preprocessor variable* `LONG_FOO` is defined, and with return type `int` if not.
    Such preprocessor variables are either set in the source files (using `#define`,
    as in `#define LONG_FOO`) or on the C compiler command line (using `-D<variable>`
    or `-D<variable>=<value>`, as in `-DLONG_FOO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such *conditional compilation* is used to configure C programs towards their
    environment. System-specific code can contain lots of conditional compilation.
    As an example, consider this excerpt of `xmlparse.c`, the XML parser that is part
    of the Python runtime library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: A typical configuration for the C preprocessor on the above code could be `cc
    -c -D_WIN32 -DXML_POOR_ENTROPY -DXML_UNICODE_WCHAR_T xmlparse.c`, defining the
    given preprocessor variables and selecting the appropriate code fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler can only compile one configuration at a time (implying that
    we can also only *test* one resulting executable at a time), your task is to find
    out which of these configurations actually compile. To this end, proceed in three
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: Extract Preprocessor Variables'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Write a *function* `cpp_identifiers()` that, given a set of lines (say, from
    `open(filename).readlines()`), extracts all preprocessor variables referenced
    in `#if` or `#ifdef` preprocessor instructions. Apply `ifdef_identifiers()` on
    the sample C input above, such that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: returns the set
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Derive an Option Grammar'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the help of `cpp_identifiers()`, create a grammar which has C compiler
    invocations with a list of options, where each option takes the form `-D<variable>`
    for a preprocessor variable `<variable>`. Using this grammar `cpp_grammar`, a
    fuzzer
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: would create C compiler invocations such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: C Preprocessor Configuration Fuzzing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using the grammar just produced, use a `GrammarCoverageFuzzer` to
  prefs: []
  type: TYPE_NORMAL
- en: Test each processor variable individually
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test each pair of processor variables, using `pairwise()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you actually run the invocations?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: .ini Configuration Fuzzing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides command-line options, *configuration files* are another important source
    of configurations. In this exercise, we will consider the very simple configuration
    language provided by the Python `ConfigParser` module, which is very similar to
    what is found in Microsoft Windows *.ini* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example for a `ConfigParser` input file stems right from [the
    ConfigParser documentation](https://docs.python.org/3/library/configparser.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `ConfigParser` file can be created programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'and be read in again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Part 1: Read Configuration'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using `configparser`, create a program reading in the above configuration file
    and accessing the individual elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Create a Configuration Grammar'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Design a grammar that will automatically create configuration files suitable
    for your above program. Fuzz your program with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Mine a Configuration Grammar'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By dynamically tracking the individual accesses to configuration elements,
    you can again extract a basic grammar from the execution. To this end, create
    a subclass of `ConfigParser` with a special method `__getitem__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `TrackingConfigParser` object `p`, `p.__getitem__(key)` will be invoked
    whenever `p[key]` is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Using `__getitem__()`, as above, implement a tracking mechanism that, while
    your program accesses the read configuration, automatically saves options accessed
    and values read. Create a prototype grammar from these values; use it for fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, don''t forget to clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Extracting and Fuzzing C Command-Line Options'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C programs, the `getopt()` function are frequently used to process configuration
    options. A call
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: indicates that the program accepts two options `-b` and `-f`, with `-f` taking
    an argument (as indicated by the following colon).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: Getopt Fuzzing'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Write a framework which, for a given C program, automatically extracts the
    argument to `getopt()` and derives a fuzzing grammar for it. There are multiple
    ways to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Scan the program source code for occurrences of `getopt()` and return the string
    passed. (Crude, but should frequently work.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert your own implementation of `getopt()` into the source code (effectively
    replacing `getopt()` from the runtime library), which outputs the `getopt()` argument
    and exits the program. Recompile and run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Advanced.) As above, but instead of changing the source code, hook into the
    *dynamic linker* which at runtime links the program with the C runtime library.
    Set the library loading path (on Linux and Unix, this is the `LD_LIBRARY_PATH`
    environment variable) such that your own version of `getopt()` is linked first,
    and the regular libraries later. Executing the program (without recompiling) should
    yield the desired result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply this on `grep` and `ls`; report the resulting grammars and results.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Fuzzing Long Options in C'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Same as Part 1, but also hook into the GNU variant `getopt_long()`, which accepts
    "long" arguments with double dashes such as `--help`. Note that method 1, above,
    will not work here, since the "long" options are defined in a separately defined
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Expansions in Context'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our above option configurations, we have multiple symbols which all expand
    to the same integer. For instance, the `--line-range` option of `autopep8` takes
    two `<line>` parameters which both expand into the same `<int>` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Once the `GrammarCoverageFuzzer` has covered all variations of `<int>` (especially
    by covering all digits) for *one* option, though, it will no longer strive to
    achieve such coverage for the next option. Yet, it could be desirable to achieve
    such coverage for each option separately.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this with our existing `GrammarCoverageFuzzer` is again to
    change the grammar accordingly. The idea is to *duplicate* expansions – that is,
    to replace an expansion of a symbol $s$ with a new symbol $s'$ whose definition
    is duplicated from $s$. This way, $s'$ and $s$ are separate symbols from a coverage
    point of view and would be independently covered.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider again the above `--line-range` option. If we want our
    tests to independently cover all elements of the two `<line>` parameters, we can
    duplicate the second `<line>` expansion into a new symbol `<line''>` with subsequent
    duplicated expansions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Design a function `inline(grammar, symbol)` that returns a duplicate of `grammar`
    in which every occurrence of `<symbol>` and its expansions become separate copies.
    The above grammar could be a result of `inline(autopep8_runner.ebnf_grammar(),
    "<line>")`.
  prefs: []
  type: TYPE_NORMAL
- en: When copying, expansions in the copy should also refer to symbols in the copy.
    Hence, when expanding `<int>` in
  prefs: []
  type: TYPE_NORMAL
- en: '`<int> ::= <int><digit>`'
  prefs: []
  type: TYPE_NORMAL
- en: make that
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: (and not `<int'> ::= <int><digit'>` or `<int'> ::= <int><digit>`).
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to add precisely one new set of symbols for each occurrence in the original
    grammar, and not to expand further in the presence of recursion.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/ConfigurationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:05+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/ConfigurationFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Testing Configurations](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/ConfigurationFuzzer.html](https://www.fuzzingbook.org/html/ConfigurationFuzzer.html).
    Retrieved 2023-11-11 18:18:05+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
