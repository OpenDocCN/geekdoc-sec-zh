- en: Mutation-Based Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/MutationFuzzer.html](http://www.fuzzingbook.org/html/MutationFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Most [randomly generated inputs](Fuzzer.html) are syntactically *invalid* and
    thus are quickly rejected by the processing program. To exercise functionality
    beyond input processing, we must increase chances to obtain valid inputs. One
    such way is so-called *mutational fuzzing* – that is, introducing small changes
    to existing inputs that may still keep the input valid, yet exercise new behavior.
    We show how to create such mutations, and how to guide them towards yet uncovered
    code, applying central concepts from the popular AFL fuzzer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should know how basic fuzzing works; for instance, from the ["Fuzzing"](Fuzzer.html)
    chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should understand the basics of [obtaining coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces a `MutationFuzzer` class that takes a list of *seed
    inputs* which are then mutated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `MutationCoverageFuzzer` maintains a *population* of inputs, which are then
    evolved in order to maximize coverage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<svg width="318pt" height="325pt" viewBox="0.00 0.00 318.38 325.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 321.25)"><g
    id="node1" class="node"><title>MutationCoverageFuzzer</title> <g id="a_node1"><a
    xlink:href="#" xlink:title="class MutationCoverageFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fuzz with mutated inputs based on coverage"><text text-anchor="start" x="8"
    y="-43.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">MutationCoverageFuzzer</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="MutationCoverageFuzzer"><g id="a_node1_1"><a xlink:href="#" xlink:title="run(self,
    runner: FunctionCoverageRunner) -> Any:'
  prefs: []
  type: TYPE_NORMAL
- en: Run function(inp) while tracking coverage.
  prefs: []
  type: TYPE_NORMAL
- en: If we reach new coverage,
  prefs: []
  type: TYPE_NORMAL
- en: 'add inp to population and its coverage to population_coverage"><text text-anchor="start"
    x="65.75" y="-21.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">run()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="reset(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Set population to initial seed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be overloaded in subclasses."><text text-anchor="start" x="65.75" y="-8.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">reset()</text></a></g></a></g></a></g></g> <g id="node2" class="node"><title>MutationFuzzer</title>
    <g id="a_node2"><a xlink:href="#" xlink:title="class MutationFuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for mutational fuzzing"><text text-anchor="start" x="36.88" y="-178.45"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">MutationFuzzer</text> <g id="a_node2_3"><a xlink:href="#" xlink:title="MutationFuzzer"><g
    id="a_node2_4"><a xlink:href="#" xlink:title="__init__(self, seed: List[str],
    min_mutations: int = 2, max_mutations: int = 10) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`seed` - a list of (input) strings to mutate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`min_mutations` - the minimum number of mutations to apply.'
  prefs: []
  type: TYPE_NORMAL
- en: '`max_mutations` - the maximum number of mutations to apply."><text text-anchor="start"
    x="32.75" y="-156.25" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text></a></g>
    <g id="a_node2_5"><a xlink:href="#" xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="32.75" y="-143.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node2_6"><a xlink:href="#" xlink:title="create_candidate(self)
    -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new candidate by mutating a population member"><text text-anchor="start"
    x="32.75" y="-129.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">create_candidate()</text></a></g> <g id="a_node2_7"><a
    xlink:href="#" xlink:title="mutate(self, inp: str) -> str"><text text-anchor="start"
    x="32.75" y="-117" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">mutate()</text></a></g> <g id="a_node2_8"><a xlink:href="#"
    xlink:title="reset(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: Set population to initial seed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be overloaded in subclasses."><text text-anchor="start" x="32.75" y="-105.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">reset()</text></a></g></a></g></a></g></g> <g id="edge1" class="edge"><title>MutationCoverageFuzzer->MutationFuzzer</title></g>
    <g id="node3" class="node"><title>Fuzzer</title> <g id="a_node3"><a xlink:href="Fuzzer.html"
    xlink:title="class Fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for fuzzers."><text text-anchor="start" x="66.12" y="-300.45" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
    <g id="a_node3_9"><a xlink:href="#" xlink:title="Fuzzer"><g id="a_node3_10"><a
    xlink:href="Fuzzer.html" xlink:title="__init__(self) -> None:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructor"><text text-anchor="start" x="56.75" y="-278.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_11"><a xlink:href="Fuzzer.html"
    xlink:title="fuzz(self) -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return fuzz input"><text text-anchor="start" x="56.75" y="-265.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-style="italic"
    font-size="10.00">fuzz()</text></a></g> <g id="a_node3_12"><a xlink:href="Fuzzer.html"
    xlink:title="run(self, runner: Fuzzer.Runner = <Fuzzer.Runner object>) -> Tuple[subprocess.CompletedProcess,
    str]:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `runner` with fuzz input"><text text-anchor="start" x="56.75" y="-252.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-style="italic" font-size="10.00">run()</text></a></g> <g id="a_node3_13"><a
    xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = <Fuzzer.PrintRunner
    object>, trials: int = 10) -> List[Tuple[subprocess.CompletedProcess, str]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `runner` with fuzz input, `trials` times"><text text-anchor="start" x="56.75"
    y="-240" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold"
    font-size="10.00">runs()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>MutationFuzzer->Fuzzer</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="191.12"
    y="-46.25" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00"
    fill="#b03a2e">Legend</text> <text text-anchor="start" x="191.12" y="-36.25" font-family="Patua
    One, Helvetica, sans-serif" font-size="10.00">• </text> <text text-anchor="start"
    x="197.12" y="-36.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier',
    monospace" font-weight="bold" font-size="8.00">public_method()</text> <text text-anchor="start"
    x="191.12" y="-26.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="197.12" y="-26.25" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text> <text
    text-anchor="start" x="191.12" y="-16.25" font-family="Patua One, Helvetica, sans-serif"
    font-size="10.00">• </text> <text text-anchor="start" x="197.12" y="-16.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
    <text text-anchor="start" x="191.12" y="-7.2" font-family="Helvetica,sans-Serif"
    font-size="9.00">Hover over names to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing with Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On November 2013, the first version of [American Fuzzy Lop](http://lcamtuf.coredump.cx/afl/)
    (AFL) was released. Since then, AFL has become one of the most successful fuzzing
    tools and comes in many flavors, e.g., [AFLFast](https://github.com/mboehme/aflfast),
    [AFLGo](https://github.com/aflgo/aflgo), and [AFLSmart](https://github.com/aflsmart/aflsmart)
    (which are discussed in this book). AFL has made fuzzing a popular choice for
    automated vulnerability detection. It was the first to demonstrate that vulnerabilities
    can be detected automatically at a large scale in many security-critical, real-world
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![American Fuzzy Lop Command Line User Interface](../Images/1fb4be95795ea77b5e85f50d4fb6db5f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 1.** American Fuzzy Lop Command Line User Interface'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to introduce the basics of mutational fuzz testing;
    the next chapter will then further show how to direct fuzzing towards specific
    code goals.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing a URL Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many programs expect their inputs to come in a very specific format before they
    would actually process them. As an example, think of a program that accepts a
    URL (a Web address). The URL has to be in a valid format (i.e., the URL format)
    such that the program can deal with it. When fuzzing with random inputs, what
    are our chances to actually produce a valid URL?
  prefs: []
  type: TYPE_NORMAL
- en: 'To get deeper into the problem, let us explore what URLs are made of. A URL
    consists of a number of elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: '`scheme` is the protocol to be used, including `http`, `https`, `ftp`, `file`...'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netloc` is the name of the host to connect to, such as `www.google.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` is the path on that very host, such as `search`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query` is a list of key/value pairs, such as `q=fuzzing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fragment` is a marker for a location in the retrieved document, such as `#result`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, we can use the `urlparse()` function to parse and decompose a URL
    into its parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We see how the result encodes the individual parts of the URL in different attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now assume we have a program that takes a URL as input. To simplify things,
    we won't let it do very much; we simply have it check the passed URL for validity.
    If the URL is valid, it returns True; otherwise, it raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let us now go and fuzz `http_program()`. To fuzz, we use the full range of printable
    ASCII characters, such that `:`, `/`, and lowercase letters are included.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's try to fuzz with 1000 random inputs and see whether we have some success.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the chances of actually getting a valid URL? We need our string to
    start with `"http://"` or `"https://"`. Let''s take the `"http://"` case first.
    These are seven very specific characters we need to start with. The chance of
    producing these seven characters randomly (with a character range of 96 different
    characters) is $1 : 96^7$, or'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The odds of producing a `"https://"` prefix are even worse, at $1 : 96^8$:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: which gives us a total chance of
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the number of runs (on average) we''d need to produce a valid URL
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s measure how long one run of `http_program()` takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's pretty fast, isn't it? Unfortunately, we have a lot of runs to cover.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: which translates into
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Even if we parallelize things a lot, we're still in for months to years of waiting.
    And that's for getting *one* successful run that will get deeper into `http_program()`.
  prefs: []
  type: TYPE_NORMAL
- en: What basic fuzzing will do well is to test `urlparse()`, and if there is an
    error in this parsing function, it has good chances of uncovering it. But as long
    as we cannot produce a valid input, we are out of luck in reaching any deeper
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating Inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The alternative to generating random strings from scratch is to start with a
    given *valid* input, and then to subsequently *mutate* it. A *mutation* in this
    context is a simple string manipulation - say, inserting a (random) character,
    deleting a character, or flipping a bit in a character representation. This is
    called *mutational fuzzing* – in contrast to the *generational fuzzing* techniques
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some mutations to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now create a random mutator that randomly chooses which mutation to
    apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The idea is now that *if* we have some valid input(s) to begin with, we may
    create more input candidates by applying one of the above mutations. To see how
    this works, let's get back to URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us now get back to our URL parsing problem. Let us create a function `is_valid_url()`
    that checks whether `http_program()` accepts the input.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let us now apply the `mutate()` function on a given URL and see how many valid
    inputs we obtain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now observe that by *mutating* the original input, we get a high proportion
    of valid inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'What are the odds of also producing a `https:` prefix by mutating a `http:`
    sample seed input? We have to insert ($1 : 3$) the right character `''s''` ($1
    : 96$) into the correct position ($1 : l$), where $l$ is the length of our seed
    input. This means that on average, we need this many runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can actually afford this. Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if we wanted to get, say, an `"ftp://"` prefix, we would need more
    mutations and more runs – most important, though, we would need to apply *multiple*
    mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Mutations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only applied one single mutation on a sample string. However,
    we can also apply *multiple* mutations, further changing it. What happens, for
    instance, if we apply, say, 20 mutations on our sample string?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: As you see, the original seed input is hardly recognizable anymore. By mutating
    the input again and again, we get a higher variety in the input.
  prefs: []
  type: TYPE_NORMAL
- en: To implement such multiple mutations in a single package, let us introduce a
    `MutationFuzzer` class. It takes a seed (a list of strings) as well as a minimum
    and a maximum number of mutations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, let us develop `MutationFuzzer` further by adding more methods
    to it. The Python language requires us to define an entire class with all methods
    as a single, continuous unit; however, we would like to introduce one method after
    another. To avoid this problem, we use a special hack: Whenever we want to introduce
    a new method to some class `C`, we use the construct'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This seems to define `C` as a subclass of itself, which would make no sense
    – but actually, it introduces a new `C` class as a subclass of the *old* `C` class,
    and then shadowing the old `C` definition. What this gets us is a `C` class with
    `new_method()` as a method, which is just what we want. (`C` objects defined earlier
    will retain the earlier `C` definition, though, and thus must be rebuilt.)
  prefs: []
  type: TYPE_NORMAL
- en: Using this hack, we can now add a `mutate()` method that actually invokes the
    above `mutate()` function. Having `mutate()` as a method is useful when we want
    to extend a `MutationFuzzer` later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get back to our strategy, maximizing *diversity in coverage* in our
    population. First, let us create a method `create_candidate()`, which randomly
    picks some input from our current population (`self.population`), and then applies
    between `min_mutations` and `max_mutations` mutation steps, returning the final
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fuzz()` method is set to first pick the seeds; when these are gone, we
    mutate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `fuzz()` method in action. With every new invocation of `fuzz()`,
    we get another variant with multiple mutations applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The higher variety in inputs, though, increases the risk of having an invalid
    input. The key to success lies in the idea of *guiding* these mutations – that
    is, *keeping those that are especially valuable.*
  prefs: []
  type: TYPE_NORMAL
- en: Guiding by Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To cover as much functionality as possible, one can rely on either *specified*
    or *implemented* functionality, as discussed in the ["Coverage"](Coverage.html)
    chapter. For now, we will not assume that there is a specification of program
    behavior (although it *definitely* would be good to have one!). We *will* assume,
    though, that the program to be tested exists – and that we can leverage its structure
    to guide test generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since testing always executes the program at hand, one can always gather information
    about its execution – the least is the information needed to decide whether a
    test passes or fails. Since coverage is frequently measured as well to determine
    test quality, let us also assume we can retrieve coverage of a test run. The question
    is then: *How can we leverage coverage to guide test generation?*'
  prefs: []
  type: TYPE_NORMAL
- en: One particularly successful idea is implemented in the popular fuzzer named
    [American fuzzy lop](http://lcamtuf.coredump.cx/afl/), or *AFL* for short. Just
    like our examples above, AFL evolves test cases that have been successful – but
    for AFL, "success" means *finding a new path through the program execution*. This
    way, AFL can keep on mutating inputs that so far have found new paths; and if
    an input finds another path, it will be retained as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us build such a strategy. We start with introducing a `Runner` class that
    captures the coverage for a given function. First, a `FunctionRunner` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: We can now extend the `FunctionRunner` class such that it also measures coverage.
    After invoking `run()`, the `coverage()` method returns the coverage achieved
    in the last run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the first five locations covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now for the main class. We maintain the population and a set of coverages already
    achieved (`coverages_seen`). The `fuzz()` helper function takes an input and runs
    the given `function()` on it. If its coverage is new (i.e. not in `coverages_seen`),
    the input is added to `population` and the coverage to `coverages_seen`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now put this to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Success! In our population, *each and every input* now is valid and has a different
    coverage, coming from various combinations of schemes, paths, queries, and fragments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/e953f03939dd0b3903681a1345fe55e5.png)'
  prefs: []
  type: TYPE_IMG
- en: The nice thing about this strategy is that, applied to larger programs, it will
    happily explore one path after the other – covering functionality after functionality.
    All that is needed is a means to capture the coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomly generated inputs are frequently invalid – and thus exercise mostly
    input processing functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations from existing valid inputs have much higher chances to be valid, and
    thus to exercise functionality beyond input processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next chapter on [greybox fuzzing](GreyboxFuzzer.html), we further extend
    the concept of mutation-based testing with *power schedules* that allow spending
    more energy on seeds that exercise "unlikely" paths and seeds that are "closer"
    to a target location.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Fuzzing CGI decode with Mutations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apply the above *guided* mutation-based fuzzing technique on `cgi_decode()`
    from the ["Coverage"](Coverage.html) chapter. How many trials do you need until
    you cover all variations of `+`, `%` (valid and invalid), and regular characters?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/cb6e55756b748962ea64bbd06d7d917a.png)'
  prefs: []
  type: TYPE_IMG
- en: After 10,000 runs, we have managed to synthesize a `+` character and a valid
    `%xx` form. We can still do better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Fuzzing bc with Mutations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apply the above mutation-based fuzzing technique on `bc`, as in the chapter
    ["Introduction to Fuzzing"](Fuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: Non-Guided Mutations'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Start with non-guided mutations. How many of the inputs are valid?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/MutationFuzzer.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Guided Mutations'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Continue with *guided* mutations. To this end, you will have to find a way
    to extract coverage from a C program such as `bc`. Proceed in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, get [GNU bc](https://www.gnu.org/software/bc/); download, say, `bc-1.07.1.tar.gz`
    and unpack it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, configure the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, compile the package with special flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The file `bc/bc` should now be executable...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '...and you should be able to run the `gcov` program to retrieve coverage information.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As sketched in the ["Coverage" chapter](Coverage.html), the file [bc-1.07.1/bc/main.c.gcov](bc-1.07.1/bc/main.c.gcov)
    now holds the coverage information for `bc.c`. Each line is prefixed with the
    number of times it was executed. `#####` means zero times; `-` means non-executable
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Parse the GCOV file for `bc` and create a `coverage` set, as in `FunctionCoverageRunner`.
    Make this a `ProgramCoverageRunner` class that would be constructed with a list
    of source files (`bc.c`, `main.c`, `load.c`) to run `gcov` on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re done, don''t forget to clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this [blog post](https://lcamtuf.blogspot.com/2014/08/binary-fuzzing-strategies-what-works.html),
    the author of *American Fuzzy Lop* (AFL), a very popular mutation-based fuzzer
    discusses the efficiency of various mutation operators. Implement four of them
    and evaluate their efficiency as in the examples above.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding a new element to the list of candidates, AFL does actually not compare
    the *coverage*, but adds an element if it exercises a new *branch*. Using branch
    coverage from the exercises of the ["Coverage"](Coverage.html) chapter, implement
    this "branch" strategy and compare it against the "coverage" strategy, above.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Design and implement a system that will gather a population of URLs from the
    Web. Can you achieve a higher coverage with these samples? What if you use them
    as initial population for further mutation?
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:25:56+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/MutationFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Mutation-Based Fuzzing](https://www.fuzzingbook.org/html/MutationFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/MutationFuzzer.html](https://www.fuzzingbook.org/html/MutationFuzzer.html).
    Retrieved 2024-11-09 17:25:56+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
