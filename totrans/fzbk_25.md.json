["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('WZi0dTvJ2Ug') \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import List, Any, Optional, Union \n```", "```py\n>>> from [fuzzingbook.InformationFlow](InformationFlow.html) import <identifier> \n```", "```py\n>>> thello = tstr('hello', taint='LOW') \n```", "```py\n>>> thello[:4]\n'hell' \n```", "```py\n>>> thello.taint\n'LOW' \n```", "```py\n>>> thello[1:2].taint\n'LOW' \n```", "```py\n>>> secret = ostr(\"joshua1234\", origin=100, taint='SECRET') \n```", "```py\n>>> secret.origin\n[100, 101, 102, 103, 104, 105, 106, 107, 108, 109]\n>>> secret.taint\n'SECRET' \n```", "```py\n>>> secret_substr = (secret[0:4] + \"-\" + secret[6:])\n>>> secret_substr.taint\n'SECRET'\n>>> secret_substr.origin\n[100, 101, 102, 103, -1, 106, 107, 108, 109] \n```", "```py\nINVENTORY = \"\"\"\\\n1997,van,Ford,E350\n2000,car,Mercury,Cougar\n1999,car,Chevy,Venture\\\n\"\"\" \n```", "```py\nVEHICLES = INVENTORY.split('\\n') \n```", "```py\nclass SQLException(Exception):\n    pass \n```", "```py\nclass DB:\n    def __init__(self, db={}):\n        self.db = dict(db) \n```", "```py\nclass DB(DB):\n    def create_table(self, table, defs):\n        self.db[table] = (defs, []) \n```", "```py\nclass DB(DB):\n    def table(self, t_name):\n        if t_name in self.db:\n            return self.db[t_name]\n        raise SQLException('Table (%s) was not found' % repr(t_name)) \n```", "```py\ndef sample_db():\n    db = DB()\n    inventory_def = {'year': int, 'kind': str, 'company': str, 'model': str}\n    db.create_table('inventory', inventory_def)\n    return db \n```", "```py\ndb = sample_db()\ndb.table('inventory') \n```", "```py\n({'year': int, 'kind': str, 'company': str, 'model': str}, [])\n\n```", "```py\nclass DB(DB):\n    def column(self, table_decl, c_name):\n        if c_name in table_decl: \n            return table_decl[c_name]\n        raise SQLException('Column (%s) was not found' % repr(c_name)) \n```", "```py\ndb = sample_db()\ndecl, rows = db.table('inventory')\ndb.column(decl, 'year') \n```", "```py\nint\n\n```", "```py\nclass DB(DB):\n    def do_select(self, query):\n        ...\n\n    def do_update(self, query):\n        ...\n\n    def do_insert(self, query):\n        ...\n\n    def do_delete(self, query):\n        ...\n\n    def sql(self, query):\n        methods = [('select ', self.do_select),\n                   ('update ', self.do_update),\n                   ('insert into ', self.do_insert),\n                   ('delete from', self.do_delete)]\n        for key, method in methods:\n            if query.startswith(key):\n                return method(query[len(key):])\n        raise SQLException('Unknown SQL (%s)' % query) \n```", "```py\nsome_db = DB()\nsome_db.sql('select year from inventory') \n```", "```py\nclass DB(DB):\n    def do_select(self, query):\n        FROM, WHERE = ' from ', ' where '\n        table_start = query.find(FROM)\n        if table_start < 0:\n            raise SQLException('no table specified')\n\n        where_start = query.find(WHERE)\n        select = query[:table_start]\n\n        if where_start >= 0:\n            t_name = query[table_start + len(FROM):where_start]\n            where = query[where_start + len(WHERE):]\n        else:\n            t_name = query[table_start + len(FROM):]\n            where = ''\n        _, table = self.table(t_name)\n\n        if where:\n            selected = self.expression_clause(table, \"(%s)\" % where)\n            selected_rows = [hm for i, data, hm in selected if data]\n        else:\n            selected_rows = table\n\n        rows = self.expression_clause(selected_rows, \"(%s)\" % select)\n        return [data for i, data, hm in rows] \n```", "```py\nclass DB(DB):\n    def expression_clause(self, table, statement):\n        selected = []\n        for i, hm in enumerate(table):\n            selected.append((i, self.my_eval(statement, {}, hm), hm))\n\n        return selected \n```", "```py\nclass DB(DB):\n    def my_eval(self, statement, g, l):\n        try:\n            return eval(statement, g, l)\n        except Exception:\n            raise SQLException('Invalid WHERE (%s)' % repr(statement)) \n```", "```py\ndb = sample_db()\ndb.sql('select year from inventory') \n```", "```py\n[]\n\n```", "```py\ndb = sample_db()\ndb.sql('select year from inventory where year == 2018') \n```", "```py\n[]\n\n```", "```py\nclass DB(DB):\n    def do_insert(self, query):\n        VALUES = ' values '\n        table_end = query.find('(')\n        t_name = query[:table_end].strip()\n        names_end = query.find(')')\n        decls, table = self.table(t_name)\n        names = [i.strip() for i in query[table_end + 1:names_end].split(',')]\n\n        # verify columns exist\n        for k in names:\n            self.column(decls, k)\n\n        values_start = query.find(VALUES)\n\n        if values_start < 0:\n            raise SQLException('Invalid INSERT (%s)' % repr(query))\n\n        values = [\n            i.strip() for i in query[values_start + len(VALUES) + 1:-1].split(',')\n        ]\n\n        if len(names) != len(values):\n            raise SQLException(\n                'names(%s) != values(%s)' % (repr(names), repr(values)))\n\n        # dict lookups happen in C code, so we can't use that\n        kvs = {}\n        for k,v in zip(names, values):\n            for key,kval in decls.items():\n                if k == key:\n                    kvs[key] = self.convert(kval, v)\n        table.append(kvs) \n```", "```py\nimport [ast](https://docs.python.org/3/library/ast.html) \n```", "```py\nclass DB(DB):\n    def convert(self, cast, value):\n        try:\n            return cast(ast.literal_eval(value))\n        except:\n            raise SQLException('Invalid Conversion %s(%s)' % (cast, value)) \n```", "```py\ndb = sample_db()\ndb.sql('insert into inventory (year, kind, company, model) values (1997, \"van\", \"Ford\", \"E350\")')\ndb.table('inventory') \n```", "```py\n({'year': int, 'kind': str, 'company': str, 'model': str},\n [{'year': 1997, 'kind': 'van', 'company': 'Ford', 'model': 'E350'}])\n\n```", "```py\ndb.sql('select year + 1, kind from inventory') \n```", "```py\n[(1998, 'van')]\n\n```", "```py\ndb.sql('select year, kind from inventory where year == 1997') \n```", "```py\n[(1997, 'van')]\n\n```", "```py\nclass DB(DB):\n    def do_update(self, query):\n        SET, WHERE = ' set ', ' where '\n        table_end = query.find(SET)\n\n        if table_end < 0:\n            raise SQLException('Invalid UPDATE (%s)' % repr(query))\n\n        set_end = table_end + 5\n        t_name = query[:table_end]\n        decls, table = self.table(t_name)\n        names_end = query.find(WHERE)\n\n        if names_end >= 0:\n            names = query[set_end:names_end]\n            where = query[names_end + len(WHERE):]\n        else:\n            names = query[set_end:]\n            where = ''\n\n        sets = [[i.strip() for i in name.split('=')]\n                for name in names.split(',')]\n\n        # verify columns exist\n        for k, v in sets:\n            self.column(decls, k)\n\n        if where:\n            selected = self.expression_clause(table, \"(%s)\" % where)\n            updated = [hm for i, d, hm in selected if d]\n        else:\n            updated = table\n\n        for hm in updated:\n            for k, v in sets:\n                # we can not do dict lookups because it is implemented in C.\n                for key, kval in decls.items():\n                    if key == k:\n                        hm[key] = self.convert(kval, v)\n\n        return \"%d records were updated\" % len(updated) \n```", "```py\ndb = sample_db()\ndb.sql('insert into inventory (year, kind, company, model) values (1997, \"van\", \"Ford\", \"E350\")')\ndb.sql('select year from inventory') \n```", "```py\n[1997]\n\n```", "```py\ndb.sql('update inventory set year = 1998 where year == 1997')\ndb.sql('select year from inventory') \n```", "```py\n[1998]\n\n```", "```py\ndb.table('inventory') \n```", "```py\n({'year': int, 'kind': str, 'company': str, 'model': str},\n [{'year': 1998, 'kind': 'van', 'company': 'Ford', 'model': 'E350'}])\n\n```", "```py\nclass DB(DB):\n    def do_delete(self, query):\n        WHERE = ' where '\n        table_end = query.find(WHERE)\n        if table_end < 0:\n            raise SQLException('Invalid DELETE (%s)' % query)\n\n        t_name = query[:table_end].strip()\n        _, table = self.table(t_name)\n        where = query[table_end + len(WHERE):]\n        selected = self.expression_clause(table, \"%s\" % where)\n        deleted = [i for i, d, hm in selected if d]\n        for i in sorted(deleted, reverse=True):\n            del table[i]\n\n        return \"%d records were deleted\" % len(deleted) \n```", "```py\ndb = sample_db()\ndb.sql('insert into inventory (year, kind, company, model) values (1997, \"van\", \"Ford\", \"E350\")')\ndb.sql('select year from inventory') \n```", "```py\n[1997]\n\n```", "```py\ndb.sql('delete from inventory where company == \"Ford\"') \n```", "```py\n'1 records were deleted'\n\n```", "```py\ndb.sql('select year from inventory') \n```", "```py\n[]\n\n```", "```py\ndb = DB() \n```", "```py\ninventory_def = {'year': int, 'kind': str, 'company': str, 'model': str}\ndb.create_table('inventory', inventory_def) \n```", "```py\ndef update_inventory(sqldb, vehicle):\n    inventory_def = sqldb.db['inventory'][0]\n    k, v = zip(*inventory_def.items())\n    val = [repr(cast(val)) for cast, val in zip(v, vehicle.split(','))]\n    sqldb.sql('insert into inventory (%s) values (%s)' % (','.join(k),\n                                                          ','.join(val))) \n```", "```py\nfor V in VEHICLES:\n    update_inventory(db, V) \n```", "```py\ndb.db \n```", "```py\n{'inventory': ({'year': int, 'kind': str, 'company': str, 'model': str},\n  [{'year': 1997, 'kind': 'van', 'company': 'Ford', 'model': 'E350'},\n   {'year': 2000, 'kind': 'car', 'company': 'Mercury', 'model': 'Cougar'},\n   {'year': 1999, 'kind': 'car', 'company': 'Chevy', 'model': 'Venture'}])}\n\n```", "```py\ndb.sql('select year,kind from inventory') \n```", "```py\n[(1997, 'van'), (2000, 'car'), (1999, 'car')]\n\n```", "```py\ndb.sql(\"select company,model from inventory where kind == 'car'\") \n```", "```py\n[('Mercury', 'Cougar'), ('Chevy', 'Venture')]\n\n```", "```py\ndb.sql(\"update inventory set year = 1998, company = 'Suzuki' where kind == 'van'\") \n```", "```py\n'1 records were updated'\n\n```", "```py\ndb.db \n```", "```py\n{'inventory': ({'year': int, 'kind': str, 'company': str, 'model': str},\n  [{'year': 1998, 'kind': 'van', 'company': 'Suzuki', 'model': 'E350'},\n   {'year': 2000, 'kind': 'car', 'company': 'Mercury', 'model': 'Cougar'},\n   {'year': 1999, 'kind': 'car', 'company': 'Chevy', 'model': 'Venture'}])}\n\n```", "```py\ndb.sql('select int(year)+10 from inventory') \n```", "```py\n[2008, 2010, 2009]\n\n```", "```py\ndb.sql(\"insert into inventory (year, kind, company, model) values (1, 'charriot', 'Rome', 'Quadriga')\") \n```", "```py\ndb.db \n```", "```py\n{'inventory': ({'year': int, 'kind': str, 'company': str, 'model': str},\n  [{'year': 1998, 'kind': 'van', 'company': 'Suzuki', 'model': 'E350'},\n   {'year': 2000, 'kind': 'car', 'company': 'Mercury', 'model': 'Cougar'},\n   {'year': 1999, 'kind': 'car', 'company': 'Chevy', 'model': 'Venture'},\n   {'year': 1, 'kind': 'charriot', 'company': 'Rome', 'model': 'Quadriga'}])}\n\n```", "```py\ndb.sql(\"delete from inventory where year < 1900\") \n```", "```py\n'1 records were deleted'\n\n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\nfrom [Grammars](Grammars.html) import START_SYMBOL, Grammar, Expansion, \\\n    is_valid_grammar, extend_grammar \n```", "```py\nEXPR_GRAMMAR: Grammar = {\n    \"<start>\": [\"<expr>\"],\n    \"<expr>\": [\"<bexpr>\", \"<aexpr>\", \"(<expr>)\", \"<term>\"],\n    \"<bexpr>\": [\n        \"<aexpr><lt><aexpr>\",\n        \"<aexpr><gt><aexpr>\",\n        \"<expr>==<expr>\",\n        \"<expr>!=<expr>\",\n    ],\n    \"<aexpr>\": [\n        \"<aexpr>+<aexpr>\", \"<aexpr>-<aexpr>\", \"<aexpr>*<aexpr>\",\n        \"<aexpr>/<aexpr>\", \"<word>(<exprs>)\", \"<expr>\"\n    ],\n    \"<exprs>\": [\"<expr>,<exprs>\", \"<expr>\"],\n    \"<lt>\": [\"<\"],\n    \"<gt>\": [\">\"],\n    \"<term>\": [\"<number>\", \"<word>\"],\n    \"<number>\": [\"<integer>.<integer>\", \"<integer>\", \"-<number>\"],\n    \"<integer>\": [\"<digit><integer>\", \"<digit>\"],\n    \"<word>\": [\"<word><letter>\", \"<word><digit>\", \"<letter>\"],\n    \"<digit>\":\n    list(string.digits),\n    \"<letter>\":\n    list(string.ascii_letters + '_:.')\n}\n\nassert is_valid_grammar(EXPR_GRAMMAR) \n```", "```py\nPRINTABLE_CHARS: List[str] = [i for i in string.printable \n                                    if i not in \"<>'\\\"\\t\\n\\r\\x0b\\x0c\\x00\"] + ['<lt>', '<gt>'] \n```", "```py\nINVENTORY_GRAMMAR = extend_grammar(EXPR_GRAMMAR,\n    {\n        '<start>': ['<query>'],\n        '<query>': [\n            'select <exprs> from <table>',\n            'select <exprs> from <table> where <bexpr>',\n            'insert into <table> (<names>) values (<literals>)',\n            'update <table> set <assignments> where <bexpr>',\n            'delete from <table> where <bexpr>',\n        ],\n        '<table>': ['<word>'],\n        '<names>': ['<column>,<names>', '<column>'],\n        '<column>': ['<word>'],\n        '<literals>': ['<literal>', '<literal>,<literals>'],\n        '<literal>': ['<number>', \"'<chars>'\"],\n        '<assignments>': ['<kvp>,<assignments>', '<kvp>'],\n        '<kvp>': ['<column>=<value>'],\n        '<value>': ['<word>'],\n        '<chars>': ['<char>', '<char><chars>'],\n        '<char>': PRINTABLE_CHARS,\n    })\n\nassert is_valid_grammar(INVENTORY_GRAMMAR) \n```", "```py\nINVENTORY_GRAMMAR_F = extend_grammar(INVENTORY_GRAMMAR, \n                                     {'<table>': ['inventory']}) \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer \n```", "```py\ngf = GrammarFuzzer(INVENTORY_GRAMMAR_F)\nfor _ in range(10):\n    query = gf.fuzz()\n    print(repr(query))\n    try:\n        res = db.sql(query)\n        print(repr(res))\n    except SQLException as e:\n        print(\"> \", e)\n        pass\n    except:\n        traceback.print_exc()\n        break\n    print() \n```", "```py\n'select O6fo,-977091.1,-36.46 from inventory'\n>  Invalid WHERE ('(O6fo,-977091.1,-36.46)')\n\n'select g3 from inventory where -3.0!=V/g/b+Q*M*G'\n>  Invalid WHERE ('(-3.0!=V/g/b+Q*M*G)')\n\n'update inventory set z=a,x=F_,Q=K where p(M)<_*S'\n>  Column ('z') was not found\n\n'update inventory set R=L5pk where e*l*y-u>K+U(:)'\n>  Column ('R') was not found\n\n'select _/d*Q+H/d(k)<t+M-A+P from inventory'\n>  Invalid WHERE ('(_/d*Q+H/d(k)<t+M-A+P)')\n\n'select F5 from inventory'\n>  Invalid WHERE ('(F5)')\n\n'update inventory set jWh.=a6 where wcY(M)>IB7(i)'\n>  Column ('jWh.') was not found\n\n'update inventory set U=y where L(W<c,(U!=W))<V(((q)==m<F),O,l)'\n>  Column ('U') was not found\n\n'delete from inventory where M/b-O*h*E<H-W>e(Y)-P'\n>  Invalid WHERE ('M/b-O*h*E<H-W>e(Y)-P')\n\n'select ((kP(86)+b*S+J/Z/U+i(U))) from inventory'\n>  Invalid WHERE ('(((kP(86)+b*S+J/Z/U+i(U))))')\n\n```", "```py\ndb.sql('select year from inventory where year < 2000') \n```", "```py\n[1998, 1999]\n\n```", "```py\ndb.sql('select year - 1900 if year < 2000 else year - 2000 from inventory') \n```", "```py\n[98, 0, 99]\n\n```", "```py\ndb.sql('select __import__(\"os\").popen(\"pwd\").read() from inventory') \n```", "```py\n['/Users/zeller/Projects/fuzzingbook/notebooks\\n',\n '/Users/zeller/Projects/fuzzingbook/notebooks\\n',\n '/Users/zeller/Projects/fuzzingbook/notebooks\\n']\n\n```", "```py\nclass tstr(str):\n  \"\"\"Wrapper for strings, saving taint information\"\"\"\n\n    def __new__(cls, value, *args, **kw):\n  \"\"\"Create a tstr() instance. Used internally.\"\"\"\n        return str.__new__(cls, value)\n\n    def __init__(self, value: Any, taint: Any = None, **kwargs) -> None:\n  \"\"\"Constructor.\n `value` is the string value the `tstr` object is to be constructed from.\n `taint` is an (optional) taint to be propagated to derived strings.\"\"\"\n        self.taint: Any = taint \n```", "```py\nclass tstr(tstr):\n    def __repr__(self) -> tstr:\n  \"\"\"Return a representation.\"\"\"\n        return tstr(str.__repr__(self), taint=self.taint) \n```", "```py\nclass tstr(tstr):\n    def __str__(self) -> str:\n  \"\"\"Convert to string\"\"\"\n        return str.__str__(self) \n```", "```py\nthello: tstr = tstr('hello', taint='LOW') \n```", "```py\nthello.taint \n```", "```py\n'LOW'\n\n```", "```py\nrepr(thello).taint \n```", "```py\n'LOW'\n\n```", "```py\nclass tstr(tstr):\n    def clear_taint(self):\n  \"\"\"Remove taint\"\"\"\n        self.taint = None\n        return self\n\n    def has_taint(self):\n  \"\"\"Check if taint is present\"\"\"\n        return self.taint is not None \n```", "```py\nclass tstr(tstr):\n    def create(self, s):\n        return tstr(s, taint=self.taint) \n```", "```py\nclass tstr(tstr):\n    @staticmethod\n    def make_str_wrapper(fun):\n  \"\"\"Make `fun` (a `str` method) a method in `tstr`\"\"\"\n        def proxy(self, *args, **kwargs):\n            res = fun(self, *args, **kwargs)\n            return self.create(res)\n\n        if hasattr(fun, '__doc__'):\n            # Copy docstring\n            proxy.__doc__ = fun.__doc__\n\n        return proxy \n```", "```py\ndef informationflow_init_1():\n    for name in ['__format__', '__mod__', '__rmod__', '__getitem__',\n                 '__add__', '__mul__', '__rmul__',\n                 'capitalize', 'casefold', 'center', 'encode',\n                 'expandtabs', 'format', 'format_map', 'join',\n                 'ljust', 'lower', 'lstrip', 'replace',\n                 'rjust', 'rstrip', 'strip', 'swapcase', 'title', 'translate', 'upper']:\n        fun = getattr(str, name)\n        setattr(tstr, name, tstr.make_str_wrapper(fun)) \n```", "```py\ninformationflow_init_1() \n```", "```py\nINITIALIZER_LIST = [informationflow_init_1] \n```", "```py\ndef initialize():\n    for fn in INITIALIZER_LIST:\n        fn() \n```", "```py\nclass tstr(tstr):\n    def __radd__(self, value):\n  \"\"\"Return value + self, as a `tstr` object\"\"\"\n        return self.create(value + str(self)) \n```", "```py\nthello = tstr('hello', taint='LOW') \n```", "```py\nthello[0].taint \n```", "```py\n'LOW'\n\n```", "```py\nthello[1:3].taint \n```", "```py\n'LOW'\n\n```", "```py\n(tstr('foo', taint='HIGH') + 'bar').taint \n```", "```py\n'HIGH'\n\n```", "```py\n('foo' + tstr('bar', taint='HIGH')).taint \n```", "```py\n'HIGH'\n\n```", "```py\nthello += ', world' \n```", "```py\nthello.taint \n```", "```py\n'LOW'\n\n```", "```py\n(thello * 5).taint \n```", "```py\n'LOW'\n\n```", "```py\n('hw %s' % thello).taint \n```", "```py\n'LOW'\n\n```", "```py\n(tstr('hello %s', taint='HIGH') % 'world').taint \n```", "```py\n'HIGH'\n\n```", "```py\nclass TrustedDB(DB):\n    def sql(self, s):\n        assert isinstance(s, tstr), \"Need a tainted string\"\n        assert s.taint == 'TRUSTED', \"Need a string with trusted taint\"\n        return super().sql(s) \n```", "```py\nbdb = TrustedDB(db.db) \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nwith ExpectError():\n    bdb.sql(\"select year from INVENTORY\") \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/3935989889.py\", line 2, in <module>\n    bdb.sql(\"select year from INVENTORY\")\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/995123203.py\", line 3, in sql\n    assert isinstance(s, tstr), \"Need a tainted string\"\n           ^^^^^^^^^^^^^^^^^^^\nAssertionError: Need a tainted string (expected)\n\n```", "```py\nbad_user_input = tstr('__import__(\"os\").popen(\"ls\").read()', taint='UNTRUSTED')\nwith ExpectError():\n    bdb.sql(bad_user_input) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/3307042773.py\", line 3, in <module>\n    bdb.sql(bad_user_input)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/995123203.py\", line 4, in sql\n    assert s.taint == 'TRUSTED', \"Need a string with trusted taint\"\n           ^^^^^^^^^^^^^^^^^^^^\nAssertionError: Need a string with trusted taint (expected)\n\n```", "```py\nimport [re](https://docs.python.org/3/library/re.html) \n```", "```py\ndef sanitize(user_input):\n    assert isinstance(user_input, tstr)\n    if re.match(\n            r'^select +[-a-zA-Z0-9_, ()]+ from +[-a-zA-Z0-9_, ()]+$', user_input):\n        return tstr(user_input, taint='TRUSTED')\n    else:\n        return tstr('', taint='UNTRUSTED') \n```", "```py\ngood_user_input = tstr(\"select year,model from inventory\", taint='UNTRUSTED')\nsanitized_input = sanitize(good_user_input)\nsanitized_input \n```", "```py\n'select year,model from inventory'\n\n```", "```py\nsanitized_input.taint \n```", "```py\n'TRUSTED'\n\n```", "```py\nbdb.sql(sanitized_input) \n```", "```py\n[(1998, 'E350'), (2000, 'Cougar'), (1999, 'Venture')]\n\n```", "```py\nsanitized_input = sanitize(bad_user_input)\nsanitized_input \n```", "```py\n''\n\n```", "```py\nsanitized_input.taint \n```", "```py\n'UNTRUSTED'\n\n```", "```py\nwith ExpectError():\n    bdb.sql(sanitized_input) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/249000876.py\", line 2, in <module>\n    bdb.sql(sanitized_input)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/995123203.py\", line 4, in sql\n    assert s.taint == 'TRUSTED', \"Need a string with trusted taint\"\n           ^^^^^^^^^^^^^^^^^^^^\nAssertionError: Need a string with trusted taint (expected)\n\n```", "```py\nclass Tainted(Exception):\n    def __init__(self, v):\n        self.v = v\n\n    def __str__(self):\n        return 'Tainted[%s]' % self.v \n```", "```py\nclass TaintedDB(DB):\n    def my_eval(self, statement, g, l):\n        if statement.taint != 'TRUSTED':\n            raise Tainted(statement)\n        try:\n            return eval(statement, g, l)\n        except:\n            raise SQLException('Invalid SQL (%s)' % repr(statement)) \n```", "```py\ntdb = TaintedDB() \n```", "```py\ntdb.db = db.db \n```", "```py\nimport [traceback](https://docs.python.org/3/library/traceback.html) \n```", "```py\nfor _ in range(10):\n    query = gf.fuzz()\n    print(repr(query))\n    try:\n        res = tdb.sql(tstr(query, taint='UNTRUSTED'))\n        print(repr(res))\n    except SQLException as e:\n        pass\n    except Tainted as e:\n        print(\"> \", e)\n    except:\n        traceback.print_exc()\n        break\n    print() \n```", "```py\n'delete from inventory where y/u-l+f/y<Y(c)/A-H*q'\n>  Tainted[y/u-l+f/y<Y(c)/A-H*q]\n\n\"insert into inventory (G,Wmp,sl3hku3) values ('<','?')\"\n\n\"insert into inventory (d0) values (',_G')\"\n\n'select P*Q-w/x from inventory where X<j==:==j*r-f'\n>  Tainted[(X<j==:==j*r-f)]\n\n'select a>F*i from inventory where Q/I-_+P*j>.'\n>  Tainted[(Q/I-_+P*j>.)]\n\n'select (V-i<T/g) from inventory where T/r/G<FK(m)/(i)'\n>  Tainted[(T/r/G<FK(m)/(i))]\n\n'select (((i))),_(S,_)/L-k<H(Sv,R,n,W,Y) from inventory'\n>  Tainted[((((i))),_(S,_)/L-k<H(Sv,R,n,W,Y))]\n\n'select (N==c*U/P/y),i-e/n*y,T!=w,u from inventory'\n>  Tainted[((N==c*U/P/y),i-e/n*y,T!=w,u)]\n\n'update inventory set _=B,n=v where o-p*k-J>T'\n\n'select s from inventory where w4g4<.m(_)/_>t'\n>  Tainted[(w4g4<.m(_)/_>t)]\n\n```", "```py\nsecrets = tstr('<Plenty of secret keys>', taint='SECRET') \n```", "```py\nsecrets[1:3].taint \n```", "```py\n'SECRET'\n\n```", "```py\nuser_input = \"hello\"\nreply = user_input \n```", "```py\nisinstance(reply, tstr) \n```", "```py\nFalse\n\n```", "```py\nreply = user_input + secrets[0:5] \n```", "```py\nreply \n```", "```py\n'hello<Plen'\n\n```", "```py\nreply.taint \n```", "```py\n'SECRET'\n\n```", "```py\ndef send_back(s):\n    assert not isinstance(s, tstr) and not s.taint == 'SECRET'\n    ... \n```", "```py\nwith ExpectError():\n    send_back(reply) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/3747050841.py\", line 2, in <module>\n    send_back(reply)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/3158733057.py\", line 2, in send_back\n    assert not isinstance(s, tstr) and not s.taint == 'SECRET'  # type: ignore\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import heartbeat \n```", "```py\nreply = heartbeat('hello', 5, memory=secrets) \n```", "```py\nreply.taint \n```", "```py\n'SECRET'\n\n```", "```py\n# Store reply in memory\n    memory = reply + memory[len(reply):] \n```", "```py\nthilo = tstr(\"High\", taint='HIGH') + tstr(\"Low\", taint='LOW') \n```", "```py\nthilo \n```", "```py\n'HighLow'\n\n```", "```py\nthilo.taint \n```", "```py\n'HIGH'\n\n```", "```py\nclass ostr(str):\n  \"\"\"Wrapper for strings, saving taint and origin information\"\"\"\n    DEFAULT_ORIGIN = 0\n\n    def __new__(cls, value, *args, **kw):\n  \"\"\"Create an ostr() instance. Used internally.\"\"\"\n        return str.__new__(cls, value)\n\n    def __init__(self, value: Any, taint: Any = None,\n                 origin: Optional[Union[int, List[int]]] = None, **kwargs) -> None:\n  \"\"\"Constructor.\n `value` is the string value the `ostr` object is to be constructed from.\n `taint` is an (optional) taint to be propagated to derived strings.\n `origin` (optional) is either\n - an integer denoting the index of the first character in `value`, or\n - a list of integers denoting the origins of the characters in `value`,\n \"\"\"\n        self.taint = taint\n\n        if origin is None:\n            origin = ostr.DEFAULT_ORIGIN\n        if isinstance(origin, int):\n            self.origin = list(range(origin, origin + len(self)))\n        else:\n            self.origin = origin\n        assert len(self.origin) == len(self) \n```", "```py\nclass ostr(ostr):\n    def create(self, s):\n        return ostr(s, taint=self.taint, origin=self.origin) \n```", "```py\nclass ostr(ostr):\n    UNKNOWN_ORIGIN = -1\n\n    def __repr__(self):\n        # handle escaped chars\n        origin = [ostr.UNKNOWN_ORIGIN]\n        for s, o in zip(str(self), self.origin):\n            origin.extend([o] * (len(repr(s)) - 2))\n\n        origin.append(ostr.UNKNOWN_ORIGIN)\n        return ostr(str.__repr__(self), taint=self.taint, origin=origin) \n```", "```py\nclass ostr(ostr):\n    def __str__(self):\n        return str.__str__(self) \n```", "```py\nothello = ostr('hello')\nassert othello.origin == [0, 1, 2, 3, 4] \n```", "```py\ntworld = ostr('world', origin=6)\nassert tworld.origin == [6, 7, 8, 9, 10] \n```", "```py\na = ostr(\"hello\\tworld\") \n```", "```py\nrepr(a).origin \n```", "```py\n[-1, 0, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, -1]\n\n```", "```py\nassert type(str(othello)) == str \n```", "```py\nrepr(othello) \n```", "```py\n\"'hello'\"\n\n```", "```py\nrepr(othello).origin \n```", "```py\n[-1, 0, 1, 2, 3, 4, -1]\n\n```", "```py\nclass ostr(ostr):\n    def clear_taint(self):\n        self.taint = None\n        return self\n\n    def has_taint(self):\n        return self.taint is not None \n```", "```py\nclass ostr(ostr):\n    def clear_origin(self):\n        self.origin = [self.UNKNOWN_ORIGIN] * len(self)\n        return self\n\n    def has_origin(self):\n        return any(origin != self.UNKNOWN_ORIGIN for origin in self.origin) \n```", "```py\nothello = ostr('Hello')\nassert othello.has_origin() \n```", "```py\nothello.clear_origin()\nassert not othello.has_origin() \n```", "```py\nclass ostr(ostr):\n    def create(self, res, origin=None):\n        return ostr(res, taint=self.taint, origin=origin) \n```", "```py\nothello = ostr('hello', taint='HIGH')\notworld = othello.create('world', origin=6) \n```", "```py\notworld.origin \n```", "```py\n[6, 7, 8, 9, 10]\n\n```", "```py\notworld.taint \n```", "```py\n'HIGH'\n\n```", "```py\nassert (othello.origin, otworld.origin) == (\n    [0, 1, 2, 3, 4], [6, 7, 8, 9, 10]) \n```", "```py\nclass ostr(ostr):\n    def __getitem__(self, key):\n        res = super().__getitem__(key)\n        if isinstance(key, int):\n            key = len(self) + key if key < 0 else key\n            return self.create(res, [self.origin[key]])\n        elif isinstance(key, slice):\n            return self.create(res, self.origin[key])\n        else:\n            assert False \n```", "```py\nohello = ostr('hello', taint='HIGH')\nassert (ohello[0], ohello[-1]) == ('h', 'o')\nohello[0].taint \n```", "```py\n'HIGH'\n\n```", "```py\nclass ostr(ostr):\n    def __iter__(self):\n        return ostr_iterator(self) \n```", "```py\nclass ostr_iterator():\n    def __init__(self, ostr):\n        self._ostr = ostr\n        self._str_idx = 0\n\n    def __next__(self):\n        if self._str_idx == len(self._ostr):\n            raise StopIteration\n        # calls ostr getitem should be ostr\n        c = self._ostr[self._str_idx]\n        assert isinstance(c, ostr)\n        self._str_idx += 1\n        return c \n```", "```py\nthw = ostr('hello world', taint='HIGH')\nthw[0:5] \n```", "```py\n'hello'\n\n```", "```py\nassert thw[0:5].has_taint()\nassert thw[0:5].has_origin() \n```", "```py\nthw[0:5].taint \n```", "```py\n'HIGH'\n\n```", "```py\nthw[0:5].origin \n```", "```py\n[0, 1, 2, 3, 4]\n\n```", "```py\ndef make_split_wrapper(fun):\n    def proxy(self, *args, **kwargs):\n        lst = fun(self, *args, **kwargs)\n        return [self.create(elem) for elem in lst]\n    return proxy \n```", "```py\nfor name in ['split', 'rsplit', 'splitlines']:\n    fun = getattr(str, name)\n    setattr(ostr, name, make_split_wrapper(fun)) \n```", "```py\nothello = ostr('hello world', taint='LOW')\nothello == 'hello world' \n```", "```py\nTrue\n\n```", "```py\nothello.split()[0].taint \n```", "```py\n'LOW'\n\n```", "```py\nclass ostr(ostr):\n    def __add__(self, other):\n        if isinstance(other, ostr):\n            return self.create(str.__add__(self, other),\n                               (self.origin + other.origin))\n        else:\n            return self.create(str.__add__(self, other),\n                               (self.origin + [self.UNKNOWN_ORIGIN for i in other])) \n```", "```py\nothello = ostr(\"hello\")\notworld = ostr(\"world\", origin=6)\nothw = othello + otworld\nassert othw.origin == [0, 1, 2, 3, 4, 6, 7, 8, 9, 10] \n```", "```py\nspace = \"  \"\nth_w = othello + space + otworld\nassert th_w.origin == [\n    0,\n    1,\n    2,\n    3,\n    4,\n    ostr.UNKNOWN_ORIGIN,\n    ostr.UNKNOWN_ORIGIN,\n    6,\n    7,\n    8,\n    9,\n    10] \n```", "```py\nclass ostr(ostr):\n    def __radd__(self, other):\n        origin = other.origin if isinstance(other, ostr) else [\n            self.UNKNOWN_ORIGIN for i in other]\n        return self.create(str.__add__(other, self), (origin + self.origin)) \n```", "```py\nshello = \"hello\"\notworld = ostr(\"world\")\nthw = shello + otworld\nassert thw.origin == [ostr.UNKNOWN_ORIGIN] * len(shello) + [0, 1, 2, 3, 4] \n```", "```py\nclass ostr(ostr):\n    class TaintException(Exception):\n        pass\n\n    def x(self, i=0):\n  \"\"\"Extract substring at index/slice `i`\"\"\"\n        if not self.origin:\n            raise origin.TaintException('Invalid request idx')\n        if isinstance(i, int):\n            return [self[p]\n                    for p in [k for k, j in enumerate(self.origin) if j == i]]\n        elif isinstance(i, slice):\n            r = range(i.start or 0, i.stop or len(self), i.step or 1)\n            return [self[p]\n                    for p in [k for k, j in enumerate(self.origin) if j in r]] \n```", "```py\nthw = ostr('hello world', origin=100) \n```", "```py\nassert thw.x(101) == ['e'] \n```", "```py\nassert thw.x(slice(101, 105)) == ['e', 'l', 'l', 'o'] \n```", "```py\nclass ostr(ostr):\n    def replace(self, a, b, n=None):\n        old_origin = self.origin\n        b_origin = b.origin if isinstance(\n            b, ostr) else [self.UNKNOWN_ORIGIN] * len(b)\n        mystr = str(self)\n        i = 0\n\n        while True:\n            if n and i >= n:\n                break\n            idx = mystr.find(a)\n            if idx == -1:\n                break\n            last = idx + len(a)\n            mystr = mystr.replace(a, b, 1)\n            partA, partB = old_origin[0:idx], old_origin[last:]\n            old_origin = partA + b_origin + partB\n            i += 1\n\n        return self.create(mystr, old_origin) \n```", "```py\nmy_str = ostr(\"aa cde aa\")\nres = my_str.replace('aa', 'bb')\nassert res, res.origin == ('bb', 'cde', 'bb',\n                           [ostr.UNKNOWN_ORIGIN, ostr.UNKNOWN_ORIGIN,\n                            2, 3, 4, 5, 6,\n                            ostr.UNKNOWN_ORIGIN, ostr.UNKNOWN_ORIGIN]) \n```", "```py\nmy_str = ostr(\"aa cde aa\")\nres = my_str.replace('aa', ostr('bb', origin=100))\nassert (\n    res, res.origin) == (\n        ('bb cde bb'), [\n            100, 101, 2, 3, 4, 5, 6, 100, 101]) \n```", "```py\nclass ostr(ostr):\n    def _split_helper(self, sep, splitted):\n        result_list = []\n        last_idx = 0\n        first_idx = 0\n        sep_len = len(sep)\n\n        for s in splitted:\n            last_idx = first_idx + len(s)\n            item = self[first_idx:last_idx]\n            result_list.append(item)\n            first_idx = last_idx + sep_len\n        return result_list\n\n    def _split_space(self, splitted):\n        result_list = []\n        last_idx = 0\n        first_idx = 0\n        sep_len = 0\n        for s in splitted:\n            last_idx = first_idx + len(s)\n            item = self[first_idx:last_idx]\n            result_list.append(item)\n            v = str(self[last_idx:])\n            sep_len = len(v) - len(v.lstrip(' '))\n            first_idx = last_idx + sep_len\n        return result_list\n\n    def rsplit(self, sep=None, maxsplit=-1):\n        splitted = super().rsplit(sep, maxsplit)\n        if not sep:\n            return self._split_space(splitted)\n        return self._split_helper(sep, splitted)\n\n    def split(self, sep=None, maxsplit=-1):\n        splitted = super().split(sep, maxsplit)\n        if not sep:\n            return self._split_space(splitted)\n        return self._split_helper(sep, splitted) \n```", "```py\nmy_str = ostr('ab cdef ghij kl')\nab, cdef, ghij, kl = my_str.rsplit(sep=' ')\nassert (ab.origin, cdef.origin, ghij.origin,\n        kl.origin) == ([0, 1], [3, 4, 5, 6], [8, 9, 10, 11], [13, 14])\n\nmy_str = ostr('ab cdef ghij kl', origin=list(range(0, 15)))\nab, cdef, ghij, kl = my_str.rsplit(sep=' ')\nassert(ab.origin, cdef.origin, kl.origin) == ([0, 1], [3, 4, 5, 6], [13, 14]) \n```", "```py\nmy_str = ostr('ab   cdef ghij    kl', origin=100, taint='HIGH')\nab, cdef, ghij, kl = my_str.rsplit()\nassert (ab.origin, cdef.origin, ghij.origin,\n        kl.origin) == ([100, 101], [105, 106, 107, 108], [110, 111, 112, 113],\n                       [118, 119])\n\nmy_str = ostr('ab   cdef ghij    kl', origin=list(range(0, 20)), taint='HIGH')\nab, cdef, ghij, kl = my_str.split()\nassert (ab.origin, cdef.origin, kl.origin) == ([0, 1], [5, 6, 7, 8], [18, 19])\nassert ab.taint == 'HIGH' \n```", "```py\nclass ostr(ostr):\n    def strip(self, cl=None):\n        return self.lstrip(cl).rstrip(cl)\n\n    def lstrip(self, cl=None):\n        res = super().lstrip(cl)\n        i = self.find(res)\n        return self[i:]\n\n    def rstrip(self, cl=None):\n        res = super().rstrip(cl)\n        return self[0:len(res)] \n```", "```py\nmy_str1 = ostr(\"  abc  \")\nv = my_str1.strip()\nassert v, v.origin == ('abc', [2, 3, 4]) \n```", "```py\nmy_str1 = ostr(\"  abc  \")\nv = my_str1.lstrip()\nassert (v, v.origin) == ('abc  ', [2, 3, 4, 5, 6]) \n```", "```py\nmy_str1 = ostr(\"  abc  \")\nv = my_str1.rstrip()\nassert (v, v.origin) == ('  abc', [0, 1, 2, 3, 4]) \n```", "```py\nclass ostr(ostr):\n    def expandtabs(self, n=8):\n        parts = self.split('\\t')\n        res = super().expandtabs(n)\n        all_parts = []\n        for i, p in enumerate(parts):\n            all_parts.extend(p.origin)\n            if i < len(parts) - 1:\n                l = len(all_parts) % n\n                all_parts.extend([p.origin[-1]] * l)\n        return self.create(res, all_parts) \n```", "```py\nmy_s = str(\"ab\\tcd\")\nmy_ostr = ostr(\"ab\\tcd\")\nv1 = my_s.expandtabs(4)\nv2 = my_ostr.expandtabs(4) \n```", "```py\nassert str(v1) == str(v2)\nassert (len(v1), repr(v2), v2.origin) == (6, \"'ab  cd'\", [0, 1, 1, 1, 3, 4]) \n```", "```py\nclass ostr(ostr):\n    def join(self, iterable):\n        mystr = ''\n        myorigin = []\n        sep_origin = self.origin\n        lst = list(iterable)\n        for i, s in enumerate(lst):\n            sorigin = s.origin if isinstance(s, ostr) else [\n                self.UNKNOWN_ORIGIN] * len(s)\n            myorigin.extend(sorigin)\n            mystr += str(s)\n            if i < len(lst) - 1:\n                myorigin.extend(sep_origin)\n                mystr += str(self)\n        res = super().join(iterable)\n        assert len(res) == len(mystr)\n        return self.create(res, myorigin) \n```", "```py\nmy_str = ostr(\"ab cd\", origin=100)\n(v1, v2), v3 = my_str.split(), 'ef'\nassert (v1.origin, v2.origin) == ([100, 101], [103, 104]) \n```", "```py\nv4 = ostr('').join([v2, v3, v1])\nassert (\n    v4, v4.origin) == (\n        'cdefab', [\n            103, 104, ostr.UNKNOWN_ORIGIN, ostr.UNKNOWN_ORIGIN, 100, 101]) \n```", "```py\nmy_str = ostr(\"ab cd\", origin=100)\n(v1, v2), v3 = my_str.split(), 'ef'\nassert (v1.origin, v2.origin) == ([100, 101], [103, 104]) \n```", "```py\nv4 = ostr(',').join([v2, v3, v1])\nassert (v4, v4.origin) == ('cd,ef,ab',\n                           [103, 104, 0, ostr.UNKNOWN_ORIGIN, ostr.UNKNOWN_ORIGIN, 0, 100, 101]) \n```", "```py\nclass ostr(ostr):\n    def partition(self, sep):\n        partA, sep, partB = super().partition(sep)\n        return (self.create(partA, self.origin[0:len(partA)]),\n                self.create(sep,\n                            self.origin[len(partA):len(partA) + len(sep)]),\n                self.create(partB, self.origin[len(partA) + len(sep):]))\n\n    def rpartition(self, sep):\n        partA, sep, partB = super().rpartition(sep)\n        return (self.create(partA, self.origin[0:len(partA)]),\n                self.create(sep,\n                            self.origin[len(partA):len(partA) + len(sep)]),\n                self.create(partB, self.origin[len(partA) + len(sep):])) \n```", "```py\nclass ostr(ostr):\n    def ljust(self, width, fillchar=' '):\n        res = super().ljust(width, fillchar)\n        initial = len(res) - len(self)\n        if isinstance(fillchar, tstr):\n            t = fillchar.x()\n        else:\n            t = self.UNKNOWN_ORIGIN\n        return self.create(res, [t] * initial + self.origin) \n```", "```py\nclass ostr(ostr):\n    def rjust(self, width, fillchar=' '):\n        res = super().rjust(width, fillchar)\n        final = len(res) - len(self)\n        if isinstance(fillchar, tstr):\n            t = fillchar.x()\n        else:\n            t = self.UNKNOWN_ORIGIN\n        return self.create(res, self.origin + [t] * final) \n```", "```py\nclass ostr(ostr):\n    def __mod__(self, s):\n        # nothing else implemented for the time being\n        assert isinstance(s, str)\n        s_origin = s.origin if isinstance(\n            s, ostr) else [self.UNKNOWN_ORIGIN] * len(s)\n        i = self.find('%s')\n        assert i >= 0\n        res = super().__mod__(s)\n        r_origin = self.origin[:]\n        r_origin[i:i + 2] = s_origin\n        return self.create(res, origin=r_origin) \n```", "```py\nclass ostr(ostr):\n    def __rmod__(self, s):\n        # nothing else implemented for the time being\n        assert isinstance(s, str)\n        r_origin = s.origin if isinstance(\n            s, ostr) else [self.UNKNOWN_ORIGIN] * len(s)\n        i = s.find('%s')\n        assert i >= 0\n        res = super().__rmod__(s)\n        s_origin = self.origin[:]\n        r_origin[i:i + 2] = s_origin\n        return self.create(res, origin=r_origin) \n```", "```py\na = ostr('hello %s world', origin=100)\na \n```", "```py\n'hello %s world'\n\n```", "```py\n(a % 'good').origin \n```", "```py\n[100, 101, 102, 103, 104, 105, -1, -1, -1, -1, 108, 109, 110, 111, 112, 113]\n\n```", "```py\nb = 'hello %s world'\nc = ostr('bad', origin=10)\n(b % c).origin \n```", "```py\n[-1, -1, -1, -1, -1, -1, 10, 11, 12, -1, -1, -1, -1, -1, -1]\n\n```", "```py\nclass ostr(ostr):\n    def swapcase(self):\n        return self.create(str(self).swapcase(), self.origin)\n\n    def upper(self):\n        return self.create(str(self).upper(), self.origin)\n\n    def lower(self):\n        return self.create(str(self).lower(), self.origin)\n\n    def capitalize(self):\n        return self.create(str(self).capitalize(), self.origin)\n\n    def title(self):\n        return self.create(str(self).title(), self.origin) \n```", "```py\na = ostr('aa', origin=100).upper()\na, a.origin \n```", "```py\n('AA', [100, 101])\n\n```", "```py\ndef make_basic_str_wrapper(fun):\n    def proxy(*args, **kwargs):\n        res = fun(*args, **kwargs)\n        return res\n    return proxy \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nimport [types](https://docs.python.org/3/library/types.html) \n```", "```py\ndef informationflow_init_2():\n    ostr_members = [name for name, fn in inspect.getmembers(ostr, callable)\n                    if isinstance(fn, types.FunctionType) and fn.__qualname__.startswith('ostr')]\n\n    for name, fn in inspect.getmembers(str, callable):\n        if name not in set(['__class__', '__new__', '__str__', '__init__',\n                            '__repr__', '__getattribute__']) | set(ostr_members):\n            setattr(ostr, name, make_basic_str_wrapper(fn)) \n```", "```py\ninformationflow_init_2() \n```", "```py\nINITIALIZER_LIST.append(informationflow_init_2) \n```", "```py\ndef make_str_abort_wrapper(fun):\n    def proxy(*args, **kwargs):\n        raise ostr.TaintException(\n            '%s Not implemented in `ostr`' %\n            fun.__name__)\n    return proxy \n```", "```py\ndef informationflow_init_3():\n    for name, fn in inspect.getmembers(str, callable):\n        # Omitted 'splitlines' as this is needed for formatting output in\n        # IPython/Jupyter\n        if name in ['__format__', 'format_map', 'format',\n                    '__mul__', '__rmul__', 'center', 'zfill', 'decode', 'encode']:\n            setattr(ostr, name, make_str_abort_wrapper(fn)) \n```", "```py\ninformationflow_init_3() \n```", "```py\nINITIALIZER_LIST.append(informationflow_init_3) \n```", "```py\ns = ostr(\"hello\", origin=100)\ns[1] \n```", "```py\n'e'\n\n```", "```py\ns[1].origin \n```", "```py\n[101]\n\n```", "```py\nset(s[1].origin) <= set(s.origin) \n```", "```py\nTrue\n\n```", "```py\nt = ostr(\"world\", origin=200) \n```", "```py\nset(s.origin) <= set(t.origin) \n```", "```py\nFalse\n\n```", "```py\nu = s + t + \"!\" \n```", "```py\nu.origin \n```", "```py\n[100, 101, 102, 103, 104, 200, 201, 202, 203, 204, -1]\n\n```", "```py\nostr.UNKNOWN_ORIGIN in u.origin \n```", "```py\nTrue\n\n```", "```py\nSECRET_ORIGIN = 1000 \n```", "```py\nsecret = ostr('<again, some super-secret input>', origin=SECRET_ORIGIN) \n```", "```py\nprint(secret.origin) \n```", "```py\n[1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031]\n\n```", "```py\nhello_s = heartbeat('hello', 5, memory=secret)\nhello_s \n```", "```py\n'hello'\n\n```", "```py\nassert isinstance(hello_s, ostr) \n```", "```py\nprint(hello_s.origin) \n```", "```py\n[-1, -1, -1, -1, -1]\n\n```", "```py\nassert hello_s.origin == [ostr.UNKNOWN_ORIGIN] * len(hello_s) \n```", "```py\nassert all(origin == ostr.UNKNOWN_ORIGIN for origin in hello_s.origin) \n```", "```py\nassert not any(origin >= SECRET_ORIGIN for origin in hello_s.origin) \n```", "```py\nhello_s = heartbeat('hello', 32, memory=secret)\nhello_s \n```", "```py\n'hellon, some super-secret input>'\n\n```", "```py\nassert isinstance(hello_s, ostr) \n```", "```py\nprint(hello_s.origin) \n```", "```py\n[-1, -1, -1, -1, -1, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029, 1030, 1031]\n\n```", "```py\nwith ExpectError():\n    assert hello_s.origin == [ostr.UNKNOWN_ORIGIN] * len(hello_s) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/2698516187.py\", line 2, in <module>\n    assert hello_s.origin == [ostr.UNKNOWN_ORIGIN] * len(hello_s)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\nwith ExpectError():\n    assert all(origin == ostr.UNKNOWN_ORIGIN for origin in hello_s.origin) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/1358366226.py\", line 2, in <module>\n    assert all(origin == ostr.UNKNOWN_ORIGIN for origin in hello_s.origin)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\nwith ExpectError():\n    assert not any(origin >= SECRET_ORIGIN for origin in hello_s.origin) \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/1577803914.py\", line 2, in <module>\n    assert not any(origin >= SECRET_ORIGIN for origin in hello_s.origin)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError (expected)\n\n```", "```py\nclass TrackingDB(TaintedDB):\n    def my_eval(self, statement, g, l):\n        if statement.origin:\n            raise Tainted(statement)\n        try:\n            return eval(statement, g, l)\n        except:\n            raise SQLException('Invalid SQL (%s)' % repr(statement)) \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer \n```", "```py\nfrom [Parser](Parser.html) import canonical \n```", "```py\nclass TaintedGrammarFuzzer(GrammarFuzzer):\n    def __init__(self,\n                 grammar,\n                 start_symbol=START_SYMBOL,\n                 expansion_switch=1,\n                 log=False):\n        self.tainted_start_symbol = ostr(\n            start_symbol, origin=[1] * len(start_symbol))\n        self.expansion_switch = expansion_switch\n        self.log = log\n        self.grammar = grammar\n        self.c_grammar = canonical(grammar)\n        self.init_tainted_grammar()\n\n    def expansion_cost(self, expansion, seen=set()):\n        symbols = [e for e in expansion if e in self.c_grammar]\n        if len(symbols) == 0:\n            return 1\n\n        if any(s in seen for s in symbols):\n            return float('inf')\n\n        return sum(self.symbol_cost(s, seen) for s in symbols) + 1\n\n    def fuzz_tree(self):\n        tree = (self.tainted_start_symbol, [])\n        nt_leaves = [tree]\n        expansion_trials = 0\n        while nt_leaves:\n            idx = random.randint(0, len(nt_leaves) - 1)\n            key, children = nt_leaves[idx]\n            expansions = self.ct_grammar[key]\n            if expansion_trials < self.expansion_switch:\n                expansion = random.choice(expansions)\n            else:\n                costs = [self.expansion_cost(e) for e in expansions]\n                m = min(costs)\n                all_min = [i for i, c in enumerate(costs) if c == m]\n                expansion = expansions[random.choice(all_min)]\n\n            new_leaves = [(token, []) for token in expansion]\n            new_nt_leaves = [e for e in new_leaves if e[0] in self.ct_grammar]\n            children[:] = new_leaves\n            nt_leaves[idx:idx + 1] = new_nt_leaves\n            if self.log:\n                print(\"%-40s\" % (key + \" -> \" + str(expansion)))\n            expansion_trials += 1\n        return tree\n\n    def fuzz(self):\n        self.derivation_tree = self.fuzz_tree()\n        return self.tree_to_string(self.derivation_tree) \n```", "```py\nclass TaintedGrammarFuzzer(TaintedGrammarFuzzer):\n    def init_tainted_grammar(self):\n        key_increment, alt_increment, token_increment = 1000, 100, 10\n        key_origin = key_increment\n        self.ct_grammar = {}\n        for key, val in self.c_grammar.items():\n            key_origin += key_increment\n            os = []\n            for v in val:\n                ts = []\n                key_origin += alt_increment\n                for t in v:\n                    nt = ostr(t, origin=key_origin)\n                    key_origin += token_increment\n                    ts.append(nt)\n                os.append(ts)\n            self.ct_grammar[key] = os\n\n        # a use tracking grammar\n        self.ctp_grammar = {}\n        for key, val in self.ct_grammar.items():\n            self.ctp_grammar[key] = [(v, dict(use=0)) for v in val] \n```", "```py\ntrdb = TrackingDB(db.db) \n```", "```py\nclass TaintedGrammarFuzzer(TaintedGrammarFuzzer):\n    def tree_to_string(self, tree):\n        symbol, children, *_ = tree\n        e = ostr('')\n        if children:\n            return e.join([self.tree_to_string(c) for c in children])\n        else:\n            return e if symbol in self.c_grammar else symbol \n```", "```py\nclass TaintedGrammarFuzzer(TaintedGrammarFuzzer):\n    def update_grammar(self, origin, dtree):\n        def update_tree(dtree, origin):\n            key, children = dtree\n            if children:\n                updated_children = [update_tree(c, origin) for c in children]\n                corigin = set.union(\n                    *[o for (key, children, o) in updated_children])\n                corigin = corigin.union(set(key.origin))\n                return (key, children, corigin)\n            else:\n                my_origin = set(key.origin).intersection(origin)\n                return (key, [], my_origin)\n\n        key, children, oset = update_tree(dtree, set(origin))\n        for key, alts in self.ctp_grammar.items():\n            for alt, o in alts:\n                alt_origins = set([i for token in alt for i in token.origin])\n                if alt_origins.intersection(oset):\n                    o['use'] += 1 \n```", "```py\ndef tree_type(tree):\n    key, children = tree\n    return (type(key), key, [tree_type(c) for c in children]) \n```", "```py\ntgf = TaintedGrammarFuzzer(INVENTORY_GRAMMAR_F)\nx = None\nfor _ in range(10):\n    qtree = tgf.fuzz_tree()\n    query = tgf.tree_to_string(qtree)\n    assert isinstance(query, ostr)\n    try:\n        print(repr(query))\n        res = trdb.sql(query)\n        print(repr(res))\n    except SQLException as e:\n        print(e)\n    except Tainted as e:\n        print(e)\n        origin = e.args[0].origin\n        tgf.update_grammar(origin, qtree)\n    except:\n        traceback.print_exc()\n        break\n    print() \n```", "```py\n'select (g!=(9)!=((:)==2==9)!=J)==-7 from inventory'\nTainted[((g!=(9)!=((:)==2==9)!=J)==-7)]\n\n'delete from inventory where ((c)==T)!=5==(8!=Y)!=-5'\nTainted[((c)==T)!=5==(8!=Y)!=-5]\n\n'select (((w==(((X!=------8)))))) from inventory'\nTainted[((((w==(((X!=------8)))))))]\n\n'delete from inventory where ((.==(-3)!=(((-3))))!=(S==(((n))==Y))!=--2!=N==-----0==--0)!=(((((R))))==((v)))!=((((((------2==Q==-8!=(q)!=(((.!=2))==J)!=(1)!=(((-4!=--5==J!=(((A==.)))))!=(((((0==(P!=((R))!=(((j)))!=7))))==O==K))==(q))==--1==((H)==(t)==s!=-6==((y))==R)!=((H))!=W==--4==(P==(u)==-0)!=O==((-5==-------2!=4!=U))!=-1==((((((R!=-6))))))!=1!=Z)))==(((I)!=((S))!=(-4==s)==(7!=(A))==(s)==p==((_)!=(C))==((w)))))))'\nTainted[((.==(-3)!=(((-3))))!=(S==(((n))==Y))!=--2!=N==-----0==--0)!=(((((R))))==((v)))!=((((((------2==Q==-8!=(q)!=(((.!=2))==J)!=(1)!=(((-4!=--5==J!=(((A==.)))))!=(((((0==(P!=((R))!=(((j)))!=7))))==O==K))==(q))==--1==((H)==(t)==s!=-6==((y))==R)!=((H))!=W==--4==(P==(u)==-0)!=O==((-5==-------2!=4!=U))!=-1==((((((R!=-6))))))!=1!=Z)))==(((I)!=((S))!=(-4==s)==(7!=(A))==(s)==p==((_)!=(C))==((w)))))))]\n\n'delete from inventory where ((2)==T!=-1)==N==(P)==((((((6==a)))))!=8)==(3)!=((---7))'\nTainted[((2)==T!=-1)==N==(P)==((((((6==a)))))!=8)==(3)!=((---7))]\n\n'delete from inventory where o!=2==---5==3!=t'\nTainted[o!=2==---5==3!=t]\n\n'select (2) from inventory'\nTainted[((2))]\n\n'select _ from inventory'\nTainted[(_)]\n\n'select L!=(((1!=(Z)==C)!=C))==(((-0==-5==Q!=((--2!=(-0)==((0))==M)==(A))!=(X)!=e==(K==((b)))!=b==9==((((l)!=-7!=4)!=s==G))!=6==((((5==(((v==(((((((a!=d))==0!=4!=(4)==--1==(h)==-8!=(9)==-4)))))!=I!=-4))==v!=(Y==b)))==(a))!=((7)))))))==((4)) from inventory'\nTainted[(L!=(((1!=(Z)==C)!=C))==(((-0==-5==Q!=((--2!=(-0)==((0))==M)==(A))!=(X)!=e==(K==((b)))!=b==9==((((l)!=-7!=4)!=s==G))!=6==((((5==(((v==(((((((a!=d))==0!=4!=(4)==--1==(h)==-8!=(9)==-4)))))!=I!=-4))==v!=(Y==b)))==(a))!=((7)))))))==((4)))]\n\n'delete from inventory where _==(7==(9)!=(---5)==1)==-8'\nTainted[_==(7==(9)!=(---5)==1)==-8]\n\n```", "```py\ntgf.ctp_grammar \n```", "```py\n{'<start>': [(['<query>'], {'use': 10})],\n '<expr>': [(['<bexpr>'], {'use': 8}),\n  (['<aexpr>'], {'use': 8}),\n  (['(', '<expr>', ')'], {'use': 8}),\n  (['<term>'], {'use': 10})],\n '<bexpr>': [(['<aexpr>', '<lt>', '<aexpr>'], {'use': 0}),\n  (['<aexpr>', '<gt>', '<aexpr>'], {'use': 0}),\n  (['<expr>', '==', '<expr>'], {'use': 8}),\n  (['<expr>', '!=', '<expr>'], {'use': 8})],\n '<aexpr>': [(['<aexpr>', '+', '<aexpr>'], {'use': 0}),\n  (['<aexpr>', '-', '<aexpr>'], {'use': 0}),\n  (['<aexpr>', '*', '<aexpr>'], {'use': 0}),\n  (['<aexpr>', '/', '<aexpr>'], {'use': 0}),\n  (['<word>', '(', '<exprs>', ')'], {'use': 0}),\n  (['<expr>'], {'use': 8})],\n '<exprs>': [(['<expr>', ',', '<exprs>'], {'use': 0}),\n  (['<expr>'], {'use': 5})],\n '<lt>': [(['<'], {'use': 0})],\n '<gt>': [(['>'], {'use': 0})],\n '<term>': [(['<number>'], {'use': 9}), (['<word>'], {'use': 9})],\n '<number>': [(['<integer>', '.', '<integer>'], {'use': 0}),\n  (['<integer>'], {'use': 9}),\n  (['-', '<number>'], {'use': 8})],\n '<integer>': [(['<digit>', '<integer>'], {'use': 0}),\n  (['<digit>'], {'use': 9})],\n '<word>': [(['<word>', '<letter>'], {'use': 0}),\n  (['<word>', '<digit>'], {'use': 0}),\n  (['<letter>'], {'use': 9})],\n '<digit>': [(['0'], {'use': 2}),\n  (['1'], {'use': 4}),\n  (['2'], {'use': 6}),\n  (['3'], {'use': 3}),\n  (['4'], {'use': 2}),\n  (['5'], {'use': 5}),\n  (['6'], {'use': 3}),\n  (['7'], {'use': 5}),\n  (['8'], {'use': 6}),\n  (['9'], {'use': 3})],\n '<letter>': [(['a'], {'use': 2}),\n  (['b'], {'use': 1}),\n  (['c'], {'use': 1}),\n  (['d'], {'use': 1}),\n  (['e'], {'use': 1}),\n  (['f'], {'use': 0}),\n  (['g'], {'use': 1}),\n  (['h'], {'use': 1}),\n  (['i'], {'use': 0}),\n  (['j'], {'use': 1}),\n  (['k'], {'use': 0}),\n  (['l'], {'use': 1}),\n  (['m'], {'use': 0}),\n  (['n'], {'use': 1}),\n  (['o'], {'use': 1}),\n  (['p'], {'use': 1}),\n  (['q'], {'use': 1}),\n  (['r'], {'use': 0}),\n  (['s'], {'use': 2}),\n  (['t'], {'use': 2}),\n  (['u'], {'use': 1}),\n  (['v'], {'use': 2}),\n  (['w'], {'use': 2}),\n  (['x'], {'use': 0}),\n  (['y'], {'use': 1}),\n  (['z'], {'use': 0}),\n  (['A'], {'use': 2}),\n  (['B'], {'use': 0}),\n  (['C'], {'use': 2}),\n  (['D'], {'use': 0}),\n  (['E'], {'use': 0}),\n  (['F'], {'use': 0}),\n  (['G'], {'use': 1}),\n  (['H'], {'use': 1}),\n  (['I'], {'use': 2}),\n  (['J'], {'use': 2}),\n  (['K'], {'use': 2}),\n  (['L'], {'use': 1}),\n  (['M'], {'use': 1}),\n  (['N'], {'use': 2}),\n  (['O'], {'use': 1}),\n  (['P'], {'use': 2}),\n  (['Q'], {'use': 2}),\n  (['R'], {'use': 1}),\n  (['S'], {'use': 1}),\n  (['T'], {'use': 2}),\n  (['U'], {'use': 1}),\n  (['V'], {'use': 0}),\n  (['W'], {'use': 1}),\n  (['X'], {'use': 2}),\n  (['Y'], {'use': 3}),\n  (['Z'], {'use': 2}),\n  (['_'], {'use': 3}),\n  ([':'], {'use': 1}),\n  (['.'], {'use': 1})],\n '<query>': [(['select ', '<exprs>', ' from ', '<table>'], {'use': 5}),\n  (['select ', '<exprs>', ' from ', '<table>', ' where ', '<bexpr>'],\n   {'use': 0}),\n  (['insert into ',\n    '<table>',\n    ' (',\n    '<names>',\n    ') values (',\n    '<literals>',\n    ')'],\n   {'use': 0}),\n  (['update ', '<table>', ' set ', '<assignments>', ' where ', '<bexpr>'],\n   {'use': 0}),\n  (['delete from ', '<table>', ' where ', '<bexpr>'], {'use': 5})],\n '<table>': [(['inventory'], {'use': 0})],\n '<names>': [(['<column>', ',', '<names>'], {'use': 0}),\n  (['<column>'], {'use': 0})],\n '<column>': [(['<word>'], {'use': 0})],\n '<literals>': [(['<literal>'], {'use': 0}),\n  (['<literal>', ',', '<literals>'], {'use': 0})],\n '<literal>': [(['<number>'], {'use': 0}),\n  ([\"'\", '<chars>', \"'\"], {'use': 0})],\n '<assignments>': [(['<kvp>', ',', '<assignments>'], {'use': 0}),\n  (['<kvp>'], {'use': 0})],\n '<kvp>': [(['<column>', '=', '<value>'], {'use': 0})],\n '<value>': [(['<word>'], {'use': 0})],\n '<chars>': [(['<char>'], {'use': 0}), (['<char>', '<chars>'], {'use': 0})],\n '<char>': [(['0'], {'use': 0}),\n  (['1'], {'use': 0}),\n  (['2'], {'use': 0}),\n  (['3'], {'use': 0}),\n  (['4'], {'use': 0}),\n  (['5'], {'use': 0}),\n  (['6'], {'use': 0}),\n  (['7'], {'use': 0}),\n  (['8'], {'use': 0}),\n  (['9'], {'use': 0}),\n  (['a'], {'use': 0}),\n  (['b'], {'use': 0}),\n  (['c'], {'use': 0}),\n  (['d'], {'use': 0}),\n  (['e'], {'use': 0}),\n  (['f'], {'use': 0}),\n  (['g'], {'use': 0}),\n  (['h'], {'use': 0}),\n  (['i'], {'use': 0}),\n  (['j'], {'use': 0}),\n  (['k'], {'use': 0}),\n  (['l'], {'use': 0}),\n  (['m'], {'use': 0}),\n  (['n'], {'use': 0}),\n  (['o'], {'use': 0}),\n  (['p'], {'use': 0}),\n  (['q'], {'use': 0}),\n  (['r'], {'use': 0}),\n  (['s'], {'use': 0}),\n  (['t'], {'use': 0}),\n  (['u'], {'use': 0}),\n  (['v'], {'use': 0}),\n  (['w'], {'use': 0}),\n  (['x'], {'use': 0}),\n  (['y'], {'use': 0}),\n  (['z'], {'use': 0}),\n  (['A'], {'use': 0}),\n  (['B'], {'use': 0}),\n  (['C'], {'use': 0}),\n  (['D'], {'use': 0}),\n  (['E'], {'use': 0}),\n  (['F'], {'use': 0}),\n  (['G'], {'use': 0}),\n  (['H'], {'use': 0}),\n  (['I'], {'use': 0}),\n  (['J'], {'use': 0}),\n  (['K'], {'use': 0}),\n  (['L'], {'use': 0}),\n  (['M'], {'use': 0}),\n  (['N'], {'use': 0}),\n  (['O'], {'use': 0}),\n  (['P'], {'use': 0}),\n  (['Q'], {'use': 0}),\n  (['R'], {'use': 0}),\n  (['S'], {'use': 0}),\n  (['T'], {'use': 0}),\n  (['U'], {'use': 0}),\n  (['V'], {'use': 0}),\n  (['W'], {'use': 0}),\n  (['X'], {'use': 0}),\n  (['Y'], {'use': 0}),\n  (['Z'], {'use': 0}),\n  (['!'], {'use': 0}),\n  (['#'], {'use': 0}),\n  (['$'], {'use': 0}),\n  (['%'], {'use': 0}),\n  (['&'], {'use': 0}),\n  (['('], {'use': 0}),\n  ([')'], {'use': 0}),\n  (['*'], {'use': 0}),\n  (['+'], {'use': 0}),\n  ([','], {'use': 0}),\n  (['-'], {'use': 0}),\n  (['.'], {'use': 0}),\n  (['/'], {'use': 0}),\n  ([':'], {'use': 0}),\n  ([';'], {'use': 0}),\n  (['='], {'use': 0}),\n  (['?'], {'use': 0}),\n  (['@'], {'use': 0}),\n  (['['], {'use': 0}),\n  (['\\\\'], {'use': 0}),\n  ([']'], {'use': 0}),\n  (['^'], {'use': 0}),\n  (['_'], {'use': 0}),\n  (['`'], {'use': 0}),\n  (['{'], {'use': 0}),\n  (['|'], {'use': 0}),\n  (['}'], {'use': 0}),\n  (['~'], {'use': 0}),\n  ([' '], {'use': 0}),\n  (['<lt>'], {'use': 0}),\n  (['<gt>'], {'use': 0})]}\n\n```", "```py\ndef strip_all_info(s):\n    t = \"\"\n    for c in s:\n        t += chr(ord(c))\n    return t \n```", "```py\nothello = ostr(\"Secret\")\nothello \n```", "```py\n'Secret'\n\n```", "```py\nothello.origin \n```", "```py\n[0, 1, 2, 3, 4, 5]\n\n```", "```py\nthello_stripped = strip_all_info(thello)\nthello_stripped \n```", "```py\n'hello, world'\n\n```", "```py\nwith ExpectError():\n    thello_stripped.origin \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/588526133.py\", line 2, in <module>\n    thello_stripped.origin\nAttributeError: 'str' object has no attribute 'origin' (expected)\n\n```", "```py\nhello = ostr('hello', origin=100)\nworld = ostr('world', origin=200)\n(hello + ' ' + world).origin \n```", "```py\n[100, 101, 102, 103, 104, -1, 200, 201, 202, 203, 204]\n\n```", "```py\nwith ExpectError():\n    ''.join([hello, ' ', world]).origin \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_34365/2341342688.py\", line 2, in <module>\n    ''.join([hello, ' ', world]).origin  # type: ignore\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAttributeError: 'str' object has no attribute 'origin' (expected)\n\n```", "```py\ndef strip_all_info_again(s):\n    t = \"\"\n    for c in s:\n        if c == 'a':\n            t += 'a'\n        elif c == 'b':\n            t += 'b'\n        elif c == 'c':\n            t += 'c'\n    ... \n```", "```py\nx = tint(42, taint='SECRET')\nassert x.taint == 'SECRET' \n```", "```py\ny = x + 1\nassert y.taint == 'SECRET' \n```", "```py\nx_s = repr(x)\nassert x_s.taint == 'SECRET' \n```", "```py\npassword = tstr('1234', taint='NOT_EXACTLY_SECRET')\nx = tint(password)\nassert x == 1234\nassert x.taint == 'NOT_EXACTLY_SECRET' \n```", "```py\n@incollection{fuzzingbook2024:InformationFlow,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Tracking Information Flow},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/InformationFlow.html}},\n    note = {Retrieved 2024-11-09 17:07:29+01:00},\n    url = {https://www.fuzzingbook.org/html/InformationFlow.html},\n    urldate = {2024-11-09 17:07:29+01:00}\n}\n\n```"]