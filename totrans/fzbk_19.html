<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Fuzzing with Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Fuzzing with Generators</h1>
<blockquote>原文：<a href="http://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html">http://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html</a></blockquote>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In this chapter, we show how to extend grammars with <em>functions</em> – pieces of code that get executed during grammar expansion, and that can generate, check, or change elements produced.  Adding functions to a grammar allows for very versatile test generation, bringing together the best of grammar generation and programming.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">'6Z35ChunpLY'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

        

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p><strong>Prerequisites</strong></p>
<ul>
<li>As this chapter deeply interacts with the techniques discussed in the <a href="GrammarFuzzer.html">chapter on efficient grammar fuzzing</a>, a good understanding of the techniques is recommended.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><div class="synopsis"><h2 id="Synopsis">Synopsis</h2><!-- Automatically generated. Do not edit. -->

<p>To <a href="Importing.html">use the code provided in this chapter</a>, write</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="GeneratorGrammarFuzzer.html" class="import" target="_blank">fuzzingbook.GeneratorGrammarFuzzer</a></span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
<p>and then make use of the following features.</p>
<p>This chapter introduces the ability to attach <em>functions</em> to individual production rules:</p>
<ul>
<li>A <code>pre</code> function is executed <em>before</em> the expansion takes place.  Its result (typically a string) can <em>replace</em> the actual expansion.</li>
<li>A <code>post</code> function is executed <em>after</em> the expansion has taken place.  If it returns a string, the string replaces the expansion; if it returns <code>False</code>, it triggers a new expansion.</li>
</ul>
<p>Both functions can return <code>None</code> to not interfere with grammar production at all.</p>
<p>To attach a function <code>F</code> to an individual expansion <code>S</code> in a grammar, replace <code>S</code> with a pair</p>
<div class="highlight"><pre><span/><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">F</span><span class="p">))</span>   <span class="c1"># Set a function to be executed before expansion</span>
</pre></div>
<p>or</p>
<div class="highlight"><pre><span/><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="n">F</span><span class="p">))</span>  <span class="c1"># Set a function to be executed after expansion</span>
</pre></div>
<p>Here is an example, To take an area code from a list that is given programmatically, we can write:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">opts</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">pick_area_code</span><span class="p">():</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">'555'</span><span class="p">,</span> <span class="s1">'554'</span><span class="p">,</span> <span class="s1">'553'</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">PICKED_US_PHONE_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">US_PHONE_GRAMMAR</span><span class="p">,</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span>
<span class="o">&gt;&gt;&gt;</span>     <span class="s2">"&lt;area&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;lead-digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">pick_area_code</span><span class="p">))]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">})</span>
</pre></div>
<p>A <code>GeneratorGrammarFuzzer</code> will extract and interpret these options.  Here is an example:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">picked_us_phone_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">PICKED_US_PHONE_GRAMMAR</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">picked_us_phone_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">[</span><span class="s1">'(554)732-6097'</span><span class="p">,</span>
 <span class="s1">'(555)469-0662'</span><span class="p">,</span>
 <span class="s1">'(553)671-5358'</span><span class="p">,</span>
 <span class="s1">'(555)686-8011'</span><span class="p">,</span>
 <span class="s1">'(554)453-4067'</span><span class="p">]</span>
</pre></div>
<p>As you can see, the area codes now all stem from <code>pick_area_code()</code>.  Such definitions allow  closely tying program code (such as <code>pick_area_code()</code>) to grammars.</p>
<p>The <code>PGGCFuzzer</code> class incorporates all features from <a href="GrammarFuzzer.html">the <code>GrammarFuzzer</code> class</a> and its <a href="GrammarCoverageFuzzer.html">coverage-based</a>, <a href="ProbabilisticGrammarFuzzer.html">probabilistic-based</a>, and <a href="GeneratorGrammarFuzzer.html">generator-based</a> derivatives.</p>
<p>

<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="566pt" height="877pt" viewbox="0.00 0.00 565.75 876.75" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 872.75)">
<g id="a_graph0"><a xlink:title="PGGCFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-872.75 561.75,-872.75 561.75,4 -4,4"/>
</a>
</g>
<!-- PGGCFuzzer -->
<g id="node1" class="node">
<title>PGGCFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class PGGCFuzzer:&#10;The one grammar-based fuzzer that supports all fuzzingbook features">
<polygon fill="none" stroke="black" points="154.12,-6.5 154.12,-42.5 245.88,-42.5 245.88,-6.5 154.12,-6.5"/>
<text text-anchor="start" x="162.12" y="-21.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">PGGCFuzzer</text>
</a>
</g>
</g>
<!-- ProbabilisticGeneratorGrammarCoverageFuzzer -->
<g id="node2" class="node">
<title>ProbabilisticGeneratorGrammarCoverageFuzzer</title>
<g id="a_node2"><a xlink:href="#" xlink:title="class ProbabilisticGeneratorGrammarCoverageFuzzer:&#10;Join the features of `GeneratorGrammarFuzzer`&#10;and `ProbabilisticGrammarCoverageFuzzer`">
<polygon fill="none" stroke="black" points="44.62,-85.5 44.62,-183.25 355.38,-183.25 355.38,-85.5 44.62,-85.5"/>
<text text-anchor="start" x="52.62" y="-166.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProbabilisticGeneratorGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="44.62,-157.25 355.38,-157.25"/>
<g id="a_node2_0"><a xlink:href="#" xlink:title="ProbabilisticGeneratorGrammarCoverageFuzzer">
<g id="a_node2_1"><a xlink:href="#" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], *, replacement_attempts: int = 10, **kwargs) -&gt; None:&#10;Constructor.&#10;`replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.&#10;All other keywords go into `ProbabilisticGrammarFuzzer`.">
<text text-anchor="start" x="143" y="-144.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node2_2"><a xlink:href="#" xlink:title="fuzz_tree(self) -&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="143" y="-132" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text>
</a>
</g>
<g id="a_node2_3"><a xlink:href="#" xlink:title="add_tree_coverage(self, tree: DerivationTree) -&gt; None">
<text text-anchor="start" x="143" y="-118.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">add_tree_coverage()</text>
</a>
</g>
<g id="a_node2_4"><a xlink:href="#" xlink:title="restart_expansion(self) -&gt; None">
<text text-anchor="start" x="143" y="-106.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">restart_expansion()</text>
</a>
</g>
<g id="a_node2_5"><a xlink:href="#" xlink:title="supported_opts(self) -&gt; Set[str]:&#10;Set of supported options. To be overloaded in subclasses.">
<text text-anchor="start" x="143" y="-93.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">supported_opts()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- PGGCFuzzer&#45;&gt;ProbabilisticGeneratorGrammarCoverageFuzzer -->
<g id="edge1" class="edge">
<title>PGGCFuzzer-&gt;ProbabilisticGeneratorGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M200,-42.83C200,-51.5 200,-62.55 200,-73.93"/>
<polygon fill="none" stroke="black" points="196.5,-73.84 200,-83.84 203.5,-73.84 196.5,-73.84"/>
</g>
<!-- GeneratorGrammarFuzzer -->
<g id="node3" class="node">
<title>GeneratorGrammarFuzzer</title>
<g id="a_node3"><a xlink:href="#" xlink:title="class GeneratorGrammarFuzzer:&#10;Produce strings from grammars efficiently, using derivation trees.">
<polygon fill="none" stroke="black" points="0,-366.25 0,-578.75 184,-578.75 184,-366.25 0,-366.25"/>
<text text-anchor="start" x="11.38" y="-562.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GeneratorGrammarFuzzer</text>
<polyline fill="none" stroke="black" points="0,-552.75 184,-552.75"/>
<g id="a_node3_6"><a xlink:href="#" xlink:title="GeneratorGrammarFuzzer">
<g id="a_node3_7"><a xlink:href="#" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], replacement_attempts: int = 10, **kwargs) -&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="8" y="-540.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node3_8"><a xlink:href="#" xlink:title="fuzz_tree(self) -&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="8" y="-527.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text>
</a>
</g>
<g id="a_node3_9"><a xlink:href="#" xlink:title="apply_result(self, result: Any, children: List[DerivationTree]) -&gt; List[DerivationTree]">
<text text-anchor="start" x="8" y="-513.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">apply_result()</text>
</a>
</g>
<g id="a_node3_10"><a xlink:href="#" xlink:title="choose_tree_expansion(self, tree: DerivationTree, expandable_children: List[DerivationTree]) -&gt; int:&#10;Return index of subtree in `expandable_children`&#10;to be selected for expansion. Defaults to random.">
<text text-anchor="start" x="8" y="-502" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">choose_tree_expansion()</text>
</a>
</g>
<g id="a_node3_11"><a xlink:href="#" xlink:title="eval_function(self, tree, function)">
<text text-anchor="start" x="8" y="-488.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">eval_function()</text>
</a>
</g>
<g id="a_node3_12"><a xlink:href="#" xlink:title="expand_tree_once(self, tree: DerivationTree) -&gt; DerivationTree:&#10;Choose an unexpanded symbol in tree; expand it.&#10;Can be overloaded in subclasses.">
<text text-anchor="start" x="8" y="-476.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">expand_tree_once()</text>
</a>
</g>
<g id="a_node3_13"><a xlink:href="#" xlink:title="find_expansion(self, tree)">
<text text-anchor="start" x="8" y="-462.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">find_expansion()</text>
</a>
</g>
<g id="a_node3_14"><a xlink:href="#" xlink:title="process_chosen_children(self, children: List[DerivationTree], expansion: Expansion) -&gt; List[DerivationTree]:&#10;Process children after selection.  By default, does nothing.">
<text text-anchor="start" x="8" y="-451" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">process_chosen_children()</text>
</a>
</g>
<g id="a_node3_15"><a xlink:href="#" xlink:title="reset_generators(self) -&gt; None">
<text text-anchor="start" x="8" y="-437.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">reset_generators()</text>
</a>
</g>
<g id="a_node3_16"><a xlink:href="#" xlink:title="restart_expansion(self) -&gt; None">
<text text-anchor="start" x="8" y="-425.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">restart_expansion()</text>
</a>
</g>
<g id="a_node3_17"><a xlink:href="#" xlink:title="run_generator(self, expansion: Expansion, function: Callable) -&gt; Iterator">
<text text-anchor="start" x="8" y="-411.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">run_generator()</text>
</a>
</g>
<g id="a_node3_18"><a xlink:href="#" xlink:title="run_post_functions(self, tree: DerivationTree, depth: Union[int, float] = inf) -&gt; Tuple[bool, Optional[List[DerivationTree]]]">
<text text-anchor="start" x="8" y="-399" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">run_post_functions()</text>
</a>
</g>
<g id="a_node3_19"><a xlink:href="#" xlink:title="run_post_functions_locally(self, new_tree: DerivationTree) -&gt; DerivationTree">
<text text-anchor="start" x="8" y="-386.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">run_post_functions_locally()</text>
</a>
</g>
<g id="a_node3_20"><a xlink:href="#" xlink:title="supported_opts(self) -&gt; Set[str]:&#10;Set of supported options. To be overloaded in subclasses.">
<text text-anchor="start" x="8" y="-374.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">supported_opts()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- ProbabilisticGeneratorGrammarCoverageFuzzer&#45;&gt;GeneratorGrammarFuzzer -->
<g id="edge2" class="edge">
<title>ProbabilisticGeneratorGrammarCoverageFuzzer-&gt;GeneratorGrammarFuzzer</title>
<path fill="none" stroke="black" d="M184.53,-183.53C170.2,-228.14 148.31,-296.25 129.42,-355.03"/>
<polygon fill="none" stroke="black" points="126.12,-353.86 126.4,-364.45 132.79,-356 126.12,-353.86"/>
</g>
<!-- ProbabilisticGrammarCoverageFuzzer -->
<g id="node6" class="node">
<title>ProbabilisticGrammarCoverageFuzzer</title>
<g id="a_node6"><a xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="class ProbabilisticGrammarCoverageFuzzer:&#10;Produce from grammars, aiming for coverage of all expansions.">
<polygon fill="none" stroke="black" points="184.38,-220.25 184.38,-256.25 433.62,-256.25 433.62,-220.25 184.38,-220.25"/>
<text text-anchor="start" x="192.38" y="-234.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProbabilisticGrammarCoverageFuzzer</text>
</a>
</g>
</g>
<!-- ProbabilisticGeneratorGrammarCoverageFuzzer&#45;&gt;ProbabilisticGrammarCoverageFuzzer -->
<g id="edge5" class="edge">
<title>ProbabilisticGeneratorGrammarCoverageFuzzer-&gt;ProbabilisticGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M251.63,-183.63C262.14,-193.45 272.79,-203.4 282.01,-212.03"/>
<polygon fill="none" stroke="black" points="279.57,-214.53 289.26,-218.8 284.35,-209.42 279.57,-214.53"/>
</g>
<!-- GrammarFuzzer -->
<g id="node4" class="node">
<title>GrammarFuzzer</title>
<g id="a_node4"><a xlink:href="GrammarFuzzer.html" xlink:title="class GrammarFuzzer:&#10;Produce strings from grammars efficiently, using derivation trees.">
<polygon fill="none" stroke="black" points="176.12,-699.5 176.12,-771.75 291.88,-771.75 291.88,-699.5 176.12,-699.5"/>
<text text-anchor="start" x="184.12" y="-755.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarFuzzer</text>
<polyline fill="none" stroke="black" points="176.12,-745.75 291.88,-745.75"/>
<g id="a_node4_21"><a xlink:href="#" xlink:title="GrammarFuzzer">
<g id="a_node4_22"><a xlink:href="GrammarFuzzer.html" xlink:title="__init__(self, grammar: Dict[str, List[Expansion]], start_symbol: str = '&lt;start&gt;', min_nonterminals: int = 0, max_nonterminals: int = 10, disp: bool = False, log: Union[bool, int] = False) -&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="201" y="-733.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node4_23"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz(self) -&gt; str:&#10;Produce a string from the grammar.">
<text text-anchor="start" x="201" y="-720.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz()</text>
</a>
</g>
<g id="a_node4_24"><a xlink:href="GrammarFuzzer.html" xlink:title="fuzz_tree(self) -&gt; DerivationTree:&#10;Produce a derivation tree from the grammar.">
<text text-anchor="start" x="201" y="-707.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">fuzz_tree()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GeneratorGrammarFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge3" class="edge">
<title>GeneratorGrammarFuzzer-&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M85.42,-579.11C88.01,-608.15 95.17,-638.39 111,-663 123.98,-683.18 144.82,-698.36 165.67,-709.42"/>
<polygon fill="none" stroke="black" points="164.02,-712.51 174.53,-713.85 167.15,-706.25 164.02,-712.51"/>
</g>
<!-- Fuzzer -->
<g id="node5" class="node">
<title>Fuzzer</title>
<g id="a_node5"><a xlink:href="Fuzzer.html" xlink:title="class Fuzzer:&#10;Base class for fuzzers.">
<polygon fill="none" stroke="black" points="205.38,-808.75 205.38,-868.25 262.62,-868.25 262.62,-808.75 205.38,-808.75"/>
<text text-anchor="start" x="213.38" y="-851.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Fuzzer</text>
<polyline fill="none" stroke="black" points="205.38,-842.25 262.62,-842.25"/>
<g id="a_node5_25"><a xlink:href="#" xlink:title="Fuzzer">
<g id="a_node5_26"><a xlink:href="Fuzzer.html" xlink:title="run(self, runner: Fuzzer.Runner = &lt;Fuzzer.Runner object&gt;) -&gt; Tuple[subprocess.CompletedProcess, str]:&#10;Run `runner` with fuzz input">
<text text-anchor="start" x="216" y="-829.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">run()</text>
</a>
</g>
<g id="a_node5_27"><a xlink:href="Fuzzer.html" xlink:title="runs(self, runner: Fuzzer.Runner = &lt;Fuzzer.PrintRunner object&gt;, trials: int = 10) -&gt; List[Tuple[subprocess.CompletedProcess, str]]:&#10;Run `runner` with fuzz input, `trials` times">
<text text-anchor="start" x="216" y="-817" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">runs()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- GrammarFuzzer&#45;&gt;Fuzzer -->
<g id="edge4" class="edge">
<title>GrammarFuzzer-&gt;Fuzzer</title>
<path fill="none" stroke="black" d="M234,-772.19C234,-780.29 234,-788.94 234,-797.22"/>
<polygon fill="none" stroke="black" points="230.5,-797.06 234,-807.06 237.5,-797.06 230.5,-797.06"/>
</g>
<!-- GrammarCoverageFuzzer -->
<g id="node7" class="node">
<title>GrammarCoverageFuzzer</title>
<g id="a_node7"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="class GrammarCoverageFuzzer:&#10;Produce from grammars, aiming for coverage of all expansions.">
<polygon fill="none" stroke="black" points="222.25,-293.25 222.25,-329.25 395.75,-329.25 395.75,-293.25 222.25,-293.25"/>
<text text-anchor="start" x="230.25" y="-307.95" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">GrammarCoverageFuzzer</text>
</a>
</g>
</g>
<!-- ProbabilisticGrammarCoverageFuzzer&#45;&gt;GrammarCoverageFuzzer -->
<g id="edge6" class="edge">
<title>ProbabilisticGrammarCoverageFuzzer-&gt;GrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M309,-256.44C309,-264.02 309,-273.15 309,-281.71"/>
<polygon fill="none" stroke="black" points="305.5,-281.71 309,-291.71 312.5,-281.71 305.5,-281.71"/>
</g>
<!-- ProbabilisticGrammarFuzzer -->
<g id="node10" class="node">
<title>ProbabilisticGrammarFuzzer</title>
<g id="a_node10"><a xlink:href="ProbabilisticGrammarFuzzer.html" xlink:title="class ProbabilisticGrammarFuzzer:&#10;A grammar-based fuzzer respecting probabilities in grammars.">
<polygon fill="none" stroke="black" points="366.25,-621.12 366.25,-657.12 557.75,-657.12 557.75,-621.12 366.25,-621.12"/>
<text text-anchor="start" x="374.25" y="-635.83" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ProbabilisticGrammarFuzzer</text>
</a>
</g>
</g>
<!-- ProbabilisticGrammarCoverageFuzzer&#45;&gt;ProbabilisticGrammarFuzzer -->
<g id="edge10" class="edge">
<title>ProbabilisticGrammarCoverageFuzzer-&gt;ProbabilisticGrammarFuzzer</title>
<path fill="none" stroke="black" d="M356.9,-256.68C374.27,-265.15 392.64,-276.98 405,-292.75 480.03,-388.45 472.59,-545.56 465.77,-609.61"/>
<polygon fill="none" stroke="black" points="462.32,-608.95 464.65,-619.28 469.27,-609.75 462.32,-608.95"/>
</g>
<!-- SimpleGrammarCoverageFuzzer -->
<g id="node8" class="node">
<title>SimpleGrammarCoverageFuzzer</title>
<g id="a_node8"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="class SimpleGrammarCoverageFuzzer:&#10;When choosing expansions, prefer expansions not covered.">
<polygon fill="none" stroke="black" points="201.62,-454.5 201.62,-490.5 416.38,-490.5 416.38,-454.5 201.62,-454.5"/>
<text text-anchor="start" x="209.62" y="-469.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">SimpleGrammarCoverageFuzzer</text>
</a>
</g>
</g>
<!-- GrammarCoverageFuzzer&#45;&gt;SimpleGrammarCoverageFuzzer -->
<g id="edge7" class="edge">
<title>GrammarCoverageFuzzer-&gt;SimpleGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M309,-329.6C309,-356.88 309,-410.1 309,-443.04"/>
<polygon fill="none" stroke="black" points="305.5,-442.66 309,-452.66 312.5,-442.66 305.5,-442.66"/>
</g>
<!-- TrackingGrammarCoverageFuzzer -->
<g id="node9" class="node">
<title>TrackingGrammarCoverageFuzzer</title>
<g id="a_node9"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="class TrackingGrammarCoverageFuzzer:&#10;Track grammar coverage during production">
<polygon fill="none" stroke="black" points="119.88,-615.75 119.88,-662.5 348.12,-662.5 348.12,-615.75 119.88,-615.75"/>
<text text-anchor="start" x="127.88" y="-646.2" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">TrackingGrammarCoverageFuzzer</text>
<polyline fill="none" stroke="black" points="119.88,-636.5 348.12,-636.5"/>
<g id="a_node9_28"><a xlink:href="#" xlink:title="TrackingGrammarCoverageFuzzer">
<g id="a_node9_29"><a xlink:href="GrammarCoverageFuzzer.html" xlink:title="__init__(self, *args, **kwargs) -&gt; None:&#10;Produce strings from `grammar`, starting with `start_symbol`.&#10;If `min_nonterminals` or `max_nonterminals` is given, use them as limits&#10;for the number of nonterminals produced.&#10;If `disp` is set, display the intermediate derivation trees.&#10;If `log` is set, show intermediate steps as text on standard output.">
<text text-anchor="start" x="204" y="-624" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- SimpleGrammarCoverageFuzzer&#45;&gt;TrackingGrammarCoverageFuzzer -->
<g id="edge8" class="edge">
<title>SimpleGrammarCoverageFuzzer-&gt;TrackingGrammarCoverageFuzzer</title>
<path fill="none" stroke="black" d="M301.12,-490.81C288.78,-517.89 264.7,-570.75 248.99,-605.23"/>
<polygon fill="none" stroke="black" points="245.99,-603.37 245.03,-613.92 252.36,-606.27 245.99,-603.37"/>
</g>
<!-- TrackingGrammarCoverageFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge9" class="edge">
<title>TrackingGrammarCoverageFuzzer-&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M234,-662.52C234,-670.11 234,-678.9 234,-687.67"/>
<polygon fill="none" stroke="black" points="230.5,-687.58 234,-697.58 237.5,-687.58 230.5,-687.58"/>
</g>
<!-- ProbabilisticGrammarFuzzer&#45;&gt;GrammarFuzzer -->
<g id="edge11" class="edge">
<title>ProbabilisticGrammarFuzzer-&gt;GrammarFuzzer</title>
<path fill="none" stroke="black" d="M419.92,-657.57C387.1,-671.17 340.85,-690.34 302.69,-706.15"/>
<polygon fill="none" stroke="black" points="301.46,-702.88 293.56,-709.94 304.14,-709.34 301.46,-702.88"/>
</g>
<!-- Legend -->
<g id="node11" class="node">
<title>Legend</title>
<text text-anchor="start" x="264.38" y="-40.5" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="264.38" y="-30.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="270.38" y="-30.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="264.38" y="-20.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="270.38" y="-20.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="264.38" y="-10.5" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="270.38" y="-10.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="264.38" y="-1.45" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</p>
</div>
</div>
</div>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Example:-Test-a-Credit-Card-System">Example: Test a Credit Card System</h2><p>Suppose you work with a shopping system that – among several other features – allows customers to pay with a credit card.  Your task is to test the payment functionality.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To make things simple, we will assume that we need only two pieces of data – a 16-digit credit card number and an amount to be charged.  Both pieces can be easily generated with grammars, as in the following:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils.setup</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/typing.html" class="import" target="_blank">typing</a></span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">cast</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Fuzzer.html" class="import" target="_blank">Fuzzer</a></span> <span class="kn">import</span> <span class="n">Fuzzer</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">EXPR_GRAMMAR</span><span class="p">,</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">is_nonterminal</span><span class="p">,</span> <span class="n">extend_grammar</span>
<span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">opts</span><span class="p">,</span> <span class="n">exp_opt</span><span class="p">,</span> <span class="n">exp_string</span><span class="p">,</span> <span class="n">crange</span><span class="p">,</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">Expansion</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="GrammarFuzzer.html" class="import" target="_blank">GrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">DerivationTree</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CHARGE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Charge &lt;amount&gt; to my credit card &lt;credit-card-number&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;amount&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"$&lt;float&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;float&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;integer&gt;.&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;integer&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="s2">"&lt;integer&gt;&lt;digit&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;digit&gt;"</span><span class="p">:</span> <span class="n">crange</span><span class="p">(</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'9'</span><span class="p">),</span>

    <span class="s2">"&lt;credit-card-number&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digits&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;digits&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digit-block&gt;&lt;digit-block&gt;&lt;digit-block&gt;&lt;digit-block&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;digit-block&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;&lt;digit&gt;"</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">CHARGE_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>All of this works neatly – we can generate arbitrary amounts and credit card numbers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="GrammarFuzzer.html" class="import" target="_blank">GrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">GrammarFuzzer</span><span class="p">,</span> <span class="n">all_terminals</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">CHARGE_GRAMMAR</span><span class="p">)</span>
<span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['Charge $9.40 to my credit card 7166898575638313',
 'Charge $8.79 to my credit card 6845418694643271',
 'Charge $5.64 to my credit card 6655894657077388',
 'Charge $0.60 to my credit card 2596728464872261',
 'Charge $8.90 to my credit card 2363769342732142']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>However, when actually testing our system with this data, we find two problems:</p>
<ol>
<li>We'd like to test <em>specific</em> amounts being charged – for instance, amounts that would excess the credit card limit.</li>
<li>We find that 9 out of 10 credit card numbers are rejected because of having an incorrect checksum.  This is fine if we want to test rejection of credit card numbers – but if we want to test the actual functionality of processing a charge, we need <em>valid</em> numbers.</li>
</ol>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We could go and ignore these issues; after all, eventually, it is only a matter of time until large amounts and valid numbers are generated.  As it comes to the first concern, we could also address it by changing the grammar appropriately – say, to only produce charges that have at least six leading digits.  However, generalizing this to arbitrary ranges of values will be cumbersome.</p>
<p>The second concern, the checksums of credit card numbers, however, runs deeper – at least as far as grammars are concerned, is that a complex arithmetic operation like a checksum cannot be expressed in a grammar alone – at least not in the <em>context-free grammars</em> we use here.  (In principle, one <em>could</em> do this in a <em>context–sensitive</em> grammar, but specifying this would be no fun at all.)  What we want is a mechanism that allows us to <em>attach programmatic computations</em> to our grammars, bringing together the best of both worlds.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Attaching-Functions-to-Expansions">Attaching Functions to Expansions</h2></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The key idea of this chapter is to <em>extend</em> grammars such that one can <em>attach Python functions</em> to individual expansions.  These functions can be executed</p>
<ol>
<li><em>before</em> expansion, <em>replacing</em> the element to be expanded by a computed value; or</li>
<li><em>after</em> expansion, <em>checking</em> generated elements, and possibly also replacing them.</li>
</ol>
<p>In both cases, functions are specified using the <code>opts()</code> expansion mechanism introduced in the <a href="Grammars.html">chapter on grammars</a>.  They are thus tied to a specific expansion $e$ of a symbol $s$.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Functions-Called-Before-Expansion">Functions Called Before Expansion</h3><p>A function defined using the <code>pre</code> option is invoked <em>before</em> expansion of $s$ into $e$. Its value <em>replaces</em> the expansion $e$ to be produced.  To generate a value for the credit card example, above, we could define a <em>pre-expansion</em> generator function</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/random.html" class="import" target="_blank">random</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">high_charge</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10000000</span><span class="p">,</span> <span class="mi">90000000</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With <code>opts()</code>, we could attach this function to the grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CHARGE_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">"&lt;float&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;integer&gt;.&lt;digit&gt;&lt;digit&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">high_charge</span><span class="p">))],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>with the intention that whenever <code>&lt;float&gt;</code> is expanded, the function <code>high_charge</code> would be invoked to generate a value for <code>&lt;float&gt;</code>.  (The actual expansion in the grammar would still be present for fuzzers that ignore functions, such as <code>GrammarFuzzer</code>).</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Since functions tied to a grammar are frequently very simple, we can also <em>inline</em> them using a <em>lambda</em> expression.  A <em>lambda expression</em> is used for <em>anonymous</em> functions that are limited in scope and functionality.  Here's an example:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">apply_twice</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">apply_twice</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>16
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here, we don't have to give the <code>function</code> to be applied twice a name (say, <code>square()</code>); instead, we apply it inline within the invocation.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Using <code>lambda</code>, this is what our grammar looks like:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CHARGE_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">"&lt;float&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;integer&gt;.&lt;digit&gt;&lt;digit&gt;"</span><span class="p">,</span>
                 <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">10000000</span><span class="p">,</span> <span class="mi">90000000</span><span class="p">)</span> <span class="o">/</span> <span class="mf">100.0</span><span class="p">))]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Functions-Called-After-Expansion">Functions Called After Expansion</h3><p>A function defined using the <code>post</code> option is invoked <em>after</em> expansion of $s$ into $e$, passing the expanded values of the symbols in $e$ as arguments.  A post-expansion function can serve in two ways:</p>
<ol>
<li>It can serve as a <em>constraint</em> or <em>filter</em> on the expanded values, returning <code>True</code> if the expansion is valid, and <code>False</code> if not; if it returns <code>False</code>, another expansion is attempted.</li>
<li>It can also serve as a <em>repair</em>, returning a string value; like pre-expansion functions, the returned value replaces the expansion.</li>
</ol>
<p>For our credit card example, we can choose both ways.  If we have a function <code>check_credit_card(s)</code> which returns <code>True</code> for a valid number <code>s</code> and <code>False</code> for invalid ones, we would go for the first option:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CHARGE_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">"&lt;credit-card-number&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;digits&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">digits</span><span class="p">:</span> <span class="n">check_credit_card</span><span class="p">(</span><span class="n">digits</span><span class="p">)))]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With such a filter, only valid credit cards will be produced.  On average, it will still take 10 attempts for each time <code>check_credit_card()</code> is satisfied.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we have a function <code>fix_credit_card(s)</code> which changes the number such that the checksum is valid and returns the "fixed" number, we can make use of this one instead:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CHARGE_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">"&lt;credit-card-number&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;digits&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">digits</span><span class="p">:</span> <span class="n">fix_credit_card</span><span class="p">(</span><span class="n">digits</span><span class="p">)))]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here, each number is generated only once and then repaired.  This is very efficient.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The checksum function used for credit cards is the <a href="https://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a>, a simple yet effective formula.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">luhn_checksum</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Compute Luhn's check digit over a string of digits"""</span>
    <span class="n">LUHN_ODD_LOOKUP</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
                       <span class="mi">9</span><span class="p">)</span>  <span class="c1"># sum_of_digits (index * 2)</span>

    <span class="n">evens</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">odds</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">LUHN_ODD_LOOKUP</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">p</span><span class="p">)]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">evens</span> <span class="o">+</span> <span class="n">odds</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">valid_luhn_checksum</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Check whether the last digit is Luhn's checksum over the earlier digits"""</span>
    <span class="k">return</span> <span class="n">luhn_checksum</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">fix_luhn_checksum</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Return the given string of digits, with a fixed check digit"""</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">luhn_checksum</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">luhn_checksum</span><span class="p">(</span><span class="s2">"123"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>8
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fix_luhn_checksum</span><span class="p">(</span><span class="s2">"123x"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'1238'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can make use of these functions in our credit card grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">check_credit_card</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_luhn_checksum</span>
<span class="n">fix_credit_card</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_luhn_checksum</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fix_credit_card</span><span class="p">(</span><span class="s2">"1234567890123456"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'1234567890123458'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="A-Class-for-Integrating-Constraints">A Class for Integrating Constraints</h2></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>While it is easy to specify functions, our grammar fuzzer will simply ignore them just as it ignores all extensions.  It will issue a warning, though:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">CHARGE_GRAMMAR</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'Charge $4.05 to my credit card 0637034038177393'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We need to define a special fuzzer that actually invokes the given <code>pre</code> and <code>post</code> functions and acts accordingly.  We name this a <code>GeneratorGrammarFuzzer</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">supported_opts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">()</span> <span class="o">|</span> <span class="p">{</span><span class="s2">"pre"</span><span class="p">,</span> <span class="s2">"post"</span><span class="p">,</span> <span class="s2">"order"</span><span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We define custom functions to access the <code>pre</code> and <code>post</code> options:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">exp_pre_expansion_function</span><span class="p">(</span><span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">"""Return the specified pre-expansion function, or None if unspecified"""</span>
    <span class="k">return</span> <span class="n">exp_opt</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="s1">'pre'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">exp_post_expansion_function</span><span class="p">(</span><span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">"""Return the specified post-expansion function, or None if unspecified"""</span>
    <span class="k">return</span> <span class="n">exp_opt</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="s1">'post'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The <code>order</code> attribute will be used <a href="#Ordering-Expansions">later in this chapter</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Generating-Elements-before-Expansion">Generating Elements before Expansion</h2></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our first task will be implementing the pre-expansion functions – that is, the function that would be invoked <em>before</em> expansion to replace the value to be expanded.  To this end, we hook into the <code>process_chosen_children()</code> method, which gets the selected children before expansion.  We set it up such that it invokes the given <code>pre</code> function and applies its result on the children, possibly replacing them.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/inspect.html" class="import" target="_blank">inspect</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">process_chosen_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span>
                                <span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]:</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">exp_pre_expansion_function</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">children</span>

        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isgeneratorfunction</span><span class="p">(</span><span class="n">function</span><span class="p">):</span>
            <span class="c1"># See "generators", below</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_generator</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">function</span><span class="p">)</span> <span class="o">+</span> <span class="s2">"()"</span><span class="p">,</span> <span class="s2">"="</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">,</span> <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">):</span>
        <span class="o">...</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The method <code>apply_result()</code> takes the result from the pre-expansion function and applies it on the children.  The exact effect depends on the type of the result:</p>
<ul>
<li>A <em>string</em> $s$ replaces the entire expansion with $s$.</li>
<li>A <em>list</em> $[x_1, x_2, \dots, x_n]$ replaces the $i$-th symbol with $x_i$ for every $x_i$ that is not <code>None</code>.  Specifying <code>None</code> as a list element $x_i$ is useful to leave that element unchanged.  If $x_i$ is not a string, it is converted to a string.</li>
<li>A value of <code>None</code> is ignored.  This is useful if one wants to simply call a function upon expansion, with no effect on the expanded strings.</li>
<li><em>Boolean</em> values are ignored.  This is useful for post-expansion functions, discussed below.</li>
<li>All <em>other types</em> are converted to strings, replacing the entire expansion.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">apply_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                     <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">children</span> <span class="o">=</span> <span class="p">[(</span><span class="n">result</span><span class="p">,</span> <span class="p">[])]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">symbol_indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
                              <span class="k">if</span> <span class="n">is_nonterminal</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">child_index</span> <span class="o">=</span> <span class="n">symbol_indexes</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="s2">"Replacing"</span><span class="p">,</span> <span class="n">all_terminals</span><span class="p">(</span>
                                <span class="n">children</span><span class="p">[</span><span class="n">child_index</span><span class="p">]),</span> <span class="s2">"by"</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

                    <span class="c1"># children[child_index] = (value, [])</span>
                    <span class="n">child_symbol</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">children</span><span class="p">[</span><span class="n">child_index</span><span class="p">]</span>
                    <span class="n">children</span><span class="p">[</span><span class="n">child_index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">child_symbol</span><span class="p">,</span> <span class="p">[(</span><span class="n">value</span><span class="p">,</span> <span class="p">[])])</span>
        <span class="k">elif</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Replacing"</span><span class="p">,</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">all_terminals</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">]),</span> <span class="s2">"by"</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>

            <span class="n">children</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">),</span> <span class="p">[])]</span>

        <span class="k">return</span> <span class="n">children</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Example:-Numeric-Ranges">Example: Numeric Ranges</h3><p>With the above extensions, we have full support for pre-expansion functions.  Using the augmented <code>CHARGE_GRAMMAR</code>, we find that the pre-expansion <code>lambda</code> function is actually used:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">charge_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CHARGE_GRAMMAR</span><span class="p">)</span>
<span class="n">charge_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'Charge $439383.87 to my credit card 2433506594138520'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The log reveals a bit more details what happens when the pre-expansion function is called.  We see that the expansion <code>&lt;integer&gt;.&lt;digit&gt;&lt;digit&gt;</code> is directly replaced by the computed value:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">amount_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span>
    <span class="n">CHARGE_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;amount&gt;"</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">amount_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Tree: &lt;amount&gt;
Expanding &lt;amount&gt; randomly
Tree: $&lt;float&gt;
Expanding &lt;float&gt; randomly
&lt;function &lt;lambda&gt; at 0x1109f2ac0&gt;() = 382087.72
Replacing &lt;integer&gt;.&lt;digit&gt;&lt;digit&gt; by 382087.72
Tree: $382087.72
'$382087.72'
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'$382087.72'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Example:-More-Numeric-Ranges">Example: More Numeric Ranges</h3><p>We can use such pre-expansion functions in other contexts, too.  Suppose we want to generate arithmetic expressions in which each number is between 100 and 200.  We can extend <code>EXPR_GRAMMAR</code> accordingly:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_100_200_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                      <span class="p">{</span>
                                          <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span>
                                              <span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span>

                                              <span class="c1"># Generate only the integer part with a function;</span>
                                              <span class="c1"># the fractional part comes from</span>
                                              <span class="c1"># the grammar</span>
                                              <span class="p">(</span><span class="s2">"&lt;integer&gt;.&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span>
                                                  <span class="n">pre</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="p">[</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">),</span> <span class="kc">None</span><span class="p">])),</span>

                                              <span class="c1"># Generate the entire integer</span>
                                              <span class="c1"># from the function</span>
                                              <span class="p">(</span><span class="s2">"&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span>
                                                  <span class="n">pre</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">))),</span>
                                          <span class="p">],</span>
                                      <span class="p">}</span>
                                      <span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_100_200_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">expr_100_200_grammar</span><span class="p">)</span>
<span class="n">expr_100_200_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'(108.6 / 155 + 177) / 118 * 120 * 107 + 151 + 195 / -200 - 150 * 188 / 147 + 112'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Support-for-Python-Generators">Support for Python Generators</h3><p>The Python language has its own concept of generator functions, which we of course want to support as well.  A <em>generator function in Python</em> is a function that returns a so-called <em>iterator object</em> which we can iterate over, one value at a time.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To create a generator function in Python, one defines a normal function, using the <code>yield</code> statement instead of a <code>return</code> statement.  While a <code>return</code> statement terminates the function, a <code>yield</code> statement pauses its execution, saving all of its state, to be resumed later for the next successive calls.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here is an example of a generator function.  When first invoked, <code>iterate()</code> yields the value 1, followed by 2, 3, and so on:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">iterate</span><span class="p">():</span>
    <span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">yield</span> <span class="n">t</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can use <code>iterate</code> in a loop, just like the <code>range()</code> function (which also is a generator function):</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">iterate</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">" "</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>1 2 3 4 5 6 7 8 9 10 
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can also use <code>iterate()</code> as a pre-expansion generator function, ensuring it will create one successive integer after another:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">iterate_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                 <span class="p">{</span>
                                     <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span>
                                         <span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span>
                                         <span class="c1"># "&lt;integer&gt;.&lt;integer&gt;",</span>

                                         <span class="c1"># Generate one integer after another</span>
                                         <span class="c1"># from the function</span>
                                         <span class="p">(</span><span class="s2">"&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">iterate</span><span class="p">)),</span>
                                     <span class="p">],</span>
                                 <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To support generators, our <code>process_chosen_children()</code> method, above, checks whether a function is a generator; if so, it invokes the <code>run_generator()</code> method.  When <code>run_generator()</code> sees the function for the first time during a <code>fuzz_tree()</code> (or <code>fuzz()</code>) call, it invokes the function to create a generator object; this is saved in the <code>generators</code> attribute, and then called.  Subsequent calls directly go to the generator, preserving state.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fuzz_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_generators</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">reset_generators</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">run_generator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">Expansion</span><span class="p">,</span>
                      <span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">((</span><span class="n">expansion</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">()</span>
        <span class="n">generator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generators</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Does this work?  Let us run our fuzzer on the above grammar, using <code>iterator()</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">iterate_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">iterate_grammar</span><span class="p">)</span>
<span class="n">iterate_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'1 * ++++3 / ---+4 - 2 * +--6 / 7 * 10 - (9 - 11) - 5 + (13) * 14 + 8 + 12'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that the expression contains all integers starting with 1.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Instead of specifying our own Python generator function such as <code>iterate()</code>, we can also use one of the built-in Python generators such as <code>range()</code>.  This will also generate integers starting with 1:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">iterate_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                 <span class="p">{</span>
                                     <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span>
                                         <span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span>
                                         <span class="p">(</span><span class="s2">"&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">))),</span>
                                     <span class="p">],</span>
                                 <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>It is also possible to use Python list comprehensions, by adding their generator functions in parentheses:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">iterate_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                 <span class="p">{</span>
                                     <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span>
                                         <span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span> <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span>
                                         <span class="p">(</span><span class="s2">"&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span>
                                             <span class="n">pre</span><span class="o">=</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)))),</span>
                                     <span class="p">],</span>
                                 <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Note that both above grammars will actually cause the fuzzer to raise an exception when more than 1,000 integers are created, but you will find it very easy to fix this.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Finally, <code>yield</code> is actually an expression, not a statement, so it is also possible to have a <code>lambda</code> expression <code>yield</code> a value.  If you find some reasonable use for this, let us know.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Checking-and-Repairing-Elements-after-Expansion">Checking and Repairing Elements after Expansion</h2><p>Let us now turn to our second set of functions to be supported – namely, post-expansion functions.  The simplest way of using them is to run them once the entire tree is generated, taking care of replacements as with <code>pre</code> functions.  If one of them returns <code>False</code>, however, we start anew.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">fuzz_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">()</span>
            <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">tree</span>
            <span class="n">result</span><span class="p">,</span> <span class="n">new_children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_post_functions</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">new_children</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">restart_expansion</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">restart_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># To be overloaded in subclasses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset_generators</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The method <code>run_post_functions()</code> is applied recursively on all nodes of the derivation tree.  For each node, it determines the expansion applied, and then runs the function associated with that expansion.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="c1"># Return True iff all constraints of grammar are satisfied in TREE</span>
    <span class="k">def</span> <span class="nf">run_post_functions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                           <span class="n">depth</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">"inf"</span><span class="p">))</span> \
                               <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]]]:</span>
        <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">],</span> <span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">children</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">children</span>  <span class="c1"># Terminal symbol</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">expansion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_expansion</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># Expansion (no longer) found - ignore</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">children</span>

        <span class="n">result</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">function</span> <span class="o">=</span> <span class="n">exp_post_expansion_function</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_function</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">function</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="n">all_terminals</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span>
                        <span class="s2">"did not satisfy"</span><span class="p">,</span>
                        <span class="n">symbol</span><span class="p">,</span>
                        <span class="s2">"constraint"</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">children</span>

            <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_post_functions</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">children</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">children</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The helper method <code>find_expansion()</code> takes a subtree <code>tree</code> and determines the expansion from the grammar that was applied to create the children in <code>tree</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">find_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
        <span class="n">symbol</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>

        <span class="n">applied_expansion</span> <span class="o">=</span> \
            <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">child_symbol</span> <span class="k">for</span> <span class="n">child_symbol</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">children</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">exp_string</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span> <span class="o">==</span> <span class="n">applied_expansion</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">expansion</span>

        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="n">symbol</span> <span class="o">+</span>
            <span class="s2">": did not find expansion "</span> <span class="o">+</span>
            <span class="nb">repr</span><span class="p">(</span><span class="n">applied_expansion</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The method <code>eval_function()</code> is the one that takes care of actually invoking the post-expansion function.  It creates an argument list containing the expansions of all nonterminal children – that is, one argument for each symbol in the grammar expansion.  It then calls the given function.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">eval_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span>
        <span class="n">symbol</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>

        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">exp</span><span class="p">)</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exp</span> <span class="o">!=</span> <span class="p">[]</span> <span class="ow">and</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">symbol_value</span> <span class="o">=</span> <span class="n">all_terminals</span><span class="p">((</span><span class="n">symbol</span><span class="p">,</span> <span class="n">exp</span><span class="p">))</span>
                <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol_value</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">function</span><span class="p">)</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="s2">"="</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">result</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Note that unlike pre-expansion functions, post-expansion functions typically process the values already produced, so we do not support Python generators here.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Example:-Negative-Expressions">Example: Negative Expressions</h3><p>Let us try out these post-expression functions on an example.  Suppose we want to produce only arithmetic expressions that evaluate to a negative number – for instance, to feed such generated expressions into a compiler or some other external system.  Doing so constructively with <code>pre</code> functions would be very difficult. Instead, we can define a constraint that checks for precisely this property, using the Python <code>eval()</code> function.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The Python <code>eval()</code> function takes a string and evaluates it according to Python rules.  Since the syntax of our generated expressions is slightly different from Python, and since Python can raise arithmetic exceptions during evaluation, we need a means to handle such errors gracefully.  The function <code>eval_with_exception()</code> wraps around <code>eval()</code>; if an exception occurs during evaluation, it returns False – which causes the production algorithm to produce another value.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="ExpectError.html" class="import" target="_blank">ExpectError</a></span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">eval_with_exception</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1"># Use "mute=True" to suppress all messages</span>
    <span class="k">with</span> <span class="n">ExpectError</span><span class="p">(</span><span class="n">print_traceback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">negative_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                       <span class="p">{</span>
                                           <span class="s2">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;expr&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">eval_with_exception</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))]</span>
                                       <span class="p">}</span>
                                       <span class="p">)</span>

<span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">negative_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">negative_expr_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">negative_expr_grammar</span><span class="p">)</span>
<span class="n">expr</span> <span class="o">=</span> <span class="n">negative_expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
<span class="n">expr</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>ZeroDivisionError: division by zero (expected)
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'(8.9 / 6 * 4 - 0.2 + -7 - 7 - 8 * 6) * 7 * 15.55 - -945.9'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The result is indeed negative:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">eval</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>-5178.726666666667
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Example:-Matching-XML-Tags">Example: Matching XML Tags</h3><p>Post-expansion functions can not only be used to <em>check</em> expansions, but also to repair them.  To this end, we can have them return a string or a list of strings; just like pre-expansion functions, these strings would then replace the entire expansion or individual symbols.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As an example, consider <em>XML documents</em>, which are composed of text within matching <em>XML tags</em>.  For instance, consider the following fragment in HTML, a subset of XML:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">HTML</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">HTML</span><span class="p">(</span><span class="s2">"&lt;strong&gt;A bold text&lt;/strong&gt;"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

<strong>A bold text</strong>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This fragment consists of two HTML (XML) tags that surround the text; the tag name (<code>strong</code>) is present both in the opening (<code>&lt;strong&gt;</code>) as well as in the closing (<code>&lt;/strong&gt;</code>) tag.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>For a <em>finite</em> set of tags (for instance, the HTML tags <code>&lt;strong&gt;</code>, <code>&lt;head&gt;</code>, <code>&lt;body&gt;</code>, <code>&lt;form&gt;</code>, and so on), we could define a context-free grammar that parses it; each pair of tags would make up an individual rule in the grammar.  If the set of tags is <em>infinite</em>, though, as with general XML, we cannot define an appropriate grammar; that is because the constraint that the closing tag must match the opening tag is context-sensitive and thus does not fit context-free grammars.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>(Incidentally, if the closing tag had the identifier <em>reversed</em> (<code>&lt;/gnorts&gt;</code>), then a context-free grammar could describe it.  Make this a programming exercise.)</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can address this problem by introducing appropriate post-expansion functions that automatically make the closing tag match the opening tag.  Let us start with a simple grammar for producing XML trees:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">XML_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;xml-tree&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;xml-tree&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;&lt;id&gt;&gt;&lt;xml-content&gt;&lt;/&lt;id&gt;&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;xml-content&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"Text"</span><span class="p">,</span> <span class="s2">"&lt;xml-tree&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;id&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;letter&gt;"</span><span class="p">,</span> <span class="s2">"&lt;id&gt;&lt;letter&gt;"</span><span class="p">],</span>
    <span class="s2">"&lt;letter&gt;"</span><span class="p">:</span> <span class="n">crange</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">XML_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we fuzz using this grammar, we get non-matching XML tags, as expected:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">xml_fuzzer</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">XML_GRAMMAR</span><span class="p">)</span>
<span class="n">xml_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'&lt;t&gt;&lt;qju&gt;Text&lt;/m&gt;&lt;/q&gt;'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Setting up a post-expansion function that sets the second identifier to the string found in the first solves the problem:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">XML_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s2">"&lt;xml-tree&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;&lt;id&gt;&gt;&lt;xml-content&gt;&lt;/&lt;id&gt;&gt;"</span><span class="p">,</span>
                    <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">id1</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">id2</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">id1</span><span class="p">])</span>
                    <span class="p">)]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">XML_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">xml_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">XML_GRAMMAR</span><span class="p">)</span>
<span class="n">xml_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'&lt;u&gt;Text&lt;/u&gt;'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Example:-Checksums">Example: Checksums</h3><p>As our last example, let us consider the checksum problem from the introduction.  With our newly defined repair mechanisms, we can now generate credit card numbers that are valid:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">credit_card_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span>
    <span class="n">CHARGE_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s2">"&lt;credit-card-number&gt;"</span><span class="p">)</span>
<span class="n">credit_card_number</span> <span class="o">=</span> <span class="n">credit_card_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
<span class="n">credit_card_number</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'2967308746680770'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">valid_luhn_checksum</span><span class="p">(</span><span class="n">credit_card_number</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The validity extends to the entire grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">charge_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CHARGE_GRAMMAR</span><span class="p">)</span>
<span class="n">charge_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'Charge $818819.97 to my credit card 2817984968014288'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Local-Checking-and-Repairing">Local Checking and Repairing</h2><p>So far, we have always first generated an entire expression tree, only to check it later for validity.  This can become expensive: If several elements are first generated only to find later that one of them is invalid, we spend a lot of time trying (randomly) to regenerate a matching input.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To demonstrate the issue, let us create an expression grammar in which all digits consist of zeros and ones.  Rather than doing this constructively, though, we filter out all non-conforming expressions after the fact, using a <code>post</code> constraint:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">binary_expr_grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">,</span>
                                     <span class="p">{</span>
                                         <span class="s2">"&lt;integer&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;digit&gt;&lt;integer&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">digit</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">digit</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">])),</span>
                                                       <span class="p">(</span><span class="s2">"&lt;digit&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">digit</span><span class="p">:</span> <span class="n">digit</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">]))]</span>
                                     <span class="p">}</span>
                                     <span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">binary_expr_grammar</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This works, but is very slow; it can take several seconds before a matching expression is found.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">binary_expr_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">binary_expr_grammar</span><span class="p">)</span>
<span class="n">binary_expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'(-+0)'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can address the problem by checking constraints not only for the final subtree, but also for partial subtrees as soon as they are complete.  To this end, we extend the method <code>expand_tree_once()</code> such that it invokes the post-expansion function as soon as all symbols in a subtree are expanded.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">RestartExpansionException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">expand_tree_once</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="c1"># Apply inherited method.  This also calls `expand_tree_once()` on all</span>
        <span class="c1"># subtrees.</span>
        <span class="n">new_tree</span><span class="p">:</span> <span class="n">DerivationTree</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">expand_tree_once</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">new_tree</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">exp_post_expansion_function</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
                <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">expansion</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">[</span><span class="n">symbol</span><span class="p">]]):</span>
            <span class="c1"># No constraints for this symbol</span>
            <span class="k">return</span> <span class="n">new_tree</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">any_possible_expansions</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
            <span class="c1"># Still expanding</span>
            <span class="k">return</span> <span class="n">new_tree</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_post_functions_locally</span><span class="p">(</span><span class="n">new_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The main work takes place in the helper method <code>run_post_functions_locally()</code>.  It runs the post-expansion function $f$ with <code>run_post_functions()</code> only on the current node by setting <code>depth</code> to zero, as any completed subtrees would have their post-expansion functions ran already.  If $f$ returns <code>False</code>, <code>run_post_functions_locally()</code> returns a non-expanded symbol, such that the main driver can try another expansion.  It does so for up to 10 times (configurable via a <code>replacement_attempts</code> parameter during construction); after that, it raises a <code>RestartExpansionException</code> to restart creating the tree from scratch.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run_post_functions_locally</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="n">symbol</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_tree</span>

        <span class="n">result</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_post_functions</span><span class="p">(</span><span class="n">new_tree</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="ow">or</span> <span class="n">result</span><span class="p">:</span>
            <span class="c1"># No constraints, or constraint satisfied</span>
            <span class="c1"># children = self.apply_result(result, children)</span>
            <span class="n">new_tree</span> <span class="o">=</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_tree</span>

        <span class="c1"># Replace tree by unexpanded symbol and try again</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="n">all_terminals</span><span class="p">(</span><span class="n">new_tree</span><span class="p">),</span>
                <span class="s2">"did not satisfy"</span><span class="p">,</span>
                <span class="n">symbol</span><span class="p">,</span>
                <span class="s2">"constraint"</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts_counter</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Trying another expansion"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts_counter</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Starting from scratch"</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">RestartExpansionException</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The class constructor method and <code>fuzz_tree()</code> are set up to handle the additional functionality:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">replacement_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts</span> <span class="o">=</span> <span class="n">replacement_attempts</span>

    <span class="k">def</span> <span class="nf">restart_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">restart_expansion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts</span>

    <span class="k">def</span> <span class="nf">fuzz_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts_counter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replacement_attempts</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># This is fuzz_tree() as defined above</span>
                <span class="n">tree</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">tree</span>
            <span class="k">except</span> <span class="n">RestartExpansionException</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">restart_expansion</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">binary_expr_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span>
    <span class="n">binary_expr_grammar</span><span class="p">,</span> <span class="n">replacement_attempts</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="n">binary_expr_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'+0 / +-1 - 1 / +0 * -+0 * 0 * 1 / 1'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Definitions-and-Uses">Definitions and Uses</h2><p>With the above generators and constraints, we can also address complex examples.  The <code>VAR_GRAMMAR</code> grammar from <a href="Parser.html">the chapter on parsers</a> defines a number of variables as arithmetic expressions (which in turn can contain variables, too).  Applying a simple <code>GrammarFuzzer</code> on the grammar produces plenty of identifiers, but each identifier has a unique name.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/string.html" class="import" target="_blank">string</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">VAR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;statements&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;statements&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;statement&gt;;&lt;statements&gt;'</span><span class="p">,</span> <span class="s1">'&lt;statement&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;statement&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;assignment&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;assignment&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;identifier&gt;=&lt;expr&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;identifier&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;word&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;word&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;alpha&gt;&lt;word&gt;'</span><span class="p">,</span> <span class="s1">'&lt;alpha&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;alpha&gt;'</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span><span class="p">),</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;term&gt;+&lt;expr&gt;'</span><span class="p">,</span> <span class="s1">'&lt;term&gt;-&lt;expr&gt;'</span><span class="p">,</span> <span class="s1">'&lt;term&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;term&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;factor&gt;*&lt;term&gt;'</span><span class="p">,</span> <span class="s1">'&lt;factor&gt;/&lt;term&gt;'</span><span class="p">,</span> <span class="s1">'&lt;factor&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;factor&gt;'</span><span class="p">:</span>
    <span class="p">[</span><span class="s1">'+&lt;factor&gt;'</span><span class="p">,</span> <span class="s1">'-&lt;factor&gt;'</span><span class="p">,</span> <span class="s1">'(&lt;expr&gt;)'</span><span class="p">,</span> <span class="s1">'&lt;identifier&gt;'</span><span class="p">,</span> <span class="s1">'&lt;number&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;number&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;integer&gt;.&lt;integer&gt;'</span><span class="p">,</span> <span class="s1">'&lt;integer&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;integer&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'&lt;digit&gt;&lt;integer&gt;'</span><span class="p">,</span> <span class="s1">'&lt;digit&gt;'</span><span class="p">],</span>
    <span class="s1">'&lt;digit&gt;'</span><span class="p">:</span> <span class="n">crange</span><span class="p">(</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'9'</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">VAR_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">GrammarFuzzer</span><span class="p">(</span><span class="n">VAR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Gc=F/1*Y+M-D-9;N=n/(m)/m*7
a=79.0;W=o-9;v=2;K=u;D=9
o=y-z+y+4;q=5+W;X=T
M=-98.032*5/o
H=IA-5-1;n=3-t;QQ=5-5
Y=-80;d=D-M+M;Z=4.3+1*r-5+b
ZDGSS=(1*Y-4)*54/0*pcO/4;RI=r*5.0
Q=6+z-6;J=6/t/9/i-3-5+k
x=-GT*+-x*6++-93*5
q=da*T/e--v;x=3+g;bk=u
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>What we'd like is that within expressions, only identifiers <em>previously defined</em> should be used.  To this end, we introduce a set of functions around a <em>symbol table</em>, which keeps track of all variables already defined.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">SYMBOL_TABLE</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">define_id</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">SYMBOL_TABLE</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">use_id</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">SYMBOL_TABLE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="nb">id</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">SYMBOL_TABLE</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">id</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">clear_symbol_table</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">SYMBOL_TABLE</span>
    <span class="n">SYMBOL_TABLE</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To make use of the symbol table, we attach pre- and post-expansion functions to <code>VAR_GRAMMAR</code> that define and lookup identifiers from the symbol table.  We name our extended grammar <code>CONSTRAINED_VAR_GRAMMAR</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">VAR_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>First, we set up the grammar such that after each time an identifier is defined, we store its name in the symbol table:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">"&lt;assignment&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;identifier&gt;=&lt;expr&gt;"</span><span class="p">,</span>
                      <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="nb">id</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">define_id</span><span class="p">(</span><span class="nb">id</span><span class="p">)))]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Second, we make sure that when an identifier is generated, we pick it from the symbol table, too.  (We use <code>post</code> here such that we can return <code>False</code> if no identifier is yet available, leading to another expansion being made.)</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s1">'+&lt;factor&gt;'</span><span class="p">,</span> <span class="s1">'-&lt;factor&gt;'</span><span class="p">,</span> <span class="s1">'(&lt;expr&gt;)'</span><span class="p">,</span>
                 <span class="p">(</span><span class="s2">"&lt;identifier&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">_</span><span class="p">:</span> <span class="n">use_id</span><span class="p">())),</span>
                 <span class="s1">'&lt;number&gt;'</span><span class="p">]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Finally, we clear the symbol table each time we (re)start an expansion.  This is helpful as we may occasionally have to restart expansions.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">"&lt;start&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;statements&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">pre</span><span class="o">=</span><span class="n">clear_symbol_table</span><span class="p">))]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Fuzzing with this grammar ensures that each identifier used is actually defined:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">var_grammar_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">var_grammar_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>DB=+(8/4/7-9+3+3)/2178/+-9
lNIqc=+(1+9-8)/2.9*8/5*0
Sg=(+9/8/6)*++1/(1+7)*8*4
r=+---552
iz=5/7/7;K=1+6*iz*1
q=3-2;MPy=q;p=2*5
zj=+5*-+35.2-+1.5727978+(-(-0/6-7+3))*--+44*1
Tl=((0*9+4-3)-6)/(-3-7*8*8/7)+9
aXZ=-5/-+3*9/3/1-8-+0*0/3+7+4
NA=-(8+a-1)*1.6;g=++7;a=++g*g*g
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Ordering-Expansions">Ordering Expansions</h2><p>While our previous def/use example ensures that each <em>used</em> variable also is a <em>defined</em> variable, it does not take care of the <em>order</em> in which these definitions are made.  In fact, it is possible that first, the term on the right-hand side of a <code>;</code> expands, creating an entry in the symbol table, which is then later used in the expression on the left hand side.  We can demonstrate this by actually evaluating the produced variable assignments in Python, using <code>exec()</code> to execute the sequence of assignments.  (Little known fact: Python <em>does</em> support <code>;</code> as statement separator.)</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">var_grammar_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
<span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">var_grammar_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">exec</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{})</span>
        <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
            <span class="k">continue</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>f=(9)*kOj*kOj-6/7;kOj=(9-8)*7*1
</pre>
</div>

</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11764/3970000697.py", line 6, in &lt;module&gt;
    exec(s, {}, {})
  File "&lt;string&gt;", line 1, in &lt;module&gt;
NameError: name 'kOj' is not defined (expected)
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To address this issue, we allow explicitly specifying an <em>ordering of expansions</em>.  For our previous fuzzers, such an ordering was inconsequential, as eventually, all symbols would be expanded; if we have expansion functions with side effects, though, having control over the ordering in which expansions are made (and thus over the ordering in which the associated functions are called) can be important.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To specify orderings, we assign a special attribute <code>order</code> to individual expansions.  This is a list with a number for each symbol in the expansion stating in which order the expansions are to be made, starting with the smallest one.  As an example, the following rule specifies that the left-hand side of a <code>;</code> separator should be expanded first:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">"&lt;statements&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;statement&gt;;&lt;statements&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])),</span>
                     <span class="s2">"&lt;statement&gt;"</span><span class="p">]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Likewise, we want the definition of a variable to be produced only <em>after</em> the expression is expanded, since otherwise, the expression might already refer to the defined variable:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s2">"&lt;assignment&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;identifier&gt;=&lt;expr&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="nb">id</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">define_id</span><span class="p">(</span><span class="nb">id</span><span class="p">),</span>
                                                  <span class="n">order</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The helper <code>exp_order()</code> allows us to retrieve the order:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">exp_order</span><span class="p">(</span><span class="n">expansion</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Return the specified expansion ordering, or None if unspecified"""</span>
    <span class="k">return</span> <span class="n">exp_opt</span><span class="p">(</span><span class="n">expansion</span><span class="p">,</span> <span class="s1">'order'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To control the ordering in which symbols are expanded, we hook into the method <code>choose_tree_expansion()</code>, which is specifically set for being extended in subclasses.  It proceeds through the list <code>expandable_children</code> of expandable children to choose from and matches them with the nonterminal children from the expansion to determine their order number.  The index <code>min_given_order</code> of the expandable child with the lowest order number is then returned, choosing this child for expansion.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">choose_tree_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">,</span>
                              <span class="n">expandable_children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">])</span> \
                              <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Return index of subtree in `expandable_children`</span>
<span class="sd">           to be selected for expansion. Defaults to random."""</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">tree_children</span><span class="p">)</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree_children</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expandable_children</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># No choice</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">choose_tree_expansion</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">expandable_children</span><span class="p">)</span>

        <span class="n">expansion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_expansion</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="n">given_order</span> <span class="o">=</span> <span class="n">exp_order</span><span class="p">(</span><span class="n">expansion</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">given_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># No order specified</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">choose_tree_expansion</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">expandable_children</span><span class="p">)</span>

        <span class="n">nonterminal_children</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">tree_children</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[]]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonterminal_children</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">given_order</span><span class="p">),</span> \
            <span class="s2">"Order must have one element for each nonterminal"</span>

        <span class="c1"># Find expandable child with lowest ordering</span>
        <span class="n">min_given_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expandable_child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">expandable_children</span><span class="p">):</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">nonterminal_children</span><span class="p">)</span> <span class="ow">and</span> <span class="n">expandable_child</span> <span class="o">!=</span> <span class="n">nonterminal_children</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">assert</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">nonterminal_children</span><span class="p">),</span> <span class="s2">"Expandable child not found"</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Expandable child #</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> has order </span><span class="si">%d</span><span class="s2">"</span> <span class="o">%</span>
                      <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">expandable_child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">given_order</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">min_given_order</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">given_order</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">given_order</span><span class="p">[</span><span class="n">min_given_order</span><span class="p">]:</span>
                <span class="n">min_given_order</span> <span class="o">=</span> <span class="n">k</span>

        <span class="k">assert</span> <span class="n">min_given_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">"Returning expandable child #</span><span class="si">%d</span><span class="s2"> </span><span class="si">%s</span><span class="s2">"</span> <span class="o">%</span>
                  <span class="p">(</span><span class="n">min_given_order</span><span class="p">,</span> <span class="n">expandable_children</span><span class="p">[</span><span class="n">min_given_order</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">min_given_order</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With this, our fuzzer can now respect orderings, and all variables are properly defined:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">var_grammar_fuzzer</span> <span class="o">=</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">var_grammar_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">exec</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{})</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="k">continue</span>
    <span class="k">except</span> <span class="ne">ZeroDivisionError</span><span class="p">:</span>
        <span class="k">continue</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>a=(1)*0*3/8+0/8-4/8-0
r=+0*+8/-4+((9)*2-1-8+6/9)
D=+(2*3+6*0)-(5)/9*0/2;Q=D
C=9*(2-1)*9*0-1.2/6-3*5
G=-25.1
H=+4*4/8.5*4-8*4+(5);D=6
PIF=4841/++(460.1---626)*51755;E=(8)/-PIF+6.8*(7-PIF)*9*PIF;k=8
X=((0)*2/0*6+7*3)/(0-7-9)
x=94.2+25;x=++x/(7)+-9/8/2/x+-1/x;I=x
cBM=51.15;f=81*-+--((2++cBM/cBM*+1*0/0-5+cBM))
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Real programming languages not only have one global scope, but multiple local scopes, frequently nested.  By carefully organizing global and local symbol tables, we can set up a grammar to handle all of these.  However, when fuzzing compilers and interpreters, we typically focus on single functions, for which one single scope is enough to make most inputs valid.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="All-Together">All Together</h2><p>Let us close this chapter by integrating our generator features with the other grammar features introduced earlier, in particular <a href="GrammarCoverageFuzzer.html">coverage-driven fuzzing</a> and <a href="ProbabilisticGrammarFuzzer.html">probabilistic grammar fuzzing</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The general idea to integrate the individual features is through <em>multiple inheritance</em>, which we already used for <code>ProbabilisticGrammarCoverageFuzzer</code>, introduced in the <a href="ProbabilisticGrammarFuzzer.html">exercises on probabilistic fuzzing</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Generators-and-Probabilistic-Fuzzing">Generators and Probabilistic Fuzzing</h3><p>Probabilistic fuzzing integrates very easily with generators, as both extend <code>GrammarFuzzer</code> in different ways.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="ProbabilisticGrammarFuzzer.html" class="import" target="_blank">ProbabilisticGrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">ProbabilisticGrammarFuzzer</span>  <span class="c1"># minor dependency</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">inheritance_conflicts</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">inheritance_conflicts</span><span class="p">(</span><span class="n">ProbabilisticGrammarFuzzer</span><span class="p">,</span> <span class="n">GeneratorGrammarFuzzer</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['supported_opts']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We have to implement <code>supported_opts()</code> as the merger of both superclasses.  At the same time, we also set up the constructor such that it invokes both.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">ProbabilisticGeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span>
                                          <span class="n">ProbabilisticGrammarFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Join the features of `GeneratorGrammarFuzzer` </span>
<span class="sd">    and `ProbabilisticGrammarFuzzer`"""</span>

    <span class="k">def</span> <span class="nf">supported_opts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">()</span> <span class="o">|</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ProbabilisticGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">replacement_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Constructor.</span>
<span class="sd">        `replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.</span>
<span class="sd">        All other keywords go into `ProbabilisticGrammarFuzzer`.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">grammar</span><span class="p">,</span>
                <span class="n">replacement_attempts</span><span class="o">=</span><span class="n">replacement_attempts</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProbabilisticGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us give our joint class a simple test, using probabilities to favor long identifiers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
    <span class="s1">'&lt;word&gt;'</span><span class="p">:</span> <span class="p">[(</span><span class="s1">'&lt;alpha&gt;&lt;word&gt;'</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">prob</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)),</span>
               <span class="s1">'&lt;alpha&gt;'</span><span class="p">],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">pgg_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGeneratorGrammarFuzzer</span><span class="p">(</span><span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
<span class="n">pgg_fuzzer</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'order', 'post', 'pre', 'prob'}
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">pgg_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'a=5+3/8/8+-1/6/9/8;E=6'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h1 id="Generators-and-Grammar-Coverage">Generators and Grammar Coverage</h1><p>Fuzzing based on grammar coverage is a bigger challenge.  Not so much for the methods overloaded in both; we can resolve these just as above.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="ProbabilisticGrammarFuzzer.html" class="import" target="_blank">ProbabilisticGrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">ProbabilisticGrammarCoverageFuzzer</span>  <span class="c1"># minor dependency</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="GrammarCoverageFuzzer.html" class="import" target="_blank">GrammarCoverageFuzzer</a></span> <span class="kn">import</span> <span class="n">GrammarCoverageFuzzer</span>  <span class="c1"># minor dependency</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">inheritance_conflicts</span><span class="p">(</span><span class="n">ProbabilisticGrammarCoverageFuzzer</span><span class="p">,</span>
                      <span class="n">GeneratorGrammarFuzzer</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['__init__', 'supported_opts']
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/copy.html" class="import" target="_blank">copy</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span>
                                                  <span class="n">ProbabilisticGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Join the features of `GeneratorGrammarFuzzer` </span>
<span class="sd">    and `ProbabilisticGrammarCoverageFuzzer`"""</span>

    <span class="k">def</span> <span class="nf">supported_opts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">()</span> <span class="o">|</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">ProbabilisticGrammarCoverageFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">supported_opts</span><span class="p">())</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">replacement_attempts</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Constructor.</span>
<span class="sd">        `replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.</span>
<span class="sd">        All other keywords go into `ProbabilisticGrammarFuzzer`.</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GeneratorGrammarFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">grammar</span><span class="p">,</span>
                <span class="n">replacement_attempts</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ProbabilisticGrammarCoverageFuzzer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">grammar</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The problem is that during expansion, we <em>may</em> generate (and cover) expansions that we later drop (for instance, because a <code>post</code> function returns <code>False</code>).  Hence, we have to <em>remove</em> this coverage which is no longer present in the final production.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We resolve the problem by <em>rebuilding the coverage</em> from the final tree after it is produced.  To this end, we hook into the <code>fuzz_tree()</code> method.  We have it save the original coverage before creating the tree, restoring it afterwards.  Then we traverse the resulting tree, adding its coverage back again (<code>add_tree_coverage()</code>).</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">(</span>
        <span class="n">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">fuzz_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DerivationTree</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_covered_expansions</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span><span class="p">)</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">fuzz_tree</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_covered_expansions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_tree_coverage</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="k">def</span> <span class="nf">add_tree_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">:</span> <span class="n">DerivationTree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span> <span class="o">=</span> <span class="n">tree</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">flat_children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DerivationTree</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="n">child_symbol</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">child_symbol</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">children</span>
            <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_coverage</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">flat_children</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_tree_coverage</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As a final step, we ensure that if we do have to restart an expansion from scratch, we also restore the previous coverage such that we can start fully anew:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">(</span>
        <span class="n">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">restart_expansion</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">restart_expansion</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">covered_expansions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_covered_expansions</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us try this out.  After we have produced a string, we should see its coverage in <code>expansion_coverage()</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">pggc_fuzzer</span> <span class="o">=</span> <span class="n">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">(</span>
    <span class="n">CONSTRAINED_VAR_GRAMMAR</span><span class="p">)</span>
<span class="n">pggc_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'H=+-2+7.4*(9)/0-6*8;T=5'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">pggc_fuzzer</span><span class="o">.</span><span class="n">expansion_coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{'&lt;alpha&gt; -&gt; H',
 '&lt;alpha&gt; -&gt; T',
 '&lt;assignment&gt; -&gt; &lt;identifier&gt;=&lt;expr&gt;',
 '&lt;digit&gt; -&gt; 0',
 '&lt;digit&gt; -&gt; 2',
 '&lt;digit&gt; -&gt; 4',
 '&lt;digit&gt; -&gt; 5',
 '&lt;digit&gt; -&gt; 6',
 '&lt;digit&gt; -&gt; 7',
 '&lt;digit&gt; -&gt; 8',
 '&lt;digit&gt; -&gt; 9',
 '&lt;expr&gt; -&gt; &lt;term&gt;',
 '&lt;expr&gt; -&gt; &lt;term&gt;+&lt;expr&gt;',
 '&lt;expr&gt; -&gt; &lt;term&gt;-&lt;expr&gt;',
 '&lt;factor&gt; -&gt; (&lt;expr&gt;)',
 '&lt;factor&gt; -&gt; +&lt;factor&gt;',
 '&lt;factor&gt; -&gt; -&lt;factor&gt;',
 '&lt;factor&gt; -&gt; &lt;number&gt;',
 '&lt;identifier&gt; -&gt; &lt;word&gt;',
 '&lt;integer&gt; -&gt; &lt;digit&gt;',
 '&lt;number&gt; -&gt; &lt;integer&gt;',
 '&lt;number&gt; -&gt; &lt;integer&gt;.&lt;integer&gt;',
 '&lt;start&gt; -&gt; &lt;statements&gt;',
 '&lt;statement&gt; -&gt; &lt;assignment&gt;',
 '&lt;statements&gt; -&gt; &lt;statement&gt;',
 '&lt;statements&gt; -&gt; &lt;statement&gt;;&lt;statements&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt;*&lt;term&gt;',
 '&lt;term&gt; -&gt; &lt;factor&gt;/&lt;term&gt;',
 '&lt;word&gt; -&gt; &lt;alpha&gt;'}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Fuzzing again would eventually cover all letters in identifiers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="p">[</span><span class="n">pggc_fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['llcyzc=3.0*02.3*1',
 'RfMgRYmd=---2.9',
 'p=+(7+3/4)*+-4-3.2*((2)-4)/2',
 'z=1-2/4-3*9+3+5',
 'v=(2/3)/1/2*8+(3)-7*2-1',
 'L=9.5/9-(7)/8/1+2-2;c=L',
 'U=+-91535-1-9-(9)/1;i=U',
 'g=-8.3*7*5+1*5*9-5;k=1',
 'J=+-8-(5/6-1)/7-6+7',
 'p=053/-(8*0*3*2/1);t=p']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With <code>ProbabilisticGeneratorGrammarCoverageFuzzer</code>, we now have a grammar fuzzer that combines efficient grammar fuzzing with coverage, probabilities, and generator functions.  The only thing that is missing is a shorter name.  <code>PGGCFuzzer</code>, maybe?</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">PGGCFuzzer</span><span class="p">(</span><span class="n">ProbabilisticGeneratorGrammarCoverageFuzzer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""The one grammar-based fuzzer that supports all fuzzingbook features"""</span>
    <span class="k">pass</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Lessons-Learned">Lessons Learned</h2><p>Functions attached to grammar expansions can serve</p>
<ul>
<li>as <em>generators</em> to efficiently produce a symbol expansion from a function;</li>
<li>as <em>constraints</em> to check produced strings against (complex) validity conditions; and</li>
<li>as <em>repairs</em> to apply changes to produced strings, such as checksums and identifiers.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Next-Steps">Next Steps</h2><p>With this chapter, we have powerful grammars which we can use in a number of domains:</p>
<ul>
<li>In the <a href="APIFuzzer.html">chapter on fuzzing APIs</a>, we show how to produce complex data structures for testing, making use of <code>GeneratorGrammarFuzzer</code> features to combine grammars and generator functions.</li>
<li>In the <a href="WebFuzzer.html">chapter on fuzzing User Interfaces</a>, we make use of <code>GeneratorGrammarFuzzer</code> to produce complex user interface inputs.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Background">Background</h2><p>For fuzzing APIs, generator functions are very common.  In the <a href="APIFuzzer.html">chapter on API fuzzing</a>, we show how to combine them with grammars for even richer test generation.</p>
<p>The combination of generator functions and grammars is mostly possible because we define and make use of grammars in an all-Python environment.  We are not aware of another grammar-based fuzzing system that exhibits similar features.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Exercises">Exercises</h2></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Exercise-1:-Tree-Processing">Exercise 1: Tree Processing</h3><p>So far, our <code>pre</code> and <code>post</code> processing functions all accept and produce strings.  In some circumstances, however, it can be useful to access the <em>derivation trees</em> directly – for instance, to access and check some child element.</p>
<p>Your task is to extend <code>GeneratorGrammarFuzzer</code> with pre- and post-processing functions that can accept and return derivation trees.  To this end, proceed as follows:</p>
<ol>
<li>Extend <code>GeneratorGrammarFuzzer</code> such that a function can return a derivation tree (a tuple) or a list of derivation trees, which would then replace subtrees in the same way as strings.</li>
<li>Extend <code>GeneratorGrammarFuzzer</code> with a <code>post_tree</code> attribute which takes a function just like <code>post</code>, except that its arguments would be derivation trees.</li>
</ol>

    
<p/><div class="solution_link"><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises" target="_blank">Use the notebook</a> to work on the exercises and see solutions.</div>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Exercise-2:-Attribute-Grammars">Exercise 2: Attribute Grammars</h3><p>Set up a mechanism through which it is possible to attach arbitrary <em>attributes</em> to individual elements in the derivation tree.  Expansion functions could attach such attributes to individual symbols (say, by returning <code>opts()</code>), and also access attributes of symbols in later calls.  Here is an example:</p>

    
<p/><div class="solution_link"><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises" target="_blank">Use the notebook</a> to work on the exercises and see solutions.</div>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ATTR_GRAMMAR</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"&lt;clause&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;xml-open&gt;Text&lt;xml-close&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">x1</span><span class="o">.</span><span class="n">name</span><span class="p">]))],</span>
    <span class="s2">"&lt;xml-open&gt;"</span><span class="p">:</span> <span class="p">[(</span><span class="s2">"&lt;&lt;tag&gt;&gt;"</span><span class="p">,</span> <span class="n">opts</span><span class="p">(</span><span class="n">post</span><span class="o">=</span><span class="k">lambda</span> <span class="n">tag</span><span class="p">:</span> <span class="n">opts</span><span class="p">(</span><span class="n">name</span><span class="o">=...</span><span class="p">)))],</span>
    <span class="s2">"&lt;xml-close&gt;"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"&lt;/&lt;tag&gt;&gt;"</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

</div>
</div>
    
<p/><div class="solution_link"><a href="https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/GeneratorGrammarFuzzer.ipynb#Exercises" target="_blank">Use the notebook</a> to work on the exercises and see solutions.</div>
</div>
</div>
</div>

        
<p class="imprint">
<img style="float:right" src="../Images/2f3faa36146c6fb38bbab67add09aa5f.png" alt="Creative Commons License" data-original-src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/>
The content of this project is licensed under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
The source code that is part of the content, as well as the source code used to format and display that content is licensed under the <a href="https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license">MIT License</a>.
<a href="https://github.com/uds-se/fuzzingbook/commits/master/notebooks/GeneratorGrammarFuzzer.ipynb" target="_blank)">Last change: 2024-01-10 15:45:59+01:00</a> • 
<a href="#citation" id="cite" onclick="revealCitation()">Cite</a> •
<a href="https://cispa.de/en/impressum" target="_blank">Imprint</a>
</p>



<div id="citation" class="citation" style="display: none;">
<a name="citation"/>
<h2>How to Cite this Work</h2>
<p>
Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler: "<a href="https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html">Fuzzing with Generators</a>".  In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "<a href="https://www.fuzzingbook.org/">The Fuzzing Book</a>", <a href="https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html">https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html</a>.  Retrieved 2024-01-10 15:45:59+01:00.
</p>
<pre>
@incollection{fuzzingbook2024:GeneratorGrammarFuzzer,
    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\"o}hme and Gordon Fraser and Christian Holler},
    booktitle = {The Fuzzing Book},
    title = {Fuzzing with Generators},
    year = {2024},
    publisher = {CISPA Helmholtz Center for Information Security},
    howpublished = {\url{https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html}},
    note = {Retrieved 2024-01-10 15:45:59+01:00},
    url = {https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html},
    urldate = {2024-01-10 15:45:59+01:00}
}
</pre>
</div>

          
</body>
</html>