["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('vBrNT9q2t1Y') \n```", "```py\n>>> from [fuzzingbook.GreyboxFuzzer](GreyboxFuzzer.html) import <identifier> \n```", "```py\n>>> seed_input = \"http://www.google.com/search?q=fuzzing\"\n>>> seeds = [seed_input] \n```", "```py\n>>> mutator = Mutator() \n```", "```py\n>>> schedule = PowerSchedule() \n```", "```py\n>>> greybox_fuzzer = GreyboxFuzzer(seeds=seeds, mutator=mutator, schedule=schedule) \n```", "```py\n>>> http_runner = FunctionCoverageRunner(http_program)\n>>> outcomes = greybox_fuzzer.runs(http_runner, trials=10000) \n```", "```py\n>>> greybox_fuzzer.population[:20]\n[http://www.google.com/search?q=fuzzing,\n http://ww.gomgle.com/searciq=fuzzing,\n |h>Att&p8?wwnOgle.cooarhl~Cp`uzza',\n http2Ot/*gv-VRgogec:om/rearc h=fu~i\n g,\n http\"Ot/*gv-VRgogecom/rearc h=u~i\n f,\n http\"Ot/g$vVRgogEecom/#reabc h=u~a\n f,\n httT`2Ot//:7ev^VRgoec:uom/re!6dctKc= hS;=fu-yH\n /,\n http'www&go/le.comm/sea:rh*?q=Ftzzifg,\n h4tpw://w.gomMle.m/weazciq=fuezzi.',\n h~Att&p8?ws_nOge.#ooarhBlw~Cp`uzza',\n ht8P:/wwvgkowcom/eacrh?q=f uzzing,\n httT`Ot//:7evVR\"goec:uom/re!dctKc=hS;=fu-yH\n I,\n htp://ww.go/gl%.otm/wearch?q=f5zzing,\n httU`Ot//:7evVR\"goec:uo2Jm/re#dctKc=hS;=fu-yH\n I,\n ht4p://ww.gomgle.co.serciq=fuzzing,\n httpp\"OtSo*gv'VRgkg;eom/earcR >\n =u|in\n f,\n htP:/wwvgMolwcomeachq=f uzzine,\n htt://[/wwgwC6.]gogleg/lE.bo/_sEarcq9Afqwz\"king,\n httT`Ot//:7evVR\"goec:uom/re!dctKc=hS;=fu-yH\n I,\n tPK:,wIfvglwvc#omeaBc`9qOin] \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import List, Set, Any, Tuple, Dict, Union\nfrom [collections.abc](https://docs.python.org/3/library/collections.abc.html) import Sequence \n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\nfrom [Coverage](Coverage.html) import population_coverage \n```", "```py\nclass Mutator:\n  \"\"\"Mutate strings\"\"\"\n\n    def __init__(self) -> None:\n  \"\"\"Constructor\"\"\"\n        self.mutators = [\n            self.delete_random_character,\n            self.insert_random_character,\n            self.flip_random_character\n        ] \n```", "```py\nclass Mutator(Mutator):\n    def insert_random_character(self, s: str) -> str:\n  \"\"\"Returns s with a random character inserted\"\"\"\n        pos = random.randint(0, len(s))\n        random_character = chr(random.randrange(32, 127))\n        return s[:pos] + random_character + s[pos:] \n```", "```py\nclass Mutator(Mutator):\n    def delete_random_character(self, s: str) -> str:\n  \"\"\"Returns s with a random character deleted\"\"\"\n        if s == \"\":\n            return self.insert_random_character(s)\n\n        pos = random.randint(0, len(s) - 1)\n        return s[:pos] + s[pos + 1:] \n```", "```py\nclass Mutator(Mutator):\n    def flip_random_character(self, s: str) -> str:\n  \"\"\"Returns s with a random bit flipped in a random position\"\"\"\n        if s == \"\":\n            return self.insert_random_character(s)\n\n        pos = random.randint(0, len(s) - 1)\n        c = s[pos]\n        bit = 1 << random.randint(0, 6)\n        new_c = chr(ord(c) ^ bit)\n        return s[:pos] + new_c + s[pos + 1:] \n```", "```py\nclass Mutator(Mutator):\n    def mutate(self, inp: Any) -> Any:  # can be str or Seed (see below)\n  \"\"\"Return s with a random mutation applied. Can be overloaded in subclasses.\"\"\"\n        mutator = random.choice(self.mutators)\n        return mutator(inp) \n```", "```py\nMutator().mutate(\"good\") \n```", "```py\n'cood'\n\n```", "```py\nfrom [Coverage](Coverage.html) import Location \n```", "```py\nclass Seed:\n  \"\"\"Represent an input with additional attributes\"\"\"\n\n    def __init__(self, data: str) -> None:\n  \"\"\"Initialize from seed data\"\"\"\n        self.data = data\n\n        # These will be needed for advanced power schedules\n        self.coverage: Set[Location] = set()\n        self.distance: Union[int, float] = -1\n        self.energy = 0.0\n\n    def __str__(self) -> str:\n  \"\"\"Returns data as string representation of the seed\"\"\"\n        return self.data\n\n    __repr__ = __str__ \n```", "```py\nclass PowerSchedule:\n  \"\"\"Define how fuzzing time should be distributed across the population.\"\"\"\n\n    def __init__(self) -> None:\n  \"\"\"Constructor\"\"\"\n        self.path_frequency: Dict = {}\n\n    def assignEnergy(self, population: Sequence[Seed]) -> None:\n  \"\"\"Assigns each seed the same energy\"\"\"\n        for seed in population:\n            seed.energy = 1\n\n    def normalizedEnergy(self, population: Sequence[Seed]) -> List[float]:\n  \"\"\"Normalize energy\"\"\"\n        energy = list(map(lambda seed: seed.energy, population))\n        sum_energy = sum(energy)  # Add up all values in energy\n        assert sum_energy != 0\n        norm_energy = list(map(lambda nrg: nrg / sum_energy, energy))\n        return norm_energy\n\n    def choose(self, population: Sequence[Seed]) -> Seed:\n  \"\"\"Choose weighted by normalized energy.\"\"\"\n        self.assignEnergy(population)\n        norm_energy = self.normalizedEnergy(population)\n        seed: Seed = random.choices(population, weights=norm_energy)[0]\n        return seed \n```", "```py\npopulation = [Seed(\"A\"), Seed(\"B\"), Seed(\"C\")]\nschedule = PowerSchedule()\nhits = {\n    \"A\": 0,\n    \"B\": 0,\n    \"C\": 0\n} \n```", "```py\nfor i in range(10000):\n    seed = schedule.choose(population)\n    hits[seed.data] += 1 \n```", "```py\nhits \n```", "```py\n{'A': 3387, 'B': 3255, 'C': 3358}\n\n```", "```py\nfrom [MutationFuzzer](MutationFuzzer.html) import FunctionCoverageRunner, http_program \n```", "```py\ndef crashme(s: str) -> None:\n    if len(s) > 0 and s[0] == 'b':\n        if len(s) > 1 and s[1] == 'a':\n            if len(s) > 2 and s[2] == 'd':\n                if len(s) > 3 and s[3] == '!':\n                    raise Exception() \n```", "```py\ncrashme_runner = FunctionCoverageRunner(crashme)\ncrashme_runner.run(\"good\")\nlist(crashme_runner.coverage()) \n```", "```py\n[('run_function', 132), ('crashme', 2)]\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\nclass AdvancedMutationFuzzer(Fuzzer):\n  \"\"\"Base class for mutation-based fuzzing.\"\"\"\n\n    def __init__(self, seeds: List[str],\n                 mutator: Mutator,\n                 schedule: PowerSchedule) -> None:\n  \"\"\"Constructor.\n `seeds` - a list of (input) strings to mutate.\n `mutator` - the mutator to apply.\n `schedule` - the power schedule to apply.\n \"\"\"\n        self.seeds = seeds\n        self.mutator = mutator\n        self.schedule = schedule\n        self.inputs: List[str] = []\n        self.reset()\n\n    def reset(self) -> None:\n  \"\"\"Reset the initial population and seed index\"\"\"\n        self.population = list(map(lambda x: Seed(x), self.seeds))\n        self.seed_index = 0\n\n    def create_candidate(self) -> str:\n  \"\"\"Returns an input generated by fuzzing a seed in the population\"\"\"\n        seed = self.schedule.choose(self.population)\n\n        # Stacking: Apply multiple mutations to generate the candidate\n        candidate = seed.data\n        trials = min(len(candidate), 1 << random.randint(1, 5))\n        for i in range(trials):\n            candidate = self.mutator.mutate(candidate)\n        return candidate\n\n    def fuzz(self) -> str:\n  \"\"\"Returns first each seed once and then generates new inputs\"\"\"\n        if self.seed_index < len(self.seeds):\n            # Still seeding\n            self.inp = self.seeds[self.seed_index]\n            self.seed_index += 1\n        else:\n            # Mutating\n            self.inp = self.create_candidate()\n\n        self.inputs.append(self.inp)\n        return self.inp \n```", "```py\nseed_input = \"good\"\nmutation_fuzzer = AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())\nprint(mutation_fuzzer.fuzz())\nprint(mutation_fuzzer.fuzz())\nprint(mutation_fuzzer.fuzz()) \n```", "```py\ngood\ngDoodC\n/\n\n```", "```py\nimport [time](https://docs.python.org/3/library/time.html) \n```", "```py\nn = 30000 \n```", "```py\nblackbox_fuzzer = AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())\n\nstart = time.time()\nblackbox_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)\nend = time.time()\n\n\"It took the blackbox mutation-based fuzzer %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the blackbox mutation-based fuzzer 4.21 seconds to generate and execute 30000 inputs.'\n\n```", "```py\n_, blackbox_coverage = population_coverage(blackbox_fuzzer.inputs, crashme)\nbb_max_coverage = max(blackbox_coverage)\n\n\"The blackbox mutation-based fuzzer achieved a maximum coverage of %d statements.\" % bb_max_coverage \n```", "```py\n'The blackbox mutation-based fuzzer achieved a maximum coverage of 2 statements.'\n\n```", "```py\n[seed_input] + \\\n    [\n        blackbox_fuzzer.inputs[idx] for idx in range(len(blackbox_coverage))\n        if blackbox_coverage[idx] > blackbox_coverage[idx - 1]\n    ] \n```", "```py\n['good', 'bo']\n\n```", "```py\nclass GreyboxFuzzer(AdvancedMutationFuzzer):\n  \"\"\"Coverage-guided mutational fuzzing.\"\"\"\n\n    def reset(self):\n  \"\"\"Reset the initial population, seed index, coverage information\"\"\"\n        super().reset()\n        self.coverages_seen = set()\n        self.population = []  # population is filled during greybox fuzzing\n\n    def run(self, runner: FunctionCoverageRunner) -> Tuple[Any, str]:\n  \"\"\"Run function(inp) while tracking coverage.\n If we reach new coverage,\n add inp to population and its coverage to population_coverage\n \"\"\"\n        result, outcome = super().run(runner)\n        new_coverage = frozenset(runner.coverage())\n        if new_coverage not in self.coverages_seen:\n            # We have new coverage\n            seed = Seed(self.inp)\n            seed.coverage = runner.coverage()\n            self.coverages_seen.add(new_coverage)\n            self.population.append(seed)\n\n        return (result, outcome) \n```", "```py\nseed_input = \"good\"\ngreybox_fuzzer = GreyboxFuzzer([seed_input], Mutator(), PowerSchedule())\n\nstart = time.time()\ngreybox_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)\nend = time.time()\n\n\"It took the greybox mutation-based fuzzer %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the greybox mutation-based fuzzer 4.23 seconds to generate and execute 30000 inputs.'\n\n```", "```py\n_, greybox_coverage = population_coverage(greybox_fuzzer.inputs, crashme)\ngb_max_coverage = max(greybox_coverage)\n\n\"Our greybox mutation-based fuzzer covers %d more statements\" % (gb_max_coverage - bb_max_coverage) \n```", "```py\n'Our greybox mutation-based fuzzer covers 2 more statements'\n\n```", "```py\ngreybox_fuzzer.population \n```", "```py\n[good, bo, baof, bad4u]\n\n```", "```py\n%matplotlib inline \n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nline_bb, = plt.plot(blackbox_coverage, label=\"Blackbox\")\nline_gb, = plt.plot(greybox_coverage, label=\"Greybox\")\nplt.legend(handles=[line_bb, line_gb])\nplt.title('Coverage over time')\nplt.xlabel('# of inputs')\nplt.ylabel('lines covered'); \n```", "```py\nfrom [Fuzzer](Fuzzer.html) import RandomFuzzer\nblackbox_gen_fuzzer = RandomFuzzer(min_length=4, max_length=4, char_start=32, char_range=96) \n```", "```py\nimport [pickle](https://docs.python.org/3/library/pickle.html)   # serializes an object by producing a byte array from all the information in the object\nimport [hashlib](https://docs.python.org/3/library/hashlib.html)  # produces a 128-bit hash value from a byte array \n```", "```py\ndef getPathID(coverage: Any) -> str:\n  \"\"\"Returns a unique hash for the covered statements\"\"\"\n    pickled = pickle.dumps(sorted(coverage))\n    return hashlib.md5(pickled).hexdigest() \n```", "```py\nclass AFLFastSchedule(PowerSchedule):\n  \"\"\"Exponential power schedule as implemented in AFL\"\"\"\n\n    def __init__(self, exponent: float) -> None:\n        self.exponent = exponent\n\n    def assignEnergy(self, population: Sequence[Seed]) -> None:\n  \"\"\"Assign exponential energy inversely proportional to path frequency\"\"\"\n        for seed in population:\n            seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent) \n```", "```py\nclass CountingGreyboxFuzzer(GreyboxFuzzer):\n  \"\"\"Count how often individual paths are exercised.\"\"\"\n\n    def reset(self):\n  \"\"\"Reset path frequency\"\"\"\n        super().reset()\n        self.schedule.path_frequency = {}\n\n    def run(self, runner: FunctionCoverageRunner) -> Tuple[Any, str]:\n  \"\"\"Inform scheduler about path frequency\"\"\"\n        result, outcome = super().run(runner)\n\n        path_id = getPathID(runner.coverage())\n        if path_id not in self.schedule.path_frequency:\n            self.schedule.path_frequency[path_id] = 1\n        else:\n            self.schedule.path_frequency[path_id] += 1\n\n        return(result, outcome) \n```", "```py\nn = 10000\nseed_input = \"good\"\nfast_schedule = AFLFastSchedule(5)\nfast_fuzzer = CountingGreyboxFuzzer([seed_input], Mutator(), fast_schedule)\nstart = time.time()\nfast_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)\nend = time.time()\n\n\"It took the fuzzer w/ exponential schedule %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the fuzzer w/ exponential schedule 1.54 seconds to generate and execute 10000 inputs.'\n\n```", "```py\nimport [numpy](https://numpy.org/) as np \n```", "```py\nx_axis = np.arange(len(fast_schedule.path_frequency))\ny_axis = list(fast_schedule.path_frequency.values())\n\nplt.bar(x_axis, y_axis)\nplt.xticks(x_axis)\nplt.ylim(0, n)\n# plt.yscale(\"log\")\n# plt.yticks([10,100,1000,10000])\nplt; \n```", "```py\nprint(\"             path id 'p'           : path frequency 'f(p)'\")\nfast_schedule.path_frequency \n```", "```py\n             path id 'p'           : path frequency 'f(p)'\n\n```", "```py\n{'e014b68ad4f3bc2daf207e2498d14cbf': 5615,\n '0a1008773804033d8a4c0e3aba4b96a0': 2597,\n 'eae4df5b039511eac56625f47c337d24': 1098,\n 'b14f545c3b39716a455034d9a0c61b8c': 454,\n '11529f85aaa30be08110f3076748e420': 235,\n '669903139e4064f7f07bc8b200fd2d26': 1}\n\n```", "```py\nseed_input = \"good\"\norig_schedule = PowerSchedule()\norig_fuzzer = CountingGreyboxFuzzer([seed_input], Mutator(), orig_schedule)\nstart = time.time()\norig_fuzzer.runs(FunctionCoverageRunner(crashme), trials=n)\nend = time.time()\n\n\"It took the fuzzer w/ original schedule %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the fuzzer w/ original schedule 1.43 seconds to generate and execute 10000 inputs.'\n\n```", "```py\nx_axis = np.arange(len(orig_schedule.path_frequency))\ny_axis = list(orig_schedule.path_frequency.values())\n\nplt.bar(x_axis, y_axis)\nplt.xticks(x_axis)\nplt.ylim(0, n)\n# plt.yscale(\"log\")\n# plt.yticks([10,100,1000,10000])\nplt; \n```", "```py\nprint(\"             path id 'p'           : path frequency 'f(p)'\")\norig_schedule.path_frequency \n```", "```py\n             path id 'p'           : path frequency 'f(p)'\n\n```", "```py\n{'e014b68ad4f3bc2daf207e2498d14cbf': 6579,\n '0a1008773804033d8a4c0e3aba4b96a0': 2381,\n 'eae4df5b039511eac56625f47c337d24': 737,\n 'b14f545c3b39716a455034d9a0c61b8c': 241,\n '11529f85aaa30be08110f3076748e420': 62}\n\n```", "```py\norig_energy = orig_schedule.normalizedEnergy(orig_fuzzer.population)\n\nfor (seed, norm_energy) in zip(orig_fuzzer.population, orig_energy):\n    print(\"'%s', %0.5f, %s\" % (getPathID(seed.coverage),\n                               norm_energy, repr(seed.data))) \n```", "```py\n'e014b68ad4f3bc2daf207e2498d14cbf', 0.20000, 'good'\n'0a1008773804033d8a4c0e3aba4b96a0', 0.20000, 'bgI/d'\n'eae4df5b039511eac56625f47c337d24', 0.20000, 'baI/dt'\n'b14f545c3b39716a455034d9a0c61b8c', 0.20000, 'badtuS'\n'11529f85aaa30be08110f3076748e420', 0.20000, 'bad!`tuS'\n\n```", "```py\nfast_energy = fast_schedule.normalizedEnergy(fast_fuzzer.population)\n\nfor (seed, norm_energy) in zip(fast_fuzzer.population, fast_energy):\n    print(\"'%s', %0.5f, %s\" % (getPathID(seed.coverage),\n                               norm_energy, repr(seed.data))) \n```", "```py\n'e014b68ad4f3bc2daf207e2498d14cbf', 0.00000, 'good'\n'0a1008773804033d8a4c0e3aba4b96a0', 0.00000, 'bnd'\n'eae4df5b039511eac56625f47c337d24', 0.00000, 'ba.'\n'b14f545c3b39716a455034d9a0c61b8c', 0.00000, 'bad.'\n'11529f85aaa30be08110f3076748e420', 0.00000, 'bad!\\\\.'\n'669903139e4064f7f07bc8b200fd2d26', 1.00000, 'bad!\\\\.'\n\n```", "```py\n_, orig_coverage = population_coverage(orig_fuzzer.inputs, crashme)\n_, fast_coverage = population_coverage(fast_fuzzer.inputs, crashme)\nline_orig, = plt.plot(orig_coverage, label=\"Original Greybox Fuzzer\")\nline_fast, = plt.plot(fast_coverage, label=\"Boosted Greybox Fuzzer\")\nplt.legend(handles=[line_orig, line_fast])\nplt.title('Coverage over time')\nplt.xlabel('# of inputs')\nplt.ylabel('lines covered'); \n```", "```py\nfrom [html.parser](https://docs.python.org/3/library/html.parser.html) import HTMLParser \n```", "```py\n# create wrapper function\ndef my_parser(inp: str) -> None:\n    parser = HTMLParser()  # resets the HTMLParser object for every fuzz input\n    parser.feed(inp) \n```", "```py\nn = 5000\nseed_input = \" \"  # empty seed\nblackbox_fuzzer = AdvancedMutationFuzzer([seed_input], Mutator(), PowerSchedule())\ngreybox_fuzzer = GreyboxFuzzer([seed_input], Mutator(), PowerSchedule())\nboosted_fuzzer = CountingGreyboxFuzzer([seed_input], Mutator(), AFLFastSchedule(5)) \n```", "```py\nstart = time.time()\nblackbox_fuzzer.runs(FunctionCoverageRunner(my_parser), trials=n)\ngreybox_fuzzer.runs(FunctionCoverageRunner(my_parser), trials=n)\nboosted_fuzzer.runs(FunctionCoverageRunner(my_parser), trials=n)\nend = time.time()\n\n\"It took all three fuzzers %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took all three fuzzers 11.23 seconds to generate and execute 5000 inputs.'\n\n```", "```py\n_, black_coverage = population_coverage(blackbox_fuzzer.inputs, my_parser)\n_, grey_coverage = population_coverage(greybox_fuzzer.inputs, my_parser)\n_, boost_coverage = population_coverage(boosted_fuzzer.inputs, my_parser)\nline_black, = plt.plot(black_coverage, label=\"Blackbox Fuzzer\")\nline_grey, = plt.plot(grey_coverage, label=\"Greybox Fuzzer\")\nline_boost, = plt.plot(boost_coverage, label=\"Boosted Greybox Fuzzer\")\nplt.legend(handles=[line_boost, line_grey, line_black])\nplt.title('Coverage over time')\nplt.xlabel('# of inputs')\nplt.ylabel('lines covered'); \n```", "```py\nblackbox_fuzzer.inputs[-10:] \n```", "```py\n['2 ', '', 'A ', '', '`', '!', '', '', '', '(']\n\n```", "```py\ngreybox_fuzzer.inputs[-10:] \n```", "```py\n['\\x00',\n '(0<2q$V\\x00\"jy}Kz',\n '_NrGlffJ%\\x14=',\n '2&8,gBa',\n '',\n 'W_&k\\\\<C<hoPqv',\n '*&\\x05t4<&d@R%',\n '0aO<4\\x06',\n 'i:',\n 'iFK&</\\x06']\n\n```", "```py\nmaze_string = \"\"\"\n+-+-----+\n|X|     |\n| | --+ |\n| |   | |\n| +-- | |\n|     |#|\n+-----+-+\n\"\"\" \n```", "```py\nfrom [ControlFlow](ControlFlow.html) import generate_maze_code \n```", "```py\nmaze_code = generate_maze_code(maze_string) \n```", "```py\nexec(maze_code) \n```", "```py\nprint(maze(\"DDDDRRRRUULLUURRRRDDDD\"))  # Appending one more 'D', you have reached the target. \n```", "```py\nSOLVED\n\n+-+-----+\n| |     |\n| | --+ |\n| |   | |\n| +-- | |\n|     |X|\n+-----+-+\n\n```", "```py\nfrom [ControlFlow](ControlFlow.html) import callgraph \n```", "```py\ncallgraph(maze_code) \n```", "```py\nclass DictMutator(Mutator):\n  \"\"\"Variant of `Mutator` inserting keywords from a dictionary\"\"\"\n\n    def __init__(self, dictionary: Sequence[str]) -> None:\n  \"\"\"Constructor.\n `dictionary` - a list of strings that can be used as keywords\n \"\"\"\n        super().__init__()\n        self.dictionary = dictionary\n        self.mutators.append(self.insert_from_dictionary)\n\n    def insert_from_dictionary(self, s: str) -> str:\n  \"\"\"Returns `s` with a keyword from the dictionary inserted\"\"\"\n        pos = random.randint(0, len(s))\n        random_keyword = random.choice(self.dictionary)\n        return s[:pos] + random_keyword + s[pos:] \n```", "```py\nclass MazeMutator(DictMutator):\n    def __init__(self, dictionary: Sequence[str]) -> None:\n        super().__init__(dictionary)\n        self.mutators.append(self.delete_last_character)\n        self.mutators.append(self.append_from_dictionary)\n\n    def append_from_dictionary(self, s: str) -> str:\n  \"\"\"Returns s with a keyword from the dictionary appended\"\"\"\n        random_keyword = random.choice(self.dictionary)\n        return s + random_keyword\n\n    def delete_last_character(self, s: str) -> str:\n  \"\"\"Returns s without the last character\"\"\"\n        if len(s) > 0:\n            return s[:-1]\n        return s \n```", "```py\nn = 20000\nseed_input = \" \"  # empty seed\n\nmaze_mutator = MazeMutator([\"L\", \"R\", \"U\", \"D\"])\nmaze_schedule = PowerSchedule()\nmaze_fuzzer = GreyboxFuzzer([seed_input], maze_mutator, maze_schedule)\n\nstart = time.time()\nmaze_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)\nend = time.time()\n\n\"It took the fuzzer %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the fuzzer 8.27 seconds to generate and execute 20000 inputs.'\n\n```", "```py\ndef print_stats(fuzzer: GreyboxFuzzer) -> None:\n    total = len(fuzzer.population)\n    solved = 0\n    invalid = 0\n    valid = 0\n    for seed in fuzzer.population:\n        s = maze(str(seed.data))\n        if \"INVALID\" in s:\n            invalid += 1\n        elif \"VALID\" in s:\n            valid += 1\n        elif \"SOLVED\" in s:\n            solved += 1\n            if solved == 1:\n                print(\"First solution: %s\" % repr(seed))\n        else:\n            print(\"??\")\n\n    print(\"\"\"Out of %d seeds,\n* %4d solved the maze,\n* %4d were valid but did not solve the maze, and\n* %4d were invalid\"\"\" % (total, solved, valid, invalid)) \n```", "```py\nprint_stats(maze_fuzzer) \n```", "```py\nOut of 1275 seeds,\n*    0 solved the maze,\n*  319 were valid but did not solve the maze, and\n*  956 were invalid\n\n```", "```py\ntarget = target_tile()\ntarget \n```", "```py\n'tile_6_7'\n\n```", "```py\nimport [networkx](https://networkx.org/) as nx \n```", "```py\nfrom [ControlFlow](ControlFlow.html) import get_callgraph \n```", "```py\ncg = get_callgraph(maze_code)\nfor node in cg.nodes():\n    if target in node:\n        target_node = node\n        break \n```", "```py\ntarget_node \n```", "```py\n'callgraphX__tile_6_7'\n\n```", "```py\ndistance = {}\nfor node in cg.nodes():\n    if \"__\" in node:\n        name = node.split(\"__\")[-1]\n    else:\n        name = node\n    try:\n        distance[name] = nx.shortest_path_length(cg, node, target_node)\n    except:\n        distance[name] = 0xFFFF \n```", "```py\n{k: distance[k] for k in list(distance) if distance[k] < 0xFFFF} \n```", "```py\n{'callgraphX': 1,\n 'maze': 23,\n 'tile_2_1': 22,\n 'tile_2_3': 8,\n 'tile_2_4': 7,\n 'tile_2_5': 6,\n 'tile_2_6': 5,\n 'tile_2_7': 4,\n 'tile_3_1': 21,\n 'tile_3_3': 9,\n 'tile_3_7': 3,\n 'tile_4_1': 20,\n 'tile_4_3': 10,\n 'tile_4_4': 11,\n 'tile_4_5': 12,\n 'tile_4_7': 2,\n 'tile_5_1': 19,\n 'tile_5_5': 13,\n 'tile_5_7': 1,\n 'tile_6_1': 18,\n 'tile_6_2': 17,\n 'tile_6_3': 16,\n 'tile_6_4': 15,\n 'tile_6_5': 14,\n 'tile_6_7': 0}\n\n```", "```py\nclass DirectedSchedule(PowerSchedule):\n  \"\"\"Assign high energy to seeds close to some target\"\"\"\n\n    def __init__(self, distance: Dict[str, int], exponent: float) -> None:\n        self.distance = distance\n        self.exponent = exponent\n\n    def __getFunctions__(self, coverage: Set[Location]) -> Set[str]:\n        functions = set()\n        for f, _ in set(coverage):\n            functions.add(f)\n        return functions\n\n    def assignEnergy(self, population: Sequence[Seed]) -> None:\n  \"\"\"Assigns each seed energy inversely proportional\n to the average function-level distance to target.\"\"\"\n        for seed in population:\n            if seed.distance < 0:\n                num_dist = 0\n                sum_dist = 0\n                for f in self.__getFunctions__(seed.coverage):\n                    if f in list(self.distance):\n                        sum_dist += self.distance[f]\n                        num_dist += 1\n                seed.distance = sum_dist / num_dist\n                seed.energy = (1 / seed.distance) ** self.exponent \n```", "```py\ndirected_schedule = DirectedSchedule(distance, 3)\ndirected_fuzzer = GreyboxFuzzer([seed_input], maze_mutator, directed_schedule)\n\nstart = time.time()\ndirected_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)\nend = time.time()\n\n\"It took the fuzzer %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the fuzzer 10.55 seconds to generate and execute 20000 inputs.'\n\n```", "```py\nprint_stats(directed_fuzzer) \n```", "```py\nOut of 2524 seeds,\n*    0 solved the maze,\n*  916 were valid but did not solve the maze, and\n* 1608 were invalid\n\n```", "```py\ny = [seed.distance for seed in directed_fuzzer.population]\nx = range(len(y))\nplt.scatter(x, y)\nplt.ylim(0, max(y))\nplt.xlabel(\"Seed ID\")\nplt.ylabel(\"Distance\"); \n```", "```py\nclass AFLGoSchedule(DirectedSchedule):\n  \"\"\"Assign high energy to seeds close to the target\"\"\"\n\n    def assignEnergy(self, population: Sequence[Seed]):\n  \"\"\"Assigns each seed energy inversely proportional\n to the average function-level distance to target.\"\"\"\n        min_dist: Union[int, float] = 0xFFFF\n        max_dist: Union[int, float] = 0\n\n        for seed in population:\n            if seed.distance < 0:\n                num_dist = 0\n                sum_dist = 0\n                for f in self.__getFunctions__(seed.coverage):\n                    if f in list(self.distance):\n                        sum_dist += self.distance[f]\n                        num_dist += 1\n                seed.distance = sum_dist / num_dist\n            if seed.distance < min_dist:\n                min_dist = seed.distance\n            if seed.distance > max_dist:\n                max_dist = seed.distance\n\n        for seed in population:\n            if seed.distance == min_dist:\n                if min_dist == max_dist:\n                    seed.energy = 1\n                else:\n                    seed.energy = max_dist - min_dist\n            else:\n                seed.energy = (max_dist - min_dist) / (seed.distance - min_dist) \n```", "```py\naflgo_schedule = AFLGoSchedule(distance, 3)\naflgo_fuzzer = GreyboxFuzzer([seed_input], maze_mutator, aflgo_schedule)\n\nstart = time.time()\naflgo_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)\nend = time.time()\n\n\"It took the fuzzer %0.2f seconds to generate and execute %d inputs.\" % (end - start, n) \n```", "```py\n'It took the fuzzer 16.13 seconds to generate and execute 20000 inputs.'\n\n```", "```py\nprint_stats(aflgo_fuzzer) \n```", "```py\nFirst solution: lMDD+D4DM69WGR>PR?RRqUUVLJLGUURRRRDDDD\nOut of 4071 seeds,\n*  649 solved the maze,\n*  438 were valid but did not solve the maze, and\n* 2984 were invalid\n\n```", "```py\nfor seed in aflgo_fuzzer.population:\n    s = maze(str(seed.data))\n    if \"SOLVED\" in s:\n        filtered = \"\".join(list(filter(lambda c: c in \"UDLR\", seed.data)))\n        print(filtered)\n        break \n```", "```py\nDDDDRRRRUULLUURRRRDDDD\n\n```", "```py\nimport [os](https://docs.python.org/3/library/os.html) \n```", "```py\nif os.path.exists('callgraph.dot'):\n    os.remove('callgraph.dot')\n\nif os.path.exists('callgraph.py'):\n    os.remove('callgraph.py') \n```", "```py\nclass MutationFuzzer(AdvancedMutationFuzzer):\n    pass \n```", "```py\n@incollection{fuzzingbook2023:GreyboxFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Greybox Fuzzing},\n    year = {2023},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/GreyboxFuzzer.html}},\n    note = {Retrieved 2023-11-11 18:18:06+01:00},\n    url = {https://www.fuzzingbook.org/html/GreyboxFuzzer.html},\n    urldate = {2023-11-11 18:18:06+01:00}\n}\n\n```"]