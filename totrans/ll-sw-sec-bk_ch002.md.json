["```asm\n[](#cb1-1)#include <stdio.h>\n[](#cb1-2)#include <string.h>\n[](#cb1-3)\n[](#cb1-4)void copy_and_print(char* src) {\n[](#cb1-5)  char dst[16];\n[](#cb1-6)\n[](#cb1-7)  for (int i = 0; i < strlen(src) + 1; ++i)\n[](#cb1-8)    dst[i] = src[i];\n[](#cb1-9)  printf(\"%s\\n\", dst);\n[](#cb1-10)}\n[](#cb1-11)\n[](#cb1-12)int main(int argc, char* argv[]) {\n[](#cb1-13)  if (argc > 1) {\n[](#cb1-14)    copy_and_print(argv[1]);\n[](#cb1-15)  }\n[](#cb1-16)}\n```", "```asm\n[](#cb2-1)struct auth_t {\n[](#cb2-2)  char name[32];\n[](#cb2-3)  int logged_in;\n[](#cb2-4)};\n[](#cb2-5) \n[](#cb2-6)int main(int argc, char** argv) {\n[](#cb2-7)  char line[50];\n[](#cb2-8) \n[](#cb2-9)  while(1) {\n[](#cb2-10)    printf(\"[ auth = %p, service = %p ]\\n\", auth, service);\n[](#cb2-11) \n[](#cb2-12)    if (fgets(line, sizeof(line), stdin) == NULL) break;\n[](#cb2-13) \n[](#cb2-14)    // Usage: auth <name>\n[](#cb2-15)    if (strncmp(line, \"auth \", 5) == 0) {\n[](#cb2-16)      auth = (struct auth_t*)malloc(sizeof(struct auth_t));\n[](#cb2-17)\n[](#cb2-18)      // Memory is only set to 0 here, not on free[1]\n[](#cb2-19)      memset(auth, 0, sizeof(struct auth_t));\n[](#cb2-20)\n[](#cb2-21)      if (strlen(line + 5) < 31) {\n[](#cb2-22)        strcpy(auth->name, line + 5);\n[](#cb2-23)      }\n[](#cb2-24)    }\n[](#cb2-25) \n[](#cb2-26)    // Usage: reset\n[](#cb2-27)    else if (strncmp(line, \"reset\", 5) == 0) {\n[](#cb2-28)      // [1]\n[](#cb2-29)      free(auth);\n[](#cb2-30)    }\n[](#cb2-31)\n[](#cb2-32)    // Usage: service <service-name>\n[](#cb2-33)    else if (strncmp(line, \"service \", 8) == 0) {\n[](#cb2-34)      service = strdup(line + 8);\n[](#cb2-35)    }\n[](#cb2-36)\n[](#cb2-37)    // Usage: login\n[](#cb2-38)    else if (strncmp(line, \"login\", 5) == 0) {\n[](#cb2-39)      // Possible use-after-free:\n[](#cb2-40)      if (auth && auth->logged_in) {\n[](#cb2-41)        printf(\"You are already logged in!\\n\");\n[](#cb2-42)      } else {\n[](#cb2-43)        printf(\"NOT AUTHORIZED!\\n\");\n[](#cb2-44)      }\n[](#cb2-45)    }\n[](#cb2-46)  }\n[](#cb2-47)\n[](#cb2-48)  return 0;\n[](#cb2-49)}\n```", "```asm\n> auth admin                                   \n[ auth = 0x78322e1000, service = 0x0 ]       \n> reset                                        \n[ auth = 0x78322e1000, service = 0x0 ]       \n> service aaaaaaaaa0aaaaaaaaa0aaaaaaaaa0121    \n[ auth = 0x78322e1000, service = 0x78322e1000 ]\n> login                                        \nYou are already logged in!\n```", "```asm\n int execve(const char *pathname, char *const argv[],\n             char *const envp[]);\n```", "```asm\n gadget_x0_x1:\n    ldp x0, x1, [sp]\n    ldp x20, x19, [sp, #64]\n    ldp x29, x30, [sp, #32]\n    ldr x21, [sp, #48]\n    add sp, sp, #0x50\n    ret\n```", "```asm\n gadget_x2:\n    mov x2, xzr\n    mov x0, x2\n    ldp x20, x19, [sp, #32]\n    ldp x29, x30, [sp]\n    ldr x21, [sp, #16]\n    add sp, sp, #0x30\n    ret\n```", "```asm\n[](#cb7-1)void f1(int a) { /* ... */ }\n[](#cb7-2)void f2(int* b) { /* ... */ }\n[](#cb7-3)void f3(int c) { /* ... */ }\n```", "```asm\n[](#cb8-1)#include <stdlib.h>\n[](#cb8-2)int cmp_long(const long *a, const long *b) { return *a < *b; }\n[](#cb8-3)long sort_array(long *arr, long size) {\n[](#cb8-4)  /* The prototype of qsort is:\n[](#cb8-5) void qsort(void *base, size_t nmemb, size_t size,\n[](#cb8-6) int (*compar)(const void *, const void *)); */\n[](#cb8-7)  qsort(arr, size, sizeof(long), &cmp_long);\n[](#cb8-8)  return arr[0];\n[](#cb8-9)}\n```", "```asm\n[](#cb9-1)struct A {\n[](#cb9-2)  virtual void f();\n[](#cb9-3)};\n[](#cb9-4)struct B : public A {\n[](#cb9-5)  virtual void f();\n[](#cb9-6)};\n[](#cb9-7)struct C : public A {\n[](#cb9-8)  virtual void f();\n[](#cb9-9)};\n[](#cb9-10)void call_foo(A* a, B* b){\n[](#cb9-11)  a->f();\n[](#cb9-12)  b->f();\n[](#cb9-13)}\n[](#cb9-14)struct D : public B {\n[](#cb9-15)  virtual void f();\n[](#cb9-16)};\n```", "```asm\n[](#cb10-1)  switch (b) {\n[](#cb10-2)    case 0:\n[](#cb10-3)      return a+1;\n[](#cb10-4)    case 1:\n[](#cb10-5)      return a-5;\n[](#cb10-6)    case 2:\n[](#cb10-7)\n[](#cb10-8)      ... /* cases 3-13 omitted for brevity */\n[](#cb10-9)\n[](#cb10-10)    case 14:\n[](#cb10-11)      return a % 4;\n[](#cb10-12)    case 15:\n[](#cb10-13)      return a & 3;\n[](#cb10-14)    }\n```", "```asm\n[](#cb11-1)  ;; x0 contains the value of b, which is the switch value.\n[](#cb11-2)  adrp  x8, lJTI0_0@PAGE\n[](#cb11-3)  add   x8, x8, lJTI0_0@PAGEOFF\n[](#cb11-4)  ;; x8 now contains the address of the jump table.\n[](#cb11-5)  adr   x9, LBB0_2\n[](#cb11-6)  ldrb  w10, [x8, x0]\n[](#cb11-7)  ;; w10 now contains the offset in words from LBB0_2\n[](#cb11-8)  ;; to the target instruction to jump to.\n[](#cb11-9)  add   x9, x9, x10, lsl #2\n[](#cb11-10)  ;; x9 now contains the address of the instruction to jump to.\n[](#cb11-11)  br    x9\n[](#cb11-12)  ;; code emitted for brevity\n[](#cb11-13)\n[](#cb11-14)lJTI0_0:\n[](#cb11-15)  .byte (LBB0_2-LBB0_2)>>2\n[](#cb11-16)  .byte (LBB0_6-LBB0_2)>>2\n[](#cb11-17)  .byte (LBB0_11-LBB0_2)>>2\n[](#cb11-18)  .byte (LBB0_10-LBB0_2)>>2\n[](#cb11-19)  .byte (LBB0_9-LBB0_2)>>2\n[](#cb11-20)  ;; more cases omitted for brevity\n```", "```asm\n[](#cb12-1)  mov   x16, x0\n[](#cb12-2)  ;; check that x0 is in range\n[](#cb12-3)  cmp   x16, #15\n[](#cb12-4)  ;; if x0 is out of range, set switch value to zero (in x16)\n[](#cb12-5)  ;; this guarantees that the value will be loaded from the jump\n[](#cb12-6)  ;; table which is read-only and cannot be modified by an attacker\n[](#cb12-7)  csel  x16, x16, xzr, ls\n[](#cb12-8)  adrp  x17, lJTI0_0@PAGE\n[](#cb12-9)  add   x17, x17, lJTI0_0@PAGEOFF\n[](#cb12-10)  ldrsw x16, [x17, x16, lsl #2]\n[](#cb12-11)Ltmp1:\n[](#cb12-12)  adr   x17, Ltmp1\n[](#cb12-13)  add    x16, x17, x16\n[](#cb12-14)  br     x16\n[](#cb12-15)  ;; code emitted for brevity\n[](#cb12-16)\n[](#cb12-17)lJTI0_0:\n[](#cb12-18)  .long LBB0_2-Ltmp1\n[](#cb12-19)  .long LBB0_6-Ltmp1\n[](#cb12-20)  .long LBB0_11-Ltmp1\n[](#cb12-21)  .long LBB0_10-Ltmp1\n[](#cb12-22)  .long LBB0_9-Ltmp1\n```", "```asm\n[](#cb13-1)  ...\n[](#cb13-2)  ;; the bl instruction jumps to function f and\n[](#cb13-3)  ;; stores the return address, i.e. the address of\n[](#cb13-4)  ;; the 'add' instruction, in register x30\n[](#cb13-5)  bl f\n[](#cb13-6)  add x0, x0, x1\n[](#cb13-7)  ...\n[](#cb13-8)\n[](#cb13-9)f:\n[](#cb13-10)  ;; stores x29 and x30 on the stack. After executing this\n[](#cb13-11)  ;; instruction the return address is in memory, on the stack.\n[](#cb13-12)  stp x29, x30, [sp, #16]!\n[](#cb13-13)  ...\n[](#cb13-14)  ;; load the x29 and x30 registers from the stack. Under the usual\n[](#cb13-15)  ;; threat model, an attacker with a write primitive may have overwritten\n[](#cb13-16)  ;; the value in memory and may control the value in registers x29 and x30\n[](#cb13-17)  ldp x29, x30, [sp], #16\n[](#cb13-18)  ;; The return instruction jumps to the address stored in register x30.\n[](#cb13-19)  ret x30\n```", "```asm\n00000000004006b4 <call_foo(A*)>:\n  4006b4:       a9bf7bfd        stp     x29, x30, [sp, #-16]!\n  4006b8:       910003fd        mov     x29, sp\n  4006bc:       f9400008        ldr     x8, [x0]\n  4006c0:       90000009        adrp    x9, 400000 <_init-0x558>\n  4006c4:       91216129        add     x9, x9, #0x858\n  4006c8:       cb090109        sub     x9, x8, x9\n  4006cc:       d1004129        sub     x9, x9, #0x10\n  4006d0:       93c91529        ror     x9, x9, #5\n  4006d4:       f100093f        cmp     x9, #0x2\n  4006d8:       540000a2        b.cs    4006ec <call_foo(A*)+0x38>\n  4006dc:       f9400108        ldr     x8, [x8]\n  4006e0:       d63f0100        blr     x8\n  4006e4:       a8c17bfd        ldp     x29, x30, [sp], #16\n  4006e8:       d65f03c0        ret\n  4006ec:       d4200020        brk     #0x1\n```", "```asm\nmain:\n    cmp w0, #2\n    b.lt    .LBB1_2\n    str x30, [x18], #8\n    stp x29, x30, [sp, #-16]!\n    mov x29, sp\n    ldr x0, [x1, #8]\n    bl  copy_and_print\n    ldp x29, x30, [sp], #16\n    ldr x30, [x18, #-8]!\n.LBB1_2:\n    mov w0, wzr\n    ret\n```", "```asm\n[](#cb16-1)main:\n[](#cb16-2)    cmp     w0, #2\n[](#cb16-3)    b.lt    .LBB1_2\n[](#cb16-4)    paciasp\n[](#cb16-5)    stp     x29, x30, [sp, #-16]!\n[](#cb16-6)    ldr     x0, [x1, #8]\n[](#cb16-7)    mov     x29, sp\n[](#cb16-8)    bl      copy_and_print\n[](#cb16-9)    ldp     x29, x30, [sp], #16\n[](#cb16-10)    autiasp\n[](#cb16-11).LBB1_2:\n[](#cb16-12)    mov     w0, wzr\n[](#cb16-13)    ret\n```", "```asm\n// Returns zero for failure, non-zero for success.\nint authenticate() {\n  int authenticated = 0;\n  char passphrase[10];\n  if (fgets(passphrase, 20, stdin)) {     // buffer overflow\n    if (!strcmp(passphrase, \"secret\\n\")) {\n      authenticated = 1;\n    }\n  }\n  return authenticated;\n}\n```", "```asm\nstruct foo {\n  int a[6];\n  int b;\n};\n\nint get(struct foo *x, int i) {\n  return x->a[i];\n}\n```", "```asm\nfunction foo(x, y) {\n  return x + y;\n}\n```", "```asm\nfoo:\n  if x not integer, deoptimize\n  if y not integer, deoptimize\n  result = x + y\n  if overflowed, deoptimize\n  return result\n```", "```asm\nfunction foo(x) {\n  y = bar(x);\n  var a = [0, 1, 2];\n  return a[y];\n}\n```"]