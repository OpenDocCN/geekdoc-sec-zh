- en: Search-Based Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/SearchBasedFuzzer.html](http://www.fuzzingbook.org/html/SearchBasedFuzzer.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Sometimes we are not only interested in fuzzing as many as possible diverse
    program inputs, but in deriving *specific* test inputs that achieve some objective,
    such as reaching specific statements in a program. When we have an idea of what
    we are looking for, then we can *search* for it. Search algorithms are at the
    core of computer science, but applying classic search algorithms like breadth
    or depth first search to search for tests is unrealistic, because these algorithms
    potentially require us to look at all possible inputs. However, domain-knowledge
    can be used to overcome this problem. For example, if we can estimate which of
    several program inputs is closer to the one we are looking for, then this information
    can guide us to reach the target quicker – this information is known as a *heuristic*.
    The way heuristics are applied systematically is captured in *meta-heuristic*
    search algorithms. The "meta" denotes that these algorithms are generic and can
    be instantiated differently to different problems. Meta-heuristics often take
    inspiration from processes observed in nature. For example, there are algorithms
    mimicking evolutionary processes, swarm intelligence, or chemical reactions. In
    general, they are much more efficient than exhaustive search approaches such that
    they can be applied to vast search spaces – search spaces as vast as the domain
    of program inputs are no problem for them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should know how code coverage works, e.g. from the [chapter on coverage](Coverage.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter demonstrates how to use meta-heuristic search algorithms to find
    inputs that reach specific locations in the source code. The simplest search algorithm
    is hillclimbing, which is applied to the simple `test_me` example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Different aspects and challenges require different variations of this algorithm,
    such as a `steepest_ascent_hillclimber` or a `restarting_hillclimber`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The search can be guided by different optimization goals captured in fitness
    functions. A fitness function to measure how close we are to reaching locations
    in the source code uses source code instrumentation. To produce an instrumented
    version of `cgi_decode`, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Fitness values are obtained by executing `cgi_decode_instrumented`, which is
    done by the `get_fitness_cgi` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Complex functions like `cgi_decode` result in vastly larger search spaces,
    which can be explored using evolutionary search algorithms such as genetic algorithms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Test Generation as a Search Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to apply a meta-heuristic search algorithm to generate test data
    for a program, then we have to make several choices: First, we need to decide
    on what exactly our *search space* is in the first place. The search space is
    defined by how we *represent* what we are looking for. Are we looking for single
    integer values? Tuples of values? Objects? XML documents?'
  prefs: []
  type: TYPE_NORMAL
- en: Representing Program Inputs as a Search Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The representation is highly dependent on the particular testing problem we
    are solving --- we know which program we are testing, so the representation needs
    to encode whatever an input to our target program is. Let''s consider the example
    function `test_me()` as our function under test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test_me()` function has two input parameters, and returns `True` or `False`
    depending on how the two relate to each other. A test input to `test_me()` consists
    of a pair of values, one for `x` and one for `y`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our search space is only concerned with inputs, thus a simple representation
    for test data would be input tuples `(x, y)`. Each point in this input space has
    eight *neighbors*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x-1, y-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-1, y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-1, y+1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x, y+1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x+1, y+1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x+1, y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x+1, y-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x, y-1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To keep things simple, let''s restrict the size of our search space to start
    with (we will change this later). For example, let''s assume we only want values
    in the range of -1000 to 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the neighbors for any point in our search space, we define the
    function `neighbors()`, which implements a basic Moore neighborhood. That is,
    we look at all 8 immediate neighbors, while considering the boundaries we just
    defined with `MAX` and `MIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This fully defines our search space: We have a representation, and we know
    how individuals are related to each other through their neighborhood. Now we just
    need to find an algorithm to explore this neighborhood, and a heuristic that guides
    the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining a Search Landscape: Fitness functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All meta-heuristics are based on the use of a heuristic function that estimates
    how good a given candidate solution is; this "goodness" is typically called the
    *fitness* of an individual, and the heuristic that estimates the fitness is the
    *fitness function*. The fitness function is a function that maps any point in
    the search space to a numerical value, the fitness value. The better a candidate
    solution in the search space with respect to being an optimal solution, the better
    its fitness value. Thus, if you plot each point in the search space with its fitness
    value as the height, you get a landscape with the optimal solution represented
    as the highest peak.
  prefs: []
  type: TYPE_NORMAL
- en: The fitness function depends on the objective one would like to achieve with
    generating the test data. Suppose that we are interested in covering the true
    branch of the if-condition in the `test_me()` function, i.e. `x == 2 * (y + 1)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How close is a given input tuple for this function from reaching the target
    branch? Let''s consider an arbitrary point in the search space, e.g. `(274, 153)`.
    The if-condition compares the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make the branch true, both values need to be the same. Thus, the
    more they differ, the further we are away from making the comparison true, and
    the less they differ, the closer we are from making the comparison true. Thus,
    we can quantify "how false" the comparison is by calculating the difference between
    `x` and `2 * (y + 1)`. Thus, we can calculate this distance as `abs(x - 2 * (y
    + 1))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can use this distance value as our fitness function, since we can nicely
    measure how close we are to an optimal solution. Note, however, that "better"
    doesn't mean "bigger" in this case; the smaller the distance the better. This
    is not a problem, since any algorithm that can maximize a value can also be made
    to minimize it instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each value in the search space of integer tuples, this distance value defines
    the elevation in our search landscape. Since our example search space is two-dimensional,
    the search landscape is three-dimensional and we can plot it to see what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/20692847dfa6a8161286fd59bf93476a.png)'
  prefs: []
  type: TYPE_IMG
- en: The optimal values, i.e. those that make the if-condition true, have fitness
    value 0 and can be clearly seen at the bottom of the plot. The further away from
    the optimal values, the higher elevated the points in the search space.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fitness function should calculate the distance value for concrete test executions.
    That is, we want to run the program, and then learn the distance value of this
    execution. However, the branching condition is hidden within the source code of
    the target function, and its value may in principle be the result of various calculations
    along the execution path reaching it. Even though in our example the condition
    is an equation using the input values of the function directly, this may not be
    the case in general; it might as well be derived values. Thus, the values we need
    to calculate our distance metric need to be observed directly at the conditional
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is typically done with *instrumentation*: We add new code immediately
    before or after the branching condition to keep track of the values observed and
    calculate the distance using these values. The following is an instrumented version
    of our program under test, which prints out the distance values as it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this out for a couple of example values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When calculating a fitness value, we will execute the instrumented program version,
    but we need some means to access the distance value calculated during that execution.
    As a simple first solution to this problem, we can just add a global variable
    and store the value of the distance calculation there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this instrumented version of `test_me()`, we can now finally define our
    fitness function, which simply runs the instrumented `test_me_instrumented()`
    function, and then retrieves the value of the global `distance` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this on some example inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Hillclimbing the Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having decided on a representation (2-tuples of integers) and a fitness function
    (distance to target branch), we can now finally go ahead and implement our search
    algorithm. Let''s explore this search space using the simplest possible meta-heuristic
    algorithm: Hillclimbing. The metaphor captures aptly what is happening: The algorithm
    tries to climb a hill in the search space defined by our representation. Except,
    that in our search landscape the best values are not those high up but down low,
    so technically we are descending into valleys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hillclimbing algorithm itself is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a random starting point
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine fitness value of all neighbors
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move to neighbor with the best fitness value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If solution is not found, continue with step 2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The hillclimber starts with a random test input, i.e., random values for `x`
    and `y`. For any pair of random integer numbers, the chances of them satisfying
    the condition `x == 2 * (y + 1)` are rather slim. Suppose the random values are
    `(274, 153)`. The right-hand side of the equation, `2 * (y + 1)`, evaluates to
    308, so the condition is clearly false. Where should the hillclimber go to now?
    Let''s look at the fitness values of this test input and its neighbors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Increasing `y` by one increases the value of the right-hand side of the equation
    to `310`. Thus, the value on the left-hand side of the equation thus differs *even
    more* to the value on the right-hand side of the equation than it did before the
    increase! So, increasing `y` does not seem like a good idea. On the other hand,
    increasing `x` by one improves things: The left-hand side and the right-hand side
    of the equation become more similar; they are "less unequal". Thus, out of the
    eight possible neighbors of `(274, 153)`, the neighbor that increases `x` and
    decreases `y` (`(275, 152)`) seems best intuitively --- the outcome of the condition
    is still false, but it is "less so" than for the original value.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement the hillcimbing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The hillclimber starts by choosing random values for `x` and `y`. We use low
    values in the range of `-1000`--`1000` (which we defined `MIN` and `MAX` to be
    earlier) to reduce the time search takes when playing with the example. Then,
    we determine the fitness value of this starting point by calling `get_fitness()`.
    Recall that we are trying to find the smallest possible fitness value, therefore
    we now loop until we have found a fitness value of `0` (i.e., an optimal value).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this loop, we iterate over all neighbors (`neighbors`), and evaluate the
    fitness value of each of the neighbors. As soon as we have found a neighbor with
    better (smaller) fitness, the hillclimber exits the loop and uses this as the
    new starting point. An alternative variant of this simple hillclimbing algorithm
    would be to remove the `break` statement: By doing so, *all* neighbors would be
    evaluated, and the best neighbor would be chosen. This is known as *steepest ascent
    hillclimbing*. You will see that the number of iterations necessary to reach the
    optimum is lower, although for each iteration more tests are executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example program has a very nice fitness landscape – there is a perfect
    gradient, and the hillclimber will always find a solution. We can see this nice
    gradient if we plot the fitness values observed over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/80503fcd92797bcfc36d4a1ea2b360eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This gradient is the result of an ideal fitness landscape. In practice, we
    won''t always have such a nice gradient. In particular, our hillclimber only works
    well as long as there is at least one neighbor that has a better fitness value.
    What if we reach a point where *none* of the neighbors actually has a better fitness
    value? Consider the following function `test_me2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to cover the true-branch of the if-condition in `test_me2` again,
    then we can calculate the distance in the same way as previously, i.e., by calculating
    the difference between the two sides of the comparison. Let''s instrument the
    `test_me2()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: With this instrumented version, we just need a fitness function that calls the
    instrumented version and reads out the global `distance` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run the hillclimber on this example, let''s have a look at the search
    landscape again by plotting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6fd48ef0c2a3b818c031e2eab37cc220.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point it would be nice to run the hillclimber using the new fitness
    function, but there is a problem: Running our hillclimber with this fitness function
    is not a good idea, because it might never terminate. Suppose we''ve reached a
    point where all neighbors have the same or a worse fitness value. The hillclimber
    can move no where and is stuck there forever! Such a point in the search landscape
    is called a *local optimum*. If one reaches such a point, the easiest way out
    is to give up and restart from a new random point. This is what we will do in
    our hillclimber with *random restarts*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The change is trivial: We simply keep track whether any movement has occurred
    with a boolean flag, and if we did not move to any of the neighbors, we pick a
    new random position to start over at. For convenience, we also made the hillclimber
    parameterizable with fitness functions. Let''s try it out with our `bad_fitness`
    and plot the resulting fitness values we observe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/0e028ddf4f35c618bc2aed4332a1b57e.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the example a couple of times. Sometimes, we are lucky and there is a gradient
    that takes it straight to an optimal solution. But sometimes you'll see restarts
    throughout the search before reaching an optimal value.
  prefs: []
  type: TYPE_NORMAL
- en: We restricted initial values of `x` and `y` to rather small range of `[MIN,
    MAX]`. This is a common trick in test generation, as in *most* cases solutions
    tend to consist of small values, and using small values to start the search makes
    the search quicker in many cases. However, what if the solution we need is at
    a completely different place in our search space? Our bias towards smaller solutions
    would mean that the hillclimber would take very long to find the solution, and
    given a fixed search budget it would thus be less likely to actually find a solution.
    To see what effects this would have, we could simply replace the `1000` with,
    say, `1000000` or more. We can play around with the range to see the performance
    we get for our simple search problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In most cases the search now will take much longer until a solution is found
    --- likely longer than we are prepared to wait for such a simple example function!
    (Although sometimes we will get lucky and randomly hit a good starting position).
    How is this ever going to work on "real" examples? Not to imagine if there were
    even more parameters and a bigger neighborhood!
  prefs: []
  type: TYPE_NORMAL
- en: Testing a More Complex Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s turn to a slightly more complex program: The CGI decoder you already
    know from [the Coverage chapter](Coverage.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: CGI Decoder as a Search Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cgi_decode()` function has one input of type string, and one possible
    way to define the neighborhood of a string is by all possible strings that have
    an edit distance of 1\. For example, string `test` would have two neighbors for
    each of its four characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tfst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tett`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tesu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tdst`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, prepending any character or appending any character would also
    have an edit distance of 1 and could be considered neighbors. To keep things simple,
    let's keep the length of our input strings fixed to a reasonable value (e.g. 10).
    In this case, each individual has 20 neighbors (i.e., each character has two neighbors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a new `neighbor_strings()` function that produces these neighboring
    strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `neighbor_strings()` function gets the numerical value of each character
    in the input string, and creates a new string with the character replaced with
    the preceding and succeeding characters in the alphabet. To start with, we only
    consider printable ASCII characters, which are in the range 32-126.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we have defined the search space for the `cgi_decode()` function. The
    next ingredient to searching for individuals in this search space is a fitness
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Branch Distances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `test_me()` function consisted of a single if-condition, in which two integer
    numbers were compared. In the `cgi_decode()` function we have three if-conditions
    and one while loop, and they all compare characters. Fortunately, as we have already
    seen, we can treat characters like numbers, so we can use the same distance estimate
    we used in the `test_me()` example. However, there are also two conditions which
    check whether a character is contained in a set, e.g. `digit_high in hex_values`.
    How close is a value to being contained in the set? An obvious solution would
    be to consider the distance to the closest value in the set as the estimate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: A further simplification we have made so far was to assume that we would always
    want conditions to evaluate to true. In practice, we might want to have if-conditions
    evaluate to false just as well. Thus, each if-condition actually has two distance
    estimates, one to estimate how close it is to being true, and one how close it
    is to being false. If the condition is true, then the true distance is 0; if the
    condition is false, then the false distance is 0\. That is, in a comparison `a
    == b`, if `a` is smaller than `b`, then the false distance is `0` by definition.
  prefs: []
  type: TYPE_NORMAL
- en: What is the distance of `a == b` being false when `a` equals `b`? Any change
    to either `a` or `b` would make the condition evaluate to false, so we can define
    the distance simply as 1 in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'More generally, there can be other types of comparisons, for example using
    relational operators. Consider the loop condition in `cgi_decode()`: `i < len(s)`,
    i.e., it uses a less-than comparison operator. It is quite straight forward to
    extend our notion of branch distance to cover different types of comparisons,
    and to calculate true and false distances. The following table shows how to calculate
    the distance for different types of comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Condition | Distance True | Distance False |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a == b | abs(a - b) | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| a != b | 1 | abs(a - b) |'
  prefs: []
  type: TYPE_TB
- en: '| a < b | b - a + 1 | a - b |'
  prefs: []
  type: TYPE_TB
- en: '| a <= b | b - a | a - b + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| a > b | a - b + 1 | b - a |'
  prefs: []
  type: TYPE_TB
- en: 'Note that several of the calculations add a constant `1`. The reason for this
    is quite simple: Suppose we want to have `a < b` evaluate to true, and let `a
    = 27` and `b = 27`. The condition is not true, but simply taking the difference
    would give us a result of `0`. To avoid this, we have to add a constant value.
    It is not important whether this value is `1` -- any positive constant works.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Complex Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `cgi_decode()` function, we can also find a somewhat more complex predicate
    which consists of two conditions joined by a logical `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if digit_high in hex_values and digit_low in hex_values:`'
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the branch distance is defined such that the distance to make
    a conjunction `A and B` true equals the sum of the branch distances for `A` and
    `B`, as both of the two conditions would need to be true. Similarly, the branch
    distance to make `A or B` true would be the minimum of the two branch distances
    of `A` and `B`, as it suffices if one of the two conditions is true to make the
    entire expression true.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is not as easy as that in practice: Predicates can consist of nested
    conditions and negations, and one would need to convert the expression to canonical
    form before being able to apply this calculation. Furthermore, most modern programming
    languages use *short-circuit evaluation*: If there is a condition `A or B`, and
    `A` is true, then `B` is never evaluated. If `B` is an expression with side effects,
    then by calculating the branch distance of `B` even though short-circuit evaluation
    would avoid its execution, we would potentially be changing the program behavior
    (by invoking the side-effect that would in normal behavior not be executed), and
    that is not acceptable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, what if the branching condition has side effects? For example,
    suppose that the branching condition were `x == 2 * foo(y)`, where `foo()` is
    a function that takes an integer as input. Naively instrumenting would lead to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the instrumentation would lead to `foo()` being executed *twice*. Suppose
    `foo()` changes the state of the system (e.g., by printing something, accessing
    the file system, changing some state variables, etc.), then clearly invoking `foo()`
    a second time is a bad idea. One way to overcome this problem is to *transform*
    the conditions, rather than *adding* tracing calls. For example, one can create
    temporary variables that hold the values necessary for the distance calculation
    and then use these in the branching condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Besides these issues, the approach of adding a global variable and method call
    to the program seems like a rather clumsy approach --- surely we cannot start
    thinking about every branch in our program on its own and instrument the program
    we want to test manually, in particular if programs have multiple branches like
    the `cgi_decode()` function. Rather, we should be looking at how to *automatically*
    instrument programs to contain the necessary added statements such that we can
    calculate fitness values.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation for Atomic Conditions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative approach to using the global and temporary variables is to replace
    the actual comparison with a call to a helper function, where the original expressions
    are evaluated as arguments, and the operator is an additional argument. Assume
    we have a function `evaluate_condition()` which takes four parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`num` is a unique id that identifies the condition;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`op` is the operator of the comparison;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lhs` and `rhs` are the operands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The function calculates two distances for the condition: The distance to the
    condition evaluating to true, and the distance to the condition evaluating to
    false. One of the two outcomes will always be true, and thus one of them will
    always have distance `0`. Since the function replaces the original comparison,
    it returns true or false, depending on which distance is `0`. That means, the
    example expression'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: would be replaced by
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'such that the arguments are only evaluated once, and side effects are thus
    handled correctly. Here is how the `evaluate_condition()` function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are initializing `distance_true` and `distance_false` with `0`.
    Thus, if `lhs` equals `rhs`, then the variable `distance_true` remains 0, and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'What the `evaluate_condition()` function does not yet do is store the distances
    observed. Obviously, we will need to store the values somewhere so that we can
    access it from our fitness function. Since the `cgi_decode()` program consists
    of several conditions, and for each condition we might be interested in the true
    and the false distance, we simply use two global dictionaries, `distances_true`
    and `distances_false`, and define a helper function that stores the distance values
    observed in the dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The variable `condition_num` is the unique ID of the condition that we've just
    evaluated. If this is the first time that we have executed this particular condition,
    then the true and false distances are simply stored in the corresponding dictionaries.
    However, it is possible that the same test executes a condition multiple times.
    For example, the loop condition `i < len(s)` in the `cgi_decode()` function is
    evaluated before every single loop iteration. In the end, however, we want to
    have a single fitness value for a test. As covering a branch just requires that
    at least one of the executions reaches the branch, we consider only the closest
    one. Therefore, if the `distances_true` and `distances_false` dictionaries already
    contain the distance from a previous execution, we only replace that value if
    the new execution was closer to reaching the branch; this is implemented using
    the `min()` function.
  prefs: []
  type: TYPE_NORMAL
- en: We now need to call this function from within `evaluate_condition()`. Let's
    also add the calculation of distance for the `in` operator and the `<` comparison,
    since we need both of them for the `cgi_decode()` example. Furthermore, `cgi_decode()`
    actually compares characters and numbers. To make sure we use the correct types,
    we first have to convert the characters to numbers to calculate the distances.
    This is done using Python's `ord()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows the instrumentation of the conjunction from `cgi_decode()`
    to make use of the `evaluate_condition()` function. There are two calls to `evaluate_condition`
    corresponding to the two conditions, and the operator `and` with which they are
    conjoined ensures that the original short-circuiting behavior is preserved:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (evaluate_condition(4, ''In'', digit_high, hex_values) and evaluate_condition(5,
    ''In'', digit_low, hex_values))`'
  prefs: []
  type: TYPE_NORMAL
- en: Of course we would like to automatically produce this instrumented version.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting Source Code Automatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Replacing comparisons automatically is actually quite easy in Python, using
    the abstract syntax tree (AST) of the program. In the AST, a comparison will typically
    be a tree node with an operator attribute and two children for the left-hand and
    right-hand operators. To replace such comparisons with a call to `evaluate_condition()`
    one simply needs to replace the comparison node in the AST with a function call
    node, and this is what the `BranchTransformer` class does use a `NodeTransformer`
    from Python''s `ast` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BranchTransformer` parses a target Python program using the built-in parser
    `ast.parse()`, which returns the AST. Python provides an API to traverse and modify
    this AST. To replace the comparison with a function call we use an `ast.NodeTransformer`,
    which uses the visitor pattern where there is one `visit_*` function for each
    type of node in the AST. As we are interested in replacing comparisons, we override
    `visit_Compare`, where instead of the original comparison node we return a new
    node of type `ast.Func`, which is a function call node. The first parameter of
    this node is the name of the function `evaluate_condition()`, and the arguments
    are the four arguments that our `evaluate_condition()` function expects:'
  prefs: []
  type: TYPE_NORMAL
- en: the number of branch (for which we keep a count in `branch_num`),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the operator (for which we simply use the class name),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the left-hand side, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the right-hand side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that Python allows comparisons of multiple expressions (e.g. `1 < x < 10`);
    to keep the code simple we only deal with individual comparisons here, but it
    would be straight forward to extend the code by treating each comparison with
    an individual call to `evaluate_condition`. You will notice that we also override
    `visit_FunctionDef`; this is just to change the name of the method by appending
    `_instrumented`, so that we can continue to use the original function together
    with the instrumented one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code parses the source code of the `cgi_decode()` function to
    an AST, then transforms it, and prints it out again (using the `unparse()` function
    from the `ast` library):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: To calculate a fitness value with the instrumented version, we need to compile
    the instrumented AST again, which is done using Python's `compile()` function.
    We then need to make the compiled function accessible, for which we first retrieve
    the current module from `sys.modules`, and then add the compiled code of the instrumented
    function to the list of functions of the current module using `exec`. After this,
    the `cgi_decode_instrumented()` function can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the `distances_true` and `distances_false` maps, conditions
    1 and 2 have evaluated to true and to false, whereas condition 3 has only evaluated
    to false, when executed on `cgi_decode_instrumented`. This is as expected, since
    the while-loop was entered and left, and there was one white space but no `%`-character
    in the input string.
  prefs: []
  type: TYPE_NORMAL
- en: Fitness Function to Create Valid Hexadecimal Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example, let''s take as objective to test the part of `cgi_decode()`
    that decodes valid hexadecimal codes. This means that we want to make condition
    1 true, 2 false, 3 true, and 4 true. To represent such a path, we can simply sum
    up the branch distances for exactly these branches. However, there is a potential
    issue with simply summing up branch distances: If the distance for one condition
    depends on a comparison of very large values and the distance calculation for
    another condition depends on small values, then an improvement of the large values
    would very likely lead to a better fitness improvement, and thus bias the search.
    To avoid this, we need to *normalize* branch distances before adding them up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A normalization function for a range `[a, b]` takes a number as input and returns
    a value that is `>=a` and `<=b`. The important thing about the function is that
    for any two numbers `x` and `y` the ordering needs to be preserved by the normalization.
    That is, if `x<y` then it must also hold that `normalize(x) < normalize(y)`. There
    are many different functions that could achieve this result; a simple one is `normalize(x)
    = x/(x+k)`: It is computationally cheap, and will normalize any positive value
    in the range `[0,1]` (to change this to `[0,b]` one would just need to multiply
    by `b`). If we use this normalization function, we also know the maximum value:
    it is `1.0`. The function assumes that the value to be normalized is positive.
    The value of the factor `k` defines the steepness of the curve. For example, for
    `k=1` (which is a good default value) the curve is very steep, with values quickly
    approaching, but never reaching, `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'To see how this normalization function works, we can plot a range of values.
    The x-axis contains the original values, the y-axis shows the corresponding normalized
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '![](../Images/6558ad36d46ba06a0717be1f7d81434c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using this normalization function, we can calculate a fitness value by running
    the instrumented program under test, and then adding up the normalized values
    of the relevant branches. However, not every if statement will be executed by
    every test case. What is the branch distance for a branch that wasn''t even executed?
    We need to make sure that the branch distance for branches that weren''t even
    executed is higher than any of the branch distances observed during execution.
    Given our normalization, we know this maximum value is 1\. Thus, the fitness function
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: To see our instrumentation in action, let's calculate fitness values for a couple
    of example inputs, progressively getting closer to the target.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Hillclimbing Valid Hexadecimal Inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have now defined the search space through our `neighbor_strings()` function,
    and we have derived a new fitness function, so before we can apply the hillclimber
    to the problem of finding strings that contain valid 2-digit hex codes, the only
    remaining point is to derive a random starting point, which you''ve already done
    previously in the [MutationFuzzer chapter](MutationFuzzer.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can put it all together and use the identical hillclimbing algorithm
    again, and just make it generate random strings instead of numbers, and use the
    new fitness function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Run the hillclimber a couple of times to see it generate strings with valid
    hex characters. Sometimes it only takes a couple of steps, sometimes it takes
    longer, but at the end it always solves the problem and generates the string we
    want to have.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hillclimbing works well, if the neighborhood is reasonably small. This was
    the case so far in the `cgi_decode()` example because we limited ourselves to
    a fixed number of characters (10) and limited the character range to printable
    ASCII characters. But imagine what happens if we are not looking for ASCII characters,
    but UTF-16 Unicode characters? These are not allowed in URLs really, but let''s
    see what happens if we change our search space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'UTF-16 characters are represented with 16 bits, and this gives us a range of
    65536 possible characters. The functions above are adapted to these boundaries.
    Before we run the hillclimber again, let''s make one more change: We will add
    an iteration limit so that we can give up the search, rather than waiting forever
    for it to complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: You can play around with the iteration limit and see how long it takes to find
    a solution in this search space. Unless you are lucky with the random starting
    point, this usually takes really unreasonably long.
  prefs: []
  type: TYPE_NORMAL
- en: Global Search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The hillclimber explores the local neighborhood of an individual in each step
    of the search, and if the neighborhood is too large, then this takes too long.
    An alternative strategy is to not restrict the search to the local neighborhood,
    but to search the search space *globally*. That is, the search algorithm is allowed
    to make larger steps around the search space. A simple modification of the hillclimber
    converts it from a local to a global search algorithm: Instead of looking at all
    the immediate neighbors, the individual is *mutated* in a way that allows larger
    modifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *mutation* is a change that represents such a larger step around the search
    space. An important decision when implementing a mutation is that it should, theoretically,
    be possible to reach any point in the search space simply by applying mutation
    successively. However, mutation usually should not completely replace an individual
    with a random one. It is important for the search to be effective that the mutation
    constitutes a reasonable change to an individual that still maintains most of
    its traits. For our search problem of 10-character strings, a possible mutation
    would be to replace only *1* out of the 10 characters, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: A simple modification of the hillclimber is to replace the exploration of the
    neighborhood with mutations. In each iteration, the current individual is mutated.
    The resulting offspring individual is compared to its parent, and the better of
    the two is the new point in the search space, and used for the next iteration
    of mutation. This is called "randomized hillclimbing".
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This algorithm usually finds the solution quicker than the standard hillclimber,
    although it is still rather slow!
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one subtle, but crucial, change between the hillclimber and the randomized
    version that is worth pointing out: Note the comparison `new_fitness <= fitness`,
    whereas in the hillclimber we used `new_fitness < fitness`. This is important
    because the search landscape may have areas with equal fitness values (plateaus)
    which we somehow need to overcome. In the standard hillcimber we did this with
    random restarts. If the randomized hillclimber would reject offspring with identical
    fitness, it would keep mutating the identical individual, and possibly struggle
    to escape the plateau. If we replace also with equal fitness, we allow the search
    to move around the plateau, increasing chances of escaping it eventually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The randomized hillclimber is also known as *1+1 Evolutionary Algorithm* (*(1+1)EA*).
    An evolutionary algorithm is a meta-heuristic search algorithm that tries to mimic
    the natural processes of evolution. Natural evolution is based on populations
    where environmental pressure causes natural selection: Only the fittest survive,
    while those that are not fit enough will die, and thus the overall fitness of
    the population gradually improves. The (1+1)EA is a very specific evolutionary
    algorithm with a population size of 1, which produces exactly 1 offspring. However,
    the most common search algorithm in practice is a genetic algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: Genetic Algorithms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the best known evolutionary algorithms is the *Genetic Algorithm* (GA).
    A GA is based on the idea that problem solutions can be genetically encoded: A
    chromosome consists of a sequence of genes, where each gene encodes one trait
    of the individual (e.g., eye color, hair color, etc.). A fitness function can
    take the information contained in this description, the so-called genotype, and
    evaluates the properties of the resulting phenotype, i.e., the actual solution
    represented by this genetic encoding. The fitness value of an individual is measured
    on the phenotype.'
  prefs: []
  type: TYPE_NORMAL
- en: For our `cgi_decode()` example, we could consider individual characters to be
    the genes, and then a chromosome is a sequence of characters. In other words,
    the genetic encoding is exactly what we already used so far! However, for the
    GA the representation requires different operations than the enumeration of the
    neighborhood.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GA emulates natural evolution with the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an initial population of random chromosomes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select fit individuals for reproduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate new population through reproduction of selected individuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue doing so until an optimal solution has been found, or some other limit
    has been reached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step, creating an initial population, is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The selection process prefers fitter individuals, therefore we need to determine
    the fitness values for all the individuals in our population. As we are going
    to need the fitness value for each individual at several places in the algorithm,
    we are going to store it by making fitness a list of *tuples*, each tuple consisting
    of an individual and its fitness value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of a fitness value in the search is typically explained using "survival
    of the fittest", but one of Darwin’s key insights on evolution was that selection
    is not only defined by survival -- individuals reproduce sexually, and sexual
    selection describes the selection pressure during reproduction. This selection
    is typically influenced by either combat: rivaling males fighting over a female,
    and the stronger (fitter) male wins; the selection is also influenced by display.
    Darwin’s example for this is the peacock: The peacock has long, beautiful tail
    feathers that appear to serve no purpose, and do not seem to support the concept
    of natural selection. However, peahens are influenced in their selection of a
    sexual partner by his appearance. Impressive ornaments suggest that a male is
    genetically particularly healthy and will lead to healthy offspring. This is reflected
    in a GA: The better the fitness value of an individual, the more likely it is
    to mate with another individual. A simple selection algorithm that reflects this
    concept is *tournament selection*: A small number of randomly chosen individuals
    compete to be selected, and the best is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tournament_size` parameter specifies how many randomly selected individuals
    out of the population participate in the tournament. This is an important choice
    as it determines *selective pressure*: The larger the tournament size, the larger
    the probability of very good individuals being included in the tournament. This,
    in turn, increases the probability of these very good individuals of dominating
    the next generation, thus reducing the diversity and leading to premature convergence.
    In contrast, if the tournament size is too small, then this inhibits evolution.
    The best value for the tournament size depends on the population size, but usually
    it is fairly small (e.g. 5). Let''s run a tournament using all individuals of
    an example population to see that the best one is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Like in natural evolution, the individuals selected based on their fitness reproduce,
    to form a new generation. During this reproduction, like in natural reproduction,
    genetic material of the selected parents is combined. This is typically done by
    a process known as *crossover*, where an offspring chromosome is produced from
    the genes of its parents. In our case, a chromosome is a sequence of characters,
    and crossing over two parent sequences of characters can simply be done by choosing
    a cutoff random point, and creating offspring by combining the halves of the parents
    chromosomes based on the cutoff point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'A further essential ingredient of genetic evolution is the concept of mutation:
    Sometimes, offspring contain small changes in their genes, which represent new
    genetic material and new physiological traits. If the mutation introduced new
    genetic material that represents useful traits leading to better fitness values,
    then this genetic material will survive. If the mutation introduced useless genetic
    material, then the resulting individuals will likely have bad fitness values and
    die off quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: An important aspect is that both, mutation and crossover, are probabilistic
    actions. They do not always happen, and their effects are different every time
    they do happen. For a sequence genetic encoding, a common approach is to first
    use a probability to decide whether to apply mutation, and then to select one
    gene and change it a bit. Alternatively, we can probabilistically mutate genes
    such that on average one is changed. We do this by calculating a probability `P`
    of each gene being mutated as 1/(number of genes). Then, if a gene is mutated,
    we don't just replace it by a random character, but make it more likely that there
    is only a small change. This is achieved by sampling from a Gaussian distribution
    with the current value as the mean. We arbitrarily use a standard deviation of
    100 to make small changes more likely than large changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Now at last we have all the ingredients to build the full algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this works on our Unicode example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A meta-heuristic search problem consists of an algorithm, a representation,
    and a fitness function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For test generation, fitness functions typically estimate how close an execution
    comes to a target location. To determine this distance, we use instrumentation
    to calculate the distance during test execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local search algorithms like hillcimbing work well when the neighborhood is
    well-defined and not too large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global search algorithms like genetic algorithms are very flexible and scale
    up well to larger test problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter we looked at rather simple program inputs. We can apply the
    same search algorithms also to evolve complex test inputs, in particular [for
    grammar input](EvoGrammarFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: \todo{Add more}
  prefs: []
  type: TYPE_NORMAL
- en: The targets of the search are typically related to coverage. For discussions,
    see the books in the [Introduction to Testing](Intro_Testing.html).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: \todo{Will be added later}
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-11-11 18:18:06+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/SearchBasedFuzzer.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Search-Based Fuzzing](https://www.fuzzingbook.org/html/SearchBasedFuzzer.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/SearchBasedFuzzer.html](https://www.fuzzingbook.org/html/SearchBasedFuzzer.html).
    Retrieved 2023-11-11 18:18:06+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
