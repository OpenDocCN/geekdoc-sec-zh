- en: Academic Prototyping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/AcademicPrototyping.html](http://www.fuzzingbook.org/html/AcademicPrototyping.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*This is the manuscript of Andreas Zeller''s tutorial "Academic Prototyping"
    at the ESEC/FSE 2022 conference.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: About this Tutorial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our [Fuzzing Book](index.html), we use Python to implement automated testing
    techniques, and also as the language for most of our test subjects. Why Python?
    The short answer is
  prefs: []
  type: TYPE_NORMAL
- en: Python made us amazingly *productive*. Most techniques in this book took **2-3
    days** to implement. This is about **10-20 times faster** than for "classic" languages
    like C or Java.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A factor of 10–20 in productivity is enormous, almost ridiculous. Why is that
    so, and which consequences does this have for research and teaching?
  prefs: []
  type: TYPE_NORMAL
- en: What I will talk about
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this tutorial, I will demonstrate this by prototyping a *symbolic test generator*
    from scratch. This normally would be considered a very difficult task, taking
    months to build. Yet, developing the code in this chapter took less than two hours
    – and explaining it takes less than 20 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the reasons for this productivity, singling out to *Python*
    and *Jupyter notebooks* as the main drivers. And we will discuss the consequences
    for academic software development.
  prefs: []
  type: TYPE_NORMAL
- en: What you will learn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using *Python* and its libraries as language for prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using *Jupyter Notebooks* as a tool for coding and running evaluations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding where gains in productivity and replicability come from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Trouble with Analyzing Compiled Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the course of my career, I have built (and let build) several tools that
    operate on compiled languages such as C or Java – notably
  prefs: []
  type: TYPE_NORMAL
- en: automated debugging tools that would extract and analyze dynamic information
    from program executions, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: automated testing tools that would exercise individual applications or functions
    with (generated) inputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What I learned from this experience can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting compiled code is **hard**. You need to plug into existing infrastructures
    such as the Java or C compilers, find out which code to add, find out how to adapt
    this to the respective compiler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capturing information from compiled code is **hard**, too. Again, you need to
    instrument code (see above), but you also need to make sure the information gets
    stored (efficiently?), later retrieved and decoded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All this is immensely bug-prone. There is a good reason why successful test
    generators assume an absolute minimum of infrastructure (e.g. getting coverage
    with existing tools, and nothing more).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to go into static or even symbolic analysis, things are even worse.
    Parsing C and Java code yourself is difficult; for large-scale code, it's next
    to impossible. Working on some intermediate representation is possible, thanks
    to the power of existing infrastructures such as Soot. But if you want to extend
    these, you are in for weeks and weeks of work.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic analysis is extra hard, as you typically want to operate on an abstraction
    level that is at least as high as the source code, requiring you to create ties
    between the symbolic level, the source code level, and the actual machine code.
    All possible, but hard.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if your focus is to actually analyze large scale code, for instance because
  prefs: []
  type: TYPE_NORMAL
- en: the domain is very important, and the problems are challenging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you are in industry and work on safety-critical systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: you'd like to evaluate some approach on lots of samples in compiled languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: then it may well make sense to *eventually* apply your approach to large-scale
    code. But before that, you may want to check whether your approach actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where *prototyping* comes into play. Prototyping means to develop a
    quick solution to explore the *feasibility* of some approach:'
  prefs: []
  type: TYPE_NORMAL
- en: to gather feedback from practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to quickly *evolve* an approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: to show that something may work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, the proof of concept that we typically need to show in our academic
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Python is Easy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python is a high-level language that allows one to focus on the actual *algorithms*
    rather than how individual bits and bytes are passed around in memory. For this
    book, this is important: We want to focus on how individual techniques work, and
    not so much their optimization. Focusing on algorithms allows you to toy and tinker
    with them, and quickly develop your own. Once you have found out how to do things,
    you can still port your approach to some other language or specialized setting.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, take the (in)famous *triangle* program, which classifies a triangle
    of lengths $a$, $b$, $c$ into one of three categories. It reads like pseudocode;
    yet, we can easily execute it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example of executing the `triangle()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the remainder of this chapter, we will use the `triangle()` function as
    ongoing example for a program to be tested. Of course, the complexity of `triangle()`
    is a far cry from large systems, and what we show in this chapter will not apply
    to, say, an ecosystem of thousands of intertwined microservices. Its point, however,
    is to show how easy certain techniques can be – if you have the right language
    and environment.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Minimal Tester
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to test `triangle()` with random values, that's fairly easy to do.
    Just bring along one of the Python random number generators and throw them into
    `triangle()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good – but that's something you can do in pretty much any programming
    language. What is it that makes Python special?
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic Analysis in Python: So Easy it Hurts'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dynamic analysis is the ability to track what is happening during program execution.
    The Python `settrace()` mechanism allows you to track all code lines, all variables,
    all values, as the program executes – and all this in a handful of lines of code.
    Our `Coverage` class from [the chapter on coverage](Coverage.html) shows how to
    capture a trace of all lines executed in five lines of code; such a trace easily
    converts into sets of lines or branches executed. With two more lines, you can
    easily track all functions, arguments, variable values, too – see for instance
    our [chapter on dynamic invariants](DynamicInvariants). And you can even access
    the source code of individual functions (and print it out, too!) All this takes
    10, maybe 20 minutes to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a piece of Python that does it all. We track lines executed, and for
    every line, we print its source codes and the current values of all local variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `sys.settrace()` registers `traceit()` as a trace function; it
    will then trace the given invocation of `triangle()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In comparison, try to build such a dynamic analysis for, say, C. You can either
    *instrument* the code to track all lines executed and record variable values,
    storing the resulting info in some database. This will take you *weeks,* if not
    *months* to implement. You can also run your code through a debugger (step-print-step-print-step-print);
    but again, programming the interaction can take days. And once you have the first
    results, you'll probably realize you need something else or better, so you go
    back to the drawing board. Not fun.
  prefs: []
  type: TYPE_NORMAL
- en: Together with a dynamic analysis such as the one above, you can make fuzzing
    much smarter. Search-based testing, for instance, evolves a population of inputs
    towards a particular goal, such as coverage. With a good dynamic analysis, you
    can quickly implement search-based strategies for arbitrary goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Static Analysis in Python: Still Easy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static analysis refers to the ability to analyze *program code* without actually
    executing it. Statically analyzing Python code to deduce any property can be a
    nightmare, because the language is so highly dynamic. (More on that below.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If your static analysis does not have to be *sound*, – for instance, because
    you only use it to *support* and *guide* another technique such as testing – then
    a static analysis in Python can be very simple. The `ast` module allows you to
    turn any Python function into an abstract syntax tree (AST), which you then can
    traverse as you like. Here''s the AST for our `triangle()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1867pt" height="476pt"
    viewBox="0.00 0.00 1867.38 476.00"><g id="graph0" class="graph" transform="scale(1
    1) rotate(0) translate(4 472)"><g id="node1" class="node"><title>0</title> <text
    text-anchor="start" x="115.88" y="-445.95" font-family="Courier,monospace" font-weight="bold"
    font-size="14.00" fill="#004080">FunctionDef</text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="49.25" y="-372.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"triangle"</text></g> <g id="edge1" class="edge"><title>0--1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="start" x="124.12"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arguments</text></g> <g id="edge2" class="edge"><title>0--2</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="start" x="495"
    y="-373.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">If</text></g> <g id="edge9" class="edge"><title>0--9</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="start" x="40.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge3" class="edge"><title>2--3</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="start" x="112.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge5" class="edge"><title>2--5</title></g>
    <g id="node8" class="node"><title>7</title> <text text-anchor="start" x="184.88"
    y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">arg</text></g> <g id="edge7" class="edge"><title>2--7</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="53.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge4" class="edge"><title>3--4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="125.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge6" class="edge"><title>5--6</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="197.25"
    y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge8" class="edge"><title>7--8</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="start" x="348.38" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g> <g id="edge10"
    class="edge"><title>9--10</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="start" x="656" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge18"
    class="edge"><title>9--18</title></g> <g id="node34" class="node"><title>33</title>
    <text text-anchor="start" x="1220" y="-301.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge33"
    class="edge"><title>9--33</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="start" x="252.75" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge11"
    class="edge"><title>10--11</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="341.25" y="-228.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge14" class="edge"><title>10--14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="start" x="396.75"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge15" class="edge"><title>10--15</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="197.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge12" class="edge"><title>11--12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="269.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge13" class="edge"><title>11--13</title></g>
    <g id="node17" class="node"><title>16</title> <text text-anchor="middle" x="341.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge16" class="edge"><title>15--16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="413.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge17" class="edge"><title>15--17</title></g>
    <g id="node20" class="node"><title>19</title> <text text-anchor="start" x="564.38"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Compare</text></g> <g id="edge19" class="edge"><title>18--19</title></g>
    <g id="node28" class="node"><title>27</title> <text text-anchor="start" x="674.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge27" class="edge"><title>18--27</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="start" x="799.5"
    y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Return</text></g> <g id="edge30" class="edge"><title>18--30</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="start" x="468.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge20" class="edge"><title>19--20</title></g>
    <g id="node24" class="node"><title>23</title> <text text-anchor="middle" x="557.25"
    y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Eq</text></g>
    <g id="edge23" class="edge"><title>19--23</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="start" x="612.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge24"
    class="edge"><title>19--24</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="413.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"b"</text></g> <g id="edge21" class="edge"><title>20--21</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="485.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge22" class="edge"><title>20--22</title></g> <g id="node26" class="node"><title>25</title>
    <text text-anchor="middle" x="557.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"c"</text></g> <g id="edge25" class="edge"><title>24--25</title></g>
    <g id="node27" class="node"><title>26</title> <text text-anchor="middle" x="629.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text></g>
    <g id="edge26" class="edge"><title>24--26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="start" x="693.25" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g> <g id="edge28"
    class="edge"><title>27--28</title></g> <g id="node30" class="node"><title>29</title>
    <text text-anchor="middle" x="736.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"equilateral"</text></g> <g id="edge29" class="edge"><title>28--29</title></g>
    <g id="node32" class="node"><title>31</title> <text text-anchor="start" x="821.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge31" class="edge"><title>30--31</title></g>
    <g id="node33" class="node"><title>32</title> <text text-anchor="middle" x="881.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"isosceles
    #1"</text></g> <g id="edge32" class="edge"><title>31--32</title></g> <g id="node35"
    class="node"><title>34</title> <text text-anchor="start" x="1131.38" y="-229.95"
    font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g>
    <g id="edge34" class="edge"><title>33--34</title></g> <g id="node43" class="node"><title>42</title>
    <text text-anchor="start" x="1235.5" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge42"
    class="edge"><title>33--42</title></g> <g id="node46" class="node"><title>45</title>
    <text text-anchor="start" x="1577" y="-229.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">If</text></g> <g id="edge45"
    class="edge"><title>33--45</title></g> <g id="node36" class="node"><title>35</title>
    <text text-anchor="start" x="1047.75" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge35"
    class="edge"><title>34--35</title></g> <g id="node39" class="node"><title>38</title>
    <text text-anchor="middle" x="1136.25" y="-156.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge38" class="edge"><title>34--38</title></g>
    <g id="node40" class="node"><title>39</title> <text text-anchor="start" x="1191.75"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge39" class="edge"><title>34--39</title></g>
    <g id="node37" class="node"><title>36</title> <text text-anchor="middle" x="992.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"b"</text></g>
    <g id="edge36" class="edge"><title>35--36</title></g> <g id="node38" class="node"><title>37</title>
    <text text-anchor="middle" x="1064.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge37" class="edge"><title>35--37</title></g>
    <g id="node41" class="node"><title>40</title> <text text-anchor="middle" x="1136.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge40" class="edge"><title>39--40</title></g> <g id="node42" class="node"><title>41</title>
    <text text-anchor="middle" x="1208.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge41" class="edge"><title>39--41</title></g>
    <g id="node44" class="node"><title>43</title> <text text-anchor="start" x="1274.25"
    y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge43" class="edge"><title>42--43</title></g>
    <g id="node45" class="node"><title>44</title> <text text-anchor="middle" x="1319.25"
    y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"isosceles
    #2"</text></g> <g id="edge44" class="edge"><title>43--44</title></g> <g id="node47"
    class="node"><title>46</title> <text text-anchor="start" x="1489.38" y="-157.95"
    font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Compare</text></g>
    <g id="edge46" class="edge"><title>45--46</title></g> <g id="node55" class="node"><title>54</title>
    <text text-anchor="start" x="1628.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge54"
    class="edge"><title>45--54</title></g> <g id="node58" class="node"><title>57</title>
    <text text-anchor="start" x="1758.5" y="-157.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Return</text></g> <g id="edge57"
    class="edge"><title>45--57</title></g> <g id="node48" class="node"><title>47</title>
    <text text-anchor="start" x="1413.75" y="-85.95" font-family="Courier,monospace"
    font-weight="bold" font-size="14.00" fill="#004080">Name</text></g> <g id="edge47"
    class="edge"><title>46--47</title></g> <g id="node51" class="node"><title>50</title>
    <text text-anchor="middle" x="1502.25" y="-84.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Eq</text></g> <g id="edge50" class="edge"><title>46--50</title></g>
    <g id="node52" class="node"><title>51</title> <text text-anchor="start" x="1557.75"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Name</text></g> <g id="edge51" class="edge"><title>46--51</title></g>
    <g id="node49" class="node"><title>48</title> <text text-anchor="middle" x="1358.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"a"</text></g>
    <g id="edge48" class="edge"><title>47--48</title></g> <g id="node50" class="node"><title>49</title>
    <text text-anchor="middle" x="1430.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge49" class="edge"><title>47--49</title></g>
    <g id="node53" class="node"><title>52</title> <text text-anchor="middle" x="1502.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"c"</text></g>
    <g id="edge52" class="edge"><title>51--52</title></g> <g id="node54" class="node"><title>53</title>
    <text text-anchor="middle" x="1574.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">Load</text></g> <g id="edge53" class="edge"><title>51--53</title></g>
    <g id="node56" class="node"><title>55</title> <text text-anchor="start" x="1640.25"
    y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00"
    fill="#004080">Constant</text></g> <g id="edge55" class="edge"><title>54--55</title></g>
    <g id="node57" class="node"><title>56</title> <text text-anchor="middle" x="1685.25"
    y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"isosceles
    #3"</text></g> <g id="edge56" class="edge"><title>55--56</title></g> <g id="node59"
    class="node"><title>58</title> <text text-anchor="start" x="1767.25" y="-85.95"
    font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text></g>
    <g id="edge58" class="edge"><title>57--58</title></g> <g id="node60" class="node"><title>59</title>
    <text text-anchor="middle" x="1814.25" y="-12.95" font-family="Courier,monospace"
    font-size="14.00" fill="#008040">"scalene"</text></g> <g id="edge59" class="edge"><title>58--59</title></g></g></svg>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose one wants to identify all `triangle` branches and their conditions
    using static analysis. You would traverse the AST, searching for `If` nodes, and
    take their first child (the condition). This is easy as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the four `if` conditions occurring in the `triangle()` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Not only can we extract individual program elements, we can also change them
    at will and convert the tree back into source code. Program transformations (say,
    for instrumentation or mutation analysis) are a breeze. The above code took five
    minutes to write. Again, try that in Java or C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbolic Reasoning in Python: There''s a Package for That'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get back to testing. We have shown how to extract conditions from code.
    To reach a particular location in the `triangle()` function, one needs to find
    a solution for the *path conditions* leading to that branch. To reach the last
    line in `triangle()` (the `'scalene'` branch), we have to find a solution for
    $$a \ne b \land b \ne c \land a \ne c$$
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of a *constraint* solver for this, such as Microsoft''s [*Z3*
    solver](https://github.com/Z3Prover/z3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us use Z3 to find a solution for the `''scalene''` branch condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**sat**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Z3 has shown us that there is a solution ("sat" = "satisfiable"). Let us get
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[a = 1, c = 3, b = 2]'
  prefs: []
  type: TYPE_NORMAL
- en: We can use this solution right away for testing the `triangle()` function and
    find that it indeed covers the `'scalene'` branch. The method `as_long()` converts
    the Z3 results into numerical values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A Symbolic Test Generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With what we have seen, we can now build a *symbolic test generator* – a tool
    that attempts to systematically create test inputs that cover all paths. Let us
    find all conditions we need to solve, by exploring all paths in the tree. We turn
    these paths to Z3 format right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all we need to do is to feed these constraints into Z3\. We see that we
    easily cover all branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Success! We have covered all branches of the triangle program!
  prefs: []
  type: TYPE_NORMAL
- en: Now, the above is still very limited – and tailored to the capabilities of the
    `triangle()` code. A full implementation would actually
  prefs: []
  type: TYPE_NORMAL
- en: translate entire Python conditions into Z3 syntax (if possible),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: handle more control flow constructs such as returns, assertions, exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and half a million things more (loops, calls, you name it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these may not be supported by the Z3 theories.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easier for a constraint solver to find solutions, you could also
    provide *concrete values* observed from earlier executions that already are known
    to reach specific paths in the program. Such concrete values would be gathered
    from the tracing mechanisms above, and boom: you would have a pretty powerful
    and scalable concolic (concrete-symbolic) test generator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the above might take you a day or two, and as you expand your test generator
    beyond `triangle()`, you will add more and more features. The nice part is that
    every of these features you will invent might actually be a research contribution
    – something nobody has thought of before. Whatever idea you might have: you can
    quickly implement it and try it out in a prototype. And again, this will be orders
    of magnitude faster than for conventional languages.'
  prefs: []
  type: TYPE_NORMAL
- en: Replicable Experiments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a language like Python alone might make you a productive (and creative)
    code researcher. As a good scientist, though, you also need *discipline* in running
    your experiments. *What exactly did you do to achieve the results as stated in
    the paper*? This is where my second not-so-secret weapon comes into play: Notebooks.'
  prefs: []
  type: TYPE_NORMAL
- en: A Jupyter Notebook can hold *all* your code (although many prefer an IDE for
    that); but at the very least, it can *document* all the steps you did in your
    experiments, together with *rich text* that explains the setup and your rationales,
    and (of course!) rich visualizations and diagrams that visualize your results.
    This is where Jupyter notebooks are great at, and if you do things right, you
    can document and replicate all your experiments from the raw data down to the
    diagrams and numbers as found in your papers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of how we use diagrams in my (Jupyter-based) books.
    First, some "standard" data visualizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Plots](https://www.fuzzingbook.org/html/GreyboxFuzzer.html#Greybox-Mutation-based-Fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Tree Maps](https://www.debuggingbook.org/html/ChangeCounter.html#Putting-it-all-Together)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we also created our *own visualizations* -- for instance
  prefs: []
  type: TYPE_NORMAL
- en: '[Class Diagrams](https://www.fuzzingbook.org/html/GreyboxFuzzer.html#Greybox-Fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[State Machines](https://www.debuggingbook.org/html/Intro_Debugging.html#Visualizing-Code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Program Spectra](https://www.debuggingbook.org/html/StatisticalDebugger.html#Continuous-Spectrum)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dependencies](https://www.debuggingbook.org/html/Slicer.html#Dependency-Graphs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Railroad diagrams](https://www.fuzzingbook.org/html/Grammars.html#Visualizing-Grammars-as-Railroad-Diagrams)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these automatically update with the program code and its results - and thus
    are always up to date. Eat that, LaTeX – and eat that, TikZ!
  prefs: []
  type: TYPE_NORMAL
- en: But not only that – you can also *check* whether the results match what you
    already have written in your paper. If you write in your paper that you found
    that $p \le 0.05$, then a computation such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: will ensure that the statement in your paper is (a) verified, and (b) can be
    verified by others, including the entire computation path. (And a continuous test
    will automatically detect should there ever be a discrepancy.)
  prefs: []
  type: TYPE_NORMAL
- en: A Prototyping Process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One neat thing about prototyping (with Python or whatever) is that it allows
    you to fully focus on your *approach*, rather than on the infrastructure. Very
    obviously, this is useful for *teaching* – you can use examples as the ones above
    in a lecture to very quickly communicate essential techniques of program analysis,
    test generation, debugging, and more.
  prefs: []
  type: TYPE_NORMAL
- en: But prototyping has more advantages. A Jupyter Notebook (like this one) documents
    how you developed your approach, together with examples, experiments, and rationales
    – and still focusing on the essentials. If you write a tool the "classical" way,
    you will eventually deliver thousands of lines of code that do everything under
    the sun, but only once you have implemented everything will you know whether things
    actually work. This is a huge risk, and if you still have to change things, you
    will have to refactor things again and again. Furthermore, for anyone who will
    work on that code later, it will take days, if not weeks, to re-extract the basic
    idea of the approach, as it will be buried under loads and loads of infrastructure
    and refactorings.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our consequence is that we now implement new ideas *twice*:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we implement things as a notebook (as this one), experimenting with various
    approaches and parameters until we get them right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only once we have the approach right, and if we have confidence that it works,
    we reimplement it in a tool that works on large scale programs. This can still
    take weeks to months, but at least we know we are on a good path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incidentally, it may well be that the original notebooks will have a longer
    life, as they are simpler, better documented, and capture the gist of our novel
    idea. And this is how several of the notebooks in this book came to be.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping things up to date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is a dynamic environment. The more packages you make use of, the higher
    the likelihood that some day someone may introduce a change that will make your
    code no longer run. I therefore recommend hat you set up a *continuous testing*
    scheme where all your notebooks are run automatically at regular intervals, running
    and re-running your experiments.
  prefs: []
  type: TYPE_NORMAL
- en: For the fuzzing book and the debugging book, I have to spend about 30 minutes
    per week to update things and fix bugs. With continuous testing, the chances of
    others actually using your code are much higher (because it will *work* on their
    machines). This is some time I can easily spend even as a PhD advisor, and it
    gives me the good feeling that others can actually make use of our work.
  prefs: []
  type: TYPE_NORMAL
- en: Things that will not work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python has a reputation for being hard to analyze statically, and this is true;
    its dynamic nature makes it hard for traditional static analysis to exclude specific
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: We see Python as a great language for prototyping automated testing and dynamic
    analysis techniques, and as a good language to illustrate *lightweight* static
    and symbolic analysis techniques that would be used to *guide* and *support* other
    techniques (say, generating software tests).
  prefs: []
  type: TYPE_NORMAL
- en: But if you want to *prove* specific properties (or the absence thereof) by static
    analysis of code only, Python is a challenge, to say the least; and there are
    areas for which we would definitely *warn* against using it.
  prefs: []
  type: TYPE_NORMAL
- en: (No) Type Checking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using Python to demonstrate *static type checking* will be suboptimal because
    Python programs often do not come with type annotations. When coding, I typically
    start without type annotations, but *retrofit* them once the code becomes stable
    and is documented; that is because I think that having typed signatures makes
    it much easier for others to use code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There are *static type checkers* available for Python, notably *mypy*; these
    do a sufficient job in uncovering type errors in your code. If your code is well-tested,
    though (and it should be), the chances of static type checkers uncovering new
    bugs is slim. Still, if you want to demonstrate the virtues of type checking (or
    build a novel static type checker or type system yourself), Python may be a good
    playground.
  prefs: []
  type: TYPE_NORMAL
- en: (No) Program Proofs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python is a highly dynamic language in which you can change *anything* at runtime.
    It is no problem assigning different types to a variable, as in
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'or change the existence (and scope) of a variable depending on some runtime
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Such properties make symbolic reasoning on code (including static analysis and
    type checking) much harder, if not outright impossible. If you need lightweight
    static and symbolic analysis techniques to *guide* other techniques (say, test
    generation), then imprecision may not hurt much. But if you want to derive *guarantees*
    from your code, do not use Python as test subject; again, strongly statically
    typed languages like Java/ML/Haskell (or some very restricted toy language) are
    much better grounds for experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean that languages like Python should *not* be statically checked.
    On the contrary, the widespread usage of Python calls loudly for better static
    checking tools. But if you want to teach or research static and symbolic techniques,
    we definitely would not use Python as our language of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the code examples above can be run by you – and changed as you like! From
    the Web page, the easiest way is to go to "Resources $\rightarrow$ Edit as Notebook",
    and you can experiment with the original Jupyter Notebook right within your browser.
    (Use `Shift` + `Return` to execute code.)
  prefs: []
  type: TYPE_NORMAL
- en: 'From the "Resources" menu, you can also download the Python code (`.py`) to
    run it within a Python environment, or download the notebook (`.ipynb`) to run
    it within Jupyter – and again, change them as you like. If you want to run this
    code on your own machine, you will need the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Python** is a great language for prototyping testing and debugging tools:'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, dynamic analysis and static analysis are extremely easy to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python provides an enormous infrastructure for parsing, handling programs as
    trees, and constraint solving.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can make you develop new techniques within *hours* instead of weeks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python is *not* recommended as a domain for pure symbolic code analysis, though.
  prefs: []
  type: TYPE_NORMAL
- en: There is little to no static typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language is highly dynamic with little to no static guarantees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, even a potentially *unsound* symbolic analysis can still guide test
    generation – and this again is very easy to build.
  prefs: []
  type: TYPE_NORMAL
- en: '**Jupyter Notebooks** (using Python or other languages) are great for *prototyping*:'
  prefs: []
  type: TYPE_NORMAL
- en: Notebooks document the gist of your approach, including examples and experiments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is great for teaching, communication, and even documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing experiments on prototypes early reduces risks for later large-scale implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to see more examples of us using Python for prototyping – have a
    look at [this book](index.html)! Specifically,
  prefs: []
  type: TYPE_NORMAL
- en: see how we develop [fuzzers](Fuzzer.html) step by step;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: see how we use [dynamic analysis to check coverage](Coverage.html); or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: see how we analyze Python code for [concolic](ConcolicFuzzer.html) and [symbolic](SymbolicFuzzer.html)
    and fuzzing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's lots to learn – enjoy the read!
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *triangle problem* is adapted from "The Art of Software Testing" by Myers
    and Sandler [[Myers *et al*, 2004](https://dl.acm.org/citation.cfm?id=983238)].
    It is an allegedly simple problem but which reveals a surprising depth when you
    think about all the things that might go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: The *Z3 solver* we use in this chapter was developed at Microsoft Research under
    the lead of Leonardo de Moura and Nikolaj Bjørner [[De Moura *et al*, 2008](https://link.springer.com/chapter/10.1007/978-3-540-78800-3_24)].
    It is one of the most powerful and most popular solvers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Features! Features!'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our path collector is still very limited. Things that do not work include
  prefs: []
  type: TYPE_NORMAL
- en: Complex conditions, such as boolean operators. Python operators `a and b` need
    to be translated to Z3 syntax `z3.And(a, b)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Early returns. After `if A: return`, the condition `not A` must hold for the
    following statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more of these you implement, the closer you will get to a full-fledged symbolic
    test generator for Python. But at some point, *your prototype may not be a prototype
    anymore*, and then, Python may no longer be the best language to use. Find a good
    moment when it is time to switch from a prototypical to a production tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2023-01-07 13:43:14+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/AcademicPrototyping.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Academic Prototyping](https://www.fuzzingbook.org/html/AcademicPrototyping.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/AcademicPrototyping.html](https://www.fuzzingbook.org/html/AcademicPrototyping.html).
    Retrieved 2023-01-07 13:43:14+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
