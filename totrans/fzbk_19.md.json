["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('6Z35ChunpLY') \n```", "```py\n>>> from [fuzzingbook.GeneratorGrammarFuzzer](GeneratorGrammarFuzzer.html) import <identifier> \n```", "```py\n(S, opts(pre=F))   # Set a function to be executed before expansion \n```", "```py\n(S, opts(post=F))  # Set a function to be executed after expansion \n```", "```py\n>>> from [Grammars](Grammars.html) import US_PHONE_GRAMMAR, extend_grammar, opts\n>>> def pick_area_code():\n>>>     return random.choice(['555', '554', '553'])\n>>> PICKED_US_PHONE_GRAMMAR = extend_grammar(US_PHONE_GRAMMAR,\n>>> {\n>>>     \"<area>\": [(\"<lead-digit><digit><digit>\", opts(pre=pick_area_code))]\n>>> }) \n```", "```py\n>>> picked_us_phone_fuzzer = GeneratorGrammarFuzzer(PICKED_US_PHONE_GRAMMAR)\n>>> [picked_us_phone_fuzzer.fuzz() for i in range(5)]\n['(554)732-6097',\n '(555)469-0662',\n '(553)671-5358',\n '(555)686-8011',\n '(554)453-4067'] \n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\nfrom [typing](https://docs.python.org/3/library/typing.html) import Callable, Set, List, Dict, Optional, Iterator, Any, Union, Tuple, cast \n```", "```py\nfrom [Fuzzer](Fuzzer.html) import Fuzzer \n```", "```py\nfrom [Grammars](Grammars.html) import EXPR_GRAMMAR, is_valid_grammar, is_nonterminal, extend_grammar\nfrom [Grammars](Grammars.html) import opts, exp_opt, exp_string, crange, Grammar, Expansion \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import DerivationTree \n```", "```py\nCHARGE_GRAMMAR: Grammar = {\n    \"<start>\": [\"Charge <amount> to my credit card <credit-card-number>\"],\n    \"<amount>\": [\"$<float>\"],\n    \"<float>\": [\"<integer>.<digit><digit>\"],\n    \"<integer>\": [\"<digit>\", \"<integer><digit>\"],\n    \"<digit>\": crange('0', '9'),\n\n    \"<credit-card-number>\": [\"<digits>\"],\n    \"<digits>\": [\"<digit-block><digit-block><digit-block><digit-block>\"],\n    \"<digit-block>\": [\"<digit><digit><digit><digit>\"],\n} \n```", "```py\nassert is_valid_grammar(CHARGE_GRAMMAR) \n```", "```py\nfrom [GrammarFuzzer](GrammarFuzzer.html) import GrammarFuzzer, all_terminals \n```", "```py\ng = GrammarFuzzer(CHARGE_GRAMMAR)\n[g.fuzz() for i in range(5)] \n```", "```py\n['Charge $9.40 to my credit card 7166898575638313',\n 'Charge $8.79 to my credit card 6845418694643271',\n 'Charge $5.64 to my credit card 6655894657077388',\n 'Charge $0.60 to my credit card 2596728464872261',\n 'Charge $8.90 to my credit card 2363769342732142']\n\n```", "```py\nimport [random](https://docs.python.org/3/library/random.html) \n```", "```py\ndef high_charge() -> float:\n    return random.randint(10000000, 90000000) / 100.0 \n```", "```py\nCHARGE_GRAMMAR.update({\n    \"<float>\": [(\"<integer>.<digit><digit>\", opts(pre=high_charge))],\n}) \n```", "```py\ndef apply_twice(function, x):\n    return function(function(x)) \n```", "```py\napply_twice(lambda x: x * x, 2) \n```", "```py\n16\n\n```", "```py\nCHARGE_GRAMMAR.update({\n    \"<float>\": [(\"<integer>.<digit><digit>\",\n                 opts(pre=lambda: random.randint(10000000, 90000000) / 100.0))]\n}) \n```", "```py\nCHARGE_GRAMMAR.update({\n    \"<credit-card-number>\": [(\"<digits>\", opts(post=lambda digits: check_credit_card(digits)))]\n}) \n```", "```py\nCHARGE_GRAMMAR.update({\n    \"<credit-card-number>\": [(\"<digits>\", opts(post=lambda digits: fix_credit_card(digits)))]\n}) \n```", "```py\ndef luhn_checksum(s: str) -> int:\n  \"\"\"Compute Luhn's check digit over a string of digits\"\"\"\n    LUHN_ODD_LOOKUP = (0, 2, 4, 6, 8, 1, 3, 5, 7,\n                       9)  # sum_of_digits (index * 2)\n\n    evens = sum(int(p) for p in s[-1::-2])\n    odds = sum(LUHN_ODD_LOOKUP[int(p)] for p in s[-2::-2])\n    return (evens + odds) % 10 \n```", "```py\ndef valid_luhn_checksum(s: str) -> bool:\n  \"\"\"Check whether the last digit is Luhn's checksum over the earlier digits\"\"\"\n    return luhn_checksum(s[:-1]) == int(s[-1]) \n```", "```py\ndef fix_luhn_checksum(s: str) -> str:\n  \"\"\"Return the given string of digits, with a fixed check digit\"\"\"\n    return s[:-1] + repr(luhn_checksum(s[:-1])) \n```", "```py\nluhn_checksum(\"123\") \n```", "```py\n8\n\n```", "```py\nfix_luhn_checksum(\"123x\") \n```", "```py\n'1238'\n\n```", "```py\ncheck_credit_card: Callable[[str], bool] = valid_luhn_checksum\nfix_credit_card: Callable[[str], str] = fix_luhn_checksum \n```", "```py\nfix_credit_card(\"1234567890123456\") \n```", "```py\n'1234567890123458'\n\n```", "```py\ng = GrammarFuzzer(CHARGE_GRAMMAR)\ng.fuzz() \n```", "```py\n'Charge $4.05 to my credit card 0637034038177393'\n\n```", "```py\nclass GeneratorGrammarFuzzer(GrammarFuzzer):\n    def supported_opts(self) -> Set[str]:\n        return super().supported_opts() | {\"pre\", \"post\", \"order\"} \n```", "```py\ndef exp_pre_expansion_function(expansion: Expansion) -> Optional[Callable]:\n  \"\"\"Return the specified pre-expansion function, or None if unspecified\"\"\"\n    return exp_opt(expansion, 'pre') \n```", "```py\ndef exp_post_expansion_function(expansion: Expansion) -> Optional[Callable]:\n  \"\"\"Return the specified post-expansion function, or None if unspecified\"\"\"\n    return exp_opt(expansion, 'post') \n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def process_chosen_children(self, children: List[DerivationTree],\n                                expansion: Expansion) -> List[DerivationTree]:\n        function = exp_pre_expansion_function(expansion)\n        if function is None:\n            return children\n\n        assert callable(function)\n        if inspect.isgeneratorfunction(function):\n            # See \"generators\", below\n            result = self.run_generator(expansion, function)\n        else:\n            result = function()\n\n        if self.log:\n            print(repr(function) + \"()\", \"=\", repr(result))\n        return self.apply_result(result, children)\n\n    def run_generator(self, expansion: Expansion, function: Callable):\n        ... \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def apply_result(self, result: Any,\n                     children: List[DerivationTree]) -> List[DerivationTree]:\n        if isinstance(result, str):\n            children = [(result, [])]\n        elif isinstance(result, list):\n            symbol_indexes = [i for i, c in enumerate(children)\n                              if is_nonterminal(c[0])]\n\n            for index, value in enumerate(result):\n                if value is not None:\n                    child_index = symbol_indexes[index]\n                    if not isinstance(value, str):\n                        value = repr(value)\n                    if self.log:\n                        print(\n                            \"Replacing\", all_terminals(\n                                children[child_index]), \"by\", value)\n\n                    # children[child_index] = (value, [])\n                    child_symbol, _ = children[child_index]\n                    children[child_index] = (child_symbol, [(value, [])])\n        elif result is None:\n            pass\n        elif isinstance(result, bool):\n            pass\n        else:\n            if self.log:\n                print(\"Replacing\", \"\".join(\n                    [all_terminals(c) for c in children]), \"by\", result)\n\n            children = [(repr(result), [])]\n\n        return children \n```", "```py\ncharge_fuzzer = GeneratorGrammarFuzzer(CHARGE_GRAMMAR)\ncharge_fuzzer.fuzz() \n```", "```py\n'Charge $439383.87 to my credit card 2433506594138520'\n\n```", "```py\namount_fuzzer = GeneratorGrammarFuzzer(\n    CHARGE_GRAMMAR, start_symbol=\"<amount>\", log=True)\namount_fuzzer.fuzz() \n```", "```py\nTree: <amount>\nExpanding <amount> randomly\nTree: $<float>\nExpanding <float> randomly\n<function <lambda> at 0x1109f2ac0>() = 382087.72\nReplacing <integer>.<digit><digit> by 382087.72\nTree: $382087.72\n'$382087.72'\n\n```", "```py\n'$382087.72'\n\n```", "```py\nexpr_100_200_grammar = extend_grammar(EXPR_GRAMMAR,\n                                      {\n                                          \"<factor>\": [\n                                              \"+<factor>\", \"-<factor>\", \"(<expr>)\",\n\n                                              # Generate only the integer part with a function;\n                                              # the fractional part comes from\n                                              # the grammar\n                                              (\"<integer>.<integer>\", opts(\n                                                  pre=lambda: [random.randint(100, 200), None])),\n\n                                              # Generate the entire integer\n                                              # from the function\n                                              (\"<integer>\", opts(\n                                                  pre=lambda: random.randint(100, 200))),\n                                          ],\n                                      }\n                                      ) \n```", "```py\nexpr_100_200_fuzzer = GeneratorGrammarFuzzer(expr_100_200_grammar)\nexpr_100_200_fuzzer.fuzz() \n```", "```py\n'(108.6 / 155 + 177) / 118 * 120 * 107 + 151 + 195 / -200 - 150 * 188 / 147 + 112'\n\n```", "```py\ndef iterate():\n    t = 0\n    while True:\n        t = t + 1\n        yield t \n```", "```py\nfor i in iterate():\n    if i > 10:\n        break\n    print(i, end=\" \") \n```", "```py\n1 2 3 4 5 6 7 8 9 10 \n\n```", "```py\niterate_grammar = extend_grammar(EXPR_GRAMMAR,\n                                 {\n                                     \"<factor>\": [\n                                         \"+<factor>\", \"-<factor>\", \"(<expr>)\",\n                                         # \"<integer>.<integer>\",\n\n                                         # Generate one integer after another\n                                         # from the function\n                                         (\"<integer>\", opts(pre=iterate)),\n                                     ],\n                                 }) \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def fuzz_tree(self) -> DerivationTree:\n        self.reset_generators()\n        return super().fuzz_tree()\n\n    def reset_generators(self) -> None:\n        self.generators: Dict[str, Iterator] = {}\n\n    def run_generator(self, expansion: Expansion,\n                      function: Callable) -> Iterator:\n        key = repr((expansion, function))\n        if key not in self.generators:\n            self.generators[key] = function()\n        generator = self.generators[key]\n        return next(generator) \n```", "```py\niterate_fuzzer = GeneratorGrammarFuzzer(iterate_grammar)\niterate_fuzzer.fuzz() \n```", "```py\n'1 * ++++3 / ---+4 - 2 * +--6 / 7 * 10 - (9 - 11) - 5 + (13) * 14 + 8 + 12'\n\n```", "```py\niterate_grammar = extend_grammar(EXPR_GRAMMAR,\n                                 {\n                                     \"<factor>\": [\n                                         \"+<factor>\", \"-<factor>\", \"(<expr>)\",\n                                         (\"<integer>\", opts(pre=range(1, 1000))),\n                                     ],\n                                 }) \n```", "```py\niterate_grammar = extend_grammar(EXPR_GRAMMAR,\n                                 {\n                                     \"<factor>\": [\n                                         \"+<factor>\", \"-<factor>\", \"(<expr>)\",\n                                         (\"<integer>\", opts(\n                                             pre=(x for x in range(1, 1000)))),\n                                     ],\n                                 }) \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def fuzz_tree(self) -> DerivationTree:\n        while True:\n            tree = super().fuzz_tree()\n            (symbol, children) = tree\n            result, new_children = self.run_post_functions(tree)\n            if not isinstance(result, bool) or result:\n                return (symbol, new_children)\n            self.restart_expansion()\n\n    def restart_expansion(self) -> None:\n        # To be overloaded in subclasses\n        self.reset_generators() \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    # Return True iff all constraints of grammar are satisfied in TREE\n    def run_post_functions(self, tree: DerivationTree,\n                           depth: Union[int, float] = float(\"inf\")) \\\n                               -> Tuple[bool, Optional[List[DerivationTree]]]:\n        symbol: str = tree[0]\n        children: List[DerivationTree] = cast(List[DerivationTree], tree[1])\n\n        if children == []:\n            return True, children  # Terminal symbol\n\n        try:\n            expansion = self.find_expansion(tree)\n        except KeyError:\n            # Expansion (no longer) found - ignore\n            return True, children\n\n        result = True\n        function = exp_post_expansion_function(expansion)\n        if function is not None:\n            result = self.eval_function(tree, function)\n            if isinstance(result, bool) and not result:\n                if self.log:\n                    print(\n                        all_terminals(tree),\n                        \"did not satisfy\",\n                        symbol,\n                        \"constraint\")\n                return False, children\n\n            children = self.apply_result(result, children)\n\n        if depth > 0:\n            for c in children:\n                result, _ = self.run_post_functions(c, depth - 1)\n                if isinstance(result, bool) and not result:\n                    return False, children\n\n        return result, children \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def find_expansion(self, tree):\n        symbol, children = tree\n\n        applied_expansion = \\\n            \"\".join([child_symbol for child_symbol, _ in children])\n\n        for expansion in self.grammar[symbol]:\n            if exp_string(expansion) == applied_expansion:\n                return expansion\n\n        raise KeyError(\n            symbol +\n            \": did not find expansion \" +\n            repr(applied_expansion)) \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def eval_function(self, tree, function):\n        symbol, children = tree\n\n        assert callable(function)\n\n        args = []\n        for (symbol, exp) in children:\n            if exp != [] and exp is not None:\n                symbol_value = all_terminals((symbol, exp))\n                args.append(symbol_value)\n\n        result = function(*args)\n        if self.log:\n            print(repr(function) + repr(tuple(args)), \"=\", repr(result))\n\n        return result \n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\ndef eval_with_exception(s):\n    # Use \"mute=True\" to suppress all messages\n    with ExpectError(print_traceback=False):\n        return eval(s)\n    return False \n```", "```py\nnegative_expr_grammar = extend_grammar(EXPR_GRAMMAR,\n                                       {\n                                           \"<start>\": [(\"<expr>\", opts(post=lambda s: eval_with_exception(s) < 0))]\n                                       }\n                                       )\n\nassert is_valid_grammar(negative_expr_grammar) \n```", "```py\nnegative_expr_fuzzer = GeneratorGrammarFuzzer(negative_expr_grammar)\nexpr = negative_expr_fuzzer.fuzz()\nexpr \n```", "```py\nZeroDivisionError: division by zero (expected)\n\n```", "```py\n'(8.9 / 6 * 4 - 0.2 + -7 - 7 - 8 * 6) * 7 * 15.55 - -945.9'\n\n```", "```py\neval(expr) \n```", "```py\n-5178.726666666667\n\n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import HTML \n```", "```py\nHTML(\"<strong>A bold text</strong>\") \n```", "```py\nXML_GRAMMAR: Grammar = {\n    \"<start>\": [\"<xml-tree>\"],\n    \"<xml-tree>\": [\"<<id>><xml-content></<id>>\"],\n    \"<xml-content>\": [\"Text\", \"<xml-tree>\"],\n    \"<id>\": [\"<letter>\", \"<id><letter>\"],\n    \"<letter>\": crange('a', 'z')\n} \n```", "```py\nassert is_valid_grammar(XML_GRAMMAR) \n```", "```py\nxml_fuzzer = GrammarFuzzer(XML_GRAMMAR)\nxml_fuzzer.fuzz() \n```", "```py\n'<t><qju>Text</m></q>'\n\n```", "```py\nXML_GRAMMAR.update({\n    \"<xml-tree>\": [(\"<<id>><xml-content></<id>>\",\n                    opts(post=lambda id1, content, id2: [None, None, id1])\n                    )]\n}) \n```", "```py\nassert is_valid_grammar(XML_GRAMMAR) \n```", "```py\nxml_fuzzer = GeneratorGrammarFuzzer(XML_GRAMMAR)\nxml_fuzzer.fuzz() \n```", "```py\n'<u>Text</u>'\n\n```", "```py\ncredit_card_fuzzer = GeneratorGrammarFuzzer(\n    CHARGE_GRAMMAR, start_symbol=\"<credit-card-number>\")\ncredit_card_number = credit_card_fuzzer.fuzz()\ncredit_card_number \n```", "```py\n'2967308746680770'\n\n```", "```py\nassert valid_luhn_checksum(credit_card_number) \n```", "```py\ncharge_fuzzer = GeneratorGrammarFuzzer(CHARGE_GRAMMAR)\ncharge_fuzzer.fuzz() \n```", "```py\n'Charge $818819.97 to my credit card 2817984968014288'\n\n```", "```py\nbinary_expr_grammar = extend_grammar(EXPR_GRAMMAR,\n                                     {\n                                         \"<integer>\": [(\"<digit><integer>\", opts(post=lambda digit, _: digit in [\"0\", \"1\"])),\n                                                       (\"<digit>\", opts(post=lambda digit: digit in [\"0\", \"1\"]))]\n                                     }\n                                     ) \n```", "```py\nassert is_valid_grammar(binary_expr_grammar) \n```", "```py\nbinary_expr_fuzzer = GeneratorGrammarFuzzer(binary_expr_grammar)\nbinary_expr_fuzzer.fuzz() \n```", "```py\n'(-+0)'\n\n```", "```py\nclass RestartExpansionException(Exception):\n    pass \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def expand_tree_once(self, tree: DerivationTree) -> DerivationTree:\n        # Apply inherited method.  This also calls `expand_tree_once()` on all\n        # subtrees.\n        new_tree: DerivationTree = super().expand_tree_once(tree)\n\n        (symbol, children) = new_tree\n        if all([exp_post_expansion_function(expansion)\n                is None for expansion in self.grammar[symbol]]):\n            # No constraints for this symbol\n            return new_tree\n\n        if self.any_possible_expansions(tree):\n            # Still expanding\n            return new_tree\n\n        return self.run_post_functions_locally(new_tree) \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def run_post_functions_locally(self, new_tree: DerivationTree) -> DerivationTree:\n        symbol, _ = new_tree\n\n        result, children = self.run_post_functions(new_tree, depth=0)\n        if not isinstance(result, bool) or result:\n            # No constraints, or constraint satisfied\n            # children = self.apply_result(result, children)\n            new_tree = (symbol, children)\n            return new_tree\n\n        # Replace tree by unexpanded symbol and try again\n        if self.log:\n            print(\n                all_terminals(new_tree),\n                \"did not satisfy\",\n                symbol,\n                \"constraint\")\n\n        if self.replacement_attempts_counter > 0:\n            if self.log:\n                print(\"Trying another expansion\")\n            self.replacement_attempts_counter -= 1\n            return (symbol, None)\n\n        if self.log:\n            print(\"Starting from scratch\")\n        raise RestartExpansionException \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def __init__(self, grammar: Grammar, replacement_attempts: int = 10,\n                 **kwargs) -> None:\n        super().__init__(grammar, **kwargs)\n        self.replacement_attempts = replacement_attempts\n\n    def restart_expansion(self) -> None:\n        super().restart_expansion()\n        self.replacement_attempts_counter = self.replacement_attempts\n\n    def fuzz_tree(self) -> DerivationTree:\n        self.replacement_attempts_counter = self.replacement_attempts\n        while True:\n            try:\n                # This is fuzz_tree() as defined above\n                tree = super().fuzz_tree()\n                return tree\n            except RestartExpansionException:\n                self.restart_expansion() \n```", "```py\nbinary_expr_fuzzer = GeneratorGrammarFuzzer(\n    binary_expr_grammar, replacement_attempts=100)\nbinary_expr_fuzzer.fuzz() \n```", "```py\n'+0 / +-1 - 1 / +0 * -+0 * 0 * 1 / 1'\n\n```", "```py\nimport [string](https://docs.python.org/3/library/string.html) \n```", "```py\nVAR_GRAMMAR: Grammar = {\n    '<start>': ['<statements>'],\n    '<statements>': ['<statement>;<statements>', '<statement>'],\n    '<statement>': ['<assignment>'],\n    '<assignment>': ['<identifier>=<expr>'],\n    '<identifier>': ['<word>'],\n    '<word>': ['<alpha><word>', '<alpha>'],\n    '<alpha>': list(string.ascii_letters),\n    '<expr>': ['<term>+<expr>', '<term>-<expr>', '<term>'],\n    '<term>': ['<factor>*<term>', '<factor>/<term>', '<factor>'],\n    '<factor>':\n    ['+<factor>', '-<factor>', '(<expr>)', '<identifier>', '<number>'],\n    '<number>': ['<integer>.<integer>', '<integer>'],\n    '<integer>': ['<digit><integer>', '<digit>'],\n    '<digit>': crange('0', '9')\n} \n```", "```py\nassert is_valid_grammar(VAR_GRAMMAR) \n```", "```py\ng = GrammarFuzzer(VAR_GRAMMAR)\nfor i in range(10):\n    print(g.fuzz()) \n```", "```py\nGc=F/1*Y+M-D-9;N=n/(m)/m*7\na=79.0;W=o-9;v=2;K=u;D=9\no=y-z+y+4;q=5+W;X=T\nM=-98.032*5/o\nH=IA-5-1;n=3-t;QQ=5-5\nY=-80;d=D-M+M;Z=4.3+1*r-5+b\nZDGSS=(1*Y-4)*54/0*pcO/4;RI=r*5.0\nQ=6+z-6;J=6/t/9/i-3-5+k\nx=-GT*+-x*6++-93*5\nq=da*T/e--v;x=3+g;bk=u\n\n```", "```py\nSYMBOL_TABLE: Set[str] = set() \n```", "```py\ndef define_id(id: str) -> None:\n    SYMBOL_TABLE.add(id) \n```", "```py\ndef use_id() -> Union[bool, str]:\n    if len(SYMBOL_TABLE) == 0:\n        return False\n\n    id = random.choice(list(SYMBOL_TABLE))\n    return id \n```", "```py\ndef clear_symbol_table() -> None:\n    global SYMBOL_TABLE\n    SYMBOL_TABLE = set() \n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(VAR_GRAMMAR) \n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(CONSTRAINED_VAR_GRAMMAR, {\n    \"<assignment>\": [(\"<identifier>=<expr>\",\n                      opts(post=lambda id, expr: define_id(id)))]\n}) \n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(CONSTRAINED_VAR_GRAMMAR, {\n    \"<factor>\": ['+<factor>', '-<factor>', '(<expr>)',\n                 (\"<identifier>\", opts(post=lambda _: use_id())),\n                 '<number>']\n}) \n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(CONSTRAINED_VAR_GRAMMAR, {\n    \"<start>\": [(\"<statements>\", opts(pre=clear_symbol_table))]\n}) \n```", "```py\nassert is_valid_grammar(CONSTRAINED_VAR_GRAMMAR) \n```", "```py\nvar_grammar_fuzzer = GeneratorGrammarFuzzer(CONSTRAINED_VAR_GRAMMAR)\nfor i in range(10):\n    print(var_grammar_fuzzer.fuzz()) \n```", "```py\nDB=+(8/4/7-9+3+3)/2178/+-9\nlNIqc=+(1+9-8)/2.9*8/5*0\nSg=(+9/8/6)*++1/(1+7)*8*4\nr=+---552\niz=5/7/7;K=1+6*iz*1\nq=3-2;MPy=q;p=2*5\nzj=+5*-+35.2-+1.5727978+(-(-0/6-7+3))*--+44*1\nTl=((0*9+4-3)-6)/(-3-7*8*8/7)+9\naXZ=-5/-+3*9/3/1-8-+0*0/3+7+4\nNA=-(8+a-1)*1.6;g=++7;a=++g*g*g\n\n```", "```py\nvar_grammar_fuzzer = GeneratorGrammarFuzzer(CONSTRAINED_VAR_GRAMMAR)\nwith ExpectError():\n    for i in range(100):\n        s = var_grammar_fuzzer.fuzz()\n        try:\n            exec(s, {}, {})\n        except SyntaxError:\n            continue\n        except ZeroDivisionError:\n            continue\nprint(s) \n```", "```py\nf=(9)*kOj*kOj-6/7;kOj=(9-8)*7*1\n\n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_11764/3970000697.py\", line 6, in <module>\n    exec(s, {}, {})\n  File \"<string>\", line 1, in <module>\nNameError: name 'kOj' is not defined (expected)\n\n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(CONSTRAINED_VAR_GRAMMAR, {\n    \"<statements>\": [(\"<statement>;<statements>\", opts(order=[1, 2])),\n                     \"<statement>\"]\n}) \n```", "```py\nCONSTRAINED_VAR_GRAMMAR = extend_grammar(CONSTRAINED_VAR_GRAMMAR, {\n    \"<assignment>\": [(\"<identifier>=<expr>\", opts(post=lambda id, expr: define_id(id),\n                                                  order=[2, 1]))],\n}) \n```", "```py\ndef exp_order(expansion):\n  \"\"\"Return the specified expansion ordering, or None if unspecified\"\"\"\n    return exp_opt(expansion, 'order') \n```", "```py\nclass GeneratorGrammarFuzzer(GeneratorGrammarFuzzer):\n    def choose_tree_expansion(self, tree: DerivationTree,\n                              expandable_children: List[DerivationTree]) \\\n                              -> int:\n  \"\"\"Return index of subtree in `expandable_children`\n to be selected for expansion. Defaults to random.\"\"\"\n        (symbol, tree_children) = tree\n        assert isinstance(tree_children, list)\n\n        if len(expandable_children) == 1:\n            # No choice\n            return super().choose_tree_expansion(tree, expandable_children)\n\n        expansion = self.find_expansion(tree)\n        given_order = exp_order(expansion)\n        if given_order is None:\n            # No order specified\n            return super().choose_tree_expansion(tree, expandable_children)\n\n        nonterminal_children = [c for c in tree_children if c[1] != []]\n        assert len(nonterminal_children) == len(given_order), \\\n            \"Order must have one element for each nonterminal\"\n\n        # Find expandable child with lowest ordering\n        min_given_order = None\n        j = 0\n        for k, expandable_child in enumerate(expandable_children):\n            while j < len(\n                    nonterminal_children) and expandable_child != nonterminal_children[j]:\n                j += 1\n            assert j < len(nonterminal_children), \"Expandable child not found\"\n            if self.log:\n                print(\"Expandable child #%d  %s has order %d\" %\n                      (k, expandable_child[0], given_order[j]))\n\n            if min_given_order is None or given_order[j] < given_order[min_given_order]:\n                min_given_order = k\n\n        assert min_given_order is not None\n\n        if self.log:\n            print(\"Returning expandable child #%d  %s\" %\n                  (min_given_order, expandable_children[min_given_order][0]))\n\n        return min_given_order \n```", "```py\nvar_grammar_fuzzer = GeneratorGrammarFuzzer(CONSTRAINED_VAR_GRAMMAR)\nfor i in range(100):\n    s = var_grammar_fuzzer.fuzz()\n    if i < 10:\n        print(s)\n    try:\n        exec(s, {}, {})\n    except SyntaxError:\n        continue\n    except ZeroDivisionError:\n        continue \n```", "```py\na=(1)*0*3/8+0/8-4/8-0\nr=+0*+8/-4+((9)*2-1-8+6/9)\nD=+(2*3+6*0)-(5)/9*0/2;Q=D\nC=9*(2-1)*9*0-1.2/6-3*5\nG=-25.1\nH=+4*4/8.5*4-8*4+(5);D=6\nPIF=4841/++(460.1---626)*51755;E=(8)/-PIF+6.8*(7-PIF)*9*PIF;k=8\nX=((0)*2/0*6+7*3)/(0-7-9)\nx=94.2+25;x=++x/(7)+-9/8/2/x+-1/x;I=x\ncBM=51.15;f=81*-+--((2++cBM/cBM*+1*0/0-5+cBM))\n\n```", "```py\nfrom [ProbabilisticGrammarFuzzer](ProbabilisticGrammarFuzzer.html) import ProbabilisticGrammarFuzzer  # minor dependency \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import inheritance_conflicts \n```", "```py\ninheritance_conflicts(ProbabilisticGrammarFuzzer, GeneratorGrammarFuzzer) \n```", "```py\n['supported_opts']\n\n```", "```py\nclass ProbabilisticGeneratorGrammarFuzzer(GeneratorGrammarFuzzer,\n                                          ProbabilisticGrammarFuzzer):\n  \"\"\"Join the features of `GeneratorGrammarFuzzer` \n and `ProbabilisticGrammarFuzzer`\"\"\"\n\n    def supported_opts(self) -> Set[str]:\n        return (super(GeneratorGrammarFuzzer, self).supported_opts() |\n                super(ProbabilisticGrammarFuzzer, self).supported_opts())\n\n    def __init__(self, grammar: Grammar, *, replacement_attempts: int = 10,\n                 **kwargs):\n  \"\"\"Constructor.\n `replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.\n All other keywords go into `ProbabilisticGrammarFuzzer`.\n \"\"\"\n        super(GeneratorGrammarFuzzer, self).__init__(\n                grammar,\n                replacement_attempts=replacement_attempts)\n        super(ProbabilisticGrammarFuzzer, self).__init__(grammar, **kwargs) \n```", "```py\nCONSTRAINED_VAR_GRAMMAR.update({\n    '<word>': [('<alpha><word>', opts(prob=0.9)),\n               '<alpha>'],\n}) \n```", "```py\npgg_fuzzer = ProbabilisticGeneratorGrammarFuzzer(CONSTRAINED_VAR_GRAMMAR)\npgg_fuzzer.supported_opts() \n```", "```py\n{'order', 'post', 'pre', 'prob'}\n\n```", "```py\npgg_fuzzer.fuzz() \n```", "```py\n'a=5+3/8/8+-1/6/9/8;E=6'\n\n```", "```py\nfrom [ProbabilisticGrammarFuzzer](ProbabilisticGrammarFuzzer.html) import ProbabilisticGrammarCoverageFuzzer  # minor dependency \n```", "```py\nfrom [GrammarCoverageFuzzer](GrammarCoverageFuzzer.html) import GrammarCoverageFuzzer  # minor dependency \n```", "```py\ninheritance_conflicts(ProbabilisticGrammarCoverageFuzzer,\n                      GeneratorGrammarFuzzer) \n```", "```py\n['__init__', 'supported_opts']\n\n```", "```py\nimport [copy](https://docs.python.org/3/library/copy.html) \n```", "```py\nclass ProbabilisticGeneratorGrammarCoverageFuzzer(GeneratorGrammarFuzzer,\n                                                  ProbabilisticGrammarCoverageFuzzer):\n  \"\"\"Join the features of `GeneratorGrammarFuzzer` \n and `ProbabilisticGrammarCoverageFuzzer`\"\"\"\n\n    def supported_opts(self) -> Set[str]:\n        return (super(GeneratorGrammarFuzzer, self).supported_opts() |\n                super(ProbabilisticGrammarCoverageFuzzer, self).supported_opts())\n\n    def __init__(self, grammar: Grammar, *,\n                 replacement_attempts: int = 10, **kwargs) -> None:\n  \"\"\"Constructor.\n `replacement_attempts` - see `GeneratorGrammarFuzzer` constructor.\n All other keywords go into `ProbabilisticGrammarFuzzer`.\n \"\"\"\n        super(GeneratorGrammarFuzzer, self).__init__(\n                grammar,\n                replacement_attempts)\n        super(ProbabilisticGrammarCoverageFuzzer, self).__init__(\n                grammar,\n                **kwargs) \n```", "```py\nclass ProbabilisticGeneratorGrammarCoverageFuzzer(\n        ProbabilisticGeneratorGrammarCoverageFuzzer):\n\n    def fuzz_tree(self) -> DerivationTree:\n        self.orig_covered_expansions = copy.deepcopy(self.covered_expansions)\n        tree = super().fuzz_tree()\n        self.covered_expansions = self.orig_covered_expansions\n        self.add_tree_coverage(tree)\n        return tree\n\n    def add_tree_coverage(self, tree: DerivationTree) -> None:\n        (symbol, children) = tree\n        assert isinstance(children, list)\n        if len(children) > 0:\n            flat_children: List[DerivationTree] = [\n                (child_symbol, None)\n                for (child_symbol, _) in children\n            ]\n            self.add_coverage(symbol, flat_children)\n            for c in children:\n                self.add_tree_coverage(c) \n```", "```py\nclass ProbabilisticGeneratorGrammarCoverageFuzzer(\n        ProbabilisticGeneratorGrammarCoverageFuzzer):\n\n    def restart_expansion(self) -> None:\n        super().restart_expansion()\n        self.covered_expansions = self.orig_covered_expansions \n```", "```py\npggc_fuzzer = ProbabilisticGeneratorGrammarCoverageFuzzer(\n    CONSTRAINED_VAR_GRAMMAR)\npggc_fuzzer.fuzz() \n```", "```py\n'H=+-2+7.4*(9)/0-6*8;T=5'\n\n```", "```py\npggc_fuzzer.expansion_coverage() \n```", "```py\n{'<alpha> -> H',\n '<alpha> -> T',\n '<assignment> -> <identifier>=<expr>',\n '<digit> -> 0',\n '<digit> -> 2',\n '<digit> -> 4',\n '<digit> -> 5',\n '<digit> -> 6',\n '<digit> -> 7',\n '<digit> -> 8',\n '<digit> -> 9',\n '<expr> -> <term>',\n '<expr> -> <term>+<expr>',\n '<expr> -> <term>-<expr>',\n '<factor> -> (<expr>)',\n '<factor> -> +<factor>',\n '<factor> -> -<factor>',\n '<factor> -> <number>',\n '<identifier> -> <word>',\n '<integer> -> <digit>',\n '<number> -> <integer>',\n '<number> -> <integer>.<integer>',\n '<start> -> <statements>',\n '<statement> -> <assignment>',\n '<statements> -> <statement>',\n '<statements> -> <statement>;<statements>',\n '<term> -> <factor>',\n '<term> -> <factor>*<term>',\n '<term> -> <factor>/<term>',\n '<word> -> <alpha>'}\n\n```", "```py\n[pggc_fuzzer.fuzz() for i in range(10)] \n```", "```py\n['llcyzc=3.0*02.3*1',\n 'RfMgRYmd=---2.9',\n 'p=+(7+3/4)*+-4-3.2*((2)-4)/2',\n 'z=1-2/4-3*9+3+5',\n 'v=(2/3)/1/2*8+(3)-7*2-1',\n 'L=9.5/9-(7)/8/1+2-2;c=L',\n 'U=+-91535-1-9-(9)/1;i=U',\n 'g=-8.3*7*5+1*5*9-5;k=1',\n 'J=+-8-(5/6-1)/7-6+7',\n 'p=053/-(8*0*3*2/1);t=p']\n\n```", "```py\nclass PGGCFuzzer(ProbabilisticGeneratorGrammarCoverageFuzzer):\n  \"\"\"The one grammar-based fuzzer that supports all fuzzingbook features\"\"\"\n    pass \n```", "```py\nATTR_GRAMMAR = {\n    \"<clause>\": [(\"<xml-open>Text<xml-close>\", opts(post=lambda x1, x2: [None, x1.name]))],\n    \"<xml-open>\": [(\"<<tag>>\", opts(post=lambda tag: opts(name=...)))],\n    \"<xml-close>\": [\"</<tag>>\"]\n} \n```", "```py\n@incollection{fuzzingbook2024:GeneratorGrammarFuzzer,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Fuzzing with Generators},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html}},\n    note = {Retrieved 2024-01-10 15:45:59+01:00},\n    url = {https://www.fuzzingbook.org/html/GeneratorGrammarFuzzer.html},\n    urldate = {2024-01-10 15:45:59+01:00}\n}\n\n```"]