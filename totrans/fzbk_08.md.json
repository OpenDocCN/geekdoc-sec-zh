["```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import YouTubeVideo\nYouTubeVideo('8HxW8j9287A') \n```", "```py\n>>> from [fuzzingbook.Coverage](Coverage.html) import <identifier> \n```", "```py\n>>> with Coverage() as cov:\n>>>     cgi_decode(\"a+b\") \n```", "```py\n>>> print(cov)\n#  1  def cgi_decode(s: str) -> str:\n#  2      \"\"\"Decode the CGI-encoded string `s`:\n#  3         * replace '+' by ' '\n#  4         * replace \"%xx\" by the character with hex number xx.\n#  5         Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n#  6 \n#  7      # Mapping of hex digits to their integer values\n   8      hex_values = {\n   9          '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n  10          '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n  11          'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n  12          'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n# 13      }\n# 14 \n  15      t = \"\"\n  16      i = 0\n  17      while i < len(s):\n  18          c = s[i]\n  19          if c == '+':\n  20              t += ' '\n  21          elif c == '%':\n# 22              digit_high, digit_low = s[i + 1], s[i + 2]\n# 23              i += 2\n# 24              if digit_high in hex_values and digit_low in hex_values:\n# 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]\n# 26                  t += chr(v)\n# 27              else:\n# 28                  raise ValueError(\"Invalid encoding\")\n# 29          else:\n  30              t += c\n  31          i += 1\n  32      return t \n```", "```py\n>>> cov.trace()\n[('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 10),\n ('cgi_decode', 8),\n ('cgi_decode', 10),\n ('cgi_decode', 8),\n ('cgi_decode', 10),\n ('cgi_decode', 8),\n ('cgi_decode', 10),\n ('cgi_decode', 8),\n ('cgi_decode', 10),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 11),\n ('cgi_decode', 8),\n ('cgi_decode', 12),\n ('cgi_decode', 8),\n ('cgi_decode', 12),\n ('cgi_decode', 8),\n ('cgi_decode', 15),\n ('cgi_decode', 16),\n ('cgi_decode', 17),\n ('cgi_decode', 18),\n ('cgi_decode', 19),\n ('cgi_decode', 21),\n ('cgi_decode', 30),\n ('cgi_decode', 31),\n ('cgi_decode', 17),\n ('cgi_decode', 18),\n ('cgi_decode', 19),\n ('cgi_decode', 20),\n ('cgi_decode', 31),\n ('cgi_decode', 17),\n ('cgi_decode', 18),\n ('cgi_decode', 19),\n ('cgi_decode', 21),\n ('cgi_decode', 30),\n ('cgi_decode', 31),\n ('cgi_decode', 17),\n ('cgi_decode', 32)] \n```", "```py\n>>> cov.coverage()\n{('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 10),\n ('cgi_decode', 11),\n ('cgi_decode', 12),\n ('cgi_decode', 15),\n ('cgi_decode', 16),\n ('cgi_decode', 17),\n ('cgi_decode', 18),\n ('cgi_decode', 19),\n ('cgi_decode', 20),\n ('cgi_decode', 21),\n ('cgi_decode', 30),\n ('cgi_decode', 31),\n ('cgi_decode', 32)} \n```", "```py\nwith Coverage() as cov:\nfunction_to_be_traced()\nc = cov.coverage()\n```", "```py\nimport [bookutils.setup](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) \n```", "```py\ndef cgi_decode(s: str) -> str:\n  \"\"\"Decode the CGI-encoded string `s`:\n * replace '+' by ' '\n * replace \"%xx\" by the character with hex number xx.\n Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n\n    # Mapping of hex digits to their integer values\n    hex_values = {\n        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n    }\n\n    t = \"\"\n    i = 0\n    while i < len(s):\n        c = s[i]\n        if c == '+':\n            t += ' '\n        elif c == '%':\n            digit_high, digit_low = s[i + 1], s[i + 2]\n            i += 2\n            if digit_high in hex_values and digit_low in hex_values:\n                v = hex_values[digit_high] * 16 + hex_values[digit_low]\n                t += chr(v)\n            else:\n                raise ValueError(\"Invalid encoding\")\n        else:\n            t += c\n        i += 1\n    return t \n```", "```py\ncgi_decode(\"Hello+world\") \n```", "```py\n'Hello world'\n\n```", "```py\nassert cgi_decode('+') == ' '\nassert cgi_decode('%20') == ' '\nassert cgi_decode('abc') == 'abc'\n\ntry:\n    cgi_decode('%?a')\n    assert False\nexcept ValueError:\n    pass \n```", "```py\ncgi_decode(\"a+b\") \n```", "```py\n'a b'\n\n```", "```py\nfrom [types](https://docs.python.org/3/library/types.html) import FrameType, TracebackType \n```", "```py\ncoverage = [] \n```", "```py\ndef traceit(frame: FrameType, event: str, arg: Any) -> Optional[Callable]:\n  \"\"\"Trace program execution. To be passed to sys.settrace().\"\"\"\n    if event == 'line':\n        global coverage\n        function_name = frame.f_code.co_name\n        lineno = frame.f_lineno\n        coverage.append(lineno)\n\n    return traceit \n```", "```py\nimport [sys](https://docs.python.org/3/library/sys.html) \n```", "```py\ndef cgi_decode_traced(s: str) -> None:\n    global coverage\n    coverage = []\n    sys.settrace(traceit)  # Turn on\n    cgi_decode(s)\n    sys.settrace(None)    # Turn off \n```", "```py\ncgi_decode_traced(\"a+b\")\nprint(coverage) \n```", "```py\n[8, 9, 8, 9, 8, 9, 8, 9, 8, 9, 8, 10, 8, 10, 8, 10, 8, 10, 8, 10, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 11, 8, 12, 8, 12, 8, 15, 16, 17, 18, 19, 21, 30, 31, 17, 18, 19, 20, 31, 17, 18, 19, 21, 30, 31, 17, 32]\n\n```", "```py\nimport [inspect](https://docs.python.org/3/library/inspect.html) \n```", "```py\ncgi_decode_code = inspect.getsource(cgi_decode) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import print_content, print_file \n```", "```py\nprint_content(cgi_decode_code[:300] + \"...\", \".py\") \n```", "```py\ndef cgi_decode(s: str) -> str:\n  \"\"\"Decode the CGI-encoded string `s`:\n * replace '+' by ' '\n * replace \"%xx\" by the character with hex number xx.\n Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n\n    # Mapping of hex digits to their integer values\n    hex_v...\n\n```", "```py\ncgi_decode_lines = [\"\"] + cgi_decode_code.splitlines() \n```", "```py\ncgi_decode_lines[1] \n```", "```py\n'def cgi_decode(s: str) -> str:'\n\n```", "```py\ncgi_decode_lines[9:13] \n```", "```py\n[\"        '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\",\n \"        '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\",\n \"        'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\",\n \"        'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\"]\n\n```", "```py\ncgi_decode_lines[15] \n```", "```py\n'    t = \"\"'\n\n```", "```py\ncovered_lines = set(coverage)\nprint(covered_lines) \n```", "```py\n{32, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 30, 31}\n\n```", "```py\nfor lineno in range(1, len(cgi_decode_lines)):\n    if lineno not in covered_lines:\n        print(\"# \", end=\"\")\n    else:\n        print(\"  \", end=\"\")\n    print(\"%2d \" % lineno, end=\"\")\n    print_content(cgi_decode_lines[lineno], '.py')\n    print() \n```", "```py\n#  1  def cgi_decode(s: str) -> str:\n#  2      \"\"\"Decode the CGI-encoded string `s`:\n#  3         * replace '+' by '  '\n#  4         * replace \"%xx\" by the character with hex number xx.\n#  5         Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n#  6  \n#  7      # Mapping of hex digits to their integer values\n   8      hex_values = {\n   9          '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n  10          '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n  11          'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n  12          'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n# 13      }\n# 14  \n  15      t = \"\"\n  16      i = 0\n  17      while i < len(s):\n  18          c = s[i]\n  19          if c == '+':\n  20              t += '  '\n  21          elif c == '%':\n# 22              digit_high, digit_low = s[i + 1], s[i + 2]\n# 23              i += 2\n# 24              if digit_high in hex_values and digit_low in hex_values:\n# 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]\n# 26                  t += chr(v)\n# 27              else:\n# 28                  raise ValueError(\"Invalid encoding\")\n# 29          else:\n  30              t += c\n  31          i += 1\n  32      return t\n\n```", "```py\nwith OBJECT [as VARIABLE]:\n    BODY \n```", "```py\nwith Coverage() as cov:\n    function_to_be_traced()\nc = cov.coverage() \n```", "```py\nLocation = Tuple[str, int] \n```", "```py\nclass Coverage:\n  \"\"\"Track coverage within a `with` block. Use as\n ```", "```py\n \"\"\"\n\n    def __init__(self) -> None:\n  \"\"\"Constructor\"\"\"\n        self._trace: List[Location] = []\n\n    # Trace function\n    def traceit(self, frame: FrameType, event: str, arg: Any) -> Optional[Callable]:\n  \"\"\"Tracing function. To be overloaded in subclasses.\"\"\"\n        if self.original_trace_function is not None:\n            self.original_trace_function(frame, event, arg)\n\n        if event == \"line\":\n            function_name = frame.f_code.co_name\n            lineno = frame.f_lineno\n            if function_name != '__exit__':  # avoid tracing ourselves:\n                self._trace.append((function_name, lineno))\n\n        return self.traceit\n\n    def __enter__(self) -> Any:\n  \"\"\"Start of `with` block. Turn on tracing.\"\"\"\n        self.original_trace_function = sys.gettrace()\n        sys.settrace(self.traceit)\n        return self\n\n    def __exit__(self, exc_type: Type, exc_value: BaseException,\n                 tb: TracebackType) -> Optional[bool]:\n  \"\"\"End of `with` block. Turn off tracing.\"\"\"\n        sys.settrace(self.original_trace_function)\n        return None  # default: pass all exceptions\n\n    def trace(self) -> List[Location]:\n  \"\"\"The list of executed lines, as (function_name, line_number) pairs\"\"\"\n        return self._trace\n\n    def coverage(self) -> Set[Location]:\n  \"\"\"The set of executed lines, as (function_name, line_number) pairs\"\"\"\n        return set(self.trace())\n\n    def function_names(self) -> Set[str]:\n  \"\"\"The set of function names seen\"\"\"\n        return set(function_name for (function_name, line_number) in self.coverage())\n\n    def __repr__(self) -> str:\n  \"\"\"Return a string representation of this object.\n Show covered (and uncovered) program code\"\"\"\n        t = \"\"\n        for function_name in self.function_names():\n            # Similar code as in the example above\n            try:\n                fun = eval(function_name)\n            except Exception as exc:\n                t += f\"Skipping {function_name}: {exc}\"\n                continue\n\n            source_lines, start_line_number = inspect.getsourcelines(fun)\n            for lineno in range(start_line_number, start_line_number + len(source_lines)):\n                if (function_name, lineno) not in self.trace():\n                    t += \"# \"\n                else:\n                    t += \"  \"\n                t += \"%2d \" % lineno\n                t += source_lines[lineno - start_line_number]\n\n        return t \n```", "```py\nwith Coverage() as cov:\n    cgi_decode(\"a+b\")\n\nprint(cov.coverage()) \n```", "```py\n{('cgi_decode', 8), ('cgi_decode', 11), ('cgi_decode', 17), ('cgi_decode', 30), ('cgi_decode', 20), ('cgi_decode', 10), ('cgi_decode', 16), ('cgi_decode', 19), ('cgi_decode', 9), ('cgi_decode', 32), ('cgi_decode', 12), ('cgi_decode', 31), ('cgi_decode', 15), ('cgi_decode', 21), ('cgi_decode', 18)}\n\n```", "```py\nprint(cov) \n```", "```py\n#  1  def cgi_decode(s: str) -> str:\n#  2      \"\"\"Decode the CGI-encoded string `s`:\n#  3         * replace '+' by ' '\n#  4         * replace \"%xx\" by the character with hex number xx.\n#  5         Return the decoded string.  Raise `ValueError` for invalid inputs.\"\"\"\n#  6  \n#  7      # Mapping of hex digits to their integer values\n   8      hex_values = {\n   9          '0': 0, '1': 1, '2': 2, '3': 3, '4': 4,\n  10          '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n  11          'a': 10, 'b': 11, 'c': 12, 'd': 13, 'e': 14, 'f': 15,\n  12          'A': 10, 'B': 11, 'C': 12, 'D': 13, 'E': 14, 'F': 15,\n# 13      }\n# 14  \n  15      t = \"\"\n  16      i = 0\n  17      while i < len(s):\n  18          c = s[i]\n  19          if c == '+':\n  20              t += ' '\n  21          elif c == '%':\n# 22              digit_high, digit_low = s[i + 1], s[i + 2]\n# 23              i += 2\n# 24              if digit_high in hex_values and digit_low in hex_values:\n# 25                  v = hex_values[digit_high] * 16 + hex_values[digit_low]\n# 26                  t += chr(v)\n# 27              else:\n# 28                  raise ValueError(\"Invalid encoding\")\n# 29          else:\n  30              t += c\n  31          i += 1\n  32      return t\n\n```", "```py\nwith Coverage() as cov_plus:\n    cgi_decode(\"a+b\")\nwith Coverage() as cov_standard:\n    cgi_decode(\"abc\")\n\ncov_plus.coverage() - cov_standard.coverage() \n```", "```py\n{('cgi_decode', 20)}\n\n```", "```py\nwith Coverage() as cov_max:\n    cgi_decode('+')\n    cgi_decode('%20')\n    cgi_decode('abc')\n    try:\n        cgi_decode('%?a')\n    except Exception:\n        pass \n```", "```py\ncov_max.coverage() - cov_plus.coverage() \n```", "```py\n{('cgi_decode', 22),\n ('cgi_decode', 23),\n ('cgi_decode', 24),\n ('cgi_decode', 25),\n ('cgi_decode', 26),\n ('cgi_decode', 28)}\n\n```", "```py\nfrom [Fuzzer](Fuzzer.html) import fuzzer \n```", "```py\nsample = fuzzer()\nsample \n```", "```py\n'!7#%\"*#0=)$;%6*;>638:*>80\"=</>(/*:-(2<4 !:5*6856&?\"\"11<7+%<%7,4.8,*+&,,$,.\"'\n\n```", "```py\nwith Coverage() as cov_fuzz:\n    try:\n        cgi_decode(sample)\n    except:\n        pass\ncov_fuzz.coverage() \n```", "```py\n{('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 10),\n ('cgi_decode', 11),\n ('cgi_decode', 12),\n ('cgi_decode', 15),\n ('cgi_decode', 16),\n ('cgi_decode', 17),\n ('cgi_decode', 18),\n ('cgi_decode', 19),\n ('cgi_decode', 21),\n ('cgi_decode', 22),\n ('cgi_decode', 23),\n ('cgi_decode', 24),\n ('cgi_decode', 28),\n ('cgi_decode', 30),\n ('cgi_decode', 31)}\n\n```", "```py\ncov_max.coverage() - cov_fuzz.coverage() \n```", "```py\n{('cgi_decode', 20),\n ('cgi_decode', 25),\n ('cgi_decode', 26),\n ('cgi_decode', 32)}\n\n```", "```py\ntrials = 100 \n```", "```py\ndef population_coverage(population: List[str], function: Callable) \\\n        -> Tuple[Set[Location], List[int]]:\n    cumulative_coverage: List[int] = []\n    all_coverage: Set[Location] = set()\n\n    for s in population:\n        with Coverage() as cov:\n            try:\n                function(s)\n            except:\n                pass\n        all_coverage |= cov.coverage()\n        cumulative_coverage.append(len(all_coverage))\n\n    return all_coverage, cumulative_coverage \n```", "```py\ndef hundred_inputs() -> List[str]:\n    population = []\n    for i in range(trials):\n        population.append(fuzzer())\n    return population \n```", "```py\nall_coverage, cumulative_coverage = \\\n    population_coverage(hundred_inputs(), cgi_decode) \n```", "```py\n%matplotlib inline \n```", "```py\nimport [matplotlib.pyplot](https://matplotlib.org/) as plt \n```", "```py\nplt.plot(cumulative_coverage)\nplt.title('Coverage of cgi_decode() with random inputs')\nplt.xlabel('# of inputs')\nplt.ylabel('lines covered') \n```", "```py\nText(0, 0.5, 'lines covered')\n\n```", "```py\nruns = 100\n\n# Create an array with TRIALS elements, all zero\nsum_coverage = [0] * trials\n\nfor run in range(runs):\n    all_coverage, coverage = population_coverage(hundred_inputs(), cgi_decode)\n    assert len(coverage) == trials\n    for i in range(trials):\n        sum_coverage[i] += coverage[i]\n\naverage_coverage = []\nfor i in range(trials):\n    average_coverage.append(sum_coverage[i] / runs) \n```", "```py\nplt.plot(average_coverage)\nplt.title('Average coverage of cgi_decode() with random inputs')\nplt.xlabel('# of inputs')\nplt.ylabel('lines covered') \n```", "```py\nText(0, 0.5, 'lines covered')\n\n```", "```py\n$  ./cgi_decode  'Hello+World'\nHello  World \n```", "```py\ncgi_c_code = \"\"\"\n/* CGI decoding as C program */\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n\"\"\" \n```", "```py\ncgi_c_code += r\"\"\"\nint hex_values[256];\n\nvoid init_hex_values() {\n for (int i = 0; i < sizeof(hex_values) / sizeof(int); i++) {\n hex_values[i] = -1;\n }\n hex_values['0'] = 0; hex_values['1'] = 1; hex_values['2'] = 2; hex_values['3'] = 3;\n hex_values['4'] = 4; hex_values['5'] = 5; hex_values['6'] = 6; hex_values['7'] = 7;\n hex_values['8'] = 8; hex_values['9'] = 9;\n\n hex_values['a'] = 10; hex_values['b'] = 11; hex_values['c'] = 12; hex_values['d'] = 13;\n hex_values['e'] = 14; hex_values['f'] = 15;\n\n hex_values['A'] = 10; hex_values['B'] = 11; hex_values['C'] = 12; hex_values['D'] = 13;\n hex_values['E'] = 14; hex_values['F'] = 15;\n}\n\"\"\" \n```", "```py\ncgi_c_code += r\"\"\"\nint cgi_decode(char *s, char *t) {\n while (*s != '\\0') {\n if (*s == '+')\n *t++ = ' ';\n else if (*s == '%') {\n int digit_high = *++s;\n int digit_low = *++s;\n if (hex_values[digit_high] >= 0 && hex_values[digit_low] >= 0) {\n *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];\n }\n else\n return -1;\n }\n else\n *t++ = *s;\n s++;\n }\n *t = '\\0';\n return 0;\n}\n\"\"\" \n```", "```py\ncgi_c_code += r\"\"\"\nint main(int argc, char *argv[]) {\n init_hex_values();\n\n if (argc >= 2) {\n char *s = argv[1];\n char *t = malloc(strlen(s) + 1); /* output is at most as long as input */\n int ret = cgi_decode(s, t);\n printf(\"%s\\n\", t);\n return ret;\n }\n else\n {\n printf(\"cgi_decode: usage: cgi_decode STRING\\n\");\n return 1;\n }\n}\n\"\"\" \n```", "```py\nwith open(\"cgi_decode.c\", \"w\") as f:\n    f.write(cgi_c_code) \n```", "```py\nfrom [bookutils](https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils) import print_file \n```", "```py\nprint_file(\"cgi_decode.c\") \n```", "```py\n/* CGI decoding as C program */\n\n#include  <stdlib.h>\n#include  <string.h>\n#include  <stdio.h>\n\nint  hex_values[256];\n\nvoid  init_hex_values()  {\n  for  (int  i  =  0;  i  <  sizeof(hex_values)  /  sizeof(int);  i++)  {\n  hex_values[i]  =  -1;\n  }\n  hex_values['0']  =  0;  hex_values['1']  =  1;  hex_values['2']  =  2;  hex_values['3']  =  3;\n  hex_values['4']  =  4;  hex_values['5']  =  5;  hex_values['6']  =  6;  hex_values['7']  =  7;\n  hex_values['8']  =  8;  hex_values['9']  =  9;\n\n  hex_values['a']  =  10;  hex_values['b']  =  11;  hex_values['c']  =  12;  hex_values['d']  =  13;\n  hex_values['e']  =  14;  hex_values['f']  =  15;\n\n  hex_values['A']  =  10;  hex_values['B']  =  11;  hex_values['C']  =  12;  hex_values['D']  =  13;\n  hex_values['E']  =  14;  hex_values['F']  =  15;\n}\n\nint  cgi_decode(char  *s,  char  *t)  {\n  while  (*s  !=  '\\0')  {\n  if  (*s  ==  '+')\n  *t++  =  '  ';\n  else  if  (*s  ==  '%')  {\n  int  digit_high  =  *++s;\n  int  digit_low  =  *++s;\n  if  (hex_values[digit_high]  >=  0  &&  hex_values[digit_low]  >=  0)  {\n  *t++  =  hex_values[digit_high]  *  16  +  hex_values[digit_low];\n  }\n  else\n  return  -1;\n  }\n  else\n  *t++  =  *s;\n  s++;\n  }\n  *t  =  '\\0';\n  return  0;\n}\n\nint  main(int  argc,  char  *argv[])  {\n  init_hex_values();\n\n  if  (argc  >=  2)  {\n  char  *s  =  argv[1];\n  char  *t  =  malloc(strlen(s)  +  1);  /* output is at most as long as input */\n  int  ret  =  cgi_decode(s,  t);\n  printf(\"%s\\n\",  t);\n  return  ret;\n  }\n  else\n  {\n  printf(\"cgi_decode: usage: cgi_decode STRING\\n\");\n  return  1;\n  }\n}\n\n```", "```py\n!cc  --coverage  -o  cgi_decode  cgi_decode.c \n```", "```py\n!./cgi_decode  'Send+mail+to+me%40fuzzingbook.org' \n```", "```py\nSend mail to me@fuzzingbook.org\n\n```", "```py\n!gcov  cgi_decode  cgi_decode-cgi_decode \n```", "```py\ncgi_decode.gcno: No such file or directory\nFile 'cgi_decode.c'\nLines executed:92.50% of 40\nCreating 'cgi_decode.c.gcov'\n\n```", "```py\nlines = open('cgi_decode.c.gcov').readlines()\nfor i in range(30, 50):\n    print(lines[i], end='') \n```", "```py\n        1:   26:int cgi_decode(char *s, char *t) {\n       32:   27:    while (*s != '\\0') {\n       31:   28:        if (*s == '+')\n        3:   29:            *t++ = ' ';\n       28:   30:        else if (*s == '%') {\n        1:   31:            int digit_high = *++s;\n        1:   32:            int digit_low = *++s;\n        1:   33:            if (hex_values[digit_high] >= 0 && hex_values[digit_low] >= 0) {\n        1:   34:                *t++ = hex_values[digit_high] * 16 + hex_values[digit_low];\n        1:   35:            }\n        -:   36:            else\n    #####:   37:                return -1;\n        1:   38:        }\n        -:   39:        else\n       27:   40:            *t++ = *s;\n       31:   41:        s++;\n        -:   42:    }\n        1:   43:    *t = '\\0';\n        1:   44:    return 0;\n        1:   45:}\n\n```", "```py\ndef read_gcov_coverage(c_file):\n    gcov_file = c_file + \".gcov\"\n    coverage = set()\n    with open(gcov_file) as file:\n        for line in file.readlines():\n            elems = line.split(':')\n            covered = elems[0].strip()\n            line_number = int(elems[1].strip())\n            if covered.startswith('-') or covered.startswith('#'):\n                continue\n            coverage.add((c_file, line_number))\n    return coverage \n```", "```py\ncoverage = read_gcov_coverage('cgi_decode.c') \n```", "```py\nlist(coverage)[:5] \n```", "```py\n[('cgi_decode.c', 53),\n ('cgi_decode.c', 62),\n ('cgi_decode.c', 16),\n ('cgi_decode.c', 13),\n ('cgi_decode.c', 19)]\n\n```", "```py\nfrom [ExpectError](ExpectError.html) import ExpectError \n```", "```py\nwith ExpectError():\n    for i in range(trials):\n        try:\n            s = fuzzer()\n            cgi_decode(s)\n        except ValueError:\n            pass \n```", "```py\nTraceback (most recent call last):\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_2687/2238772797.py\", line 5, in <module>\n    cgi_decode(s)\n  File \"/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_2687/1071239422.py\", line 22, in cgi_decode\n    digit_high, digit_low = s[i + 1], s[i + 2]\n                                      ~^^^^^^^\nIndexError: string index out of range (expected)\n\n```", "```py\ns \n```", "```py\n'82 202*&<1&($34\\'\"/\\'.<5/!8\"\\'5:!4))%;'\n\n```", "```py\nint  digit_high  =  *++s;\nint  digit_low  =  *++s; \n```", "```py\nimport [os](https://docs.python.org/3/library/os.html)\nimport [glob](https://docs.python.org/3/library/glob.html) \n```", "```py\nfor file in (glob.glob(\"cgi_decode\") + \n             glob.glob(\"cgi_decode.*\") + \n             glob.glob(\"cgi_decode-*\")):\n    os.remove(file) \n```", "```py\nif CONDITION:\n    do_a()\nelse:\n    do_b() \n```", "```py\nif CONDITION:\n    do_a()\nsomething_else() \n```", "```py\nwith Coverage() as cov:\n    cgi_decode(\"a+b\")\ntrace = cov.trace()\ntrace[:5] \n```", "```py\n[('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8),\n ('cgi_decode', 9),\n ('cgi_decode', 8)]\n\n```", "```py\nset(\n(('cgi_decode', 9), ('cgi_decode', 10)),\n(('cgi_decode', 10), ('cgi_decode', 11)),\n# more_pairs\n) \n```", "```py\n@incollection{fuzzingbook2024:Coverage,\n    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\\\"o}hme and Gordon Fraser and Christian Holler},\n    booktitle = {The Fuzzing Book},\n    title = {Code Coverage},\n    year = {2024},\n    publisher = {CISPA Helmholtz Center for Information Security},\n    howpublished = {\\url{https://www.fuzzingbook.org/html/Coverage.html}},\n    note = {Retrieved 2024-11-09 17:28:17+01:00},\n    url = {https://www.fuzzingbook.org/html/Coverage.html},\n    urldate = {2024-11-09 17:28:17+01:00}\n}\n\n```"]