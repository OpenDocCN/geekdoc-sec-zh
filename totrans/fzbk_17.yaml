- en: Parsing Inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/Parser.html](http://www.fuzzingbook.org/html/Parser.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the chapter on [Grammars](Grammars.html), we discussed how grammars can be
    used to represent various languages. We also saw how grammars can be used to generate
    strings of the corresponding language. Grammars can also perform the reverse.
    That is, given a string, one can decompose the string into its constituent parts
    that correspond to the parts of grammar used to generate it – the *derivation
    tree* of that string. These parts (and parts from other similar strings) can later
    be recombined using the same grammar to produce new strings.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we use grammars to parse and decompose a given set of valid
    seed inputs into their corresponding derivation trees. This structural representation
    allows us to mutate, crossover, and recombine their parts in order to generate
    new valid, slightly changed inputs (i.e., fuzz)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: You should have read the [chapter on grammars](Grammars.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An understanding of derivation trees from the [chapter on grammar fuzzer](GrammarFuzzer.html)
    is also required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces `Parser` classes, parsing a string into a *derivation
    tree* as introduced in the [chapter on efficient grammar fuzzing](GrammarFuzzer.html).
    Two important parser classes are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Parsing Expression Grammar parsers](#Parsing-Expression-Grammars) (`PEGParser`).
    These are very efficient, but limited to specific grammar structure. Notably,
    the alternatives represent *ordered choice*. That is, rather than choosing all
    rules that can potentially match, we stop at the first match that succeed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Earley parsers](#Parsing-Context-Free-Grammars) (`EarleyParser`). These accept
    any kind of context-free grammars, and explore all parsing alternatives (if any).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using any of these is fairly easy, though. First, instantiate them with a grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `parse()` method to retrieve a list of possible derivation trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="636pt" height="223pt" viewBox="0.00 0.00 635.75 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="265.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="265.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><phone-number></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="113.12" y="-101.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="166.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><area></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="232.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge10"
    class="edge"><title>1->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="299.12" y="-101.45" font-family="Times,serif" font-size="14.00"><exchange></text></g>
    <g id="edge11" class="edge"><title>1->11</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="366.12" y="-101.45" font-family="Times,serif" font-size="14.00">-
    (45)</text></g> <g id="edge18" class="edge"><title>1->18</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="489.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><line></text></g> <g id="edge19" class="edge"><title>1->19</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="34.12"
    y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="107.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge6" class="edge"><title>3->6</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="166.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge8" class="edge"><title>3->8</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="34.12" y="-0.95" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="107.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="166.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="239.12" y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge12" class="edge"><title>11->12</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="312.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge14" class="edge"><title>11->14</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>11->16</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="239.12" y="-0.95" font-family="Times,serif" font-size="14.00">9
    (57)</text></g> <g id="edge13" class="edge"><title>12->13</title></g> <g id="node16"
    class="node"><title>15</title> <text text-anchor="middle" x="312.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">8 (56)</text></g> <g id="edge15" class="edge"><title>14->15</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="371.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">7 (55)</text></g> <g id="edge17"
    class="edge"><title>16->17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="430.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge20" class="edge"><title>19->20</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="489.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>19->22</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="548.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge24" class="edge"><title>19->24</title></g> <g id="node27" class="node"><title>26</title>
    <text text-anchor="middle" x="607.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge26" class="edge"><title>19->26</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="430.12" y="-0.95" font-family="Times,serif" font-size="14.00">6
    (54)</text></g> <g id="edge21" class="edge"><title>20->21</title></g> <g id="node24"
    class="node"><title>23</title> <text text-anchor="middle" x="489.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge23" class="edge"><title>22->23</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="548.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">4 (52)</text></g> <g id="edge25"
    class="edge"><title>24->25</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="607.12" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: These derivation trees can then be used for test generation, notably for mutating
    and recombining existing inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '<svg width="382pt" height="395pt" viewBox="0.00 0.00 381.62 394.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 390.5)"><g
    id="node1" class="node"><title>PEGParser</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class PEGParser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Packrat parser for Parsing Expression Grammars (PEGs)."><text text-anchor="start"
    x="18.12" y="-126.58" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">PEGParser</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="PEGParser"><g id="a_node1_1"><a xlink:href="#" xlink:title="parse_prefix(self,
    text):'
  prefs: []
  type: TYPE_NORMAL
- en: Return pair (cursor, forest) for longest prefix of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be defined in subclasses."><text text-anchor="start" x="8" y="-104.38" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="unify_rule(self, rule, text,
    at)"><text text-anchor="start" x="8" y="-90.62" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">unify_rule()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="unify_key(self, key, text, at=0)"><text
    text-anchor="start" x="8" y="-77.88" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">unify_key()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Parser</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Parser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base class for parsing."><text text-anchor="start" x="93.5" y="-369.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Parser</text>
    <g id="a_node2_4"><a xlink:href="#" xlink:title="Parser"><g id="a_node2_5"><a
    xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`grammar` is the grammar to be used for parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start_symbol` is the start symbol (default: ''<start>'').'
  prefs: []
  type: TYPE_NORMAL
- en: '`log` enables logging (default: False).'
  prefs: []
  type: TYPE_NORMAL
- en: '`coalesce` defines if tokens should be coalesced (default: True).'
  prefs: []
  type: TYPE_NORMAL
- en: '`tokens`, if set, is a set of tokens to be used."><text text-anchor="start"
    x="71" y="-347.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g> <g id="a_node2_6"><a
    xlink:href="#" xlink:title="grammar(self) -> Grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the grammar of this parser."><text text-anchor="start" x="71" y="-334.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">grammar()</text></a></g> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="parse(self, text: str) -> Iterable[DerivationTree]:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse `text` using the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return an iterable of parse trees."><text text-anchor="start" x="71" y="-322"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">parse()</text></a></g> <g id="a_node2_8"><a xlink:href="#" xlink:title="start_symbol(self)
    -> str:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return the start symbol of this parser."><text text-anchor="start" x="71" y="-309.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">start_symbol()</text></a></g> <g id="a_node2_9"><a xlink:href="#"
    xlink:title="coalesce(self, children: List[DerivationTree]) -> List[DerivationTree]"><text
    text-anchor="start" x="71" y="-295.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">coalesce()</text></a></g> <g
    id="a_node2_10"><a xlink:href="#" xlink:title="parse_on(self, text: str, start_symbol:
    str) -> Generator"><text text-anchor="start" x="71" y="-282.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">parse_on()</text></a></g>
    <g id="a_node2_11"><a xlink:href="#" xlink:title="parse_prefix(self, text: str)
    -> Tuple[int, Iterable[DerivationTree]]:'
  prefs: []
  type: TYPE_NORMAL
- en: Return pair (cursor, forest) for longest prefix of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be defined in subclasses."><text text-anchor="start" x="71" y="-271" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node2_12"><a xlink:href="#" xlink:title="prune_tree(self, tree)"><text
    text-anchor="start" x="71" y="-257.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">prune_tree()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>PEGParser->Parser</title></g> <g id="node3"
    class="node"><title>EarleyParser</title> <g id="a_node3"><a xlink:href="#" xlink:title="class
    EarleyParser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Earley Parser. This parser can parse any context-free grammar."><text text-anchor="start"
    x="138" y="-196.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">EarleyParser</text> <g id="a_node3_13"><a xlink:href="#"
    xlink:title="EarleyParser"><g id="a_node3_14"><a xlink:href="#" xlink:title="__init__(self,
    grammar, **kwargs):'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '`grammar` is the grammar to be used for parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start_symbol` is the start symbol (default: ''<start>'').'
  prefs: []
  type: TYPE_NORMAL
- en: '`log` enables logging (default: False).'
  prefs: []
  type: TYPE_NORMAL
- en: '`coalesce` defines if tokens should be coalesced (default: True).'
  prefs: []
  type: TYPE_NORMAL
- en: '`tokens`, if set, is a set of tokens to be used."><text text-anchor="start"
    x="126" y="-174.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">__init__()</text></a></g> <g
    id="a_node3_15"><a xlink:href="#" xlink:title="chart_parse(self, words, start)"><text
    text-anchor="start" x="126" y="-160.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">chart_parse()</text></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="complete(self, col, state)"><text
    text-anchor="start" x="126" y="-148" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">complete()</text></a></g> <g
    id="a_node3_17"><a xlink:href="#" xlink:title="earley_complete(self, col, state)"><text
    text-anchor="start" x="126" y="-135.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">earley_complete()</text></a></g>
    <g id="a_node3_18"><a xlink:href="#" xlink:title="extract_a_tree(self, forest_node)"><text
    text-anchor="start" x="126" y="-122.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_a_tree()</text></a></g>
    <g id="a_node3_19"><a xlink:href="#" xlink:title="extract_trees(self, forest_node)"><text
    text-anchor="start" x="126" y="-109.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_trees()</text></a></g>
    <g id="a_node3_20"><a xlink:href="#" xlink:title="fill_chart(self, chart)"><text
    text-anchor="start" x="126" y="-97" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">fill_chart()</text></a></g> <g
    id="a_node3_21"><a xlink:href="#" xlink:title="forest(self, s, kind, chart)"><text
    text-anchor="start" x="126" y="-84.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">forest()</text></a></g> <g id="a_node3_22"><a
    xlink:href="#" xlink:title="parse(self, text):'
  prefs: []
  type: TYPE_NORMAL
- en: Parse `text` using the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return an iterable of parse trees."><text text-anchor="start" x="126" y="-72.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">parse()</text></a></g> <g id="a_node3_23"><a xlink:href="#"
    xlink:title="parse_forest(self, chart, state)"><text text-anchor="start" x="126"
    y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">parse_forest()</text></a></g> <g id="a_node3_24"><a xlink:href="#"
    xlink:title="parse_paths(self, named_expr, chart, frm, til)"><text text-anchor="start"
    x="126" y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">parse_paths()</text></a></g> <g id="a_node3_25"><a
    xlink:href="#" xlink:title="parse_prefix(self, text):'
  prefs: []
  type: TYPE_NORMAL
- en: Return pair (cursor, forest) for longest prefix of text.
  prefs: []
  type: TYPE_NORMAL
- en: To be defined in subclasses."><text text-anchor="start" x="126" y="-34.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node3_26"><a xlink:href="#" xlink:title="predict(self, col, sym, state)"><text
    text-anchor="start" x="126" y="-20.5" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-size="10.00">predict()</text></a></g> <g id="a_node3_27"><a
    xlink:href="#" xlink:title="scan(self, col, state, letter)"><text text-anchor="start"
    x="126" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">scan()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>EarleyParser->Parser</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="254.38"
    y="-122.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="254.38"
    y="-112.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="260.38" y="-112.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="254.38" y="-102.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-102.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="254.38" y="-92.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-92.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="254.38"
    y="-83.7" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Why Parsing for Fuzzing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Why would one want to parse existing inputs in order to fuzz? Let us illustrate
    the problem with an example. Here is a simple program that accepts a CSV file
    of vehicle details and processes this information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The CSV file contains details of one vehicle per line. Each row is processed
    in `process_vehicle()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Depending on the kind of vehicle, the processing changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here is a sample of inputs that the `process_inventory()` accepts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let us try to fuzz this program. Given that the `process_inventory()` takes
    a CSV file, we can write a simple grammar for generating comma separated values,
    and generate the required CSV rows. For convenience, we fuzz `process_vehicle()`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We need some infrastructure first for viewing the grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">csvline</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">items</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 305.0 92" width="305.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">item</text></g>
    <g class="terminal"><text x="148.25" y="35">,</text></g> <g class="non-terminal"><text
    x="213.75" y="35">items</text></g></g> <g><g class="non-terminal"><text x="152.5"
    y="65">item</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">letters</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">letter</text></g>
    <g class="non-terminal"><text x="190.75" y="35">letters</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">letter</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="618" viewBox="0 0 611.0 618" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="283">i</text></g></g>
    <g><g class="terminal"><text x="84.25" y="253">h</text></g></g> <g><g class="terminal"><text
    x="84.25" y="223">g</text></g></g> <g><g class="terminal"><text x="84.25" y="193">f</text></g></g>
    <g><g class="terminal"><text x="84.25" y="163">e</text></g></g> <g><g class="terminal"><text
    x="84.25" y="133">d</text></g></g> <g><g class="terminal"><text x="84.25" y="103">c</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">b</text></g></g> <g><g class="terminal"><text
    x="84.25" y="43">a</text></g></g> <g><g class="terminal"><text x="84.25" y="313">j</text></g></g>
    <g><g class="terminal"><text x="84.25" y="343">k</text></g></g> <g><g class="terminal"><text
    x="84.25" y="373">l</text></g></g> <g><g class="terminal"><text x="84.25" y="403">m</text></g></g>
    <g><g class="terminal"><text x="84.25" y="433">n</text></g></g> <g><g class="terminal"><text
    x="84.25" y="463">o</text></g></g> <g><g class="terminal"><text x="84.25" y="493">p</text></g></g>
    <g><g class="terminal"><text x="84.25" y="523">q</text></g></g> <g><g class="terminal"><text
    x="84.25" y="553">r</text></g></g> <g><g class="terminal"><text x="84.25" y="583">s</text></g></g></g>
    <g><g><g class="terminal"><text x="172.75" y="283">B</text></g></g> <g><g class="terminal"><text
    x="172.75" y="253">A</text></g></g> <g><g class="terminal"><text x="172.75" y="223">z</text></g></g>
    <g><g class="terminal"><text x="172.75" y="193">y</text></g></g> <g><g class="terminal"><text
    x="172.75" y="163">x</text></g></g> <g><g class="terminal"><text x="172.75" y="133">w</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">v</text></g></g> <g><g class="terminal"><text
    x="172.75" y="73">u</text></g></g> <g><g class="terminal"><text x="172.75" y="43">t</text></g></g>
    <g><g class="terminal"><text x="172.75" y="313">C</text></g></g> <g><g class="terminal"><text
    x="172.75" y="343">D</text></g></g> <g><g class="terminal"><text x="172.75" y="373">E</text></g></g>
    <g><g class="terminal"><text x="172.75" y="403">F</text></g></g> <g><g class="terminal"><text
    x="172.75" y="433">G</text></g></g> <g><g class="terminal"><text x="172.75" y="463">H</text></g></g>
    <g><g class="terminal"><text x="172.75" y="493">I</text></g></g> <g><g class="terminal"><text
    x="172.75" y="523">J</text></g></g> <g><g class="terminal"><text x="172.75" y="553">K</text></g></g>
    <g><g class="terminal"><text x="172.75" y="583">L</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="283">U</text></g></g> <g><g class="terminal"><text
    x="261.25" y="253">T</text></g></g> <g><g class="terminal"><text x="261.25" y="223">S</text></g></g>
    <g><g class="terminal"><text x="261.25" y="193">R</text></g></g> <g><g class="terminal"><text
    x="261.25" y="163">Q</text></g></g> <g><g class="terminal"><text x="261.25" y="133">P</text></g></g>
    <g><g class="terminal"><text x="261.25" y="103">O</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">N</text></g></g> <g><g class="terminal"><text x="261.25" y="43">M</text></g></g>
    <g><g class="terminal"><text x="261.25" y="313">V</text></g></g> <g><g class="terminal"><text
    x="261.25" y="343">W</text></g></g> <g><g class="terminal"><text x="261.25" y="373">X</text></g></g>
    <g><g class="terminal"><text x="261.25" y="403">Y</text></g></g> <g><g class="terminal"><text
    x="261.25" y="433">Z</text></g></g> <g><g class="terminal"><text x="261.25" y="463">0</text></g></g>
    <g><g class="terminal"><text x="261.25" y="493">1</text></g></g> <g><g class="terminal"><text
    x="261.25" y="523">2</text></g></g> <g><g class="terminal"><text x="261.25" y="553">3</text></g></g>
    <g><g class="terminal"><text x="261.25" y="583">4</text></g></g></g> <g><g><g
    class="terminal"><text x="349.75" y="283">$</text></g></g> <g><g class="terminal"><text
    x="349.75" y="253">#</text></g></g> <g><g class="terminal"><text x="349.75" y="223">"</text></g></g>
    <g><g class="terminal"><text x="349.75" y="193">!</text></g></g> <g><g class="terminal"><text
    x="349.75" y="163">9</text></g></g> <g><g class="terminal"><text x="349.75" y="133">8</text></g></g>
    <g><g class="terminal"><text x="349.75" y="103">7</text></g></g> <g><g class="terminal"><text
    x="349.75" y="73">6</text></g></g> <g><g class="terminal"><text x="349.75" y="43">5</text></g></g>
    <g><g class="terminal"><text x="349.75" y="313">%</text></g></g> <g><g class="terminal"><text
    x="349.75" y="343">&</text></g></g> <g><g class="terminal"><text x="349.75" y="373">'</text></g></g>
    <g><g class="terminal"><text x="349.75" y="403">(</text></g></g> <g><g class="terminal"><text
    x="349.75" y="433">)</text></g></g> <g><g class="terminal"><text x="349.75" y="463">*</text></g></g>
    <g><g class="terminal"><text x="349.75" y="493">+</text></g></g> <g><g class="terminal"><text
    x="349.75" y="523">,</text></g></g> <g><g class="terminal"><text x="349.75" y="553">-</text></g></g>
    <g><g class="terminal"><text x="349.75" y="583">.</text></g></g></g> <g><g><g
    class="terminal"><text x="438.25" y="283">[</text></g></g> <g><g class="terminal"><text
    x="438.25" y="253">@</text></g></g> <g><g class="terminal"><text x="438.25" y="223">?</text></g></g>
    <g><g class="terminal"><text x="438.25" y="193">></text></g></g> <g><g class="terminal"><text
    x="438.25" y="163">=</text></g></g> <g><g class="terminal"><text x="438.25" y="133"><</text></g></g>
    <g><g class="terminal"><text x="438.25" y="103">;</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">:</text></g></g> <g><g class="terminal"><text x="438.25" y="43">/</text></g></g>
    <g><g class="terminal"><text x="438.25" y="313">\</text></g></g> <g><g class="terminal"><text
    x="438.25" y="343">]</text></g></g> <g><g class="terminal"><text x="438.25" y="373">^</text></g></g>
    <g><g class="terminal"><text x="438.25" y="403">_</text></g></g> <g><g class="terminal"><text
    x="438.25" y="433">`</text></g></g> <g><g class="terminal"><text x="438.25" y="463">{</text></g></g>
    <g><g class="terminal"><text x="438.25" y="493">|</text></g></g> <g><g class="terminal"><text
    x="438.25" y="523">}</text></g></g> <g><g class="terminal"><text x="438.25" y="553">~</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: We generate `1000` values, and evaluate the `process_vehicle()` with each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously not working. But why?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: None of the entries will get through unless the fuzzer can produce either `van`
    or `car`. Indeed, the reason is that the grammar itself does not capture the complete
    information about the format. So here is another idea. We modify the `GrammarFuzzer`
    to know a bit about our format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let us try again!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'At least we are getting somewhere! It would be really nice if *we could incorporate
    what we know about the sample data in our fuzzer.* In fact, it would be nice if
    we could *extract* the template and valid values from samples, and use them in
    our fuzzing. How do we do that? The quick answer to this question is: Use a *parser*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generally speaking, a *parser* is the part of a program that processes (structured)
    input. The parsers we discuss in this chapter transform an input string into a
    *derivation tree* (discussed in the [chapter on efficient grammar fuzzing](GrammarFuzzer.html)).
    From a user''s perspective, all it takes to parse an input is two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the parser with a grammar, as in
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the parser to retrieve a list of derivation trees:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once we have parsed a tree, we can use it just as the derivation trees produced
    from grammar fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: We discuss a number of such parsers, in particular
  prefs: []
  type: TYPE_NORMAL
- en: '[parsing expression grammar parsers](#Parsing-Expression-Grammars) (`PEGParser`),
    which are very efficient, but limited to specific grammar structure; and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Earley parsers](#Parsing-Context-Free-Grammars) (`EarleyParser`), which accept
    any kind of context-free grammars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you just want to *use* parsers (say, because your main focus is testing),
    you can just stop here and move on [to the next chapter](LangFuzzer.html), where
    we learn how to make use of parsed inputs to mutate and recombine them. If you
    want to *understand* how parsers work, though, this chapter is right for you.
  prefs: []
  type: TYPE_NORMAL
- en: An Ad Hoc Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in the previous section, programmers often have to extract parts of
    data that obey certain rules. For example, for *CSV* files, each element in a
    row is separated by *commas*, and multiple raws are used to store the data.
  prefs: []
  type: TYPE_NORMAL
- en: To extract the information, we write an ad hoc parser `simple_parse_csv()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We also change the default orientation of the graph to *left to right* rather
    than *top to bottom* for easier viewing using `lr_graph()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `display_tree()` shows the structure of our CSV file after parsing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="212pt" height="246pt" viewBox="0.00 0.00 212.00 246.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 242.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-112.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="98.25"
    y="-160.95" font-family="Times,serif" font-size="14.00">record 0</text></g> <g
    id="edge1" class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-64.95" font-family="Times,serif" font-size="14.00">record
    1</text></g> <g id="edge6" class="edge"><title>0->6</title></g> <g id="node3"
    class="node"><title>2</title> <text text-anchor="middle" x="180.38" y="-224.95"
    font-family="Times,serif" font-size="14.00">1997</text></g> <g id="edge2" class="edge"><title>1->2</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="180.38"
    y="-192.95" font-family="Times,serif" font-size="14.00">van</text></g> <g id="edge3"
    class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="180.38" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="180.38" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="180.38" y="-96.95" font-family="Times,serif" font-size="14.00">2000</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="180.38" y="-64.95" font-family="Times,serif" font-size="14.00">car</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="180.38" y="-32.95" font-family="Times,serif" font-size="14.00">Mercury</text></g>
    <g id="edge9" class="edge"><title>6->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="180.38" y="-0.95" font-family="Times,serif" font-size="14.00">Cougar</text></g>
    <g id="edge10" class="edge"><title>6->10</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: This is of course simple. What if we encounter slightly more complexity? Again,
    another example from the Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We define a new annotation method `highlight_node()` to mark the nodes that
    are interesting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Using `highlight_node()` we can highlight particular nodes that we were wrongly
    parsed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="209pt" height="214pt" viewBox="0.00 0.00 209.00 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-96.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-96.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="178.88" y="-192.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="178.88" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="178.88" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="178.88" y="-96.95" font-family="Times,serif" font-size="14.00"
    fill="red">"ac</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g
    id="node7" class="node"><title>6</title> <text text-anchor="middle" x="178.88"
    y="-64.95" font-family="Times,serif" font-size="14.00" fill="red">abs</text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="178.88" y="-32.95" font-family="Times,serif" font-size="14.00"
    fill="red">moon"</text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="178.88"
    y="-0.95" font-family="Times,serif" font-size="14.00">3000.00</text></g> <g id="edge8"
    class="edge"><title>1->8</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: The marked nodes indicate where our parsing went wrong. We can of course extend
    our parser to understand quotes. First we define some of the helper functions
    `parse_quote()`, `find_comma()` and `comma_split()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can update our `parse_csv()` procedure to use our advanced quote parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Our new `parse_csv()` can now handle quotes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="253pt" height="150pt" viewBox="0.00 0.00 253.25 150.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 146.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-64.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-64.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="201" y="-128.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="201" y="-96.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="201" y="-64.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="201" y="-32.95" font-family="Times,serif" font-size="14.00">"ac,
    abs, moon"</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7"
    class="node"><title>6</title> <text text-anchor="middle" x="201" y="-0.95" font-family="Times,serif"
    font-size="14.00">3000.00</text></g> <g id="edge6" class="edge"><title>1->6</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'That of course does not survive long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: A few embedded quotes are sufficient to confuse our parser again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="321pt" height="168pt" viewBox="0.00 0.00 320.75 168.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 164.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-66.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-66.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="234.75" y="-146.95" font-family="Times,serif" font-size="14.00">1999</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="234.75" y="-114.95" font-family="Times,serif" font-size="14.00">Chevy</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-82.95" font-family="Times,serif" font-size="14.00"
    fill="red">"Venture \"Extended Edition</text></g> <g id="edge4" class="edge"><title>1->4</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="middle" x="234.75"
    y="-50.95" font-family="Times,serif" font-size="14.00" fill="red">Very Large\""</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="234.75" y="-0.95" font-family="Times,serif" font-size="14.00">5000.00</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another record from that CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="259pt" height="214pt" viewBox="0.00 0.00 258.50 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-48.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-128.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-48.95" font-family="Times,serif" font-size="14.00"
    fill="red">record 1</text></g> <g id="edge6" class="edge"><title>0->6</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="98.25"
    y="-16.95" font-family="Times,serif" font-size="14.00" fill="red">record 2</text></g>
    <g id="edge10" class="edge"><title>0->10</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="203.62" y="-192.95" font-family="Times,serif" font-size="14.00">1996</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="203.62" y="-160.95" font-family="Times,serif" font-size="14.00">Jeep</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="203.62" y="-128.95" font-family="Times,serif" font-size="14.00">Grand
    Cherokee</text></g> <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6"
    class="node"><title>5</title> <text text-anchor="middle" x="203.62" y="-96.95"
    font-family="Times,serif" font-size="14.00" fill="red">"MUST SELL!</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="203.62" y="-64.95" font-family="Times,serif" font-size="14.00"
    fill="red">air</text></g> <g id="edge7" class="edge"><title>6->7</title></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="203.62"
    y="-32.95" font-family="Times,serif" font-size="14.00" fill="red">moon roof</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="203.62" y="-0.95" font-family="Times,serif" font-size="14.00"
    fill="red">loaded",4799.00</text></g> <g id="edge9" class="edge"><title>6->9</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Fixing this would require modifying both inner `parse_quote()` and the outer
    `parse_csv()` procedures. We note that each of these features actually documented
    in the CSV [RFC 4180](https://tools.ietf.org/html/rfc4180)
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, each additional improvement falls apart even with a little extra complexity.
    The problem becomes severe when one encounters recursive expressions. For example,
    JSON is a common alternative to CSV files for saving data. Similarly, one may
    have to parse data from an HTML table instead of a CSV file if one is getting
    the data from the web.
  prefs: []
  type: TYPE_NORMAL
- en: One might be tempted to fix it with a little more ad hoc parsing, with a bit
    of *regular expressions* thrown in. However, that is the [path to insanity](https://stackoverflow.com/a/1732454).
  prefs: []
  type: TYPE_NORMAL
- en: It is here that *formal parsers* shine. The main idea is that, any given set
    of strings belong to a language, and these languages can be specified by their
    grammars (as we saw in the [chapter on grammars](Grammars.html)). The great thing
    about grammars is that they can be *composed*. That is, one can introduce finer
    and finer details into an internal structure without affecting the external structure,
    and similarly, one can change the external structure without much impact on the
    internal structure.
  prefs: []
  type: TYPE_NORMAL
- en: Grammars in Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly describe grammars in the context of parsing.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Grammars-and-Derivation-Trees"><summary>Grammars and
    Derivation Trees</summary>
  prefs: []
  type: TYPE_NORMAL
- en: A grammar, as you have read from the [chapter on grammars](Grammars.html) is
    a set of *rules* that explain how the start symbol can be expanded. Each rule
    has a name, also called a *nonterminal*, and a set of *alternative choices* in
    how the nonterminal can be expanded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 296.5 122" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g>
    <g class="terminal"><text x="148.25" y="35">+</text></g> <g class="non-terminal"><text
    x="209.5" y="35">expr</text></g></g> <g><g class="non-terminal"><text x="87.0"
    y="65">expr</text></g> <g class="terminal"><text x="148.25" y="65">-</text></g>
    <g class="non-terminal"><text x="209.5" y="65">expr</text></g></g> <g><g class="non-terminal"><text
    x="148.25" y="95">integer</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above expression, the rule `<expr> : [<expr>+<expr>,<expr>-<expr>,<integer>]`
    corresponds to how the nonterminal `<expr>` might be expanded. The expression
    `<expr>+<expr>` corresponds to one of the alternative choices. We call this an
    *alternative* expansion for the nonterminal `<expr>`. Finally, in an expression
    `<expr>+<expr>`, each of `<expr>`, `+`, and `<expr>` are *symbols* in that expansion.
    A symbol could be either a nonterminal or a terminal symbol based on whether its
    expansion is available in the grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a string that represents an arithmetic expression that we would like
    to parse, which is specified by the grammar above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The *derivation tree* for our expression from this grammar is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="174pt" height="274pt" viewBox="0.00 0.00 174.00 273.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 269.5)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="83" y="-252.2"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="83" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="27" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="139"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="139" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge10" class="edge"><title>9->10</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: While a grammar can be used to specify a given language, there could be multiple
    grammars that correspond to the same language. For example, here is another grammar
    to describe the same addition expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 282.0 62" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g>
    <g class="non-terminal"><text x="190.75" y="35">expr_</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 222.5 122" width="222.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">+</text></g>
    <g class="non-terminal"><text x="135.5" y="35">expr</text></g></g> <g><g class="terminal"><text
    x="74.25" y="65">-</text></g> <g class="non-terminal"><text x="135.5" y="65">expr</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 290.5 62" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="186.5" y="35">integer_</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 199.5 92" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'The corresponding derivation tree is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="278pt" height="324pt" viewBox="0.00 0.00 278.25 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="122.62"
    y="-302.45" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="122.62"
    y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="88.62" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="157.62" y="-201.95" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="20.62" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="89.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge5" class="edge"><title>2->5</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="20.62" y="-101.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="156.62" y="-151.7"
    font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="212.62"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge8"
    class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="177.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="246.62" y="-101.45" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge13" class="edge"><title>8->13</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="142.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="211.62" y="-51.2" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge12" class="edge"><title>9->12</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="142.62" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, there could be different classes of grammars that describe the same
    language. For example, the first grammar `A1_GRAMMAR` is a grammar that sports
    both *right* and *left* recursion, while the second grammar `A2_GRAMMAR` does
    not have left recursion in the nonterminals in any of its productions, but contains
    *epsilon* productions. (An epsilon production is a production that has empty string
    in its right-hand side.)</details> <details id="Excursion:-Recursion"><summary>Recursion</summary>
  prefs: []
  type: TYPE_NORMAL
- en: You would have noticed that we reuse the term `<expr>` in its own definition.
    Using the same nonterminal in its own definition is called *recursion*. There
    are two specific kinds of recursion one should be aware of in parsing, as we see
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A grammar is *left recursive* if any of its nonterminals are left recursive,
    and a nonterminal is *directly left-recursive* if the left-most symbol of any
    of its productions is itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="terminal"><text x="122.75" y="35">a</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="130pt" height="173pt" viewBox="0.00 0.00 130.25 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="82.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="59.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="106.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge6"
    class="edge"><title>0->6</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="36.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="83.12" y="-51.2" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="13.12" y="-0.95" font-family="Times,serif"
    font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>2->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="60.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>2->4</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: A grammar is indirectly left-recursive if any of the left-most symbols can be
    expanded using their definitions to produce the nonterminal as the left-most symbol
    of the expansion. The left recursion is called a *hidden-left-recursion* if during
    the series of expansions of a nonterminal, one reaches a rule where the rule contains
    the same nonterminal after a prefix of other symbols, and these symbols can derive
    the empty string. For example, in `A1_GRAMMAR`, `<integer>` will be considered
    hidden-left recursive if `<digit>` could derive an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Right recursive grammars are defined similarly. Below is the derivation tree
    for the right recursive grammar that represents the same language as that of `LR_GRAMMAR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="130pt" height="223pt" viewBox="0.00 0.00 130.25 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="39.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="39.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="16.12" y="-101.45" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="63.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="39.12"
    y="-51.2" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="86.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge5" class="edge"><title>3->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="62.12" y="-0.95" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="109.12" y="-0.95"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge7" class="edge"><title>5->7</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To complicate matters further, there could be multiple derivation trees – also
    called *parses* – corresponding to the same string from the same grammar. For
    example, a string `1+2+3` can be parsed in two ways as we see below using the
    `A1_GRAMMAR`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="145" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="145" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="87" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="145" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge12" class="edge"><title>1->12</title></g> <g id="node14"
    class="node"><title>13</title> <text text-anchor="middle" x="202" y="-201.95"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge13" class="edge"><title>1->13</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge3"
    class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>2->8</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="138" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="138"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="138" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge14" class="edge"><title>13->14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="204"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="89" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="89" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="31" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="89" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="146" y="-201.95" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="92" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="148"
    y="-151.7" font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge12"
    class="edge"><title>7->12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge13" class="edge"><title>7->13</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="93" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="93" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="93" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-101.45"
    font-family="Times,serif" font-size="14.00"><integer></text></g> <g id="edge14"
    class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to resolve ambiguities. One approach taken by *Parsing Expression
    Grammars* explained in the next section is to specify a particular order of resolution,
    and choose the first one. Another approach is to simply return all possible derivation
    trees, which is the approach taken by *Earley parser* we develop later.</details>
  prefs: []
  type: TYPE_NORMAL
- en: A Parser Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we develop different parsers. To do that, we define a minimal interface
    for parsing that is obeyed by all parsers. There are two approaches to parsing
    a string using a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional approach is to use a *lexer* (also called a *tokenizer* or a
    *scanner*) to first tokenize the incoming string, and feed the grammar one token
    at a time. The lexer is typically a smaller parser that accepts a *regular language*.
    The advantage of this approach is that the grammar used by the parser can eschew
    the details of tokenization. Further, one gets a shallow derivation tree at the
    end of the parsing which can be directly used for generating the *Abstract Syntax
    Tree*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second approach is to use a tree pruner after the complete parse. With this
    approach, one uses a grammar that incorporates complete details of the syntax.
    Next, the nodes corresponding to tokens are pruned and replaced with their corresponding
    strings as leaf nodes. The utility of this approach is that the parser is more
    powerful, and further there is no artificial distinction between *lexing* and
    *parsing*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we use the second approach. This approach is implemented in
    the `prune_tree` method.
  prefs: []
  type: TYPE_NORMAL
- en: The *Parser* class we define below provides the minimal interface. The main
    methods that need to be implemented by the classes implementing this interface
    are `parse_prefix` and `parse`. The `parse_prefix` returns a tuple, which contains
    the index until which parsing was completed successfully, and the parse forest
    until that index. The method `parse` returns a list of derivation trees if the
    parse was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: <details id="Excursion:-Canonical-Grammars"><summary>Canonical Grammars</summary>
  prefs: []
  type: TYPE_NORMAL
- en: The `EXPR_GRAMMAR` we import from the [chapter on grammars](Grammars.html) is
    oriented towards generation. In particular, the production rules are stored as
    strings. We need to massage this representation a little to conform to a *canonical
    representation* where each token in a rule is represented separately. The `canonical`
    format uses separate tokens to represent each symbol in an expansion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: We also provide a convenience method for easier display of canonical grammars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: We provide a way to revert a canonical expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: It is easier to work with the `canonical` representation during parsing. Hence,
    we update our parser class to store the `canonical` representation also.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: We update the `prune_tree()` to account for the phony start symbol if it was
    insserted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Expression Grammars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *[Parsing Expression Grammar](http://bford.info/pub/lang/peg)* (*PEG*) [[Ford
    *et al*, 2004](https://doi.org/10.1145/982962.964011)] is a type of *recognition
    based formal grammar* that specifies the sequence of steps to take to parse a
    given string. A *parsing expression grammar* is very similar to a *context-free
    grammar* (*CFG*) such as the ones we saw in the [chapter on grammars](Grammars.html).
    As in a CFG, a parsing expression grammar is represented by a set of nonterminals
    and corresponding alternatives representing how to match each. For example, here
    is a PEG that matches `a` or `b`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: However, unlike the *CFG*, the alternatives represent *ordered choice*. That
    is, rather than choosing all rules that can potentially match, we stop at the
    first match that succeed. For example, the below *PEG* can match `ab` but not
    `abc` unlike a *CFG* which will match both. (We call the sequence of ordered choice
    expressions *choice expressions* rather than alternatives to make the distinction
    from *CFG* clear.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Each choice in a *choice expression* represents a rule on how to satisfy that
    particular choice. The choice is a sequence of symbols (terminals and nonterminals)
    that are matched against a given text as in a *CFG*.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the syntax of grammar definitions we have seen so far, a *PEG* can also
    contain a few additional elements. See the exercises at the end of the chapter
    for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: The PEGs model the typical practice in handwritten recursive descent parsers,
    and hence it may be considered more intuitive to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The Packrat Parser for Predicate Expression Grammars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Short of hand rolling a parser, *Packrat* parsing is one of the simplest parsing
    techniques, and is one of the techniques for parsing PEGs. The *Packrat* parser
    is so named because it tries to cache all results from simpler problems in the
    hope that these solutions can be used to avoid re-computation later. We develop
    a minimal *Packrat* parser next.
  prefs: []
  type: TYPE_NORMAL
- en: We derive from the `Parser` base class first, and we accept the text to be parsed
    in the `parse()` method, which in turn calls `unify_key()` with the `start_symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note.** While our PEG parser can produce only a single unambiguous parse
    tree, other parsers can produce multiple parses for ambiguous grammars. Hence,
    we return a list of trees (in this case with a single element).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: <details id="Excursion:-Implementing-PEGParser"><summary>Implementing `PEGParser`</summary>
  prefs: []
  type: TYPE_NORMAL
- en: Unify Key
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `unify_key()` algorithm is simple. If given a terminal symbol, it tries
    to match the symbol with the current position in the text. If the symbol and text
    match, it returns successfully with the new parse index `at`.
  prefs: []
  type: TYPE_NORMAL
- en: If on the other hand, it was given a nonterminal, it retrieves the choice expression
    corresponding to the key, and tries to match each choice *in order* using `unify_rule()`.
    If **any** of the rules succeed in being unified with the given text, the parse
    is considered a success, and we return with the new parse index returned by `unify_rule()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Unify Rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `unify_rule()` method is similar. It retrieves the tokens corresponding
    to the rule that it needs to unify with the text, and calls `unify_key()` on them
    in sequence. If **all** tokens are successfully unified with the text, the parse
    is a success.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The two methods are mutually recursive, and given that `unify_key()` tries each
    alternative until it succeeds, `unify_key` can be called multiple times with the
    same arguments. Hence, it is important to memoize the results of `unify_key`.
    Python provides a simple decorator `lru_cache` for memoizing any function call
    that has hashable arguments. We add that to our implementation so that repeated
    calls to `unify_key()` with the same argument get cached results.
  prefs: []
  type: TYPE_NORMAL
- en: This memoization gives the algorithm its name – *Packrat*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: We wrap initialization and calling of `PEGParser` in a method `parse()` already
    implemented in the `Parser` base class that accepts the text to be parsed along
    with the grammar.</details>
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few examples of our parser in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: One should be aware that while the grammar looks like a *CFG*, the language
    described by a *PEG* may be different. Indeed, only *LL(1)* grammars are guaranteed
    to represent the same language for both PEGs and other parsers. Behavior of PEGs
    for other classes of grammars could be surprising [[Redziejowski *et al*, 2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)].
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Context-Free Grammars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problems with PEG
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While *PEGs* are simple at first sight, their behavior in some cases might
    be a bit unintuitive. For example, here is an example [[Redziejowski *et al*,
    2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: When interpreted as a *CFG* and used as a string generator, it will produce
    strings of the form `aa, aaaa, aaaaaa` that is, it produces strings where the
    number of `a` is $ 2*n $ where $ n > 0 $.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: However, the *PEG* parser can only recognize strings of the form $2^n$
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This is not the only problem with *Parsing Expression Grammars*. While *PEGs*
    are expressive and the *packrat* parser for parsing them is simple and intuitive,
    *PEGs* suffer from a major deficiency for our purposes. *PEGs* are oriented towards
    language recognition, and it is not clear how to translate an arbitrary *PEG*
    to a *CFG*. As we mentioned earlier, a naive re-interpretation of a *PEG* as a
    *CFG* does not work very well. Further, it is not clear what is the exact relation
    between the class of languages represented by *PEG* and the class of languages
    represented by *CFG*. Since our primary focus is *fuzzing* – that is *generation*
    of strings – , we next look at *parsers that can accept context-free grammars*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea of *CFG* parser is the following: Peek at the input text for
    the allowed number of characters, and use these, and our parser state to determine
    which rules can be applied to complete parsing. We next look at a typical *CFG*
    parsing algorithm, the Earley Parser.'
  prefs: []
  type: TYPE_NORMAL
- en: The Earley Parser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Earley parser is a general parser that is able to parse any arbitrary *CFG*.
    It was invented by Jay Earley [[Earley *et al*, 1970](https://doi.org/10.1145/362007.362035)]
    for use in computational linguistics. While its computational complexity is $O(n^3)$
    for parsing strings with arbitrary grammars, it can parse strings with unambiguous
    grammars in $O(n^2)$ time, and all *[LR(k)](https://en.wikipedia.org/wiki/LR_parser)*
    grammars in linear time ($O(n)$ [[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)]).
    Further improvements – notably handling epsilon rules – were invented by Aycock
    et al. [John Aycock *et al*, 2002].
  prefs: []
  type: TYPE_NORMAL
- en: Note that one restriction of our implementation is that the start symbol can
    have only one alternative in its alternative expressions. This is not a restriction
    in practice because any grammar with multiple alternatives for its start symbol
    can be extended with a new start symbol that has the original start symbol as
    its only choice. That is, given a grammar as below,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: one may rewrite it as below to conform to the *single-alternative* rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Let us implement a class `EarleyParser`, again derived from `Parser` which implements
    an Earley parser.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Implementing-EarleyParser"><summary>Implementing `EarleyParser`</summary>
  prefs: []
  type: TYPE_NORMAL
- en: We first implement a simpler parser that is a parser for nearly all *CFGs*,
    but not quite. In particular, our parser does not understand *epsilon rules* –
    rules that derive empty string. We show later how the parser can be extended to
    handle these.
  prefs: []
  type: TYPE_NORMAL
- en: We use the following grammar in our examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 197.0 62" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 245.5 92" width="245.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g> <g class="terminal"><text
    x="171.25" y="35">c</text></g></g> <g><g class="terminal"><text x="98.5" y="65">a</text></g>
    <g class="non-terminal"><text x="147.0" y="65">A</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">b</text></g>
    <g class="non-terminal"><text x="122.75" y="35">C</text></g></g> <g><g class="non-terminal"><text
    x="98.5" y="65">D</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">c</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">d</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea of Earley parsing is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the alternative expressions corresponding to the START_SYMBOL. These
    represent the possible ways to parse the string from a high level. Essentially
    each expression represents a parsing path. Queue each expression in our set of
    possible parses of the string. The parsed index of an expression is the part of
    expression that has already been recognized. In the beginning of parse, the parsed
    index of all expressions is at the beginning. Further, each letter gets a queue
    of expressions that recognizes that letter at that point in our parse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine our queue of possible parses and check if any of them start with a nonterminal.
    If it does, then that nonterminal needs to be recognized from the input before
    the given rule can be parsed. Hence, add the alternative expressions corresponding
    to the nonterminal to the queue. Do this recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we are ready to advance. Examine the current letter in the input,
    and select all expressions that have that particular letter at the parsed index.
    These expressions can now advance one step. Advance these selected expressions
    by incrementing their parsed index and add them to the queue of expressions in
    line for recognizing the next input letter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If while doing these things, we find that any of the expressions have finished
    parsing, we fetch its corresponding nonterminal, and advance all expressions that
    have that nonterminal at their parsed index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue this procedure recursively until all expressions that we have queued
    for the current letter have been processed. Then start processing the queue for
    the next letter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explain each step in detail with examples in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: The parser uses dynamic programming to generate a table containing a *forest
    of possible parses* at each letter index – the table contains as many columns
    as there are letters in the input, and each column contains different parsing
    rules at various stages of the parse.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given an input `adcd`, the Column 0 would contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: which is the starting rule that indicates that we are currently parsing the
    rule `<start>`, and the parsing state is just before identifying the symbol `<A>`.
    It would also contain the following which are two alternative paths it could take
    to complete the parsing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Column 1 would contain the following, which represents the possible completion
    after reading `a`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Column 2 would contain the following after reading `d`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, Column 3 would contain the following after reading `c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Column 4 would contain the following after reading `d`, with the `●`
    at the end of the `<start>` rule indicating that the parse was successful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from above, we are essentially filling a table (a table is also
    called a **chart**) of entries based on each letter we read, and the grammar rules
    that can be applied. This chart gives the parser its other name -- Chart parsing.
  prefs: []
  type: TYPE_NORMAL
- en: Columns
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We define the `Column` first. The `Column` is initialized by its own `index`
    in the input string, and the `letter` at that index. Internally, we also keep
    track of the states that are added to the column as the parsing progresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: The `Column` only stores unique `states`. Hence, when a new `state` is `added`
    to our `Column`, we check whether it is already known.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Items
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An item represents a *parse in progress for a specific rule.* Hence the item
    contains the name of the nonterminal, and the corresponding alternative expression
    (`expr`) which together form the rule, and the current position of parsing in
    this expression -- `dot`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note.** If you are familiar with [LR parsing](https://en.wikipedia.org/wiki/LR_parser),
    you will notice that an item is simply an `LR0` item.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: We also provide a few convenience methods. The method `finished()` checks if
    the `dot` has moved beyond the last element in `expr`. The method `advance()`
    produces a new `Item` with the `dot` advanced one token, and represents an advance
    of the parsing. The method `at_dot()` returns the current symbol being parsed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Here is how an item could be used. We first define our item
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: To determine where the status of parsing, we use `at_dot()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: That is, the next symbol to be parsed is `<D>`
  prefs: []
  type: TYPE_NORMAL
- en: If we advance the item, we get another item that represents the finished parsing
    rule `<B>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: States
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For `Earley` parsing, the state of the parsing is simply one `Item` along with
    some meta information such as the starting `s_col` and ending column `e_col` for
    each state. Hence we inherit from `Item` to create a `State`. Since we are interested
    in comparing states, we define `hash()` and `eq()` with the corresponding methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of `State` is similar to that of `Item`. The only difference is that
    it is used along with the `Column` to track the parsing state. For example, we
    initialize the first column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The first column is then updated by using `add()` method of `Column`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: The Parsing Algorithm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Earley* algorithm starts by initializing the chart with columns (as many
    as there are letters in the input). We also seed the first column with a state
    representing the expression corresponding to the start symbol. In our case, the
    state corresponds to the start symbol with the `dot` at `0` is represented as
    below. The `●` symbol represents the parsing status. In this case, we have not
    parsed anything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: We pass this partial chart to a method for filling the rest of the parse chart.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to parse, we seed the chart with the state representing the
    ongoing parse of the start symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: The main parsing loop in `fill_chart()` has three fundamental operations. `predict()`,
    `scan()`, and `complete()`. We discuss `predict` next.
  prefs: []
  type: TYPE_NORMAL
- en: Predicting States
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We have already seeded `chart[0]` with a state `[<A>,<B>]` with `dot` at `0`.
    Next, given that `<A>` is a nonterminal, we `predict` the possible parse continuations
    of this state. That is, it could be either `a <B> c` or `A <A>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea of `predict()` is as follows: Say you have a state with name
    `<A>` from the above grammar, and expression containing `[a,<B>,c]`. Imagine that
    you have seen `a` already, which means that the `dot` will be on `<B>`. Below,
    is a representation of our parse status. The left-hand side of ● represents the
    portion already parsed (`a`), and the right-hand side represents the portion yet
    to be parsed (`<B> c`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: To recognize `<B>`, we look at the definition of `<B>`, which has different
    alternative expressions. The `predict()` step adds each of these alternatives
    to the set of states, with `dot` at `0`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: In essence, the `predict()` method, when called with the current nonterminal,
    fetches the alternative expressions corresponding to this nonterminal, and adds
    these as predicted *child* states to the *current* column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: To see how to use `predict`, we first construct the 0th column as before, and
    we assign the constructed column to an instance of the EarleyParser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: It should contain a single state -- `<start> at 0`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: We apply `predict()` to fill out the 0th column, and the column should contain
    the possible parse paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Scanning Tokens
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if rather than a nonterminal, the state contained a terminal symbol such
    as a letter? In that case, we are ready to make some progress. For example, consider
    the second state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: We `scan` the next column's letter. Say the next token is `b`. If the letter
    matches what we have, then create a new state by advancing the current state by
    one letter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: This new state is added to the next column (i.e the column that has the matched
    letter).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: As before, we construct the partial parse first, this time adding a new column
    so that we can observe the effects of `scan()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Completing Processing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we advance, what if we actually `complete()` the processing of the current
    rule? If so, we want to update not just this state, but also all the *parent*
    states from which this state was derived. For example, say we have states as below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The state `<B>: b c ●` is now complete. So, we need to advance `<A>: a ● <B>
    c` one step forward.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we determine the parent states? Note from `predict` that we added the
    predicted child states to the *same* column as that of the inspected state. Hence,
    we look at the starting column of the current state, with the same symbol `at_dot`
    as that of the name of the completed state.
  prefs: []
  type: TYPE_NORMAL
- en: For each such parent found, we advance that parent (because we have just finished
    parsing that nonterminal for their `at_dot`) and add the new states to the current
    column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Here is an example of completed processing. First we complete the Column 0
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Then we use `scan()` to populate Column 1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: Then we use `scan()` again to populate Column 2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use `complete()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Filling the Chart
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main driving loop in `fill_chart()` essentially calls these operations in
    order. We loop over each column in order.
  prefs: []
  type: TYPE_NORMAL
- en: For each column, fetch one state in the column at a time, and check if the state
    is `finished`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is, then we `complete()` all the parent states depending on this state.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the state was not finished, we check to see if the state's current symbol
    `at_dot` is a nonterminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is a nonterminal, we `predict()` possible continuations, and update the
    current column with these states.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it was not, we `scan()` the next column and advance the current state if
    it matches the next letter.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: We now can recognize a given string as belonging to a language represented by
    a grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The chart we printed above only shows completed entries at each index. The parenthesized
    expression indicates the column just before the first character was recognized,
    and the ending column.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the `<start>` nonterminal shows fully parsed status.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Since `chart_parse()` returns the completed table, we now need to extract the
    derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: The Parse Method
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For determining how far we have managed to parse, we simply look for the last
    index from `chart_parse()` where the `start_symbol` was found.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `parse_prefix()` in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The following is adapted from the excellent reference on Earley parsing by [Loup
    Vaillant](http://loup-vaillant.fr/tutorials/earley-parsing/).
  prefs: []
  type: TYPE_NORMAL
- en: Our `parse()` method is as follows. It depends on two methods `parse_forest()`
    and `extract_trees()` that will be defined next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Paths
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `parse_paths()` method tries to unify the given expression in `named_expr`
    with the parsed string. For that, it extracts the last symbol in `named_expr`
    and checks if it is a terminal symbol. If it is, then it checks the chart at `til`
    to see if the letter corresponding to the position matches the terminal symbol.
    If it does, extend our start index by the length of the symbol.
  prefs: []
  type: TYPE_NORMAL
- en: If the symbol was a nonterminal symbol, then we retrieve the parsed states at
    the current end column index (`til`) that correspond to the nonterminal symbol,
    and collect the start index. These are the end column indexes for the remaining
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Given our list of start indexes, we obtain the parse paths from the remaining
    expression. If we can obtain any, then we return the parse paths. If not, we return
    an empty list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `parse_paths()` in action
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the parse path for `<start>` given the input `adcd` included recognizing
    the expression `<A><B>`. This was recognized by the two states: `<A>` from input(0)
    to input(2) which further involved recognizing the rule `a<B>c`, and the next
    state `<B>` from input(3) which involved recognizing the rule `<D>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing Forests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `parse_forest()` method takes the state which represents the completed parse,
    and determines the possible ways that its expressions corresponded to the parsed
    expression. For example, say we are parsing `1+2+3`, and the state has `[<expr>,+,<expr>]`
    in `expr`. It could have been parsed as either `[{<expr>:1+2},+,{<expr>:3}]` or
    `[{<expr>:1},+,{<expr>:2+3}]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What we have from `parse_forest()` is a forest of trees. We need to extract
    a single tree from that forest. That is accomplished as follows.
  prefs: []
  type: TYPE_NORMAL
- en: (For now, we return the first available derivation tree. To do that, we need
    to extract the parse forest from the state corresponding to `start`.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: We now verify that our parser can parse a given expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">bexpr</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="80" viewBox="0 0 1837.5 80" width="1837.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="non-terminal"><text x="101.25"
    y="44">aexpr</text></g> <g class="non-terminal"><text x="171.0" y="44">gt</text></g>
    <g class="non-terminal"><text x="240.75" y="44">aexpr</text></g></g></g> <g><g><g
    class="non-terminal"><text x="363.25" y="44">aexpr</text></g> <g class="non-terminal"><text
    x="433.0" y="44">lt</text></g> <g class="non-terminal"><text x="502.75" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="625.25" y="44">aexpr</text></g> <g class="terminal"><text
    x="690.75" y="44">=</text></g> <g class="non-terminal"><text x="756.25" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="878.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="944.25" y="44">=</text></g> <g class="non-terminal"><text x="1009.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1132.25" y="44">bexpr</text></g> <g class="terminal"><text
    x="1197.75" y="44">&</text></g> <g class="non-terminal"><text x="1263.25" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1385.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="1451.25" y="44">|</text></g> <g class="non-terminal"><text x="1516.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="terminal"><text x="1622.25" y="44">(</text></g> <g class="non-terminal"><text
    x="1687.75" y="44">bexrp</text></g> <g class="terminal"><text x="1753.25" y="44">)</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="152" viewBox="0 0 313.5 152" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="65">aexpr</text></g>
    <g class="terminal"><text x="156.75" y="65">-</text></g> <g class="non-terminal"><text
    x="222.25" y="65">aexpr</text></g></g> <g><g class="non-terminal"><text x="91.25"
    y="35">aexpr</text></g> <g class="terminal"><text x="156.75" y="35">+</text></g>
    <g class="non-terminal"><text x="222.25" y="35">aexpr</text></g></g> <g><g class="terminal"><text
    x="91.25" y="95">(</text></g> <g class="non-terminal"><text x="156.75" y="95">aexpr</text></g>
    <g class="terminal"><text x="222.25" y="95">)</text></g></g> <g><g class="non-terminal"><text
    x="156.75" y="125">integer</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: We now have a complete parser that can parse almost arbitrary *CFG*. There remains
    a small corner to fix -- the case of epsilon rules as we will see later.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguous Parsing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ambiguous grammars are grammars that can produce multiple derivation trees for
    some given string. For example, the `A3_GRAMMAR` can parse `1+2+3` in two different
    ways – `[1+2]+3` and `1+[2+3]`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a single tree might be reasonable for unambiguous parses. However,
    what if the given grammar produces ambiguity when given a string? We need to extract
    all derivation trees in that case. We enhance our `extract_trees()` method to
    extract multiple derivation trees.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: As before, we verify that everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: One can also use a `GrammarFuzzer` to verify that everything works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: The Aycock Epsilon Fix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While parsing, one often requires to know whether a given nonterminal can derive
    an empty string. For example, in the following grammar A can derive an empty string,
    while B can't. The nonterminals that can derive an empty string are called *nullable*
    nonterminals. For example, in the below grammar `E_GRAMMAR_1`, `<A>` is *nullable*,
    and since `<A>` is one of the alternatives of `<start>`, `<start>` is also *nullable*.
    But `<B>` is not *nullable*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: One of the problems with the original Earley implementation is that it does
    not handle rules that can derive empty strings very well. For example, the given
    grammar should match `a`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">S</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 294.0 62" width="294.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g> <g class="non-terminal"><text
    x="171.25" y="35">A</text></g> <g class="non-terminal"><text x="219.75" y="35">A</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 148.5 92" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g></g>
    <g><g class="non-terminal"><text x="74.25" y="65">E</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Aycock et al.[John Aycock *et al*, 2002] suggests a simple fix. Their idea is
    to pre-compute the `nullable` set and use it to advance the `nullable` states.
    However, before we do that, we need to compute the `nullable` set. The `nullable`
    set consists of all nonterminals that can derive an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the `nullable` set requires expanding each production rule in the
    grammar iteratively and inspecting whether a given rule can derive the empty string.
    Each iteration needs to take into account new terminals that have been found to
    be `nullable`. The procedure stops when we obtain a stable result. This procedure
    can be abstracted into a more general method `fixpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: Fixpoint
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A `fixpoint` of a function is an element in the function's domain such that
    it is mapped to itself. For example, 1 is a `fixpoint` of square root because
    `squareroot(1) == 1`.
  prefs: []
  type: TYPE_NORMAL
- en: (We use `str` rather than `hash` to check for equality in `fixpoint` because
    the data structure `set`, which we would like to use as an argument has a good
    string representation but is not hashable).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Remember `my_sqrt()` from [the first chapter](Intro_Testing.html)? We can define
    `my_sqrt()` using fixpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Nullable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Similarly, we can define `nullable` using `fixpoint`. We essentially provide
    the definition of a single intermediate step. That is, assuming that `nullables`
    contain the current `nullable` nonterminals, we iterate over the grammar looking
    for productions which are `nullable` -- that is, productions where the entire
    sequence can yield an empty string on some expansion.
  prefs: []
  type: TYPE_NORMAL
- en: We need to iterate over the different alternative expressions and their corresponding
    nonterminals. Hence we define a `rules()` method converts our dictionary representation
    to this pair format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The `terminals()` method extracts all terminal symbols from a `canonical` grammar
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: So, once we have the `nullable` set, all that we need to do is, after we have
    called `predict` on a state corresponding to a nonterminal, check if it is `nullable`
    and if it is, advance and add the state to the current column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that our parser does parse all kinds of grammars, let us try two more
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Why do we get recursion error here? The reason is that, our implementation of
    `extract_trees()` is eager. That is, it attempts to extract *all* inner parse
    trees before it can construct the outer parse tree. When there is a self reference,
    this results in recursion. Here is a simple extractor that avoids this problem.
    The idea here is that we randomly and lazily choose a node to expand, which avoids
    the infinite recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Tree Extractor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you saw above, one of the problems with attempting to extract all trees is
    that the parse forest can consist of an infinite number of trees. So, here, we
    solve that problem by extracting one tree at a time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Using it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'On the indirect reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `SimpleExtractor` gives no guarantee of the uniqueness of the
    returned trees. This can however be fixed by keeping track of the particular nodes
    that were expanded from `pos_tree` variable, and hence, avoiding exploration of
    the same paths.
  prefs: []
  type: TYPE_NORMAL
- en: For implementing this, we extract the random stream passing into the `SimpleExtractor`,
    and use it to control which nodes are explored. Different exploration paths can
    then form a tree of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We start with the node definition for a single choice. The `self._chosen` is
    the current choice made, `self.next` holds the next choice done using `self._chosen`.
    The `self.total` holds the total number of choices that one can have in this node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Now we come to the enhanced `EnhancedExtractor()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: First we define `choose_path()` that given an array and a choice node, returns
    the element in array corresponding to the next choice node if it exists, or produces
    a new choice nodes, and returns that element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: We define `extract_a_node()` here. While extracting, we have a choice. Should
    we allow infinite forests, or should we have a finite number of trees with no
    direct recursion? A direct recursion is when there exists a parent node with the
    same nonterminal that parsed the same span. We choose here not to extract such
    trees. They can be added back after parsing.
  prefs: []
  type: TYPE_NORMAL
- en: This is a recursive procedure that inspects a node, extracts the path required
    to complete that node. A single path (corresponding to a nonterminal) may again
    be composed of a sequence of smaller paths. Such paths are again extracted using
    another call to `extract_a_node()` recursively.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we hit on one of the node recursions we want to avoid? In
    that case, we return the current choice node, which bubbles up to `extract_a_tree()`.
    That procedure increments the last choice, which in turn increments up the parents
    until we reach a choice node that still has options to explore.
  prefs: []
  type: TYPE_NORMAL
- en: What if we hit the end of choices for a particular choice node(i.e, we have
    exhausted paths that can be taken from a node)? In this case also, we return the
    current choice node, which bubbles up to `extract_a_tree()`. That procedure increments
    the last choice, which bubbles up to the next choice that has some unexplored
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: The `extract_a_tree()` is a depth first extractor of a single tree. It tries
    to extract a tree, and if the extraction returns `None`, it means that a particular
    choice was exhausted, or we hit on a recursion. In that case, we increment the
    choice, and explore a new path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `EnhancedExtractor` only extracts nodes that are not directly
    recursive. That is, if it finds a node with a nonterminal that covers the same
    span as that of a parent node with the same nonterminal, it skips the node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: More Earley Parsing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A number of other optimizations exist for Earley parsers. A fast industrial
    strength Earley parser implementation is the [Marpa parser](https://jeffreykegler.github.io/Marpa-web-site/).
    Further, Earley parsing need not be restricted to character data. One may also
    parse streams (audio and video streams) [Qi *et al*, 2018] using a generalized
    Earley parser.</details>
  prefs: []
  type: TYPE_NORMAL
- en: Here are a few examples of the Earley parser in action.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the `PEGParser`, above, the `EarleyParser` can handle arbitrary
    context-free grammars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excursion: Testing the Parsers'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While we have defined two parser variants, it would be nice to have some confirmation
    that our parses work well. While it is possible to formally prove that they work,
    it is much more satisfying to generate random grammars, their corresponding strings,
    and parse them using the same grammar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">symbols</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">symbol</text></g>
    <g class="non-terminal"><text x="190.75" y="35">symbols</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">symbol</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 242.0 92" width="242.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="121.0" y="35">nonterminals</text></g></g>
    <g><g class="non-terminal"><text x="121.0" y="65">terminals</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 296.5 62" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="78.5" y="35">lt</text></g>
    <g class="non-terminal"><text x="148.25" y="35">alpha</text></g> <g class="non-terminal"><text
    x="218.0" y="35">gt</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">A</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">B</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">C</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">1</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">2</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">3</text></g></g></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Now we verify if our arbitrary grammars can be used by the Earley parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have completed both implementation and testing of *arbitrary*
    CFG, which can now be used along with `LangFuzzer` to generate better fuzzing
    inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numerous parsing techniques exist that can parse a given string using a given
    grammar, and produce corresponding derivation tree or trees. However, some of
    these techniques work only on specific classes of grammars. These classes of grammars
    are named after the specific kind of parser that can accept grammars of that category.
    That is, the upper bound for the capabilities of the parser defines the grammar
    class named after that parser.
  prefs: []
  type: TYPE_NORMAL
- en: The *LL* and *LR* parsing are the main traditions in parsing. Here, *LL* means
    left-to-right, leftmost derivation, and it represents a top-down approach. On
    the other hand, and LR (left-to-right, rightmost derivation) represents a bottom-up
    approach. Another way to look at it is that LL parsers compute the derivation
    tree incrementally in *pre-order* while LR parsers compute the derivation tree
    in *post-order* [Pingali *et al*, 2015]).
  prefs: []
  type: TYPE_NORMAL
- en: Different classes of grammars differ in the features that are available to the
    user for writing a grammar of that class. That is, the corresponding kind of parser
    will be unable to parse a grammar that makes use of more features than allowed.
    For example, the `A2_GRAMMAR` is an *LL* grammar because it lacks left recursion,
    while `A1_GRAMMAR` is not an *LL* grammar. This is because an *LL* parser parses
    its input from left to right, and constructs the leftmost derivation of its input
    by expanding the nonterminals it encounters. If there is a left recursion in one
    of these rules, an *LL* parser will enter an infinite loop.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a grammar is LL(k) if it can be parsed by an LL parser with k lookahead
    token, and LR(k) grammar can only be parsed with LR parser with at least k lookahead
    tokens. These grammars are interesting because both LL(k) and LR(k) grammars have
    $O(n)$ parsers, and can be used with relatively restricted computational budget
    compared to other grammars.
  prefs: []
  type: TYPE_NORMAL
- en: The languages for which one can provide an *LL(k)* grammar is called *LL(k)*
    languages (where k is the minimum lookahead required). Similarly, *LR(k)* is defined
    as the set of languages that have an *LR(k)* grammar. In terms of languages, LL(k)
    $\subset$ LL(k+1) and LL(k) $\subset$ LR(k), and *LR(k)* $=$ *LR(1)*. All deterministic
    *CFLs* have an *LR(1)* grammar. However, there exist *CFLs* that are inherently
    ambiguous [Ogden *et al*, 1968], and for these, one can't provide an *LR(1)* grammar.
  prefs: []
  type: TYPE_NORMAL
- en: The other main parsing algorithms for *CFGs* are GLL [Scott *et al*, 2010],
    GLR [Tomita *et al*, 1987, Tomita *et al*, 2012], and CYK [Grune *et al*, 2008].
    The ALL(*) (used by ANTLR) on the other hand is a grammar representation that
    uses *Regular Expression* like predicates (similar to advanced PEGs – see [Exercise](#Exercise-3:-PEG-Predicates))
    rather than a fixed lookahead. Hence, ALL(*) can accept a larger class of grammars
    than CFGs.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of computational limits of parsing, the main CFG parsers have a complexity
    of $O(n^3)$ for arbitrary grammars. However, parsing with arbitrary *CFG* is reducible
    to boolean matrix multiplication [[Valiant *et al*, 1975](https://doi.org/10.1016/S0022-0000(75)80046-8)]
    (and the reverse [[Lee *et al*, 2002](https://doi.org/10.1145/505241.505242)]).
    This is at present bounded by $O(2^{23728639})$ [[Le Gall *et al*, 2014](https://doi.org/10.1145/2608628.2608664)].
    Hence, worse case complexity for parsing arbitrary CFG is likely to remain close
    to cubic.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding PEGs, the actual class of languages that is expressible in *PEG* is
    currently unknown. In particular, we know that *PEGs* can express certain languages
    such as $a^n b^n c^n$. However, we do not know if there exist *CFLs* that are
    not expressible with *PEGs*. In Section 2.3, we provided an instance of a counter-intuitive
    PEG grammar. While important for our purposes (we use grammars for generation
    of inputs) this is not a criticism of parsing with PEGs. PEG focuses on writing
    grammars for recognizing a given language, and not necessarily in interpreting
    what language an arbitrary PEG might yield. Given a Context-Free Language to parse,
    it is almost always possible to write a grammar for it in PEG, and given that
    1) a PEG can parse any string in $O(n)$ time, and 2) at present we know of no
    CFL that can't be expressed as a PEG, and 3) compared with *LR* grammars, a PEG
    is often more intuitive because it allows top-down interpretation, when writing
    a parser for a language, PEGs should be under serious consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grammars can be used to generate derivation trees for a given string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing Expression Grammars are intuitive, and easy to implement, but require
    care to write.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Earley Parsers can parse arbitrary Context Free Grammars.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use parsed inputs to [recombine existing inputs](LangFuzzer.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: An Alternative Packrat'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *Packrat* parser, we showed how one could implement a simple *PEG* parser.
    That parser kept track of the current location in the text using an index. Can
    you modify the parser so that it simply uses the current substring rather than
    tracking the index? That is, it should no longer have the `at` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is a possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: More PEG Syntax'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *PEG* syntax provides a few notational conveniences reminiscent of regular
    expressions. For example, it supports the following operators (letters `T` and
    `A` represents tokens that can be either terminal or nonterminal. `ε` is an empty
    string, and `/` is the ordered choice operator similar to the non-ordered choice
    operator `|`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`T?` represents an optional greedy match of T and `A := T?` is equivalent to
    `A := T/ε`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T*` represents zero or more greedy matches of `T` and `A := T*` is equivalent
    to `A := T A/ε`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T+` represents one or more greedy matches – equivalent to `TT*`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you look at the three notations above, each can be represented in the grammar
    in terms of basic syntax. Remember the exercise from [the chapter on grammars](Grammars.html)
    that developed `define_ex_grammar()` that can represent grammars as Python code?
    extend `define_ex_grammar()` to `define_peg()` to support the above notational
    conveniences. The decorator should rewrite a given grammar that contains these
    notations to an equivalent grammar in basic syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: PEG Predicates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beyond these notational conveniences, it also supports two predicates that can
    provide a powerful lookahead facility that does not consume any input.
  prefs: []
  type: TYPE_NORMAL
- en: '`T&A` represents an *And-predicate* that matches `T` if `T` is matched, and
    it is immediately followed by `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T!A` represents a *Not-predicate* that matches `T` if `T` is matched, and
    it is *not* immediately followed by `A`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement these predicates in our *PEG* parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Earley Fill Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `Earley Parser`, `Column` class, we keep the states both as a `list`
    and also as a `dict` even though `dict` is ordered. Can you explain why?
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint**: see the `fill_chart` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5: Leo Parser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the problems with the original Earley parser is that while it can parse
    strings using arbitrary *Context Free Gramamrs*, its performance on right-recursive
    grammars is quadratic. That is, it takes $O(n^2)$ runtime and space for parsing
    with right-recursive grammars. For example, consider the parsing of the following
    string by two different grammars `LR_GRAMMAR` and `RR_GRAMMAR`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: To see the problem, we need to enable logging. Here is the logged version of
    parsing with the `LR_GRAMMAR`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare that to the parsing of `RR_GRAMMAR` as seen below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'As can be seen from the parsing log for each letter, the number of states with
    representation `<A>: a <A> ● (i, j)` increases at each stage, and these are simply
    a left over from the previous letter. They do not contribute anything more to
    the parse other than to simply complete these entries. However, they take up space,
    and require resources for inspection, contributing a factor of `n` in analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: Joop Leo [[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)]
    found that this inefficiency can be avoided by detecting right recursion. The
    idea is that before starting the `completion` step, check whether the current
    item has a *deterministic reduction path*. If such a path exists, add a copy of
    the topmost element of the *deteministic reduction path* to the current column,
    and return. If not, perform the original `completion` step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 2.1**: An item is said to be on the deterministic reduction path
    above $[A \rightarrow \gamma., i]$ if it is $[B \rightarrow \alpha A ., k]$ with
    $[B \rightarrow \alpha . A, k]$ being the only item in $ I_i $ with the dot in
    front of A, or if it is on the deterministic reduction path above $[B \rightarrow
    \alpha A ., k]$. An item on such a path is called *topmost* one if there is no
    item on the deterministic reduction path above it[[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)].'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding a *deterministic reduction path* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a complete state, represented by `<A> : seq_1 ● (s, e)` where `s` is
    the starting column for this rule, and `e` the current column, there is a *deterministic
    reduction path* **above** it if two constraints are satisfied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There exist a *single* item in the form `<B> : seq_2 ● <A> (k, s)` in column
    `s`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That should be the *single* item in s with dot in front of `<A>`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The resulting item is of the form `<B> : seq_2 <A> ● (k, e)`, which is simply
    item from (1) advanced, and is considered above `<A>:.. (s, e)` in the deterministic
    reduction path. The `seq_1` and `seq_2` are arbitrary symbol sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: This forms the following chain of links, with `<A>:.. (s_1, e)` being the child
    of `<B>:.. (s_2, e)` etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is one way to visualize the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, what we want to do is to identify potential deterministic right
    recursion candidates, perform completion on them, and *throw away the result*.
    We do this until we reach the top. See Grune et al.~[Grune *et al*, 2008] for
    further information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the completions are in the same column (`e`), with each candidate
    with constraints satisfied in further and further earlier columns (as shown below):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: Following this chain, the topmost item is the item `<C>:.. (s_3, e)` that does
    not have a parent. The topmost item needs to be saved is called a *transitive*
    item by Leo, and it is associated with the non-terminal symbol that started the
    lookup. The transitive item needs to be added to each column we inspect.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the skeleton for the parser `LeoParser`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Can you implement the `deterministic_reduction()` method to obtain the topmost
    element?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is a possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Advanced:** We have fixed the complexity bounds. However, because we are
    saving only the topmost item of a right recursion, we need to fix our parser to
    be aware of our fix while extracting parse trees. Can you fix it?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint:** Leo suggests simply transforming the Leo item sets to normal Earley
    sets, with the results from deterministic reduction expanded to their originals.
    For that, keep in mind the picture of constraint chain we drew earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is a possible solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6: Filtered Earley Parser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the problems with our Earley and Leo Parsers is that it can get stuck
    in infinite loops when parsing with grammars that contain token repetitions in
    alternatives. For example, consider the grammar below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: With this grammar, one can produce an infinite chain of derivations of `<A>`,
    (direct recursion) or an infinite chain of derivations of `<B> -> <C> -> <B> ...`
    (indirect recursion). The problem is that, our implementation can get stuck trying
    to derive one of these infinite chains. One possibility is to use the `LazyExtractor`.
    Another, is to simply avoid generating such chains.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Can you implement a solution such that any tree that contains such a chain is
    discarded?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is a possible solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7: Iterative Earley Parser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive algorithms are quite handy in some cases, but sometimes we might want
    to have iteration instead of recursion due to memory or speed problems.
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement an iterative version of the `EarleyParser`?
  prefs: []
  type: TYPE_NORMAL
- en: '**Hint:** In general, you can use a stack to replace a recursive algorithm
    with an iterative one. An easy way to do this is pushing the parameters onto a
    stack instead of passing them to the recursive function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is a possible solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8: First Set of a Nonterminal'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We previously gave a way to extract the `nullable` (epsilon) set, which is often
    used for parsing. Along with `nullable`, parsing algorithms often use two other
    sets [`first` and `follow`](https://en.wikipedia.org/wiki/Canonical_LR_parser#FIRST_and_FOLLOW_sets).
    The first set of a terminal symbol is itself, and the first set of a nonterminal
    is composed of terminal symbols that can come at the beginning of any derivation
    of that nonterminal. The first set of any nonterminal that can derive the empty
    string should contain `EPSILON`. For example, using our `A1_GRAMMAR`, the first
    set of both `<expr>` and `<start>` is `{0,1,2,3,4,5,6,7,8,9}`. The extraction
    first set for any self-recursive nonterminal is simple enough. One simply has
    to recursively compute the first set of the first element of its choice expressions.
    The computation of `first` set for a self-recursive nonterminal is tricky. One
    has to recursively compute the first set until one is sure that no more terminals
    can be added to the first set.
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement the `first` set using our `fixpoint()` decorator?
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9: Follow Set of a Nonterminal'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The follow set definition is similar to the first set. The follow set of a nonterminal
    is the set of terminals that can occur just after that nonterminal is used in
    any derivation. The follow set of the start symbol is `EOF`, and the follow set
    of any nonterminal is the super set of first sets of all symbols that come after
    it in any choice expression.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the follow set of `<expr>` in `A1_GRAMMAR` is the set `{EOF, +,
    -}`.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous exercise, implement the `followset()` using the `fixpoint()`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10: A LL(1) Parser'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we mentioned previously, there exist other kinds of parsers that operate
    left-to-right with right most derivation (*LR(k)*) or left-to-right with left
    most derivation (*LL(k)*) with *k* signifying the amount of lookahead the parser
    is permitted to use.
  prefs: []
  type: TYPE_NORMAL
- en: What should one do with the lookahead? That lookahead can be used to determine
    which rule to apply. In the case of an *LL(1)* parser, the rule to apply is determined
    by looking at the *first* set of the different rules. We previously implemented
    `first_expr()` that takes an expression, the set of `nullables`, and computes
    the first set of that rule.
  prefs: []
  type: TYPE_NORMAL
- en: If a rule can derive an empty set, then that rule may also be applicable if
    of sees the `follow()` set of the corresponding nonterminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 1: A LL(1) Parsing Table'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first part of this exercise is to implement the *parse table* that describes
    what action to take for an *LL(1)* parser on seeing a terminal symbol on lookahead.
    The table should be in the form of a *dictionary* such that the keys represent
    the nonterminal symbol, and the value should contain another dictionary with keys
    as terminal symbols and the particular rule to continue parsing as the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us illustrate this table with an example. The `parse_table()` method populates
    a `self.table` data structure that should conform to the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'On invocation of `LL1Parser(A2_GRAMMAR).show_table()` It should result in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '| Rule Name |  | + | - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- |'
  prefs: []
  type: TYPE_TB
- en: '| start |  |  |  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| expr |  |  |  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| expr_ |  | 2 | 3 |  |  |  |  |  |  |  |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| integer |  |  |  | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| integer_ |  | 7 | 7 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| digit |  |  |  | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |'
  prefs: []
  type: TYPE_TB
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: The Parser'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once we have the parse table, implementing the parser is as follows: Consider
    the first item from the sequence of tokens to parse, and seed the stack with the
    start symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: While the stack is not empty, extract the first symbol from the stack, and if
    the symbol is a terminal, verify that the symbol matches the item from the input
    stream. If the symbol is a nonterminal, use the symbol and input item to look
    up the next rule from the parse table. Insert the rule thus found to the top of
    the stack. Keep track of the expressions being parsed to build up the parse table.
  prefs: []
  type: TYPE_NORMAL
- en: Use the parse table defined previously to implement the complete LL(1) parser.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution.** Here is the complete parser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Parser.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Parsing Inputs](https://www.fuzzingbook.org/html/Parser.html)". In Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "[The
    Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Parser.html](https://www.fuzzingbook.org/html/Parser.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
