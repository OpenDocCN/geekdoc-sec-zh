- en: Parsing Inputs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析输入
- en: 原文：[http://www.fuzzingbook.org/html/Parser.html](http://www.fuzzingbook.org/html/Parser.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[http://www.fuzzingbook.org/html/Parser.html](http://www.fuzzingbook.org/html/Parser.html)
- en: In the chapter on [Grammars](Grammars.html), we discussed how grammars can be
    used to represent various languages. We also saw how grammars can be used to generate
    strings of the corresponding language. Grammars can also perform the reverse.
    That is, given a string, one can decompose the string into its constituent parts
    that correspond to the parts of grammar used to generate it – the *derivation
    tree* of that string. These parts (and parts from other similar strings) can later
    be recombined using the same grammar to produce new strings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[语法](Grammars.html)章节中，我们讨论了语法如何用来表示各种语言。我们还看到了语法如何用来生成对应语言的字符串。语法还可以执行相反的操作。也就是说，给定一个字符串，可以将该字符串分解为其构成部分，这些部分对应于生成它的语法部分——该字符串的*推导树*。这些部分（以及来自其他类似字符串的部分）可以稍后使用相同的语法重新组合，以生成新的字符串。
- en: In this chapter, we use grammars to parse and decompose a given set of valid
    seed inputs into their corresponding derivation trees. This structural representation
    allows us to mutate, crossover, and recombine their parts in order to generate
    new valid, slightly changed inputs (i.e., fuzz)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用语法来解析和分解给定的一组有效种子输入到它们对应的推导树。这种结构表示允许我们突变、交叉和重新组合它们的部分，以生成新的有效、略有变化的输入（即模糊测试）。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Prerequisites**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件**'
- en: You should have read the [chapter on grammars](Grammars.html).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该已经阅读了[关于语法的章节](Grammars.html)。
- en: An understanding of derivation trees from the [chapter on grammar fuzzer](GrammarFuzzer.html)
    is also required.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还需要理解[语法模糊测试章节](GrammarFuzzer.html)中的推导树。
- en: Synopsis
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: To [use the code provided in this chapter](Importing.html), write
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章提供的代码（Importing.html），请编写
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: and then make use of the following features.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后利用以下功能。
- en: 'This chapter introduces `Parser` classes, parsing a string into a *derivation
    tree* as introduced in the [chapter on efficient grammar fuzzing](GrammarFuzzer.html).
    Two important parser classes are provided:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 `Parser` 类，将字符串解析为*推导树*，如[关于高效语法模糊测试的章节](GrammarFuzzer.html)中所述。提供了两个重要的解析器类：
- en: '[Parsing Expression Grammar parsers](#Parsing-Expression-Grammars) (`PEGParser`).
    These are very efficient, but limited to specific grammar structure. Notably,
    the alternatives represent *ordered choice*. That is, rather than choosing all
    rules that can potentially match, we stop at the first match that succeed.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解析表达式语法解析器](#Parsing-Expression-Grammars) (`PEGParser`)。这些非常高效，但限于特定的语法结构。值得注意的是，备选方案代表*有序选择*。也就是说，我们不会选择所有可能匹配的规则，而是在第一个成功匹配的地方停止。'
- en: '[Earley parsers](#Parsing-Context-Free-Grammars) (`EarleyParser`). These accept
    any kind of context-free grammars, and explore all parsing alternatives (if any).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Earley 解析器](#Parsing-Context-Free-Grammars) (`EarleyParser`)。这些解析器接受任何类型的上下文无关语法，并探索所有解析备选方案（如果有的话）。'
- en: 'Using any of these is fairly easy, though. First, instantiate them with a grammar:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些中的任何一个都相当简单。首先，用一种语法实例化它们：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, use the `parse()` method to retrieve a list of possible derivation trees:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用 `parse()` 方法检索可能的推导树列表：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <svg width="636pt" height="223pt" viewBox="0.00 0.00 635.75 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="265.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="265.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><phone-number></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="113.12" y="-101.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="166.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><area></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="232.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge10"
    class="edge"><title>1->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="299.12" y="-101.45" font-family="Times,serif" font-size="14.00"><exchange></text></g>
    <g id="edge11" class="edge"><title>1->11</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="366.12" y="-101.45" font-family="Times,serif" font-size="14.00">-
    (45)</text></g> <g id="edge18" class="edge"><title>1->18</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="489.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><line></text></g> <g id="edge19" class="edge"><title>1->19</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="34.12"
    y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="107.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge6" class="edge"><title>3->6</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="166.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge8" class="edge"><title>3->8</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="34.12" y="-0.95" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="107.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="166.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="239.12" y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge12" class="edge"><title>11->12</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="312.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge14" class="edge"><title>11->14</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>11->16</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="239.12" y="-0.95" font-family="Times,serif" font-size="14.00">9
    (57)</text></g> <g id="edge13" class="edge"><title>12->13</title></g> <g id="node16"
    class="node"><title>15</title> <text text-anchor="middle" x="312.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">8 (56)</text></g> <g id="edge15" class="edge"><title>14->15</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="371.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">7 (55)</text></g> <g id="edge17"
    class="edge"><title>16->17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="430.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge20" class="edge"><title>19->20</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="489.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>19->22</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="548.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge24" class="edge"><title>19->24</title></g> <g id="node27" class="node"><title>26</title>
    <text text-anchor="middle" x="607.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge26" class="edge"><title>19->26</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="430.12" y="-0.95" font-family="Times,serif" font-size="14.00">6
    (54)</text></g> <g id="edge21" class="edge"><title>20->21</title></g> <g id="node24"
    class="node"><title>23</title> <text text-anchor="middle" x="489.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge23" class="edge"><title>22->23</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="548.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">4 (52)</text></g> <g id="edge25"
    class="edge"><title>24->25</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="607.12" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g></g></svg>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="636pt" height="223pt" viewBox="0.00 0.00 635.75 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="265.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="265.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><phone-number></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="113.12" y="-101.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="166.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><area></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="232.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge10"
    class="edge"><title>1->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="299.12" y="-101.45" font-family="Times,serif" font-size="14.00"><exchange></text></g>
    <g id="edge11" class="edge"><title>1->11</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="366.12" y="-101.45" font-family="Times,serif" font-size="14.00">-
    (45)</text></g> <g id="edge18" class="edge"><title>1->18</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="489.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><line></text></g> <g id="edge19" class="edge"><title>1->19</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="34.12"
    y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="107.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge6" class="edge"><title>3->6</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="166.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge8" class="edge"><title>3->8</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="34.12" y="-0.95" font-family="Times,serif" font-size="14.00">5
    (53)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="107.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="166.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="239.12" y="-51.2" font-family="Times,serif" font-size="14.00"><lead-digit></text></g>
    <g id="edge12" class="edge"><title>11->12</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="312.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge14" class="edge"><title>11->14</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="371.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>11->16</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="239.12" y="-0.95" font-family="Times,serif" font-size="14.00">9
    (57)</text></g> <g id="edge13" class="edge"><title>12->13</title></g> <g id="node16"
    class="node"><title>15</title> <text text-anchor="middle" x="312.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">8 (56)</text></g> <g id="edge15" class="edge"><title>14->15</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="371.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">7 (55)</text></g> <g id="edge17"
    class="edge"><title>16->17</title></g> <g id="node21" class="node"><title>20</title>
    <text text-anchor="middle" x="430.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge20" class="edge"><title>19->20</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="489.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>19->22</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="548.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge24" class="edge"><title>19->24</title></g> <g id="node27" class="node"><title>26</title>
    <text text-anchor="middle" x="607.12" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge26" class="edge"><title>19->26</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="430.12" y="-0.95" font-family="Times,serif" font-size="14.00">6
    (54)</text></g> <g id="edge21" class="edge"><title>20->21</title></g> <g id="node24"
    class="node"><title>23</title> <text text-anchor="middle" x="489.12" y="-0.95"
    font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge23" class="edge"><title>22->23</title></g>
    <g id="node26" class="node"><title>25</title> <text text-anchor="middle" x="548.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">4 (52)</text></g> <g id="edge25"
    class="edge"><title>24->25</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="607.12" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g></g></svg>
- en: These derivation trees can then be used for test generation, notably for mutating
    and recombining existing inputs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些推导树可以用于测试生成，特别是用于突变和重新组合现有输入。
- en: '<svg width="382pt" height="395pt" viewBox="0.00 0.00 381.62 394.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 390.5)"><g
    id="node1" class="node"><title>PEGParser</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class PEGParser:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '<svg width="382pt" height="395pt" viewBox="0.00 0.00 381.62 394.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 390.5)"><g
    id="node1" class="node"><title>PEGParser</title> <g id="a_node1"><a xlink:href="#"
    xlink:title="class PEGParser:'
- en: 'Packrat parser for Parsing Expression Grammars (PEGs)."><text text-anchor="start"
    x="18.12" y="-126.58" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">PEGParser</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="PEGParser"><g id="a_node1_1"><a xlink:href="#" xlink:title="parse_prefix(self,
    text):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '用于解析表达式语法（PEGs）的 Packrat 解析器。《PEGParser》"><text text-anchor="start" x="18.12"
    y="-126.58" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">PEGParser</text> <g id="a_node1_0"><a xlink:href="#"
    xlink:title="PEGParser"><g id="a_node1_1"><a xlink:href="#" xlink:title="parse_prefix(self,
    text):'
- en: Return pair (cursor, forest) for longest prefix of text.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文本的最长前缀的（光标，森林）对。
- en: 'To be defined in subclasses."><text text-anchor="start" x="8" y="-104.38" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="unify_rule(self, rule, text,
    at)"><text text-anchor="start" x="8" y="-90.62" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">unify_rule()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="unify_key(self, key, text, at=0)"><text
    text-anchor="start" x="8" y="-77.88" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">unify_key()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>Parser</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Parser:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '在子类中定义。"><text text-anchor="start" x="8" y="-104.38" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node1_2"><a xlink:href="#" xlink:title="unify_rule(self, rule, text,
    at)"><text text-anchor="start" x="8" y="-90.62" font-family="''Fira Mono'', ''Source
    Code Pro'', ''Courier'', monospace" font-size="10.00">unify_rule()</text></a></g>
    <g id="a_node1_3"><a xlink:href="#" xlink:title="unify_key(self, key, text, at=0)"><text
    text-anchor="start" x="8" y="-77.88" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">unify_key()</text></a></g></a></g></a></g></g>
    <g id="node2" class="node"><title>解析器</title> <g id="a_node2"><a xlink:href="#"
    xlink:title="class Parser:'
- en: 'Base class for parsing."><text text-anchor="start" x="93.5" y="-369.7" font-family="Patua
    One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Parser</text>
    <g id="a_node2_4"><a xlink:href="#" xlink:title="Parser"><g id="a_node2_5"><a
    xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '解析的基类。"><text text-anchor="start" x="93.5" y="-369.7" font-family="Patua One,
    Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">Parser</text>
    <g id="a_node2_4"><a xlink:href="#" xlink:title="Parser"><g id="a_node2_5"><a
    xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):'
- en: Constructor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数。
- en: '`grammar` is the grammar to be used for parsing.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`grammar` 是用于解析的语法。'
- en: 'Keyword arguments:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数：
- en: '`start_symbol` is the start symbol (default: ''<start>'').'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_symbol` 是起始符号（默认：''<start>''）。'
- en: '`log` enables logging (default: False).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 启用日志记录（默认：False）。'
- en: '`coalesce` defines if tokens should be coalesced (default: True).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`coalesce` 定义了是否应该合并标记（默认：True）。'
- en: '`tokens`, if set, is a set of tokens to be used."><text text-anchor="start"
    x="71" y="-347.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g> <g id="a_node2_6"><a
    xlink:href="#" xlink:title="grammar(self) -> Grammar:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokens`，如果设置，是用于的标记集合。"><text text-anchor="start" x="71" y="-347.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">__init__()</text></a></g>
    <g id="a_node2_6"><a xlink:href="#" xlink:title="grammar(self) -> Grammar:'
- en: 'Return the grammar of this parser."><text text-anchor="start" x="71" y="-334.75"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">grammar()</text></a></g> <g id="a_node2_7"><a xlink:href="#"
    xlink:title="parse(self, text: str) -> Iterable[DerivationTree]:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '返回此解析器的语法。"><text text-anchor="start" x="71" y="-334.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">grammar()</text></a></g>
    <g id="a_node2_7"><a xlink:href="#" xlink:title="parse(self, text: str) -> Iterable[DerivationTree]:'
- en: Parse `text` using the grammar.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法解析 `text`。
- en: 'Return an iterable of parse trees."><text text-anchor="start" x="71" y="-322"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">parse()</text></a></g> <g id="a_node2_8"><a xlink:href="#" xlink:title="start_symbol(self)
    -> str:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '返回一个解析树的迭代器。"><text text-anchor="start" x="71" y="-322" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">parse()</text></a></g>
    <g id="a_node2_8"><a xlink:href="#" xlink:title="start_symbol(self) -> str:'
- en: 'Return the start symbol of this parser."><text text-anchor="start" x="71" y="-309.25"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold"
    font-size="10.00">start_symbol()</text></a></g> <g id="a_node2_9"><a xlink:href="#"
    xlink:title="coalesce(self, children: List[DerivationTree]) -> List[DerivationTree]"><text
    text-anchor="start" x="71" y="-295.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">coalesce()</text></a></g> <g
    id="a_node2_10"><a xlink:href="#" xlink:title="parse_on(self, text: str, start_symbol:
    str) -> Generator"><text text-anchor="start" x="71" y="-282.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">parse_on()</text></a></g>
    <g id="a_node2_11"><a xlink:href="#" xlink:title="parse_prefix(self, text: str)
    -> Tuple[int, Iterable[DerivationTree]]:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '返回此解析器的起始符号。"><text text-anchor="start" x="71" y="-309.25" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-weight="bold" font-size="10.00">start_symbol()</text></a></g>
    <g id="a_node2_9"><a xlink:href="#" xlink:title="coalesce(self, children: List[DerivationTree])
    -> List[DerivationTree]"><text text-anchor="start" x="71" y="-295.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">coalesce()</text></a></g>
    <g id="a_node2_10"><a xlink:href="#" xlink:title="parse_on(self, text: str, start_symbol:
    str) -> Generator"><text text-anchor="start" x="71" y="-282.75" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">parse_on()</text></a></g>
    <g id="a_node2_11"><a xlink:href="#" xlink:title="parse_prefix(self, text: str)
    -> Tuple[int, Iterable[DerivationTree]]:'
- en: Return pair (cursor, forest) for longest prefix of text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文本的最长前缀的（光标，森林）对。
- en: 'To be defined in subclasses."><text text-anchor="start" x="71" y="-271" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node2_12"><a xlink:href="#" xlink:title="prune_tree(self, tree)"><text
    text-anchor="start" x="71" y="-257.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">prune_tree()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>PEGParser->Parser</title></g> <g id="node3"
    class="node"><title>EarleyParser</title> <g id="a_node3"><a xlink:href="#" xlink:title="class
    EarleyParser:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '在子类中定义。《text text-anchor="start" x="71" y="-271" font-family="''Fira Mono'',
    ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node2_12"><a xlink:href="#" xlink:title="prune_tree(self, tree)"><text
    text-anchor="start" x="71" y="-257.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">prune_tree()</text></a></g></a></g></a></g></g>
    <g id="edge1" class="edge"><title>PEGParser->Parser</title></g> <g id="node3"
    class="node"><title>EarleyParser</title> <g id="a_node3"><a xlink:href="#" xlink:title="class
    EarleyParser:'
- en: 'Earley Parser. This parser can parse any context-free grammar."><text text-anchor="start"
    x="138" y="-196.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="14.00" fill="#b03a2e">EarleyParser</text> <g id="a_node3_13"><a xlink:href="#"
    xlink:title="EarleyParser"><g id="a_node3_14"><a xlink:href="#" xlink:title="__init__(self,
    grammar, **kwargs):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 'Earley 解析器。此解析器可以解析任何上下文无关文法。"><text text-anchor="start" x="138" y="-196.7"
    font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00"
    fill="#b03a2e">EarleyParser</text> <g id="a_node3_13"><a xlink:href="#" xlink:title="EarleyParser"><g
    id="a_node3_14"><a xlink:href="#" xlink:title="__init__(self, grammar, **kwargs):'
- en: Constructor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数。
- en: '`grammar` is the grammar to be used for parsing.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`grammar` 是用于解析的文法。'
- en: 'Keyword arguments:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数：
- en: '`start_symbol` is the start symbol (default: ''<start>'').'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_symbol` 是起始符号（默认: ''<start>''）。'
- en: '`log` enables logging (default: False).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`log` 启用日志记录（默认: False）。'
- en: '`coalesce` defines if tokens should be coalesced (default: True).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`coalesce` 定义是否应该合并标记（默认: True）。'
- en: '`tokens`, if set, is a set of tokens to be used."><text text-anchor="start"
    x="126" y="-174.5" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-style="italic" font-size="10.00">__init__()</text></a></g> <g
    id="a_node3_15"><a xlink:href="#" xlink:title="chart_parse(self, words, start)"><text
    text-anchor="start" x="126" y="-160.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">chart_parse()</text></a></g>
    <g id="a_node3_16"><a xlink:href="#" xlink:title="complete(self, col, state)"><text
    text-anchor="start" x="126" y="-148" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">complete()</text></a></g> <g
    id="a_node3_17"><a xlink:href="#" xlink:title="earley_complete(self, col, state)"><text
    text-anchor="start" x="126" y="-135.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">earley_complete()</text></a></g>
    <g id="a_node3_18"><a xlink:href="#" xlink:title="extract_a_tree(self, forest_node)"><text
    text-anchor="start" x="126" y="-122.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_a_tree()</text></a></g>
    <g id="a_node3_19"><a xlink:href="#" xlink:title="extract_trees(self, forest_node)"><text
    text-anchor="start" x="126" y="-109.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_trees()</text></a></g>
    <g id="a_node3_20"><a xlink:href="#" xlink:title="fill_chart(self, chart)"><text
    text-anchor="start" x="126" y="-97" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">fill_chart()</text></a></g> <g
    id="a_node3_21"><a xlink:href="#" xlink:title="forest(self, s, kind, chart)"><text
    text-anchor="start" x="126" y="-84.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">forest()</text></a></g> <g id="a_node3_22"><a
    xlink:href="#" xlink:title="parse(self, text):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`tokens`, 如果设置，是一个将要使用的标记集合。"><text text-anchor="start" x="126" y="-174.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">__init__()</text></a></g> <g id="a_node3_15"><a xlink:href="#"
    xlink:title="chart_parse(self, words, start)"><text text-anchor="start" x="126"
    y="-160.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">chart_parse()</text></a></g> <g id="a_node3_16"><a xlink:href="#"
    xlink:title="complete(self, col, state)"><text text-anchor="start" x="126" y="-148"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">complete()</text></a></g>
    <g id="a_node3_17"><a xlink:href="#" xlink:title="earley_complete(self, col, state)"><text
    text-anchor="start" x="126" y="-135.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">earley_complete()</text></a></g>
    <g id="a_node3_18"><a xlink:href="#" xlink:title="extract_a_tree(self, forest_node)"><text
    text-anchor="start" x="126" y="-122.5" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_a_tree()</text></a></g>
    <g id="a_node3_19"><a xlink:href="#" xlink:title="extract_trees(self, forest_node)"><text
    text-anchor="start" x="126" y="-109.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">extract_trees()</text></a></g>
    <g id="a_node3_20"><a xlink:href="#" xlink:title="fill_chart(self, chart)"><text
    text-anchor="start" x="126" y="-97" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">fill_chart()</text></a></g> <g
    id="a_node3_21"><a xlink:href="#" xlink:title="forest(self, s, kind, chart)"><text
    text-anchor="start" x="126" y="-84.25" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">forest()</text></a></g> <g id="a_node3_22"><a
    xlink:href="#" xlink:title="parse(self, text):'
- en: Parse `text` using the grammar.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法解析`text`。
- en: 'Return an iterable of parse trees."><text text-anchor="start" x="126" y="-72.5"
    font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic"
    font-size="10.00">parse()</text></a></g> <g id="a_node3_23"><a xlink:href="#"
    xlink:title="parse_forest(self, chart, state)"><text text-anchor="start" x="126"
    y="-58.75" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'', monospace"
    font-size="10.00">parse_forest()</text></a></g> <g id="a_node3_24"><a xlink:href="#"
    xlink:title="parse_paths(self, named_expr, chart, frm, til)"><text text-anchor="start"
    x="126" y="-46" font-family="''Fira Mono'', ''Source Code Pro'', ''Courier'',
    monospace" font-size="10.00">parse_paths()</text></a></g> <g id="a_node3_25"><a
    xlink:href="#" xlink:title="parse_prefix(self, text):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '返回一个解析树的可迭代对象。"><text text-anchor="start" x="126" y="-72.5" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-style="italic" font-size="10.00">parse()</text></a></g>
    <g id="a_node3_23"><a xlink:href="#" xlink:title="parse_forest(self, chart, state)"><text
    text-anchor="start" x="126" y="-58.75" font-family="''Fira Mono'', ''Source Code
    Pro'', ''Courier'', monospace" font-size="10.00">parse_forest()</text></a></g>
    <g id="a_node3_24"><a xlink:href="#" xlink:title="parse_paths(self, named_expr,
    chart, frm, til)"><text text-anchor="start" x="126" y="-46" font-family="''Fira
    Mono'', ''Source Code Pro'', ''Courier'', monospace" font-size="10.00">parse_paths()</text></a></g>
    <g id="a_node3_25"><a xlink:href="#" xlink:title="parse_prefix(self, text):'
- en: Return pair (cursor, forest) for longest prefix of text.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 返回文本的最长前缀的（光标，森林）对。"><text text-anchor="start" x="126" y="-34" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-size="10.00">parse_prefix()</text></a></g>
- en: To be defined in subclasses."><text text-anchor="start" x="126" y="-34.25" font-family="'Fira
    Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node3_26"><a xlink:href="#" xlink:title="predict(self, col, sym, state)"><text
    text-anchor="start" x="126" y="-20.5" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-size="10.00">predict()</text></a></g> <g id="a_node3_27"><a
    xlink:href="#" xlink:title="scan(self, col, state, letter)"><text text-anchor="start"
    x="126" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">scan()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>EarleyParser->Parser</title></g>
    <g id="node4" class="node"><title>Legend</title> <text text-anchor="start" x="254.38"
    y="-122.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">Legend</text> <text text-anchor="start" x="254.38"
    y="-112.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="260.38" y="-112.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
    <text text-anchor="start" x="254.38" y="-102.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-102.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
    <text text-anchor="start" x="254.38" y="-92.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-92.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">overloaded_method()</text> <text text-anchor="start" x="254.38"
    y="-83.7" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names
    to see doc</text></g></g></svg>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中定义。"><text text-anchor="start" x="126" y="-34.25" font-family="'Fira Mono',
    'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="10.00">parse_prefix()</text></a></g>
    <g id="a_node3_26"><a xlink:href="#" xlink:title="predict(self, col, sym, state)"><text
    text-anchor="start" x="126" y="-20.5" font-family="'Fira Mono', 'Source Code Pro',
    'Courier', monospace" font-size="10.00">predict()</text></a></g> <g id="a_node3_27"><a
    xlink:href="#" xlink:title="scan(self, col, state, letter)"><text text-anchor="start"
    x="126" y="-7.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace"
    font-size="10.00">scan()</text></a></g></a></g></a></g></g> <g id="edge2" class="edge"><title>EarleyParser->Parser</title></g>
    <g id="node4" class="node"><title>图例</title> <text text-anchor="start" x="254.38"
    y="-122.75" font-family="Patua One, Helvetica, sans-serif" font-weight="bold"
    font-size="10.00" fill="#b03a2e">图例</text> <text text-anchor="start" x="254.38"
    y="-112.75" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
    <text text-anchor="start" x="260.38" y="-112.75" font-family="'Fira Mono', 'Source
    Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">公共方法()</text>
    <text text-anchor="start" x="254.38" y="-102.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-102.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">私有方法()</text>
    <text text-anchor="start" x="254.38" y="-92.75" font-family="Patua One, Helvetica,
    sans-serif" font-size="10.00">• </text> <text text-anchor="start" x="260.38" y="-92.75"
    font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic"
    font-size="8.00">重载方法()</text> <text text-anchor="start" x="254.38" y="-83.7"
    font-family="Helvetica,sans-Serif" font-size="9.00">将鼠标悬停在名称上以查看文档</text></g></g></svg>
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Why Parsing for Fuzzing?
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么进行模糊测试的解析？
- en: Why would one want to parse existing inputs in order to fuzz? Let us illustrate
    the problem with an example. Here is a simple program that accepts a CSV file
    of vehicle details and processes this information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么想要解析现有的输入来进行模糊测试？让我们用一个例子来说明这个问题。这是一个简单的程序，它接受一个包含车辆详情的CSV文件并处理这些信息。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The CSV file contains details of one vehicle per line. Each row is processed
    in `process_vehicle()`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: CSV文件每行包含一辆车的详细信息。每一行都在`process_vehicle()`中处理。
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Depending on the kind of vehicle, the processing changes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据车辆类型的不同，处理方式也会变化。
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here is a sample of inputs that the `process_inventory()` accepts.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`process_inventory()`接受的输入样本。
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let us try to fuzz this program. Given that the `process_inventory()` takes
    a CSV file, we can write a simple grammar for generating comma separated values,
    and generate the required CSV rows. For convenience, we fuzz `process_vehicle()`
    directly.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试对这个程序进行模糊测试。鉴于`process_inventory()`接受CSV文件，我们可以编写一个简单的语法来生成逗号分隔的值，并生成所需的CSV行。为了方便起见，我们直接模糊`process_vehicle()`。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need some infrastructure first for viewing the grammar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一些基础设施来查看语法。
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">csvline</text></g></g></g></g></svg>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">csvline</text></g></g></g></g></svg>
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">items</text></g></g></g></g></svg>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">items</text></g></g></g></g></svg>
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 305.0 92" width="305.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">item</text></g>
    <g class="terminal"><text x="148.25" y="35">,</text></g> <g class="non-terminal"><text
    x="213.75" y="35">items</text></g></g> <g><g class="non-terminal"><text x="152.5"
    y="65">item</text></g></g></g></g></svg>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 305.0 92" width="305.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">item</text></g>
    <g class="terminal"><text x="148.25" y="35">,</text></g> <g class="non-terminal"><text
    x="213.75" y="35">items</text></g></g> <g><g class="non-terminal"><text x="152.5"
    y="65">item</text></g></g></g></g></svg>
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">letters</text></g></g></g></g></svg>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">letters</text></g></g></g></g></svg>
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">letter</text></g>
    <g class="non-terminal"><text x="190.75" y="35">letters</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">letter</text></g></g></g></g></svg>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">letter</text></g>
    <g class="non-terminal"><text x="190.75" y="35">letters</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">letter</text></g></g></g></g></svg>
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <svg class="railroad-diagram" height="618" viewBox="0 0 611.0 618" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="283">i</text></g></g>
    <g><g class="terminal"><text x="84.25" y="253">h</text></g></g> <g><g class="terminal"><text
    x="84.25" y="223">g</text></g></g> <g><g class="terminal"><text x="84.25" y="193">f</text></g></g>
    <g><g class="terminal"><text x="84.25" y="163">e</text></g></g> <g><g class="terminal"><text
    x="84.25" y="133">d</text></g></g> <g><g class="terminal"><text x="84.25" y="103">c</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">b</text></g></g> <g><g class="terminal"><text
    x="84.25" y="43">a</text></g></g> <g><g class="terminal"><text x="84.25" y="313">j</text></g></g>
    <g><g class="terminal"><text x="84.25" y="343">k</text></g></g> <g><g class="terminal"><text
    x="84.25" y="373">l</text></g></g> <g><g class="terminal"><text x="84.25" y="403">m</text></g></g>
    <g><g class="terminal"><text x="84.25" y="433">n</text></g></g> <g><g class="terminal"><text
    x="84.25" y="463">o</text></g></g> <g><g class="terminal"><text x="84.25" y="493">p</text></g></g>
    <g><g class="terminal"><text x="84.25" y="523">q</text></g></g> <g><g class="terminal"><text
    x="84.25" y="553">r</text></g></g> <g><g class="terminal"><text x="84.25" y="583">s</text></g></g></g>
    <g><g><g class="terminal"><text x="172.75" y="283">B</text></g></g> <g><g class="terminal"><text
    x="172.75" y="253">A</text></g></g> <g><g class="terminal"><text x="172.75" y="223">z</text></g></g>
    <g><g class="terminal"><text x="172.75" y="193">y</text></g></g> <g><g class="terminal"><text
    x="172.75" y="163">x</text></g></g> <g><g class="terminal"><text x="172.75" y="133">w</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">v</text></g></g> <g><g class="terminal"><text
    x="172.75" y="73">u</text></g></g> <g><g class="terminal"><text x="172.75" y="43">t</text></g></g>
    <g><g class="terminal"><text x="172.75" y="313">C</text></g></g> <g><g class="terminal"><text
    x="172.75" y="343">D</text></g></g> <g><g class="terminal"><text x="172.75" y="373">E</text></g></g>
    <g><g class="terminal"><text x="172.75" y="403">F</text></g></g> <g><g class="terminal"><text
    x="172.75" y="433">G</text></g></g> <g><g class="terminal"><text x="172.75" y="463">H</text></g></g>
    <g><g class="terminal"><text x="172.75" y="493">I</text></g></g> <g><g class="terminal"><text
    x="172.75" y="523">J</text></g></g> <g><g class="terminal"><text x="172.75" y="553">K</text></g></g>
    <g><g class="terminal"><text x="172.75" y="583">L</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="283">U</text></g></g> <g><g class="terminal"><text
    x="261.25" y="253">T</text></g></g> <g><g class="terminal"><text x="261.25" y="223">S</text></g></g>
    <g><g class="terminal"><text x="261.25" y="193">R</text></g></g> <g><g class="terminal"><text
    x="261.25" y="163">Q</text></g></g> <g><g class="terminal"><text x="261.25" y="133">P</text></g></g>
    <g><g class="terminal"><text x="261.25" y="103">O</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">N</text></g></g> <g><g class="terminal"><text x="261.25" y="43">M</text></g></g>
    <g><g class="terminal"><text x="261.25" y="313">V</text></g></g> <g><g class="terminal"><text
    x="261.25" y="343">W</text></g></g> <g><g class="terminal"><text x="261.25" y="373">X</text></g></g>
    <g><g class="terminal"><text x="261.25" y="403">Y</text></g></g> <g><g class="terminal"><text
    x="261.25" y="433">Z</text></g></g> <g><g class="terminal"><text x="261.25" y="463">0</text></g></g>
    <g><g class="terminal"><text x="261.25" y="493">1</text></g></g> <g><g class="terminal"><text
    x="261.25" y="523">2</text></g></g> <g><g class="terminal"><text x="261.25" y="553">3</text></g></g>
    <g><g class="terminal"><text x="261.25" y="583">4</text></g></g></g> <g><g><g
    class="terminal"><text x="349.75" y="283">$</text></g></g> <g><g class="terminal"><text
    x="349.75" y="253">#</text></g></g> <g><g class="terminal"><text x="349.75" y="223">"</text></g></g>
    <g><g class="terminal"><text x="349.75" y="193">!</text></g></g> <g><g class="terminal"><text
    x="349.75" y="163">9</text></g></g> <g><g class="terminal"><text x="349.75" y="133">8</text></g></g>
    <g><g class="terminal"><text x="349.75" y="103">7</text></g></g> <g><g class="terminal"><text
    x="349.75" y="73">6</text></g></g> <g><g class="terminal"><text x="349.75" y="43">5</text></g></g>
    <g><g class="terminal"><text x="349.75" y="313">%</text></g></g> <g><g class="terminal"><text
    x="349.75" y="343">&</text></g></g> <g><g class="terminal"><text x="349.75" y="373">'</text></g></g>
    <g><g class="terminal"><text x="349.75" y="403">(</text></g></g> <g><g class="terminal"><text
    x="349.75" y="433">)</text></g></g> <g><g class="terminal"><text x="349.75" y="463">*</text></g></g>
    <g><g class="terminal"><text x="349.75" y="493">+</text></g></g> <g><g class="terminal"><text
    x="349.75" y="523">,</text></g></g> <g><g class="terminal"><text x="349.75" y="553">-</text></g></g>
    <g><g class="terminal"><text x="349.75" y="583">.</text></g></g></g> <g><g><g
    class="terminal"><text x="438.25" y="283">[</text></g></g> <g><g class="terminal"><text
    x="438.25" y="253">@</text></g></g> <g><g class="terminal"><text x="438.25" y="223">?</text></g></g>
    <g><g class="terminal"><text x="438.25" y="193">></text></g></g> <g><g class="terminal"><text
    x="438.25" y="163">=</text></g></g> <g><g class="terminal"><text x="438.25" y="133"><</text></g></g>
    <g><g class="terminal"><text x="438.25" y="103">;</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">:</text></g></g> <g><g class="terminal"><text x="438.25" y="43">/</text></g></g>
    <g><g class="terminal"><text x="438.25" y="313">\</text></g></g> <g><g class="terminal"><text
    x="438.25" y="343">]</text></g></g> <g><g class="terminal"><text x="438.25" y="373">^</text></g></g>
    <g><g class="terminal"><text x="438.25" y="403">_</text></g></g> <g><g class="terminal"><text
    x="438.25" y="433">`</text></g></g> <g><g class="terminal"><text x="438.25" y="463">{</text></g></g>
    <g><g class="terminal"><text x="438.25" y="493">|</text></g></g> <g><g class="terminal"><text
    x="438.25" y="523">}</text></g></g> <g><g class="terminal"><text x="438.25" y="553">~</text></g></g></g></g></g></svg>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="618" viewBox="0 0 611.0 618" width="611.0"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="283">i</text></g></g>
    <g><g class="terminal"><text x="84.25" y="253">h</text></g></g> <g><g class="terminal"><text
    x="84.25" y="223">g</text></g></g> <g><g class="terminal"><text x="84.25" y="193">f</text></g></g>
    <g><g class="terminal"><text x="84.25" y="163">e</text></g></g> <g><g class="terminal"><text
    x="84.25" y="133">d</text></g></g> <g><g class="terminal"><text x="84.25" y="103">c</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">b</text></g></g> <g><g class="terminal"><text
    x="84.25" y="43">a</text></g></g> <g><g class="terminal"><text x="84.25" y="313">j</text></g></g>
    <g><g class="terminal"><text x="84.25" y="343">k</text></g></g> <g><g class="terminal"><text
    x="84.25" y="373">l</text></g></g> <g><g class="terminal"><text x="84.25" y="403">m</text></g></g>
    <g><g class="terminal"><text x="84.25" y="433">n</text></g></g> <g><g class="terminal"><text
    x="84.25" y="463">o</text></g></g> <g><g class="terminal"><text x="84.25" y="493">p</text></g></g>
    <g><g class="terminal"><text x="84.25" y="523">q</text></g></g> <g><g class="terminal"><text
    x="84.25" y="553">r</text></g></g> <g><g class="terminal"><text x="84.25" y="583">s</text></g></g></g>
    <g><g><g class="terminal"><text x="172.75" y="283">B</text></g></g> <g><g class="terminal"><text
    x="172.75" y="253">A</text></g></g> <g><g class="terminal"><text x="172.75" y="223">z</text></g></g>
    <g><g class="terminal"><text x="172.75" y="193">y</text></g></g> <g><g class="terminal"><text
    x="172.75" y="163">x</text></g></g> <g><g class="terminal"><text x="172.75" y="133">w</text></g></g>
    <g><g class="terminal"><text x="172.75" y="103">v</text></g></g> <g><g class="terminal"><text
    x="172.75" y="73">u</text></g></g> <g><g class="terminal"><text x="172.75" y="43">t</text></g></g>
    <g><g class="terminal"><text x="172.75" y="313">C</text></g></g> <g><g class="terminal"><text
    x="172.75" y="343">D</text></g></g> <g><g class="terminal"><text x="172.75" y="373">E</text></g></g>
    <g><g class="terminal"><text x="172.75" y="403">F</text></g></g> <g><g class="terminal"><text
    x="172.75" y="433">G</text></g></g> <g><g class="terminal"><text x="172.75" y="463">H</text></g></g>
    <g><g class="terminal"><text x="172.75" y="493">I</text></g></g> <g><g class="terminal"><text
    x="172.75" y="523">J</text></g></g> <g><g class="terminal"><text x="172.75" y="553">K</text></g></g>
    <g><g class="terminal"><text x="172.75" y="583">L</text></g></g></g> <g><g><g
    class="terminal"><text x="261.25" y="283">U</text></g></g> <g><g class="terminal"><text
    x="261.25" y="253">T</text></g></g> <g><g class="terminal"><text x="261.25" y="223">S</text></g></g>
    <g><g class="terminal"><text x="261.25" y="193">R</text></g></g> <g><g class="terminal"><text
    x="261.25" y="163">Q</text></g></g> <g><g class="terminal"><text x="261.25" y="133">P</text></g></g>
    <g><g class="terminal"><text x="261.25" y="103">O</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">N</text></g></g> <g><g class="terminal"><text x="261.25" y="43">M</text></g></g>
    <g><g class="terminal"><text x="261.25" y="313">V</text></g></g> <g><g class="terminal"><text
    x="261.25" y="343">W</text></g></g> <g><g class="terminal"><text x="261.25" y="373">X</text></g></g>
    <g><g class="terminal"><text x="261.25" y="403">Y</text></g></g> <g><g class="terminal"><text
    x="261.25" y="433">Z</text></g></g> <g><g class="terminal"><text x="261.25" y="463">0</text></g></g>
    <g><g class="terminal"><text x="261.25" y="493">1</text></g></g> <g><g class="terminal"><text
    x="261.25" y="523">2</text></g></g> <g><g class="terminal"><text x="261.25" y="553">3</text></g></g>
    <g><g class="terminal"><text x="261.25" y="583">4</text></g></g></g> <g><g><g
    class="terminal"><text x="349.75" y="283">$</text></g></g> <g><g class="terminal"><text
    x="349.75" y="253">#</text></g></g> <g><g class="terminal"><text x="349.75" y="223">"</text></g></g>
    <g><g class="terminal"><text x="349.75" y="193">!</text></g></g> <g><g class="terminal"><text
    x="349.75" y="163">9</text></g></g> <g><g class="terminal"><text x="349.75" y="133">8</text></g></g>
    <g><g class="terminal"><text x="349.75" y="103">7</text></g></g> <g><g class="terminal"><text
    x="349.75" y="73">6</text></g></g> <g><g class="terminal"><text x="349.75" y="43">5</text></g></g>
    <g><g class="terminal"><text x="349.75" y="313">%</text></g></g> <g><g class="terminal"><text
    x="349.75" y="343">&</text></g></g> <g><g class="terminal"><text x="349.75" y="373">'</text></g></g>
    <g><g class="terminal"><text x="349.75" y="403">(</text></g></g> <g><g class="terminal"><text
    x="349.75" y="433">)</text></g></g> <g><g class="terminal"><text x="349.75" y="463">*</text></g></g>
    <g><g class="terminal"><text x="349.75" y="493">+</text></g></g> <g><g class="terminal"><text
    x="349.75" y="523">,</text></g></g> <g><g class="terminal"><text x="349.75" y="553">-</text></g></g>
    <g><g class="terminal"><text x="349.75" y="583">.</text></g></g></g> <g><g><g
    class="terminal"><text x="438.25" y="283">[</text></g></g> <g><g class="terminal"><text
    x="438.25" y="253">@</text></g></g> <g><g class="terminal"><text x="438.25" y="223">?</text></g></g>
    <g><g class="terminal"><text x="438.25" y="193">></text></g></g> <g><g class="terminal"><text
    x="438.25" y="163">=</text></g></g> <g><g class="terminal"><text x="438.25" y="133"><</text></g></g>
    <g><g class="terminal"><text x="438.25" y="103">;</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">:</text></g></g> <g><g class="terminal"><text x="438.25" y="43">/</text></g></g>
    <g><g class="terminal"><text x="438.25" y="313">\</text></g></g> <g><g class="terminal"><text
    x="438.25" y="343">]</text></g></g> <g><g class="terminal"><text x="438.25" y="373">^</text></g></g>
    <g><g class="terminal"><text x="438.25" y="403">_</text></g></g> <g><g class="terminal"><text
    x="438.25" y="433">`</text></g></g> <g><g class="terminal"><text x="438.25" y="463">{</text></g></g>
    <g><g class="terminal"><text x="438.25" y="493">|</text></g></g> <g><g class="terminal"><text
    x="438.25" y="523">}</text></g></g> <g><g class="terminal"><text x="438.25" y="553">~</text></g></g></g></g></g></svg>
- en: We generate `1000` values, and evaluate the `process_vehicle()` with each.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生成了`1000`个值，并用每个值评估`process_vehicle()`。
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is obviously not working. But why?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是不起作用的。但为什么呢？
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: None of the entries will get through unless the fuzzer can produce either `van`
    or `car`. Indeed, the reason is that the grammar itself does not capture the complete
    information about the format. So here is another idea. We modify the `GrammarFuzzer`
    to know a bit about our format.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 除非fuzzer能够生成`van`或`car`，否则没有任何条目能够通过。实际上，原因是语法本身并没有捕获关于格式的完整信息。所以这里有一个想法。我们修改`GrammarFuzzer`以了解我们的格式。
- en: '[PRE31]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Let us try again!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次！
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'At least we are getting somewhere! It would be really nice if *we could incorporate
    what we know about the sample data in our fuzzer.* In fact, it would be nice if
    we could *extract* the template and valid values from samples, and use them in
    our fuzzing. How do we do that? The quick answer to this question is: Use a *parser*.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们正在取得进展！如果*我们能够在我们的fuzzer中结合我们对样本数据的了解*，那就太好了。实际上，如果我们可以从样本中*提取*模板和有效值，并在我们的模糊测试中使用它们，那就更好了。我们如何做到这一点？对这个问题的快速回答是：使用*解析器*。
- en: Using a Parser
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用解析器
- en: 'Generally speaking, a *parser* is the part of a program that processes (structured)
    input. The parsers we discuss in this chapter transform an input string into a
    *derivation tree* (discussed in the [chapter on efficient grammar fuzzing](GrammarFuzzer.html)).
    From a user''s perspective, all it takes to parse an input is two steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，*解析器*是程序处理（结构化）输入的部分。我们本章讨论的解析器将输入字符串转换成*推导树*（在[关于高效语法模糊测试的章节](GrammarFuzzer.html)中讨论）。从用户的角度来看，解析输入只需要两个步骤：
- en: Initialize the parser with a grammar, as in
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用语法初始化解析器，如下所示
- en: '[PRE36]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using the parser to retrieve a list of derivation trees:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用解析器检索推导树列表：
- en: '[PRE37]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once we have parsed a tree, we can use it just as the derivation trees produced
    from grammar fuzzing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们解析了一个树，我们就可以像从语法模糊测试中产生的推导树一样使用它。
- en: We discuss a number of such parsers, in particular
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了许多这样的解析器，特别是
- en: '[parsing expression grammar parsers](#Parsing-Expression-Grammars) (`PEGParser`),
    which are very efficient, but limited to specific grammar structure; and'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解析表达式语法解析器](#Parsing-Expression-Grammars) (`PEGParser`)，它们非常高效，但仅限于特定的语法结构；'
- en: '[Earley parsers](#Parsing-Context-Free-Grammars) (`EarleyParser`), which accept
    any kind of context-free grammars.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Earley解析器](#Parsing-Context-Free-Grammars) (`EarleyParser`)，它接受任何类型的上下文无关语法。'
- en: If you just want to *use* parsers (say, because your main focus is testing),
    you can just stop here and move on [to the next chapter](LangFuzzer.html), where
    we learn how to make use of parsed inputs to mutate and recombine them. If you
    want to *understand* how parsers work, though, this chapter is right for you.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想*使用*解析器（比如说，因为你的主要重点是测试），你只需在这里停下来，继续[下一章](LangFuzzer.html)，在那里我们将学习如何利用解析输入来变异和重新组合它们。不过，如果你想*理解*解析器是如何工作的，那么这一章就是为你准备的。
- en: An Ad Hoc Parser
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 临时解析器
- en: As we saw in the previous section, programmers often have to extract parts of
    data that obey certain rules. For example, for *CSV* files, each element in a
    row is separated by *commas*, and multiple raws are used to store the data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，程序员经常必须提取遵循某些规则的数据部分。例如，对于*CSV*文件，每一行的元素之间由*逗号*分隔，并且使用多行来存储数据。
- en: To extract the information, we write an ad hoc parser `simple_parse_csv()`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提取信息，我们编写了一个临时的解析器`simple_parse_csv()`。
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We also change the default orientation of the graph to *left to right* rather
    than *top to bottom* for easier viewing using `lr_graph()`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更改了图表的默认方向，将其从*从上到下*改为*从左到右*，以便使用`lr_graph()`更容易查看。
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `display_tree()` shows the structure of our CSV file after parsing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`display_tree()`显示了我们的CSV文件在解析后的结构。'
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: <svg width="212pt" height="246pt" viewBox="0.00 0.00 212.00 246.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 242.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-112.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="98.25"
    y="-160.95" font-family="Times,serif" font-size="14.00">record 0</text></g> <g
    id="edge1" class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-64.95" font-family="Times,serif" font-size="14.00">record
    1</text></g> <g id="edge6" class="edge"><title>0->6</title></g> <g id="node3"
    class="node"><title>2</title> <text text-anchor="middle" x="180.38" y="-224.95"
    font-family="Times,serif" font-size="14.00">1997</text></g> <g id="edge2" class="edge"><title>1->2</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="180.38"
    y="-192.95" font-family="Times,serif" font-size="14.00">van</text></g> <g id="edge3"
    class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="180.38" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="180.38" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="180.38" y="-96.95" font-family="Times,serif" font-size="14.00">2000</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="180.38" y="-64.95" font-family="Times,serif" font-size="14.00">car</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="180.38" y="-32.95" font-family="Times,serif" font-size="14.00">Mercury</text></g>
    <g id="edge9" class="edge"><title>6->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="180.38" y="-0.95" font-family="Times,serif" font-size="14.00">Cougar</text></g>
    <g id="edge10" class="edge"><title>6->10</title></g></g></svg>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="212pt" height="246pt" viewBox="0.00 0.00 212.00 246.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 242.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-112.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="98.25"
    y="-160.95" font-family="Times,serif" font-size="14.00">record 0</text></g> <g
    id="edge1" class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-64.95" font-family="Times,serif" font-size="14.00">record
    1</text></g> <g id="edge6" class="edge"><title>0->6</title></g> <g id="node3"
    class="node"><title>2</title> <text text-anchor="middle" x="180.38" y="-224.95"
    font-family="Times,serif" font-size="14.00">1997</text></g> <g id="edge2" class="edge"><title>1->2</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="180.38"
    y="-192.95" font-family="Times,serif" font-size="14.00">van</text></g> <g id="edge3"
    class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="180.38" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="180.38" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="180.38" y="-96.95" font-family="Times,serif" font-size="14.00">2000</text></g>
    <g id="edge7" class="edge"><title>6->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="180.38" y="-64.95" font-family="Times,serif" font-size="14.00">car</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="180.38" y="-32.95" font-family="Times,serif" font-size="14.00">Mercury</text></g>
    <g id="edge9" class="edge"><title>6->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="180.38" y="-0.95" font-family="Times,serif" font-size="14.00">Cougar</text></g>
    <g id="edge10" class="edge"><title>6->10</title></g></g></svg>
- en: This is of course simple. What if we encounter slightly more complexity? Again,
    another example from the Wikipedia.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是简单的。如果我们遇到稍微复杂一些的情况呢？再次，另一个来自维基百科的例子。
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We define a new annotation method `highlight_node()` to mark the nodes that
    are interesting.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一种新的注释方法`highlight_node()`来标记有趣的节点。
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using `highlight_node()` we can highlight particular nodes that we were wrongly
    parsed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`highlight_node()`我们可以突出显示那些被错误解析的特定节点。
- en: '[PRE44]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <svg width="209pt" height="214pt" viewBox="0.00 0.00 209.00 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-96.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-96.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="178.88" y="-192.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="178.88" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="178.88" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="178.88" y="-96.95" font-family="Times,serif" font-size="14.00"
    fill="red">"ac</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g
    id="node7" class="node"><title>6</title> <text text-anchor="middle" x="178.88"
    y="-64.95" font-family="Times,serif" font-size="14.00" fill="red">abs</text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="178.88" y="-32.95" font-family="Times,serif" font-size="14.00"
    fill="red">moon"</text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="178.88"
    y="-0.95" font-family="Times,serif" font-size="14.00">3000.00</text></g> <g id="edge8"
    class="edge"><title>1->8</title></g></g></svg>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="209pt" height="214pt" viewBox="0.00 0.00 209.00 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-96.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-96.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="178.88" y="-192.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="178.88" y="-160.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="178.88" y="-128.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="178.88" y="-96.95" font-family="Times,serif" font-size="14.00"
    fill="red">"ac</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g
    id="node7" class="node"><title>6</title> <text text-anchor="middle" x="178.88"
    y="-64.95" font-family="Times,serif" font-size="14.00" fill="red">abs</text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="178.88" y="-32.95" font-family="Times,serif" font-size="14.00"
    fill="red">moon"</text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="178.88"
    y="-0.95" font-family="Times,serif" font-size="14.00">3000.00</text></g> <g id="edge8"
    class="edge"><title>1->8</title></g></g></svg>
- en: The marked nodes indicate where our parsing went wrong. We can of course extend
    our parser to understand quotes. First we define some of the helper functions
    `parse_quote()`, `find_comma()` and `comma_split()`
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的节点表示我们的解析出错的地方。我们当然可以扩展我们的解析器以理解引号。首先我们定义一些辅助函数`parse_quote()`、`find_comma()`和`comma_split()`
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can update our `parse_csv()` procedure to use our advanced quote parser.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的`parse_csv()`过程更新为使用我们的高级引号解析器。
- en: '[PRE50]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Our new `parse_csv()` can now handle quotes correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的`parse_csv()`现在可以正确处理引号。
- en: '[PRE51]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: <svg width="253pt" height="150pt" viewBox="0.00 0.00 253.25 150.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 146.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-64.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-64.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="201" y="-128.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="201" y="-96.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="201" y="-64.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="201" y="-32.95" font-family="Times,serif" font-size="14.00">"ac,
    abs, moon"</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7"
    class="node"><title>6</title> <text text-anchor="middle" x="201" y="-0.95" font-family="Times,serif"
    font-size="14.00">3000.00</text></g> <g id="edge6" class="edge"><title>1->6</title></g></g></svg>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="253pt" height="150pt" viewBox="0.00 0.00 253.25 150.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 146.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-64.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-64.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="201" y="-128.95" font-family="Times,serif" font-size="14.00">1997</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="201" y="-96.95" font-family="Times,serif" font-size="14.00">Ford</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="201" y="-64.95" font-family="Times,serif" font-size="14.00">E350</text></g>
    <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="201" y="-32.95" font-family="Times,serif" font-size="14.00">"ac,
    abs, moon"</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7"
    class="node"><title>6</title> <text text-anchor="middle" x="201" y="-0.95" font-family="Times,serif"
    font-size="14.00">3000.00</text></g> <g id="edge6" class="edge"><title>1->6</title></g></g></svg>
- en: 'That of course does not survive long:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不能长久地存活：
- en: '[PRE52]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A few embedded quotes are sufficient to confuse our parser again.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 几个嵌入的引号就足以再次让我们的解析器困惑。
- en: '[PRE54]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <svg width="321pt" height="168pt" viewBox="0.00 0.00 320.75 168.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 164.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-66.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-66.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="234.75" y="-146.95" font-family="Times,serif" font-size="14.00">1999</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="234.75" y="-114.95" font-family="Times,serif" font-size="14.00">Chevy</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-82.95" font-family="Times,serif" font-size="14.00"
    fill="red">"Venture \"Extended Edition</text></g> <g id="edge4" class="edge"><title>1->4</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="middle" x="234.75"
    y="-50.95" font-family="Times,serif" font-size="14.00" fill="red">Very Large\""</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="234.75" y="-0.95" font-family="Times,serif" font-size="14.00">5000.00</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g></g></svg>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="321pt" height="168pt" viewBox="0.00 0.00 320.75 168.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 164.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-66.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-66.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="234.75" y="-146.95" font-family="Times,serif" font-size="14.00">1999</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="234.75" y="-114.95" font-family="Times,serif" font-size="14.00">Chevy</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="234.75" y="-82.95" font-family="Times,serif" font-size="14.00"
    fill="red">"Venture \"Extended Edition</text></g> <g id="edge4" class="edge"><title>1->4</title></g>
    <g id="node6" class="node"><title>5</title> <text text-anchor="middle" x="234.75"
    y="-50.95" font-family="Times,serif" font-size="14.00" fill="red">Very Large\""</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node7" class="node"><title>6</title></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="234.75" y="-0.95" font-family="Times,serif" font-size="14.00">5000.00</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g></g></svg>
- en: 'Here is another record from that CSV file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是CSV文件中的另一个记录：
- en: '[PRE55]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: <svg width="259pt" height="214pt" viewBox="0.00 0.00 258.50 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-48.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-128.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-48.95" font-family="Times,serif" font-size="14.00"
    fill="red">record 1</text></g> <g id="edge6" class="edge"><title>0->6</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="98.25"
    y="-16.95" font-family="Times,serif" font-size="14.00" fill="red">record 2</text></g>
    <g id="edge10" class="edge"><title>0->10</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="203.62" y="-192.95" font-family="Times,serif" font-size="14.00">1996</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="203.62" y="-160.95" font-family="Times,serif" font-size="14.00">Jeep</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="203.62" y="-128.95" font-family="Times,serif" font-size="14.00">Grand
    Cherokee</text></g> <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6"
    class="node"><title>5</title> <text text-anchor="middle" x="203.62" y="-96.95"
    font-family="Times,serif" font-size="14.00" fill="red">"MUST SELL!</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="203.62" y="-64.95" font-family="Times,serif" font-size="14.00"
    fill="red">air</text></g> <g id="edge7" class="edge"><title>6->7</title></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="203.62"
    y="-32.95" font-family="Times,serif" font-size="14.00" fill="red">moon roof</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="203.62" y="-0.95" font-family="Times,serif" font-size="14.00"
    fill="red">loaded",4799.00</text></g> <g id="edge9" class="edge"><title>6->9</title></g></g></svg>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="259pt" height="214pt" viewBox="0.00 0.00 258.50 214.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 210.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="19.88"
    y="-48.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="98.25" y="-128.95"
    font-family="Times,serif" font-size="14.00">record 0</text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="98.25" y="-48.95" font-family="Times,serif" font-size="14.00"
    fill="red">record 1</text></g> <g id="edge6" class="edge"><title>0->6</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="98.25"
    y="-16.95" font-family="Times,serif" font-size="14.00" fill="red">record 2</text></g>
    <g id="edge10" class="edge"><title>0->10</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="203.62" y="-192.95" font-family="Times,serif" font-size="14.00">1996</text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="203.62" y="-160.95" font-family="Times,serif" font-size="14.00">Jeep</text></g>
    <g id="edge3" class="edge"><title>1->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="203.62" y="-128.95" font-family="Times,serif" font-size="14.00">Grand
    Cherokee</text></g> <g id="edge4" class="edge"><title>1->4</title></g> <g id="node6"
    class="node"><title>5</title> <text text-anchor="middle" x="203.62" y="-96.95"
    font-family="Times,serif" font-size="14.00" fill="red">"MUST SELL!</text></g>
    <g id="edge5" class="edge"><title>1->5</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="203.62" y="-64.95" font-family="Times,serif" font-size="14.00"
    fill="red">air</text></g> <g id="edge7" class="edge"><title>6->7</title></g> <g
    id="node9" class="node"><title>8</title> <text text-anchor="middle" x="203.62"
    y="-32.95" font-family="Times,serif" font-size="14.00" fill="red">moon roof</text></g>
    <g id="edge8" class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="203.62" y="-0.95" font-family="Times,serif" font-size="14.00"
    fill="red">loaded",4799.00</text></g> <g id="edge9" class="edge"><title>6->9</title></g></g></svg>
- en: Fixing this would require modifying both inner `parse_quote()` and the outer
    `parse_csv()` procedures. We note that each of these features actually documented
    in the CSV [RFC 4180](https://tools.ietf.org/html/rfc4180)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题需要修改内层的`parse_quote()`和外层的`parse_csv()`过程。我们注意到，这些特性实际上在CSV [RFC 4180](https://tools.ietf.org/html/rfc4180)中都有记录。
- en: Indeed, each additional improvement falls apart even with a little extra complexity.
    The problem becomes severe when one encounters recursive expressions. For example,
    JSON is a common alternative to CSV files for saving data. Similarly, one may
    have to parse data from an HTML table instead of a CSV file if one is getting
    the data from the web.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，任何额外的改进都会因为一点额外的复杂性而崩溃。当遇到递归表达式时，问题变得严重。例如，JSON是CSV文件的常见替代品，用于保存数据。同样，如果数据来自网络，可能不得不从HTML表格而不是CSV文件中解析数据。
- en: One might be tempted to fix it with a little more ad hoc parsing, with a bit
    of *regular expressions* thrown in. However, that is the [path to insanity](https://stackoverflow.com/a/1732454).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可能会倾向于用一点更具体的解析方法来修复它，加入一些*正则表达式*。然而，这却是[通向疯狂的道路](https://stackoverflow.com/a/1732454)。
- en: It is here that *formal parsers* shine. The main idea is that, any given set
    of strings belong to a language, and these languages can be specified by their
    grammars (as we saw in the [chapter on grammars](Grammars.html)). The great thing
    about grammars is that they can be *composed*. That is, one can introduce finer
    and finer details into an internal structure without affecting the external structure,
    and similarly, one can change the external structure without much impact on the
    internal structure.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正式解析器在这里大放异彩。主要思想是，任何给定的一组字符串属于一种语言，这些语言可以通过它们的语法来指定（正如我们在[语法章节](Grammars.html)中看到的）。语法的好处在于它们可以被*组合*。也就是说，可以在不影响外部结构的情况下，将更细致的细节引入内部结构，同样，也可以在不严重影响内部结构的情况下改变外部结构。
- en: Grammars in Parsing
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析中的语法
- en: We briefly describe grammars in the context of parsing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要描述了在解析上下文中的语法。
- en: <details id="Excursion:-Grammars-and-Derivation-Trees"><summary>Grammars and
    Derivation Trees</summary>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Grammars-and-Derivation-Trees"><summary>语法和推导树</summary>
- en: A grammar, as you have read from the [chapter on grammars](Grammars.html) is
    a set of *rules* that explain how the start symbol can be expanded. Each rule
    has a name, also called a *nonterminal*, and a set of *alternative choices* in
    how the nonterminal can be expanded.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[语法章节](Grammars.html)中读到的，语法是一组*规则*，它解释了起始符号如何被扩展。每条规则都有一个名称，也称为*非终结符*，以及一组非终结符可以如何扩展的*选择方案*。
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
- en: '[PRE61]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 296.5 122" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g>
    <g class="terminal"><text x="148.25" y="35">+</text></g> <g class="non-terminal"><text
    x="209.5" y="35">expr</text></g></g> <g><g class="non-terminal"><text x="87.0"
    y="65">expr</text></g> <g class="terminal"><text x="148.25" y="65">-</text></g>
    <g class="non-terminal"><text x="209.5" y="65">expr</text></g></g> <g><g class="non-terminal"><text
    x="148.25" y="95">integer</text></g></g></g></g></svg>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 296.5 122" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g>
    <g class="terminal"><text x="148.25" y="35">+</text></g> <g class="non-terminal"><text
    x="209.5" y="35">expr</text></g></g> <g><g class="non-terminal"><text x="87.0"
    y="65">expr</text></g> <g class="terminal"><text x="148.25" y="65">-</text></g>
    <g class="non-terminal"><text x="209.5" y="65">expr</text></g></g> <g><g class="non-terminal"><text
    x="148.25" y="95">integer</text></g></g></g></g></svg>
- en: '[PRE62]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
- en: '[PRE63]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: 'In the above expression, the rule `<expr> : [<expr>+<expr>,<expr>-<expr>,<integer>]`
    corresponds to how the nonterminal `<expr>` might be expanded. The expression
    `<expr>+<expr>` corresponds to one of the alternative choices. We call this an
    *alternative* expansion for the nonterminal `<expr>`. Finally, in an expression
    `<expr>+<expr>`, each of `<expr>`, `+`, and `<expr>` are *symbols* in that expansion.
    A symbol could be either a nonterminal or a terminal symbol based on whether its
    expansion is available in the grammar.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '在上述表达式中，规则`<expr> : [<expr>+<expr>,<expr>-<expr>,<integer>]`对应于非终结符`<expr>`可能如何扩展。表达式`<expr>+<expr>`对应于一种选择方案。我们称这种扩展为非终结符`<expr>`的*选择*扩展。最后，在表达式`<expr>+<expr>`中，`<expr>`、`+`和`<expr>`都是该扩展中的*符号*。根据其扩展是否在语法中可用，符号可以是非终结符或终结符。'
- en: 'Here is a string that represents an arithmetic expression that we would like
    to parse, which is specified by the grammar above:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个表示我们想要解析的算术表达式的字符串，该表达式由上面的语法指定：
- en: '[PRE64]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The *derivation tree* for our expression from this grammar is given by:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由这个语法得出的我们表达式的*推导树*如下所示：
- en: '[PRE65]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <svg width="174pt" height="274pt" viewBox="0.00 0.00 174.00 273.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 269.5)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="83" y="-252.2"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="83" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="27" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="139"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="139" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge10" class="edge"><title>9->10</title></g></g></svg>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="174pt" height="274pt" viewBox="0.00 0.00 174.00 273.50" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 269.5)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="83" y="-252.2"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="83" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="27" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node10" class="node"><title>9</title> <text text-anchor="middle" x="139"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge9"
    class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="139" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge10" class="edge"><title>9->10</title></g></g></svg>
- en: While a grammar can be used to specify a given language, there could be multiple
    grammars that correspond to the same language. For example, here is another grammar
    to describe the same addition expression.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然语法可以用来指定一种给定的语言，但可能存在多个语法对应于同一种语言。例如，这里还有一个语法来描述相同的加法表达式。
- en: '[PRE66]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 174.0 62" width="174.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="87.0" y="35">expr</text></g></g></g></g></svg>
- en: '[PRE69]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 282.0 62" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g>
    <g class="non-terminal"><text x="190.75" y="35">expr_</text></g></g></g></g></svg>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 282.0 62" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g>
    <g class="non-terminal"><text x="190.75" y="35">expr_</text></g></g></g></g></svg>
- en: '[PRE70]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 222.5 122" width="222.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">+</text></g>
    <g class="non-terminal"><text x="135.5" y="35">expr</text></g></g> <g><g class="terminal"><text
    x="74.25" y="65">-</text></g> <g class="non-terminal"><text x="135.5" y="65">expr</text></g></g></g></g></svg>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 222.5 122" width="222.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">+</text></g>
    <g class="non-terminal"><text x="135.5" y="35">expr</text></g></g> <g><g class="terminal"><text
    x="74.25" y="65">-</text></g> <g class="non-terminal"><text x="135.5" y="65">expr</text></g></g></g></g></svg>
- en: '[PRE71]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 290.5 62" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="186.5" y="35">integer_</text></g></g></g></g></svg>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 290.5 62" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="186.5" y="35">integer_</text></g></g></g></g></svg>
- en: '[PRE72]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 199.5 92" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g></g></g></g></svg>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 199.5 92" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">integer</text></g></g></g></g></svg>
- en: '[PRE73]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: 'The corresponding derivation tree is given by:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的推导树如下所示：
- en: '[PRE74]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: <svg width="278pt" height="324pt" viewBox="0.00 0.00 278.25 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="122.62"
    y="-302.45" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="122.62"
    y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="88.62" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="157.62" y="-201.95" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="20.62" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="89.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge5" class="edge"><title>2->5</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="20.62" y="-101.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="156.62" y="-151.7"
    font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="212.62"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge8"
    class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="177.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="246.62" y="-101.45" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge13" class="edge"><title>8->13</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="142.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="211.62" y="-51.2" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge12" class="edge"><title>9->12</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="142.62" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g></g></svg>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="278pt" height="324pt" viewBox="0.00 0.00 278.25 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="122.62"
    y="-302.45" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="122.62"
    y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="88.62" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="157.62" y="-201.95" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge6" class="edge"><title>1->6</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="20.62" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="89.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge5" class="edge"><title>2->5</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="20.62" y="-101.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge4" class="edge"><title>3->4</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="156.62" y="-151.7"
    font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge7" class="edge"><title>6->7</title></g>
    <g id="node9" class="node"><title>8</title> <text text-anchor="middle" x="212.62"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge8"
    class="edge"><title>6->8</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="177.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="246.62" y="-101.45" font-family="Times,serif" font-size="14.00"><expr_></text></g>
    <g id="edge13" class="edge"><title>8->13</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="142.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="211.62" y="-51.2" font-family="Times,serif" font-size="14.00"><integer_></text></g>
    <g id="edge12" class="edge"><title>9->12</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="142.62" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g></g></svg>
- en: Indeed, there could be different classes of grammars that describe the same
    language. For example, the first grammar `A1_GRAMMAR` is a grammar that sports
    both *right* and *left* recursion, while the second grammar `A2_GRAMMAR` does
    not have left recursion in the nonterminals in any of its productions, but contains
    *epsilon* productions. (An epsilon production is a production that has empty string
    in its right-hand side.)</details> <details id="Excursion:-Recursion"><summary>Recursion</summary>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，可能存在不同类别的语法来描述同一种语言。例如，第一个语法`A1_GRAMMAR`是一种同时具有*右递归*和*左递归*的语法，而第二个语法`A2_GRAMMAR`在其任何产生式中的非终结符中都没有左递归，但包含*ε产生式*。（ε产生式是指其右侧为空字符串的产生式。）</details>
    <details id="Excursion:-Recursion"><summary>递归</summary>
- en: You would have noticed that we reuse the term `<expr>` in its own definition.
    Using the same nonterminal in its own definition is called *recursion*. There
    are two specific kinds of recursion one should be aware of in parsing, as we see
    in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们在自己的定义中重复使用了术语`<expr>`。在自己的定义中使用相同的非终结符称为*递归*。在解析中，应该注意两种特定的递归类型，正如我们在下一节中看到的。
- en: Recursion
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 递归
- en: A grammar is *left recursive* if any of its nonterminals are left recursive,
    and a nonterminal is *directly left-recursive* if the left-most symbol of any
    of its productions is itself.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个语法的任何非终结符都是左递归的，则该语法是*左递归的*，如果一个非终结符的任何产生式的最左边符号本身，则该非终结符是*直接左递归的*。
- en: '[PRE75]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
- en: '[PRE78]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="terminal"><text x="122.75" y="35">a</text></g></g></g></g></svg>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="terminal"><text x="122.75" y="35">a</text></g></g></g></g></svg>
- en: '[PRE79]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: <svg width="130pt" height="173pt" viewBox="0.00 0.00 130.25 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="82.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="59.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="106.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge6"
    class="edge"><title>0->6</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="36.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="83.12" y="-51.2" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="13.12" y="-0.95" font-family="Times,serif"
    font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>2->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="60.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>2->4</title></g></g></svg>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="130pt" height="173pt" viewBox="0.00 0.00 130.25 173.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 169)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="82.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="59.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node7" class="node"><title>6</title> <text text-anchor="middle" x="106.12"
    y="-101.45" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge6"
    class="edge"><title>0->6</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="36.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="83.12" y="-51.2" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge5" class="edge"><title>1->5</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="13.12" y="-0.95" font-family="Times,serif"
    font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>2->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="60.12"
    y="-0.95" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>2->4</title></g></g></svg>
- en: A grammar is indirectly left-recursive if any of the left-most symbols can be
    expanded using their definitions to produce the nonterminal as the left-most symbol
    of the expansion. The left recursion is called a *hidden-left-recursion* if during
    the series of expansions of a nonterminal, one reaches a rule where the rule contains
    the same nonterminal after a prefix of other symbols, and these symbols can derive
    the empty string. For example, in `A1_GRAMMAR`, `<integer>` will be considered
    hidden-left recursive if `<digit>` could derive an empty string.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何最左边的符号可以通过其定义扩展为产生非终结符作为扩展的最左边符号，则语法是间接左递归的。如果在非终结符的连续扩展过程中，达到一个规则，该规则在其它符号的前缀之后包含相同的非终结符，并且这些符号可以推导出空字符串，则左递归被称为*隐藏左递归*。例如，在`A1_GRAMMAR`中，如果`<digit>`可以推导出空字符串，则`<integer>`将被认为是隐藏左递归的。
- en: Right recursive grammars are defined similarly. Below is the derivation tree
    for the right recursive grammar that represents the same language as that of `LR_GRAMMAR`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 右递归语法定义方式类似。下面是表示与`LR_GRAMMAR`相同语言的右递归语法的推导树。
- en: '[PRE80]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g></g></g></g></svg>
- en: '[PRE83]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g></g></g></g></svg>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g></g></g></g></svg>
- en: '[PRE84]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: <svg width="130pt" height="223pt" viewBox="0.00 0.00 130.25 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="39.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="39.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="16.12" y="-101.45" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="63.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="39.12"
    y="-51.2" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="86.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge5" class="edge"><title>3->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="62.12" y="-0.95" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="109.12" y="-0.95"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge7" class="edge"><title>5->7</title></g></g></svg>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="130pt" height="223pt" viewBox="0.00 0.00 130.25 223.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 219.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="39.12"
    y="-201.95" font-family="Times,serif" font-size="14.00"><start></text></g> <g
    id="node2" class="node"><title>1</title> <text text-anchor="middle" x="39.12"
    y="-151.7" font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge1"
    class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="16.12" y="-101.45" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4"
    class="node"><title>3</title> <text text-anchor="middle" x="63.12" y="-101.45"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge3" class="edge"><title>1->3</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="39.12"
    y="-51.2" font-family="Times,serif" font-size="14.00">a (97)</text></g> <g id="edge4"
    class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="86.12" y="-51.2" font-family="Times,serif" font-size="14.00"><A></text></g>
    <g id="edge5" class="edge"><title>3->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="62.12" y="-0.95" font-family="Times,serif" font-size="14.00">a
    (97)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="109.12" y="-0.95"
    font-family="Times,serif" font-size="14.00"><A></text></g> <g id="edge7" class="edge"><title>5->7</title></g></g></svg>
- en: Ambiguity
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二义性
- en: To complicate matters further, there could be multiple derivation trees – also
    called *parses* – corresponding to the same string from the same grammar. For
    example, a string `1+2+3` can be parsed in two ways as we see below using the
    `A1_GRAMMAR`
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使问题更加复杂，可能存在多个推导树——也称为*解析*——对应于同一语法中的同一字符串。例如，字符串`1+2+3`可以使用`A1_GRAMMAR`以两种方式解析，如下所示：
- en: '[PRE85]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="145" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="145" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="87" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="145" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge12" class="edge"><title>1->12</title></g> <g id="node14"
    class="node"><title>13</title> <text text-anchor="middle" x="202" y="-201.95"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge13" class="edge"><title>1->13</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge3"
    class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>2->8</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="138" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="138"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="138" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge14" class="edge"><title>13->14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="204"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="145" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="145" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="87" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node13" class="node"><title>12</title>
    <text text-anchor="middle" x="145" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge12" class="edge"><title>1->12</title></g> <g id="node14"
    class="node"><title>13</title> <text text-anchor="middle" x="202" y="-201.95"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge13" class="edge"><title>1->13</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge3"
    class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="83" y="-151.7" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="139" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>2->8</title></g>
    <g id="node5" class="node"><title>4</title> <text text-anchor="middle" x="27"
    y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="27" y="-0.95" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="138" y="-101.45" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="138"
    y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="138" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge14" class="edge"><title>13->14</title></g>
    <g id="node16" class="node"><title>15</title> <text text-anchor="middle" x="204"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
- en: '[PRE86]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="89" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="89" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="31" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="89" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="146" y="-201.95" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="92" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="148"
    y="-151.7" font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge12"
    class="edge"><title>7->12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge13" class="edge"><title>7->13</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="93" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="93" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="93" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-101.45"
    font-family="Times,serif" font-size="14.00"><integer></text></g> <g id="edge14"
    class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="239pt" height="324pt" viewBox="0.00 0.00 239.00 323.75" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 319.75)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="89" y="-302.45"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="89" y="-252.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="31" y="-201.95" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="89" y="-201.95" font-family="Times,serif" font-size="14.00">+
    (43)</text></g> <g id="edge6" class="edge"><title>1->6</title></g> <g id="node8"
    class="node"><title>7</title> <text text-anchor="middle" x="146" y="-201.95" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge7" class="edge"><title>1->7</title></g>
    <g id="node4" class="node"><title>3</title> <text text-anchor="middle" x="27"
    y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g> <g
    id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="27" y="-51.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge5" class="edge"><title>4->5</title></g> <g id="node9"
    class="node"><title>8</title> <text text-anchor="middle" x="92" y="-151.7" font-family="Times,serif"
    font-size="14.00"><expr></text></g> <g id="edge8" class="edge"><title>7->8</title></g>
    <g id="node13" class="node"><title>12</title> <text text-anchor="middle" x="148"
    y="-151.7" font-family="Times,serif" font-size="14.00">+ (43)</text></g> <g id="edge12"
    class="edge"><title>7->12</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="204" y="-151.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge13" class="edge"><title>7->13</title></g> <g id="node10" class="node"><title>9</title>
    <text text-anchor="middle" x="93" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge9" class="edge"><title>8->9</title></g> <g id="node11" class="node"><title>10</title>
    <text text-anchor="middle" x="93" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="93" y="-0.95" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node15"
    class="node"><title>14</title> <text text-anchor="middle" x="204" y="-101.45"
    font-family="Times,serif" font-size="14.00"><integer></text></g> <g id="edge14"
    class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="204" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="204" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge16" class="edge"><title>15->16</title></g></g></svg>
- en: There are many ways to resolve ambiguities. One approach taken by *Parsing Expression
    Grammars* explained in the next section is to specify a particular order of resolution,
    and choose the first one. Another approach is to simply return all possible derivation
    trees, which is the approach taken by *Earley parser* we develop later.</details>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以解决二义性。在下一节中解释的*解析表达式语法*采取的一种方法是指定特定的解决顺序，并选择第一个。另一种方法是简单地返回所有可能的生产树，这是我们稍后开发的*Earley解析器*采取的方法。</details>
- en: A Parser Class
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析器类
- en: Next, we develop different parsers. To do that, we define a minimal interface
    for parsing that is obeyed by all parsers. There are two approaches to parsing
    a string using a grammar.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开发不同的解析器。为了做到这一点，我们定义了一个所有解析器都必须遵守的最小解析接口。使用语法解析字符串有两种方法。
- en: The traditional approach is to use a *lexer* (also called a *tokenizer* or a
    *scanner*) to first tokenize the incoming string, and feed the grammar one token
    at a time. The lexer is typically a smaller parser that accepts a *regular language*.
    The advantage of this approach is that the grammar used by the parser can eschew
    the details of tokenization. Further, one gets a shallow derivation tree at the
    end of the parsing which can be directly used for generating the *Abstract Syntax
    Tree*.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传统的方法是使用一个*词法分析器*（也称为*标记器*或*扫描器*）首先对输入的字符串进行标记化，然后一次喂给语法一个标记。词法分析器通常是一个较小的解析器，它接受*正则语言*。这种方法的优势在于，解析器使用的语法可以避免标记化的细节。此外，在解析结束时，可以得到一个浅层推导树，可以直接用于生成*抽象语法树*。
- en: The second approach is to use a tree pruner after the complete parse. With this
    approach, one uses a grammar that incorporates complete details of the syntax.
    Next, the nodes corresponding to tokens are pruned and replaced with their corresponding
    strings as leaf nodes. The utility of this approach is that the parser is more
    powerful, and further there is no artificial distinction between *lexing* and
    *parsing*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是使用完整的解析后的树剪枝器。使用这种方法，一个人使用包含语法完整细节的语法。接下来，与标记对应的节点被剪枝，并用它们对应的字符串作为叶节点替换。这种方法的优势在于解析器更强大，并且没有人工区分*词法分析*和*解析*。
- en: In this chapter, we use the second approach. This approach is implemented in
    the `prune_tree` method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用第二种方法。这种方法在`prune_tree`方法中实现。
- en: The *Parser* class we define below provides the minimal interface. The main
    methods that need to be implemented by the classes implementing this interface
    are `parse_prefix` and `parse`. The `parse_prefix` returns a tuple, which contains
    the index until which parsing was completed successfully, and the parse forest
    until that index. The method `parse` returns a list of derivation trees if the
    parse was successful.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下面定义的`*Parser*`类提供了最小的接口。实现此接口的类需要实现的主要方法是`parse_prefix`和`parse`。`parse_prefix`返回一个元组，其中包含成功解析到的索引，以及直到该索引的解析森林。如果解析成功，`parse`方法返回一个推导树列表。
- en: '[PRE87]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: <details id="Excursion:-Canonical-Grammars"><summary>Canonical Grammars</summary>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Canonical-Grammars"><summary>规范语法</summary>
- en: The `EXPR_GRAMMAR` we import from the [chapter on grammars](Grammars.html) is
    oriented towards generation. In particular, the production rules are stored as
    strings. We need to massage this representation a little to conform to a *canonical
    representation* where each token in a rule is represented separately. The `canonical`
    format uses separate tokens to represent each symbol in an expansion.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[语法章节](Grammars.html)导入的`EXPR_GRAMMAR`面向生成。特别是，生成规则存储为字符串。我们需要稍微调整这种表示法，以符合*规范表示法*，其中每个规则中的每个标记都单独表示。`canonical`格式使用单独的标记来表示扩展中的每个符号。
- en: '[PRE88]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We also provide a convenience method for easier display of canonical grammars.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一种方便的方法，以便更容易地显示规范语法。
- en: '[PRE94]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We provide a way to revert a canonical expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一种回滚规范表达式的方法。
- en: '[PRE98]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: It is easier to work with the `canonical` representation during parsing. Hence,
    we update our parser class to store the `canonical` representation also.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析过程中使用`canonical`表示法更容易。因此，我们更新了我们的解析器类，以存储`canonical`表示法。
- en: '[PRE101]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We update the `prune_tree()` to account for the phony start symbol if it was
    insserted.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了`prune_tree()`以考虑如果插入了一个假起始符号。
- en: '[PRE102]</details>'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE102]'
- en: Parsing Expression Grammars
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析表达式语法
- en: A *[Parsing Expression Grammar](http://bford.info/pub/lang/peg)* (*PEG*) [[Ford
    *et al*, 2004](https://doi.org/10.1145/982962.964011)] is a type of *recognition
    based formal grammar* that specifies the sequence of steps to take to parse a
    given string. A *parsing expression grammar* is very similar to a *context-free
    grammar* (*CFG*) such as the ones we saw in the [chapter on grammars](Grammars.html).
    As in a CFG, a parsing expression grammar is represented by a set of nonterminals
    and corresponding alternatives representing how to match each. For example, here
    is a PEG that matches `a` or `b`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一种*[解析表达式语法](http://bford.info/pub/lang/peg)* (*PEG*) [[Ford *et al*, 2004](https://doi.org/10.1145/982962.964011)]
    是一种基于*识别*的形式语法，它指定了解析给定字符串所需的步骤序列。解析表达式语法与我们在[语法章节](Grammars.html)中看到的*上下文无关语法*
    (*CFG*)非常相似。与CFG一样，解析表达式语法由一组非终结符和相应的备选方案表示，这些备选方案表示如何匹配每个符号。例如，这里是一个匹配`a`或`b`的PEG。
- en: '[PRE103]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: However, unlike the *CFG*, the alternatives represent *ordered choice*. That
    is, rather than choosing all rules that can potentially match, we stop at the
    first match that succeed. For example, the below *PEG* can match `ab` but not
    `abc` unlike a *CFG* which will match both. (We call the sequence of ordered choice
    expressions *choice expressions* rather than alternatives to make the distinction
    from *CFG* clear.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与*CFG*不同，备选方案代表*有序选择*。也就是说，我们不会选择所有可能匹配的规则，而是在第一个成功匹配的地方停止。例如，下面的*PEG*可以匹配`ab`但不能匹配`abc`，而*CFG*会匹配两者。（我们称有序选择表达式的序列为*选择表达式*，而不是备选方案，以区分*CFG*。）
- en: '[PRE104]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Each choice in a *choice expression* represents a rule on how to satisfy that
    particular choice. The choice is a sequence of symbols (terminals and nonterminals)
    that are matched against a given text as in a *CFG*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*选择表达式* 中的每个选择代表满足该特定选择的方法规则。选择是一系列符号（终结符和非终结符），它们与给定的文本匹配，就像在 *CFG* 中一样。'
- en: Beyond the syntax of grammar definitions we have seen so far, a *PEG* can also
    contain a few additional elements. See the exercises at the end of the chapter
    for additional information.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们迄今为止看到的语法定义的语法之外，*PEG* 还可以包含一些额外的元素。有关更多信息，请参阅本章末尾的练习。
- en: The PEGs model the typical practice in handwritten recursive descent parsers,
    and hence it may be considered more intuitive to understand.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PEGs 模拟了手写递归下降解析器中的典型实践，因此它可能被认为更容易理解。
- en: The Packrat Parser for Predicate Expression Grammars
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于谓词表达式语法的 Packrat 解析器
- en: Short of hand rolling a parser, *Packrat* parsing is one of the simplest parsing
    techniques, and is one of the techniques for parsing PEGs. The *Packrat* parser
    is so named because it tries to cache all results from simpler problems in the
    hope that these solutions can be used to avoid re-computation later. We develop
    a minimal *Packrat* parser next.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在不手动编写解析器的情况下，*Packrat* 解析是一种最简单的解析技术之一，也是解析 PEGs 的技术之一。*Packrat* 解析器之所以得名，是因为它试图缓存所有简单问题的结果，希望这些解决方案可以在以后避免重新计算。我们接下来开发一个最小的
    *Packrat* 解析器。
- en: We derive from the `Parser` base class first, and we accept the text to be parsed
    in the `parse()` method, which in turn calls `unify_key()` with the `start_symbol`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从 `Parser` 基类派生，并在 `parse()` 方法中接受要解析的文本，该方法反过来调用 `unify_key()` 并使用 `start_symbol`。
- en: '**Note.** While our PEG parser can produce only a single unambiguous parse
    tree, other parsers can produce multiple parses for ambiguous grammars. Hence,
    we return a list of trees (in this case with a single element).'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意。**虽然我们的 PEG 解析器只能生成单个无歧义的解析树，但其他解析器可以为歧义语法生成多个解析。因此，我们返回一个树列表（在这种情况下只有一个元素）。'
- en: '[PRE105]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: <details id="Excursion:-Implementing-PEGParser"><summary>Implementing `PEGParser`</summary>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-PEGParser"><summary>实现 `PEGParser`</summary>
- en: Unify Key
  id: totrans-264
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 统一键
- en: The `unify_key()` algorithm is simple. If given a terminal symbol, it tries
    to match the symbol with the current position in the text. If the symbol and text
    match, it returns successfully with the new parse index `at`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`unify_key()` 算法很简单。如果给定一个终结符，它尝试将符号与文本中的当前位置匹配。如果符号和文本匹配，它成功返回新的解析索引 `at`。'
- en: If on the other hand, it was given a nonterminal, it retrieves the choice expression
    corresponding to the key, and tries to match each choice *in order* using `unify_rule()`.
    If **any** of the rules succeed in being unified with the given text, the parse
    is considered a success, and we return with the new parse index returned by `unify_rule()`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一方面，它被给了一个非终结符，它检索与键对应的选项表达式，并尝试使用 `unify_rule()` 按顺序匹配每个选择。如果 **任何** 规则成功与给定的文本统一化，则解析被认为是成功的，我们返回
    `unify_rule()` 返回的新解析索引。
- en: '[PRE106]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Unify Rule
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 统一规则
- en: The `unify_rule()` method is similar. It retrieves the tokens corresponding
    to the rule that it needs to unify with the text, and calls `unify_key()` on them
    in sequence. If **all** tokens are successfully unified with the text, the parse
    is a success.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`unify_rule()` 方法类似。它检索需要与文本统一化的规则对应的标记，并按顺序对它们调用 `unify_key()`。如果 **所有** 标记都成功地与文本统一化，则解析成功。'
- en: '[PRE113]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The two methods are mutually recursive, and given that `unify_key()` tries each
    alternative until it succeeds, `unify_key` can be called multiple times with the
    same arguments. Hence, it is important to memoize the results of `unify_key`.
    Python provides a simple decorator `lru_cache` for memoizing any function call
    that has hashable arguments. We add that to our implementation so that repeated
    calls to `unify_key()` with the same argument get cached results.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法是相互递归的，鉴于 `unify_key()` 尝试每个替代方案直到成功，`unify_key` 可以多次用相同的参数调用。因此，记忆化 `unify_key`
    的结果非常重要。Python 提供了一个简单的装饰器 `lru_cache`，用于记忆化任何具有可哈希参数的函数调用。我们将它添加到我们的实现中，以便重复调用
    `unify_key()` 与相同的参数时获取缓存的结果。
- en: This memoization gives the algorithm its name – *Packrat*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种记忆化赋予了算法其名称 – *Packrat*。
- en: '[PRE122]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We wrap initialization and calling of `PEGParser` in a method `parse()` already
    implemented in the `Parser` base class that accepts the text to be parsed along
    with the grammar.</details>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `PEGParser` 的初始化和调用封装在 `Parser` 基类中已经实现的 `parse()` 方法中，该方法接受要解析的文本以及语法。</details>
- en: Here are a few examples of our parser in action.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们解析器在行动中的例子。
- en: '[PRE124]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
- en: '[PRE125]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
- en: One should be aware that while the grammar looks like a *CFG*, the language
    described by a *PEG* may be different. Indeed, only *LL(1)* grammars are guaranteed
    to represent the same language for both PEGs and other parsers. Behavior of PEGs
    for other classes of grammars could be surprising [[Redziejowski *et al*, 2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)].
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 应该意识到，虽然语法看起来像是一个 *CFG*，但由 *PEG* 描述的语言可能不同。实际上，只有 *LL(1)* 文法才能保证 PEG 和其他解析器表示相同的语言。对于其他类别的文法，PEG
    的行为可能会令人惊讶 [[Redziejowski 等人，2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)]。
- en: Parsing Context-Free Grammars
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析上下文无关文法
- en: Problems with PEG
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PEG 的问题
- en: 'While *PEGs* are simple at first sight, their behavior in some cases might
    be a bit unintuitive. For example, here is an example [[Redziejowski *et al*,
    2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)]:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *PEG* 在表面上看起来很简单，但它们在某些情况下的行为可能有点不直观。例如，这里有一个例子 [[Redziejowski 等人，2008](http://dl.acm.org/citation.cfm?id=2365896.2365924)]：
- en: '[PRE126]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: When interpreted as a *CFG* and used as a string generator, it will produce
    strings of the form `aa, aaaa, aaaaaa` that is, it produces strings where the
    number of `a` is $ 2*n $ where $ n > 0 $.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当将其解释为 *CFG* 并用作字符串生成器时，它将产生形式为 `aa, aaaa, aaaaaa` 的字符串，即它产生 `a` 的数量为 $ 2*n
    $（其中 $ n > 0 $）的字符串。
- en: '[PRE127]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: However, the *PEG* parser can only recognize strings of the form $2^n$
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*PEG* 解析器只能识别形式为 $2^n$ 的字符串
- en: '[PRE129]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This is not the only problem with *Parsing Expression Grammars*. While *PEGs*
    are expressive and the *packrat* parser for parsing them is simple and intuitive,
    *PEGs* suffer from a major deficiency for our purposes. *PEGs* are oriented towards
    language recognition, and it is not clear how to translate an arbitrary *PEG*
    to a *CFG*. As we mentioned earlier, a naive re-interpretation of a *PEG* as a
    *CFG* does not work very well. Further, it is not clear what is the exact relation
    between the class of languages represented by *PEG* and the class of languages
    represented by *CFG*. Since our primary focus is *fuzzing* – that is *generation*
    of strings – , we next look at *parsers that can accept context-free grammars*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是 *解析表达式文法* 的唯一问题。虽然 *PEG* 表达能力强，并且用于解析它们的 *packrat* 解析器简单直观，但 *PEG* 在我们的目的上存在一个主要的缺陷。*PEG*
    旨在进行语言识别，并且不清楚如何将任意的 *PEG* 转换为 *CFG*。正如我们之前提到的，将 *PEG* 作为 *CFG* 的天真重新解释并不奏效。此外，不清楚由
    *PEG* 表示的语言类与由 *CFG* 表示的语言类之间的确切关系。由于我们的主要重点是 *fuzzing*（即字符串的生成），我们接下来将查看 *可以接受上下文无关文法的解析器*。
- en: 'The general idea of *CFG* parser is the following: Peek at the input text for
    the allowed number of characters, and use these, and our parser state to determine
    which rules can be applied to complete parsing. We next look at a typical *CFG*
    parsing algorithm, the Earley Parser.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '*CFG* 解析器的一般思想如下：查看输入文本中允许的字符数，并使用这些字符以及我们的解析器状态来确定哪些规则可以应用于完成解析。接下来，我们将查看一个典型的
    *CFG* 解析算法，即 Earley 解析器。'
- en: The Earley Parser
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 耳语法分析器
- en: The Earley parser is a general parser that is able to parse any arbitrary *CFG*.
    It was invented by Jay Earley [[Earley *et al*, 1970](https://doi.org/10.1145/362007.362035)]
    for use in computational linguistics. While its computational complexity is $O(n^3)$
    for parsing strings with arbitrary grammars, it can parse strings with unambiguous
    grammars in $O(n^2)$ time, and all *[LR(k)](https://en.wikipedia.org/wiki/LR_parser)*
    grammars in linear time ($O(n)$ [[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)]).
    Further improvements – notably handling epsilon rules – were invented by Aycock
    et al. [John Aycock *et al*, 2002].
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Earley 解析器是一种通用解析器，能够解析任何任意的 *CFG*。它是由 Jay Earley [[Earley 等人，1970](https://doi.org/10.1145/362007.362035)]
    发明的，用于计算语言学。虽然对于具有任意文法的字符串解析，其计算复杂度为 $O(n^3)$，但它可以在 $O(n^2)$ 时间内解析具有无歧义文法的字符串，并且可以在线性时间（$O(n)$）内解析所有
    *[LR(k)](https://en.wikipedia.org/wiki/LR_parser)* 文法 [[Joop M.I.M. Leo，1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)]。进一步的改进——特别是处理
    ε 规则——是由 Aycock 等人发明的 [John Aycock 等人，2002]。
- en: Note that one restriction of our implementation is that the start symbol can
    have only one alternative in its alternative expressions. This is not a restriction
    in practice because any grammar with multiple alternatives for its start symbol
    can be extended with a new start symbol that has the original start symbol as
    its only choice. That is, given a grammar as below,
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实现的一个限制是，起始符号在其备选表达式中只能有一个备选方案。这在实践中并不是一个限制，因为任何具有多个起始符号备选方案的语法都可以通过添加一个新的起始符号来扩展，该起始符号只选择原始起始符号。也就是说，给定以下语法，
- en: '[PRE132]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: one may rewrite it as below to conform to the *single-alternative* rule.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将其重写如下以符合 *单备选方案* 规则。
- en: '[PRE133]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Let us implement a class `EarleyParser`, again derived from `Parser` which implements
    an Earley parser.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个名为 `EarleyParser` 的类，它再次从 `Parser` 类派生，而 `Parser` 类实现了 Earley 解析器。
- en: <details id="Excursion:-Implementing-EarleyParser"><summary>Implementing `EarleyParser`</summary>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <details id="Excursion:-Implementing-EarleyParser"><summary>实现 `EarleyParser`</summary>
- en: We first implement a simpler parser that is a parser for nearly all *CFGs*,
    but not quite. In particular, our parser does not understand *epsilon rules* –
    rules that derive empty string. We show later how the parser can be extended to
    handle these.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先实现一个更简单的解析器，它几乎适用于所有 *CFGs*，但并不完全。特别是，我们的解析器不理解 *epsilon rules* – 产生空字符串的规则。我们稍后展示如何扩展解析器来处理这些规则。
- en: We use the following grammar in our examples below.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在下面的示例中使用以下语法。
- en: '[PRE134]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 197.0 62" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g></g></g></g></svg>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 197.0 62" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g></g></g></g></svg>
- en: '[PRE137]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 245.5 92" width="245.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g> <g class="terminal"><text
    x="171.25" y="35">c</text></g></g> <g><g class="terminal"><text x="98.5" y="65">a</text></g>
    <g class="non-terminal"><text x="147.0" y="65">A</text></g></g></g></g></svg>
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 245.5 92" width="245.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g>
    <g class="non-terminal"><text x="122.75" y="35">B</text></g> <g class="terminal"><text
    x="171.25" y="35">c</text></g></g> <g><g class="terminal"><text x="98.5" y="65">a</text></g>
    <g class="non-terminal"><text x="147.0" y="65">A</text></g></g></g></g></svg>
- en: '[PRE138]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">b</text></g>
    <g class="non-terminal"><text x="122.75" y="35">C</text></g></g> <g><g class="non-terminal"><text
    x="98.5" y="65">D</text></g></g></g></g></svg>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 197.0 92" width="197.0"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">b</text></g>
    <g class="non-terminal"><text x="122.75" y="35">C</text></g></g> <g><g class="non-terminal"><text
    x="98.5" y="65">D</text></g></g></g></g></svg>
- en: '[PRE139]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">c</text></g></g></g></g></svg>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">c</text></g></g></g></g></svg>
- en: '[PRE140]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">d</text></g></g></g></g></svg>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">d</text></g></g></g></g></svg>
- en: 'The basic idea of Earley parsing is the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Earley 解析的基本思想如下：
- en: Start with the alternative expressions corresponding to the START_SYMBOL. These
    represent the possible ways to parse the string from a high level. Essentially
    each expression represents a parsing path. Queue each expression in our set of
    possible parses of the string. The parsed index of an expression is the part of
    expression that has already been recognized. In the beginning of parse, the parsed
    index of all expressions is at the beginning. Further, each letter gets a queue
    of expressions that recognizes that letter at that point in our parse.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从与 START_SYMBOL 对应的备选表达式开始。这些代表从高层次解析字符串的可能方式。本质上，每个表达式代表一个解析路径。将我们字符串的可能解析集的每个表达式排队。一个表达式的解析索引是已经识别的表达式部分。在解析的开始，所有表达式的解析索引都在开始处。此外，每个字母都得到一个表达式队列，该队列识别我们在解析中的该点的字母。
- en: Examine our queue of possible parses and check if any of them start with a nonterminal.
    If it does, then that nonterminal needs to be recognized from the input before
    the given rule can be parsed. Hence, add the alternative expressions corresponding
    to the nonterminal to the queue. Do this recursively.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们可能的解析队列，看是否有任何以非终结符开始的。如果是这样，那么在解析给定的规则之前，需要从输入中识别出该非终结符。因此，将对应于非终结符的备选表达式添加到队列中。递归地这样做。
- en: At this point, we are ready to advance. Examine the current letter in the input,
    and select all expressions that have that particular letter at the parsed index.
    These expressions can now advance one step. Advance these selected expressions
    by incrementing their parsed index and add them to the queue of expressions in
    line for recognizing the next input letter.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到这一点，我们已准备好前进。检查输入中的当前字母，并选择所有在解析索引处具有该特定字母的表达式。这些表达式现在可以前进一步。通过增加它们的解析索引并将它们添加到准备识别下一个输入字母的表达式队列中来实现这些选择的表达式。
- en: If while doing these things, we find that any of the expressions have finished
    parsing, we fetch its corresponding nonterminal, and advance all expressions that
    have that nonterminal at their parsed index.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在执行这些操作时，我们发现任何表达式已经完成解析，我们就获取其相应的非终结符，并前进所有在其解析索引处具有该非终结符的表达式。
- en: Continue this procedure recursively until all expressions that we have queued
    for the current letter have been processed. Then start processing the queue for
    the next letter.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归地继续此过程，直到我们为当前字母排队的所有表达式都已被处理。然后开始处理下一个字母的队列。
- en: We explain each step in detail with examples in the coming sections.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中通过示例详细解释每个步骤。
- en: The parser uses dynamic programming to generate a table containing a *forest
    of possible parses* at each letter index – the table contains as many columns
    as there are letters in the input, and each column contains different parsing
    rules at various stages of the parse.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器使用动态规划在每个字母索引处生成一个包含可能解析的 *森林* 的表 – 表中有与输入中字母数量一样多的列，并且每列包含解析的各个阶段的不同的解析规则。
- en: 'For example, given an input `adcd`, the Column 0 would contain the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定输入`adcd`，第0列将包含以下内容：
- en: '[PRE141]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: which is the starting rule that indicates that we are currently parsing the
    rule `<start>`, and the parsing state is just before identifying the symbol `<A>`.
    It would also contain the following which are two alternative paths it could take
    to complete the parsing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是起始规则，表示我们目前正在解析规则`<start>`，解析状态是在识别符号`<A>`之前。它还会包含以下内容，这是它可能采取的两个完成解析的路径。
- en: '[PRE142]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Column 1 would contain the following, which represents the possible completion
    after reading `a`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 第1列将包含以下内容，这代表了读取`a`后的可能完成情况。
- en: '[PRE143]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Column 2 would contain the following after reading `d`
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取`d`之后，第2列将包含以下内容
- en: '[PRE144]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Similarly, Column 3 would contain the following after reading `c`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在读取`c`之后，第3列将包含以下内容
- en: '[PRE145]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Finally, Column 4 would contain the following after reading `d`, with the `●`
    at the end of the `<start>` rule indicating that the parse was successful.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在读取`d`之后，第4列将包含以下内容，其中`<start>`规则末尾的`●`表示解析成功。
- en: '[PRE146]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As you can see from above, we are essentially filling a table (a table is also
    called a **chart**) of entries based on each letter we read, and the grammar rules
    that can be applied. This chart gives the parser its other name -- Chart parsing.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们实际上是在根据我们读取的每个字母和可以应用的语言规则填充一个表（这个表也称为**图表**）的条目。这个图表给了解析器它的另一个名字——图表解析。
- en: Columns
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: We define the `Column` first. The `Column` is initialized by its own `index`
    in the input string, and the `letter` at that index. Internally, we also keep
    track of the states that are added to the column as the parsing progresses.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`Column`。`Column`通过其在输入字符串中的`index`和该索引处的`letter`进行初始化。内部上，我们也会随着解析的进行跟踪添加到列中的状态。
- en: '[PRE147]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The `Column` only stores unique `states`. Hence, when a new `state` is `added`
    to our `Column`, we check whether it is already known.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`只存储唯一的`states`。因此，当一个新的`state`被添加到我们的`Column`中时，我们会检查它是否已知。'
- en: '[PRE148]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Items
  id: totrans-357
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项
- en: An item represents a *parse in progress for a specific rule.* Hence the item
    contains the name of the nonterminal, and the corresponding alternative expression
    (`expr`) which together form the rule, and the current position of parsing in
    this expression -- `dot`.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 项表示对特定规则的*解析过程中的解析*。因此，项包含非终端名称和相应的替代表达式（`expr`），它们共同形成规则，以及在这个表达式中的当前解析位置——`dot`。
- en: '**Note.** If you are familiar with [LR parsing](https://en.wikipedia.org/wiki/LR_parser),
    you will notice that an item is simply an `LR0` item.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意。**如果你熟悉[LR解析](https://en.wikipedia.org/wiki/LR_parser)，你会注意到一个项只是一个`LR0`项。'
- en: '[PRE149]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We also provide a few convenience methods. The method `finished()` checks if
    the `dot` has moved beyond the last element in `expr`. The method `advance()`
    produces a new `Item` with the `dot` advanced one token, and represents an advance
    of the parsing. The method `at_dot()` returns the current symbol being parsed.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了一些便利方法。`finished()`方法检查`dot`是否已经移动到`expr`的最后一个元素之外。`advance()`方法产生一个新的`Item`，其中`dot`向前移动一个标记，表示解析的推进。`at_dot()`方法返回当前正在解析的符号。
- en: '[PRE150]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here is how an item could be used. We first define our item
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用项的一个例子。我们首先定义我们的项
- en: '[PRE151]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: To determine where the status of parsing, we use `at_dot()`
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定解析的状态，我们使用`at_dot()`
- en: '[PRE152]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: That is, the next symbol to be parsed is `<D>`
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是下一个要解析的符号是`<D>`
- en: If we advance the item, we get another item that represents the finished parsing
    rule `<B>`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们推进项，我们会得到另一个表示完成解析规则`<B>`的项。
- en: '[PRE154]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: States
  id: totrans-373
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 状态
- en: For `Earley` parsing, the state of the parsing is simply one `Item` along with
    some meta information such as the starting `s_col` and ending column `e_col` for
    each state. Hence we inherit from `Item` to create a `State`. Since we are interested
    in comparing states, we define `hash()` and `eq()` with the corresponding methods.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Earley`解析，解析状态仅仅是与每个状态的起始`s_col`和结束列`e_col`等一些元信息相关的`Item`。因此，我们通过继承`Item`来创建`State`。由于我们感兴趣的是比较状态，我们定义了`hash()`和`eq()`方法。
- en: '[PRE157]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The usage of `State` is similar to that of `Item`. The only difference is that
    it is used along with the `Column` to track the parsing state. For example, we
    initialize the first column as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`State`的使用与`Item`类似。唯一的区别是它用于与`Column`一起跟踪解析状态。例如，我们如下初始化第一列：'
- en: '[PRE158]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: The first column is then updated by using `add()` method of `Column`
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过使用`Column`的`add()`方法更新第一列。
- en: '[PRE160]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The Parsing Algorithm
  id: totrans-382
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析算法
- en: The *Earley* algorithm starts by initializing the chart with columns (as many
    as there are letters in the input). We also seed the first column with a state
    representing the expression corresponding to the start symbol. In our case, the
    state corresponds to the start symbol with the `dot` at `0` is represented as
    below. The `●` symbol represents the parsing status. In this case, we have not
    parsed anything.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '*Earley*算法首先通过将列（与输入中的字母数量一样多）初始化到图表中开始。我们还用表示对应于起始符号的表达式的状态初始化第一列。在我们的例子中，状态对应于起始符号，其中`点`位于`0`，表示如下。`●`符号代表解析状态。在这种情况下，我们还没有解析任何内容。'
- en: '[PRE162]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: We pass this partial chart to a method for filling the rest of the parse chart.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个部分图表传递给一个用于填充解析图表其余部分的方法。
- en: Before starting to parse, we seed the chart with the state representing the
    ongoing parse of the start symbol.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解析之前，我们用表示起始符号的当前解析状态初始化图表。
- en: '[PRE163]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: The main parsing loop in `fill_chart()` has three fundamental operations. `predict()`,
    `scan()`, and `complete()`. We discuss `predict` next.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill_chart()`中的主要解析循环有三个基本操作：`predict()`、`scan()`和`complete()`。我们接下来讨论`predict`。'
- en: Predicting States
  id: totrans-389
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 预测状态
- en: We have already seeded `chart[0]` with a state `[<A>,<B>]` with `dot` at `0`.
    Next, given that `<A>` is a nonterminal, we `predict` the possible parse continuations
    of this state. That is, it could be either `a <B> c` or `A <A>`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用状态`[<A>,<B>]`和`点`在`0`的位置初始化了`chart[0]`。接下来，鉴于`<A>`是一个非终结符，我们`predict`这个状态的可能的解析延续。也就是说，它可以是`a
    <B> c`或`A <A>`。
- en: 'The general idea of `predict()` is as follows: Say you have a state with name
    `<A>` from the above grammar, and expression containing `[a,<B>,c]`. Imagine that
    you have seen `a` already, which means that the `dot` will be on `<B>`. Below,
    is a representation of our parse status. The left-hand side of ● represents the
    portion already parsed (`a`), and the right-hand side represents the portion yet
    to be parsed (`<B> c`).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`predict()`的一般思想如下：假设你有一个名为`<A>`的状态，来自上面的语法，包含表达式`[a,<B>,c]`。想象一下你已经看到了`a`，这意味着`点`将位于`<B>`上。下面是我们解析状态的一个表示。●的左侧代表已经解析的部分（`a`），右侧代表尚未解析的部分（`<B>
    c`）。'
- en: '[PRE164]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: To recognize `<B>`, we look at the definition of `<B>`, which has different
    alternative expressions. The `predict()` step adds each of these alternatives
    to the set of states, with `dot` at `0`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别`<B>`，我们查看`<B>`的定义，它有不同的可选表达式。`predict()`步骤将每个这些可选表达式添加到状态的集合中，`点`位于`0`。
- en: '[PRE165]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: In essence, the `predict()` method, when called with the current nonterminal,
    fetches the alternative expressions corresponding to this nonterminal, and adds
    these as predicted *child* states to the *current* column.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，当用当前非终结符调用`predict()`方法时，它会获取与这个非终结符对应的可选表达式，并将这些作为预测的*子状态*添加到*当前*列。
- en: '[PRE166]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: To see how to use `predict`, we first construct the 0th column as before, and
    we assign the constructed column to an instance of the EarleyParser.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用`predict`，我们首先像之前一样构建第0列，并将构建的列分配给一个`EarleyParser`的实例。
- en: '[PRE167]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: It should contain a single state -- `<start> at 0`
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该包含一个单一的状态——`<start> at 0`。
- en: '[PRE168]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: We apply `predict()` to fill out the 0th column, and the column should contain
    the possible parse paths.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用`predict()`来填充第0列，该列应包含可能的解析路径。
- en: '[PRE170]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Scanning Tokens
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 扫描标记
- en: 'What if rather than a nonterminal, the state contained a terminal symbol such
    as a letter? In that case, we are ready to make some progress. For example, consider
    the second state:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态中包含的不是非终结符，而是一个终结符，比如一个字母呢？在这种情况下，我们就可以取得一些进展了。例如，考虑第二个状态：
- en: '[PRE172]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: We `scan` the next column's letter. Say the next token is `b`. If the letter
    matches what we have, then create a new state by advancing the current state by
    one letter.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扫描下一列的字母。假设下一个标记是`b`。如果字母与我们已有的匹配，则通过将当前状态向前移动一个字母来创建一个新的状态。
- en: '[PRE173]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This new state is added to the next column (i.e the column that has the matched
    letter).
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新状态被添加到下一列（即匹配字母所在的列）。
- en: '[PRE174]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: As before, we construct the partial parse first, this time adding a new column
    so that we can observe the effects of `scan()`
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们首先构建部分解析，这次添加一个新列，这样我们就可以观察`scan()`的效果。
- en: '[PRE175]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Completing Processing
  id: totrans-418
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完成处理
- en: When we advance, what if we actually `complete()` the processing of the current
    rule? If so, we want to update not just this state, but also all the *parent*
    states from which this state was derived. For example, say we have states as below.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们前进时，如果我们实际上`complete()`当前规则的解析处理怎么办？如果是这样，我们不仅想更新这个状态，还想更新所有*父状态*，这些状态是从这个状态派生出来的。例如，假设我们有以下状态。
- en: '[PRE180]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The state `<B>: b c ●` is now complete. So, we need to advance `<A>: a ● <B>
    c` one step forward.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '状态`<B>: b c ●`现在已完成。因此，我们需要将`<A>: a ● <B> c`向前推进一步。'
- en: How do we determine the parent states? Note from `predict` that we added the
    predicted child states to the *same* column as that of the inspected state. Hence,
    we look at the starting column of the current state, with the same symbol `at_dot`
    as that of the name of the completed state.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定父状态？注意从`predict`中，我们将预测的子状态添加到与检查状态相同的列。因此，我们查看当前状态的起始列，具有与完成状态名称相同的符号`at_dot`。
- en: For each such parent found, we advance that parent (because we have just finished
    parsing that nonterminal for their `at_dot`) and add the new states to the current
    column.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于找到的每个此类父状态，我们前进该父状态（因为我们刚刚完成了它们的`at_dot`的非终结符解析）并将新状态添加到当前列。
- en: '[PRE181]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Here is an example of completed processing. First we complete the Column 0
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完成处理的例子。首先我们完成第0列。
- en: '[PRE182]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Then we use `scan()` to populate Column 1
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`scan()`来填充第1列。
- en: '[PRE184]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Then we use `scan()` again to populate Column 2
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们再次使用`scan()`来填充第2列。
- en: '[PRE188]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Now, we can use `complete()`:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`complete()`：
- en: '[PRE190]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Filling the Chart
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 填充图表
- en: The main driving loop in `fill_chart()` essentially calls these operations in
    order. We loop over each column in order.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill_chart()`中的主要驱动循环基本上按顺序调用这些操作。我们按顺序遍历每一列。'
- en: For each column, fetch one state in the column at a time, and check if the state
    is `finished`.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一列，一次获取列中的一个状态，并检查该状态是否为`finished`。
- en: If it is, then we `complete()` all the parent states depending on this state.
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，那么我们`complete()`依赖于此状态的所有父状态。
- en: If the state was not finished, we check to see if the state's current symbol
    `at_dot` is a nonterminal.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态未完成，我们检查该状态当前符号`at_dot`是否为非终结符。
- en: If it is a nonterminal, we `predict()` possible continuations, and update the
    current column with these states.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是非终结符，我们`predict()`可能的延续，并使用这些状态更新当前列。
- en: If it was not, we `scan()` the next column and advance the current state if
    it matches the next letter.
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，我们`scan()`下一个列，并在它匹配下一个字母时前进当前状态。
- en: '[PRE192]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: We now can recognize a given string as belonging to a language represented by
    a grammar.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以识别一个给定的字符串属于由语法表示的语言。
- en: '[PRE193]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: The chart we printed above only shows completed entries at each index. The parenthesized
    expression indicates the column just before the first character was recognized,
    and the ending column.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印的图表只显示了每个索引处的完成条目。括号内的表达式表示识别第一个字符之前的列，以及结束列。
- en: Notice how the `<start>` nonterminal shows fully parsed status.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`<start>`非终结符如何显示完全解析的状态。
- en: '[PRE195]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Since `chart_parse()` returns the completed table, we now need to extract the
    derivation trees.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`chart_parse()`返回完成表，我们现在需要提取推导树。
- en: The Parse Method
  id: totrans-455
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析方法
- en: For determining how far we have managed to parse, we simply look for the last
    index from `chart_parse()` where the `start_symbol` was found.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定我们已经解析多远，我们只需查找`chart_parse()`中`start_symbol`被找到的最后一个索引。
- en: '[PRE197]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Here is the `parse_prefix()` in action.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`parse_prefix()`的实际应用。
- en: '[PRE198]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The following is adapted from the excellent reference on Earley parsing by [Loup
    Vaillant](http://loup-vaillant.fr/tutorials/earley-parsing/).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的内容改编自关于Earley解析的优秀参考资料[Loup Vaillant](http://loup-vaillant.fr/tutorials/earley-parsing/)。
- en: Our `parse()` method is as follows. It depends on two methods `parse_forest()`
    and `extract_trees()` that will be defined next.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`parse()`方法如下。它依赖于两个将在下面定义的方法`parse_forest()`和`extract_trees()`。
- en: '[PRE200]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Parsing Paths
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析路径
- en: The `parse_paths()` method tries to unify the given expression in `named_expr`
    with the parsed string. For that, it extracts the last symbol in `named_expr`
    and checks if it is a terminal symbol. If it is, then it checks the chart at `til`
    to see if the letter corresponding to the position matches the terminal symbol.
    If it does, extend our start index by the length of the symbol.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_paths()`方法尝试将`named_expr`中给出的表达式与解析的字符串统一。为此，它提取`named_expr`中的最后一个符号并检查它是否是终结符号。如果是，那么它检查`til`处的图表以查看对应位置的字母是否与终结符号匹配。如果匹配，则将我们的起始索引扩展到符号的长度。'
- en: If the symbol was a nonterminal symbol, then we retrieve the parsed states at
    the current end column index (`til`) that correspond to the nonterminal symbol,
    and collect the start index. These are the end column indexes for the remaining
    expression.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果符号是非终结符，那么我们从当前末尾列索引（`til`）检索与该非终结符对应的已解析状态，并收集起始索引。这些是剩余表达式的末尾列索引。
- en: Given our list of start indexes, we obtain the parse paths from the remaining
    expression. If we can obtain any, then we return the parse paths. If not, we return
    an empty list.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 给定我们的起始索引列表，我们从剩余的表达式中获得解析路径。如果我们能获得任何，则返回解析路径。如果不能，则返回一个空列表。
- en: '[PRE201]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Here is the `parse_paths()` in action
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`parse_paths()`的实际应用
- en: '[PRE202]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'That is, the parse path for `<start>` given the input `adcd` included recognizing
    the expression `<A><B>`. This was recognized by the two states: `<A>` from input(0)
    to input(2) which further involved recognizing the rule `a<B>c`, and the next
    state `<B>` from input(3) which involved recognizing the rule `<D>`.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，给定输入`adcd`，对于`<start>`的解析路径包括识别表达式`<A><B>`。这通过两个状态识别：从输入(0)到输入(2)的`<A>`状态，它进一步涉及到识别规则`a<B>c`，以及下一个状态`<B>`，它涉及到识别规则`<D>`。
- en: Parsing Forests
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解析森林
- en: The `parse_forest()` method takes the state which represents the completed parse,
    and determines the possible ways that its expressions corresponded to the parsed
    expression. For example, say we are parsing `1+2+3`, and the state has `[<expr>,+,<expr>]`
    in `expr`. It could have been parsed as either `[{<expr>:1+2},+,{<expr>:3}]` or
    `[{<expr>:1},+,{<expr>:2+3}]`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_forest()`方法接受表示完成解析的状态，并确定其表达式对应解析表达式的可能方式。例如，假设我们正在解析`1+2+3`，状态在`expr`中有`[<expr>,+,<expr>]`。它可以解析为`[{<expr>:1+2},+,{<expr>:3}]`或`[{<expr>:1},+,{<expr>:2+3}]`。'
- en: '[PRE204]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Extracting Trees
  id: totrans-478
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取树
- en: What we have from `parse_forest()` is a forest of trees. We need to extract
    a single tree from that forest. That is accomplished as follows.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 从`parse_forest()`我们得到一棵树森林。我们需要从那个森林中提取一棵树。这是通过以下方式完成的。
- en: (For now, we return the first available derivation tree. To do that, we need
    to extract the parse forest from the state corresponding to `start`.)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: （目前，我们返回第一个可用的推导树。为了做到这一点，我们需要从对应于`start`的状态中提取解析森林。）
- en: '[PRE207]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: We now verify that our parser can parse a given expression.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在验证我们的解析器是否可以解析给定的表达式。
- en: '[PRE208]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">bexpr</text></g></g></g></g></svg>
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 182.5 62" width="182.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">bexpr</text></g></g></g></g></svg>
- en: '[PRE211]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: <svg class="railroad-diagram" height="80" viewBox="0 0 1837.5 80" width="1837.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="non-terminal"><text x="101.25"
    y="44">aexpr</text></g> <g class="non-terminal"><text x="171.0" y="44">gt</text></g>
    <g class="non-terminal"><text x="240.75" y="44">aexpr</text></g></g></g> <g><g><g
    class="non-terminal"><text x="363.25" y="44">aexpr</text></g> <g class="non-terminal"><text
    x="433.0" y="44">lt</text></g> <g class="non-terminal"><text x="502.75" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="625.25" y="44">aexpr</text></g> <g class="terminal"><text
    x="690.75" y="44">=</text></g> <g class="non-terminal"><text x="756.25" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="878.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="944.25" y="44">=</text></g> <g class="non-terminal"><text x="1009.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1132.25" y="44">bexpr</text></g> <g class="terminal"><text
    x="1197.75" y="44">&</text></g> <g class="non-terminal"><text x="1263.25" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1385.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="1451.25" y="44">|</text></g> <g class="non-terminal"><text x="1516.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="terminal"><text x="1622.25" y="44">(</text></g> <g class="non-terminal"><text
    x="1687.75" y="44">bexrp</text></g> <g class="terminal"><text x="1753.25" y="44">)</text></g></g></g></g></g></svg>
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="80" viewBox="0 0 1837.5 80" width="1837.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="non-terminal"><text x="101.25"
    y="44">aexpr</text></g> <g class="non-terminal"><text x="171.0" y="44">gt</text></g>
    <g class="non-terminal"><text x="240.75" y="44">aexpr</text></g></g></g> <g><g><g
    class="non-terminal"><text x="363.25" y="44">aexpr</text></g> <g class="non-terminal"><text
    x="433.0" y="44">lt</text></g> <g class="non-terminal"><text x="502.75" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="625.25" y="44">aexpr</text></g> <g class="terminal"><text
    x="690.75" y="44">=</text></g> <g class="non-terminal"><text x="756.25" y="44">aexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="878.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="944.25" y="44">=</text></g> <g class="non-terminal"><text x="1009.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1132.25" y="44">bexpr</text></g> <g class="terminal"><text
    x="1197.75" y="44">&</text></g> <g class="non-terminal"><text x="1263.25" y="44">bexpr</text></g></g></g>
    <g><g><g class="non-terminal"><text x="1385.75" y="44">bexpr</text></g> <g class="terminal"><text
    x="1451.25" y="44">|</text></g> <g class="non-terminal"><text x="1516.75" y="44">bexpr</text></g></g></g>
    <g><g><g class="terminal"><text x="1622.25" y="44">(</text></g> <g class="non-terminal"><text
    x="1687.75" y="44">bexrp</text></g> <g class="terminal"><text x="1753.25" y="44">)</text></g></g></g></g></g></svg>
- en: '[PRE212]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: <svg class="railroad-diagram" height="152" viewBox="0 0 313.5 152" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="65">aexpr</text></g>
    <g class="terminal"><text x="156.75" y="65">-</text></g> <g class="non-terminal"><text
    x="222.25" y="65">aexpr</text></g></g> <g><g class="non-terminal"><text x="91.25"
    y="35">aexpr</text></g> <g class="terminal"><text x="156.75" y="35">+</text></g>
    <g class="non-terminal"><text x="222.25" y="35">aexpr</text></g></g> <g><g class="terminal"><text
    x="91.25" y="95">(</text></g> <g class="non-terminal"><text x="156.75" y="95">aexpr</text></g>
    <g class="terminal"><text x="222.25" y="95">)</text></g></g> <g><g class="non-terminal"><text
    x="156.75" y="125">integer</text></g></g></g></g></svg>
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="152" viewBox="0 0 313.5 152" width="313.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="65">aexpr</text></g>
    <g class="terminal"><text x="156.75" y="65">-</text></g> <g class="non-terminal"><text
    x="222.25" y="65">aexpr</text></g></g> <g><g class="non-terminal"><text x="91.25"
    y="35">aexpr</text></g> <g class="terminal"><text x="156.75" y="35">+</text></g>
    <g class="non-terminal"><text x="222.25" y="35">aexpr</text></g></g> <g><g class="terminal"><text
    x="91.25" y="95">(</text></g> <g class="non-terminal"><text x="156.75" y="95">aexpr</text></g>
    <g class="terminal"><text x="222.25" y="95">)</text></g></g> <g><g class="non-terminal"><text
    x="156.75" y="125">integer</text></g></g></g></g></svg>
- en: '[PRE213]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 282.0 92" width="282.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="91.25" y="35">digit</text></g>
    <g class="non-terminal"><text x="182.25" y="35">integer</text></g></g> <g><g class="non-terminal"><text
    x="141.0" y="65">digit</text></g></g></g></g></svg>
- en: '[PRE214]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="109" viewBox="0 0 522.5 109" width="522.5"><g
    transform="translate(.5 .5)"><g><g><g><g class="terminal"><text x="84.25" y="43">0</text></g></g>
    <g><g class="terminal"><text x="84.25" y="73">1</text></g></g></g> <g><g><g class="terminal"><text
    x="172.75" y="43">2</text></g></g> <g><g class="terminal"><text x="172.75" y="73">3</text></g></g></g>
    <g><g><g class="terminal"><text x="261.25" y="43">4</text></g></g> <g><g class="terminal"><text
    x="261.25" y="73">5</text></g></g></g> <g><g><g class="terminal"><text x="349.75"
    y="43">6</text></g></g> <g><g class="terminal"><text x="349.75" y="73">7</text></g></g></g>
    <g><g><g class="terminal"><text x="438.25" y="43">8</text></g></g> <g><g class="terminal"><text
    x="438.25" y="73">9</text></g></g></g></g></g></svg>
- en: '[PRE215]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
- en: '[PRE216]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
- en: '[PRE217]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: We now have a complete parser that can parse almost arbitrary *CFG*. There remains
    a small corner to fix -- the case of epsilon rules as we will see later.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的解析器，可以解析几乎任意的*CFG*。剩下一个小问题需要修复——即后面我们将看到的epsilon规则的情况。
- en: Ambiguous Parsing
  id: totrans-501
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 含糊解析
- en: Ambiguous grammars are grammars that can produce multiple derivation trees for
    some given string. For example, the `A3_GRAMMAR` can parse `1+2+3` in two different
    ways – `[1+2]+3` and `1+[2+3]`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 含糊的语法是可以为某些给定字符串产生多个推导树的语法。例如，`A3_GRAMMAR`可以以两种不同的方式解析`1+2+3`——`[1+2]+3`和`1+[2+3]`。
- en: Extracting a single tree might be reasonable for unambiguous parses. However,
    what if the given grammar produces ambiguity when given a string? We need to extract
    all derivation trees in that case. We enhance our `extract_trees()` method to
    extract multiple derivation trees.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 对于无歧义解析，提取一棵树可能是合理的。但是，如果给定的语法在给定字符串时产生歧义怎么办？在这种情况下，我们需要提取所有推导树。我们增强`extract_trees()`方法以提取多个推导树。
- en: '[PRE218]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: As before, we verify that everything works.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们验证一切是否正常工作。
- en: '[PRE220]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: One can also use a `GrammarFuzzer` to verify that everything works.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`GrammarFuzzer`来验证一切是否正常工作。
- en: '[PRE221]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: The Aycock Epsilon Fix
  id: totrans-511
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Aycock Epsilon修复
- en: While parsing, one often requires to know whether a given nonterminal can derive
    an empty string. For example, in the following grammar A can derive an empty string,
    while B can't. The nonterminals that can derive an empty string are called *nullable*
    nonterminals. For example, in the below grammar `E_GRAMMAR_1`, `<A>` is *nullable*,
    and since `<A>` is one of the alternatives of `<start>`, `<start>` is also *nullable*.
    But `<B>` is not *nullable*.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析过程中，人们经常需要知道一个给定的非终结符是否可以推导出空字符串。例如，在下面的语法中，A可以推导出空字符串，而B则不能。可以推导出空字符串的非终结符被称为*可空*非终结符。例如，在下面的语法`E_GRAMMAR_1`中，`<A>`是*可空*的，由于`<A>`是`<start>`的其中一个选择，因此`<start>`也是*可空*的。但`<B>`不是*可空*的。
- en: '[PRE223]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: One of the problems with the original Earley implementation is that it does
    not handle rules that can derive empty strings very well. For example, the given
    grammar should match `a`
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 原始Earley实现的一个问题是它处理可以推导出空字符串的规则不好。例如，给定的语法应该匹配`a`
- en: '[PRE224]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">S</text></g></g></g></g></svg>
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">S</text></g></g></g></g></svg>
- en: '[PRE227]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 294.0 62" width="294.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g> <g class="non-terminal"><text
    x="171.25" y="35">A</text></g> <g class="non-terminal"><text x="219.75" y="35">A</text></g></g></g></g></svg>
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 294.0 62" width="294.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="74.25" y="35">A</text></g>
    <g class="non-terminal"><text x="122.75" y="35">A</text></g> <g class="non-terminal"><text
    x="171.25" y="35">A</text></g> <g class="non-terminal"><text x="219.75" y="35">A</text></g></g></g></g></svg>
- en: '[PRE228]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 148.5 92" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g></g>
    <g><g class="non-terminal"><text x="74.25" y="65">E</text></g></g></g></g></svg>
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 148.5 92" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">a</text></g></g>
    <g><g class="non-terminal"><text x="74.25" y="65">E</text></g></g></g></g></svg>
- en: '[PRE229]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Aycock et al.[John Aycock *et al*, 2002] suggests a simple fix. Their idea is
    to pre-compute the `nullable` set and use it to advance the `nullable` states.
    However, before we do that, we need to compute the `nullable` set. The `nullable`
    set consists of all nonterminals that can derive an empty string.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: Aycock等人[John Aycock *et al*, 2002]提出了一种简单的修复方法。他们的想法是预先计算`nullable`集合，并使用它来推进`nullable`状态。然而，在我们这样做之前，我们需要计算`nullable`集合。`nullable`集合包括所有可以推导出空字符串的非终结符。
- en: Computing the `nullable` set requires expanding each production rule in the
    grammar iteratively and inspecting whether a given rule can derive the empty string.
    Each iteration needs to take into account new terminals that have been found to
    be `nullable`. The procedure stops when we obtain a stable result. This procedure
    can be abstracted into a more general method `fixpoint`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 计算可空集需要迭代语法中的每个产生式规则，并检查给定的规则是否可以推导出空字符串。每次迭代都需要考虑新发现的 `nullable` 终端。当获得稳定的结果时，该过程停止。这个过程可以抽象为一个更通用的方法
    `fixpoint`。
- en: Fixpoint
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Fixpoint
- en: A `fixpoint` of a function is an element in the function's domain such that
    it is mapped to itself. For example, 1 is a `fixpoint` of square root because
    `squareroot(1) == 1`.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的 `fixpoint` 是函数域中的一个元素，该元素映射到自身。例如，1 是平方根的 `fixpoint`，因为 `squareroot(1) ==
    1`。
- en: (We use `str` rather than `hash` to check for equality in `fixpoint` because
    the data structure `set`, which we would like to use as an argument has a good
    string representation but is not hashable).
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: （我们使用 `str` 而不是 `hash` 来检查 `fixpoint` 中的等价性，因为作为参数我们希望使用的 `set` 数据结构有一个良好的字符串表示，但不是可哈希的）。
- en: '[PRE231]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: Remember `my_sqrt()` from [the first chapter](Intro_Testing.html)? We can define
    `my_sqrt()` using fixpoint.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 记得 [第一章](Intro_Testing.html) 中的 `my_sqrt()` 吗？我们可以使用 `fixpoint` 来定义 `my_sqrt()`。
- en: '[PRE232]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: Nullable
  id: totrans-535
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Nullable
- en: Similarly, we can define `nullable` using `fixpoint`. We essentially provide
    the definition of a single intermediate step. That is, assuming that `nullables`
    contain the current `nullable` nonterminals, we iterate over the grammar looking
    for productions which are `nullable` -- that is, productions where the entire
    sequence can yield an empty string on some expansion.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用 `fixpoint` 来定义 `nullable`。我们本质上提供了单个中间步骤的定义。也就是说，假设 `nullables` 包含当前的
    `nullable` 非终结符，我们遍历语法，寻找 `nullable` 的产生式——即，整个序列在某些扩展中可以产生空字符串的产生式。
- en: We need to iterate over the different alternative expressions and their corresponding
    nonterminals. Hence we define a `rules()` method converts our dictionary representation
    to this pair format.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要遍历不同的替代表达式及其对应非终结符。因此，我们定义了一个 `rules()` 方法，将我们的字典表示转换为这种对格式。
- en: '[PRE235]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: The `terminals()` method extracts all terminal symbols from a `canonical` grammar
    representation.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`terminals()` 方法从 `canonical` 语法表示中提取所有终端符号。'
- en: '[PRE236]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: So, once we have the `nullable` set, all that we need to do is, after we have
    called `predict` on a state corresponding to a nonterminal, check if it is `nullable`
    and if it is, advance and add the state to the current column.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们有了 `nullable` 集合，我们只需要在调用与一个非终结符对应的状态的 `predict` 之后检查它是否是 `nullable`，如果是，就前进并将状态添加到当前列。
- en: '[PRE241]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: To ensure that our parser does parse all kinds of grammars, let us try two more
    test cases.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的解析器可以解析所有类型的语法，让我们尝试两个更多的测试用例。
- en: '[PRE243]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: Why do we get recursion error here? The reason is that, our implementation of
    `extract_trees()` is eager. That is, it attempts to extract *all* inner parse
    trees before it can construct the outer parse tree. When there is a self reference,
    this results in recursion. Here is a simple extractor that avoids this problem.
    The idea here is that we randomly and lazily choose a node to expand, which avoids
    the infinite recursion.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里会出现递归错误？原因是，我们的 `extract_trees()` 实现是急切的。也就是说，在它能够构建外层解析树之前，它会尝试提取 *所有*
    内部解析树。当存在自引用时，这会导致递归。这里有一个简单的提取器可以避免这个问题。这里的想法是随机和懒惰地选择一个节点来扩展，这样可以避免无限递归。
- en: Tree Extractor
  id: totrans-553
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Tree Extractor
- en: As you saw above, one of the problems with attempting to extract all trees is
    that the parse forest can consist of an infinite number of trees. So, here, we
    solve that problem by extracting one tree at a time.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你上面看到的，尝试提取所有树的其中一个问题是解析森林可以由无限数量的树组成。因此，我们通过一次提取一棵树来解决这个问题。
- en: '[PRE246]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Using it is as follows:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE247]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'On the indirect reference:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 关于间接引用：
- en: '[PRE250]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Note that the `SimpleExtractor` gives no guarantee of the uniqueness of the
    returned trees. This can however be fixed by keeping track of the particular nodes
    that were expanded from `pos_tree` variable, and hence, avoiding exploration of
    the same paths.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`SimpleExtractor` 并不保证返回的树的唯一性。然而，可以通过跟踪从 `pos_tree` 变量扩展出的特定节点来解决这个问题，从而避免探索相同的路径。
- en: For implementing this, we extract the random stream passing into the `SimpleExtractor`,
    and use it to control which nodes are explored. Different exploration paths can
    then form a tree of nodes.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们提取传递到 `SimpleExtractor` 的随机流，并使用它来控制哪些节点被探索。不同的探索路径可以形成一个节点树。
- en: We start with the node definition for a single choice. The `self._chosen` is
    the current choice made, `self.next` holds the next choice done using `self._chosen`.
    The `self.total` holds the total number of choices that one can have in this node.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从单个选择节点的定义开始。`self._chosen` 表示当前做出的选择，`self.next` 存储使用 `self._chosen` 完成的下一个选择。`self.total`
    存储在这个节点中可以拥有的总选择数。
- en: '[PRE253]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Now we come to the enhanced `EnhancedExtractor()`.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到增强的 `EnhancedExtractor()`。
- en: '[PRE254]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: First we define `choose_path()` that given an array and a choice node, returns
    the element in array corresponding to the next choice node if it exists, or produces
    a new choice nodes, and returns that element.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 `choose_path()`，它给定一个数组和选择节点，如果存在，返回对应于下一个选择节点的数组元素，或者产生一个新的选择节点，并返回该元素。
- en: '[PRE255]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: We define `extract_a_node()` here. While extracting, we have a choice. Should
    we allow infinite forests, or should we have a finite number of trees with no
    direct recursion? A direct recursion is when there exists a parent node with the
    same nonterminal that parsed the same span. We choose here not to extract such
    trees. They can be added back after parsing.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义 `extract_a_node()`。在提取过程中，我们有一个选择：是允许无限森林，还是应该有一个没有直接递归的有限树的数量？直接递归是指存在一个具有相同非终端的父节点，它解析了相同的范围。在这里，我们选择不提取这样的树。它们可以在解析后添加回来。
- en: This is a recursive procedure that inspects a node, extracts the path required
    to complete that node. A single path (corresponding to a nonterminal) may again
    be composed of a sequence of smaller paths. Such paths are again extracted using
    another call to `extract_a_node()` recursively.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个递归过程，它检查一个节点，提取完成该节点所需的路径。单个路径（对应于非终端）可能再次由一系列较小的路径组成。这些路径再次使用对 `extract_a_node()`
    的递归调用提取。
- en: What happens when we hit on one of the node recursions we want to avoid? In
    that case, we return the current choice node, which bubbles up to `extract_a_tree()`.
    That procedure increments the last choice, which in turn increments up the parents
    until we reach a choice node that still has options to explore.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到我们想要避免的节点递归之一时会发生什么？在这种情况下，我们返回当前的选择节点，它会冒泡到 `extract_a_tree()`。该过程增加最后一个选择，然后依次增加父节点，直到我们达到一个仍有探索选项的选择节点。
- en: What if we hit the end of choices for a particular choice node(i.e, we have
    exhausted paths that can be taken from a node)? In this case also, we return the
    current choice node, which bubbles up to `extract_a_tree()`. That procedure increments
    the last choice, which bubbles up to the next choice that has some unexplored
    paths.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到特定选择节点的选择结束（即，我们已经从节点中耗尽了可以采取的路径）怎么办？在这种情况下，我们也返回当前的选择节点，它会冒泡到 `extract_a_tree()`。该过程增加最后一个选择，然后冒泡到下一个具有未探索路径的选择。
- en: '[PRE256]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: The `extract_a_tree()` is a depth first extractor of a single tree. It tries
    to extract a tree, and if the extraction returns `None`, it means that a particular
    choice was exhausted, or we hit on a recursion. In that case, we increment the
    choice, and explore a new path.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract_a_tree()` 是单个树的深度优先提取器。它试图提取一个树，如果提取返回 `None`，则表示特定的选择已经耗尽，或者我们遇到了递归。在这种情况下，我们增加选择，并探索新的路径。'
- en: '[PRE257]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: Note that the `EnhancedExtractor` only extracts nodes that are not directly
    recursive. That is, if it finds a node with a nonterminal that covers the same
    span as that of a parent node with the same nonterminal, it skips the node.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`EnhancedExtractor` 只提取非直接递归的节点。也就是说，如果它找到一个具有与具有相同非终端的父节点覆盖相同范围的非终端的节点，它就会跳过该节点。
- en: '[PRE258]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: More Earley Parsing
  id: totrans-586
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更多 Earley 解析
- en: A number of other optimizations exist for Earley parsers. A fast industrial
    strength Earley parser implementation is the [Marpa parser](https://jeffreykegler.github.io/Marpa-web-site/).
    Further, Earley parsing need not be restricted to character data. One may also
    parse streams (audio and video streams) [Qi *et al*, 2018] using a generalized
    Earley parser.</details>
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Earley 解析器，存在许多其他优化。一个快速的工业强度 Earley 解析器实现是 [Marpa 解析器](https://jeffreykegler.github.io/Marpa-web-site/)。此外，Earley
    解析不必限于字符数据。也可以使用广义 Earley 解析器解析流（音频和视频流）[Qi 等人，2018]。</details>
- en: Here are a few examples of the Earley parser in action.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 Earley 解析器在行动中的示例。
- en: '[PRE264]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="210pt" height="575pt" viewBox="0.00 0.00 209.62 575.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 571)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81.62"
    y="-553.7" font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2"
    class="node"><title>1</title> <text text-anchor="middle" x="81.62" y="-503.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge1" class="edge"><title>0->1</title></g>
    <g id="node3" class="node"><title>2</title> <text text-anchor="middle" x="33.62"
    y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge2"
    class="edge"><title>1->2</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81.62" y="-453.2" font-family="Times,serif" font-size="14.00">+</text></g>
    <g id="edge7" class="edge"><title>1->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="127.62" y="-453.2" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge8" class="edge"><title>1->8</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="31.62" y="-402.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27.62" y="-352.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="20.62" y="-302.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="20.62" y="-252.2" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="127.62" y="-402.95"
    font-family="Times,serif" font-size="14.00"><term></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="127.62"
    y="-352.7" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge10" class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="74.62" y="-302.45" font-family="Times,serif" font-size="14.00">(
    (40)</text></g> <g id="edge11" class="edge"><title>10->11</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="128.62" y="-302.45"
    font-family="Times,serif" font-size="14.00"><expr></text></g> <g id="edge12" class="edge"><title>10->12</title></g>
    <g id="node25" class="node"><title>24</title> <text text-anchor="middle" x="182.62"
    y="-302.45" font-family="Times,serif" font-size="14.00">) (41)</text></g> <g id="edge24"
    class="edge"><title>10->24</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="128.62" y="-252.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="79.62" y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="128.62" y="-201.95" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge18" class="edge"><title>13->18</title></g> <g id="node20" class="node"><title>19</title>
    <text text-anchor="middle" x="174.62" y="-201.95" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge19" class="edge"><title>13->19</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="79.62" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="79.62" y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge16" class="edge"><title>15->16</title></g> <g id="node18" class="node"><title>17</title>
    <text text-anchor="middle" x="79.62" y="-51.2" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge17" class="edge"><title>16->17</title></g> <g id="node21"
    class="node"><title>20</title> <text text-anchor="middle" x="174.62" y="-151.7"
    font-family="Times,serif" font-size="14.00"><factor></text></g> <g id="edge20"
    class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="174.62" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node23" class="node"><title>22</title>
    <text text-anchor="middle" x="174.62" y="-51.2" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="174.62" y="-0.95" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g></g></svg>
- en: '[PRE265]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: <svg width="312pt" height="625pt" viewBox="0.00 0.00 312.00 625.25" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 621.25)"><g
    id="node1" class="node"><title>0</title> <text text-anchor="middle" x="81" y="-603.95"
    font-family="Times,serif" font-size="14.00"><start></text></g> <g id="node2" class="node"><title>1</title>
    <text text-anchor="middle" x="81" y="-553.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge1" class="edge"><title>0->1</title></g> <g id="node3" class="node"><title>2</title>
    <text text-anchor="middle" x="81" y="-503.45" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge2" class="edge"><title>1->2</title></g> <g id="node4" class="node"><title>3</title>
    <text text-anchor="middle" x="30" y="-453.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge3" class="edge"><title>2->3</title></g> <g id="node8" class="node"><title>7</title>
    <text text-anchor="middle" x="81" y="-453.2" font-family="Times,serif" font-size="14.00">*</text></g>
    <g id="edge7" class="edge"><title>2->7</title></g> <g id="node9" class="node"><title>8</title>
    <text text-anchor="middle" x="128" y="-453.2" font-family="Times,serif" font-size="14.00"><term></text></g>
    <g id="edge8" class="edge"><title>2->8</title></g> <g id="node5" class="node"><title>4</title>
    <text text-anchor="middle" x="27" y="-402.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge4" class="edge"><title>3->4</title></g> <g id="node6" class="node"><title>5</title>
    <text text-anchor="middle" x="21" y="-352.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge5" class="edge"><title>4->5</title></g> <g id="node7" class="node"><title>6</title>
    <text text-anchor="middle" x="21" y="-302.45" font-family="Times,serif" font-size="14.00">1
    (49)</text></g> <g id="edge6" class="edge"><title>5->6</title></g> <g id="node10"
    class="node"><title>9</title> <text text-anchor="middle" x="128" y="-402.95" font-family="Times,serif"
    font-size="14.00"><factor></text></g> <g id="edge9" class="edge"><title>8->9</title></g>
    <g id="node11" class="node"><title>10</title> <text text-anchor="middle" x="75"
    y="-352.7" font-family="Times,serif" font-size="14.00">( (40)</text></g> <g id="edge10"
    class="edge"><title>9->10</title></g> <g id="node12" class="node"><title>11</title>
    <text text-anchor="middle" x="129" y="-352.7" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge11" class="edge"><title>9->11</title></g> <g id="node32" class="node"><title>31</title>
    <text text-anchor="middle" x="183" y="-352.7" font-family="Times,serif" font-size="14.00">)
    (41)</text></g> <g id="edge31" class="edge"><title>9->31</title></g> <g id="node13"
    class="node"><title>12</title> <text text-anchor="middle" x="80" y="-302.45" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge12" class="edge"><title>11->12</title></g>
    <g id="node18" class="node"><title>17</title> <text text-anchor="middle" x="129"
    y="-302.45" font-family="Times,serif" font-size="14.00">+</text></g> <g id="edge17"
    class="edge"><title>11->17</title></g> <g id="node19" class="node"><title>18</title>
    <text text-anchor="middle" x="176" y="-302.45" font-family="Times,serif" font-size="14.00"><expr></text></g>
    <g id="edge18" class="edge"><title>11->18</title></g> <g id="node14" class="node"><title>13</title>
    <text text-anchor="middle" x="80" y="-252.2" font-family="Times,serif" font-size="14.00"><factor></text></g>
    <g id="edge13" class="edge"><title>12->13</title></g> <g id="node15" class="node"><title>14</title>
    <text text-anchor="middle" x="72" y="-201.95" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge14" class="edge"><title>13->14</title></g> <g id="node16" class="node"><title>15</title>
    <text text-anchor="middle" x="56" y="-151.7" font-family="Times,serif" font-size="14.00"><digit></text></g>
    <g id="edge15" class="edge"><title>14->15</title></g> <g id="node17" class="node"><title>16</title>
    <text text-anchor="middle" x="56" y="-101.45" font-family="Times,serif" font-size="14.00">2
    (50)</text></g> <g id="edge16" class="edge"><title>15->16</title></g> <g id="node20"
    class="node"><title>19</title> <text text-anchor="middle" x="177" y="-252.2" font-family="Times,serif"
    font-size="14.00"><term></text></g> <g id="edge19" class="edge"><title>18->19</title></g>
    <g id="node21" class="node"><title>20</title> <text text-anchor="middle" x="181"
    y="-201.95" font-family="Times,serif" font-size="14.00"><factor></text></g> <g
    id="edge20" class="edge"><title>19->20</title></g> <g id="node22" class="node"><title>21</title>
    <text text-anchor="middle" x="122" y="-151.7" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge21" class="edge"><title>20->21</title></g> <g id="node25" class="node"><title>24</title>
    <text text-anchor="middle" x="182" y="-151.7" font-family="Times,serif" font-size="14.00">.
    (46)</text></g> <g id="edge24" class="edge"><title>20->24</title></g> <g id="node26"
    class="node"><title>25</title> <text text-anchor="middle" x="242" y="-151.7" font-family="Times,serif"
    font-size="14.00"><integer></text></g> <g id="edge25" class="edge"><title>20->25</title></g>
    <g id="node23" class="node"><title>22</title> <text text-anchor="middle" x="122"
    y="-101.45" font-family="Times,serif" font-size="14.00"><digit></text></g> <g
    id="edge22" class="edge"><title>21->22</title></g> <g id="node24" class="node"><title>23</title>
    <text text-anchor="middle" x="122" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge23" class="edge"><title>22->23</title></g> <g id="node27"
    class="node"><title>26</title> <text text-anchor="middle" x="211" y="-101.45"
    font-family="Times,serif" font-size="14.00"><digit></text></g> <g id="edge26"
    class="edge"><title>25->26</title></g> <g id="node29" class="node"><title>28</title>
    <text text-anchor="middle" x="277" y="-101.45" font-family="Times,serif" font-size="14.00"><integer></text></g>
    <g id="edge28" class="edge"><title>25->28</title></g> <g id="node28" class="node"><title>27</title>
    <text text-anchor="middle" x="211" y="-51.2" font-family="Times,serif" font-size="14.00">3
    (51)</text></g> <g id="edge27" class="edge"><title>26->27</title></g> <g id="node30"
    class="node"><title>29</title> <text text-anchor="middle" x="277" y="-51.2" font-family="Times,serif"
    font-size="14.00"><digit></text></g> <g id="edge29" class="edge"><title>28->29</title></g>
    <g id="node31" class="node"><title>30</title> <text text-anchor="middle" x="277"
    y="-0.95" font-family="Times,serif" font-size="14.00">5 (53)</text></g> <g id="edge30"
    class="edge"><title>29->30</title></g></g></svg>
- en: In contrast to the `PEGParser`, above, the `EarleyParser` can handle arbitrary
    context-free grammars.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 与上面的 `PEGParser` 相比，`EarleyParser` 可以处理任意上下文无关文法。
- en: 'Excursion: Testing the Parsers'
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索：测试解析器
- en: While we have defined two parser variants, it would be nice to have some confirmation
    that our parses work well. While it is possible to formally prove that they work,
    it is much more satisfying to generate random grammars, their corresponding strings,
    and parse them using the same grammar.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经定义了两种解析器变体，但得到一些确认我们的解析工作良好的信息会很好。虽然可以形式化证明它们是有效的，但生成随机的文法、它们对应的字符串，并使用相同的文法进行解析，会更有满足感。
- en: '[PRE266]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">symbols</text></g></g></g></g></svg>
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 199.5 62" width="199.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="99.75" y="35">symbols</text></g></g></g></g></svg>
- en: '[PRE269]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">symbol</text></g>
    <g class="non-terminal"><text x="190.75" y="35">symbols</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">symbol</text></g></g></g></g></svg>
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 290.5 92" width="290.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="95.5" y="35">symbol</text></g>
    <g class="non-terminal"><text x="190.75" y="35">symbols</text></g></g> <g><g class="non-terminal"><text
    x="145.25" y="65">symbol</text></g></g></g></g></svg>
- en: '[PRE270]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: <svg class="railroad-diagram" height="92" viewBox="0 0 242.0 92" width="242.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="121.0" y="35">nonterminals</text></g></g>
    <g><g class="non-terminal"><text x="121.0" y="65">terminals</text></g></g></g></g></svg>
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="92" viewBox="0 0 242.0 92" width="242.0"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="121.0" y="35">nonterminals</text></g></g>
    <g><g class="non-terminal"><text x="121.0" y="65">terminals</text></g></g></g></g></svg>
- en: '[PRE271]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 296.5 62" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="78.5" y="35">lt</text></g>
    <g class="non-terminal"><text x="148.25" y="35">alpha</text></g> <g class="non-terminal"><text
    x="218.0" y="35">gt</text></g></g></g></g></svg>
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 296.5 62" width="296.5"><g
    transform="translate(.5 .5)"><g><g><g class="non-terminal"><text x="78.5" y="35">lt</text></g>
    <g class="non-terminal"><text x="148.25" y="35">alpha</text></g> <g class="non-terminal"><text
    x="218.0" y="35">gt</text></g></g></g></g></svg>
- en: '[PRE272]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35"><</text></g></g></g></g></svg>
- en: '[PRE273]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="62" viewBox="0 0 148.5 62" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">></text></g></g></g></g></svg>
- en: '[PRE274]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">A</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">B</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">C</text></g></g></g></g></svg>
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">A</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">B</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">C</text></g></g></g></g></svg>
- en: '[PRE275]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">1</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">2</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">3</text></g></g></g></g></svg>
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: <svg class="railroad-diagram" height="122" viewBox="0 0 148.5 122" width="148.5"><g
    transform="translate(.5 .5)"><g><g><g class="terminal"><text x="74.25" y="35">1</text></g></g>
    <g><g class="terminal"><text x="74.25" y="65">2</text></g></g> <g><g class="terminal"><text
    x="74.25" y="95">3</text></g></g></g></g></svg>
- en: '[PRE276]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Now we verify if our arbitrary grammars can be used by the Earley parser.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们验证我们的任意文法是否可以被 Earley 解析器使用。
- en: '[PRE283]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: With this, we have completed both implementation and testing of *arbitrary*
    CFG, which can now be used along with `LangFuzzer` to generate better fuzzing
    inputs.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经完成了对 *任意* CFG 的实现和测试，现在它可以与 `LangFuzzer` 一起使用，以生成更好的模糊测试输入。
- en: Background
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景
- en: Numerous parsing techniques exist that can parse a given string using a given
    grammar, and produce corresponding derivation tree or trees. However, some of
    these techniques work only on specific classes of grammars. These classes of grammars
    are named after the specific kind of parser that can accept grammars of that category.
    That is, the upper bound for the capabilities of the parser defines the grammar
    class named after that parser.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多解析技术，可以使用给定的文法解析给定的字符串，并产生相应的推导树或树。然而，其中一些技术仅在特定的文法类别上工作。这些文法类别以可以接受该类别文法的特定类型的解析器命名。也就是说，解析器能力的上限定义了以该解析器命名的文法类别。
- en: The *LL* and *LR* parsing are the main traditions in parsing. Here, *LL* means
    left-to-right, leftmost derivation, and it represents a top-down approach. On
    the other hand, and LR (left-to-right, rightmost derivation) represents a bottom-up
    approach. Another way to look at it is that LL parsers compute the derivation
    tree incrementally in *pre-order* while LR parsers compute the derivation tree
    in *post-order* [Pingali *et al*, 2015]).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '*LL* 和 *LR* 解析是解析的主要传统。在这里，*LL* 表示从左到右、最左推导，它代表自顶向下的方法。另一方面，LR（从左到右、最右推导）代表自底向上的方法。另一种看待它的方式是，LL
    解析器按 *前序* 递增地计算推导树，而 LR 解析器按 *后序* 计算推导树 [Pingali 等人，2015])。'
- en: Different classes of grammars differ in the features that are available to the
    user for writing a grammar of that class. That is, the corresponding kind of parser
    will be unable to parse a grammar that makes use of more features than allowed.
    For example, the `A2_GRAMMAR` is an *LL* grammar because it lacks left recursion,
    while `A1_GRAMMAR` is not an *LL* grammar. This is because an *LL* parser parses
    its input from left to right, and constructs the leftmost derivation of its input
    by expanding the nonterminals it encounters. If there is a left recursion in one
    of these rules, an *LL* parser will enter an infinite loop.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的文法类别在用户编写该类别文法时可以使用的特性上有所不同。也就是说，相应的解析器将无法解析使用比允许的更多特性的文法。例如，`A2_GRAMMAR`
    是一个 *LL* 文法，因为它没有左递归，而 `A1_GRAMMAR` 不是一个 *LL* 文法。这是因为 *LL* 解析器从左到右解析其输入，并通过展开它遇到的非终结符来构建其输入的最左推导。如果这些规则之一有左递归，*LL*
    解析器将进入无限循环。
- en: Similarly, a grammar is LL(k) if it can be parsed by an LL parser with k lookahead
    token, and LR(k) grammar can only be parsed with LR parser with at least k lookahead
    tokens. These grammars are interesting because both LL(k) and LR(k) grammars have
    $O(n)$ parsers, and can be used with relatively restricted computational budget
    compared to other grammars.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一个文法如果是 LL(k) 的，那么它可以被一个具有 k 个前瞻标记的 LL 解析器解析，而 LR(k) 文法只能用至少 k 个前瞻标记的 LR
    解析器解析。这些文法很有趣，因为 LL(k) 和 LR(k) 文法都有 $O(n)$ 解析器，并且与其他文法相比，可以在相对有限的计算预算下使用。
- en: The languages for which one can provide an *LL(k)* grammar is called *LL(k)*
    languages (where k is the minimum lookahead required). Similarly, *LR(k)* is defined
    as the set of languages that have an *LR(k)* grammar. In terms of languages, LL(k)
    $\subset$ LL(k+1) and LL(k) $\subset$ LR(k), and *LR(k)* $=$ *LR(1)*. All deterministic
    *CFLs* have an *LR(1)* grammar. However, there exist *CFLs* that are inherently
    ambiguous [Ogden *et al*, 1968], and for these, one can't provide an *LR(1)* grammar.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供*LL(k)*语法的语言被称为*LL(k)*语言（其中k是所需的最小前瞻）。类似地，*LR(k)*定义为具有*LR(k)*语法的语言集合。就语言而言，LL(k)
    $\subset$ LL(k+1) 和 LL(k) $\subset$ LR(k)，且 *LR(k)* $=$ *LR(1)*。所有确定性的 *CFLs*
    都有一个 *LR(1)* 语法。然而，存在本质上模糊的 *CFLs* [Ogden等人，1968]，对于这些语言，无法提供 *LR(1)* 语法。
- en: The other main parsing algorithms for *CFGs* are GLL [Scott *et al*, 2010],
    GLR [Tomita *et al*, 1987, Tomita *et al*, 2012], and CYK [Grune *et al*, 2008].
    The ALL(*) (used by ANTLR) on the other hand is a grammar representation that
    uses *Regular Expression* like predicates (similar to advanced PEGs – see [Exercise](#Exercise-3:-PEG-Predicates))
    rather than a fixed lookahead. Hence, ALL(*) can accept a larger class of grammars
    than CFGs.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*CFGs*的其它主要解析算法是GLL [Scott等人，2010]，GLR [Tomita等人，1987, Tomita等人，2012]，和CYK
    [Grune等人，2008]。另一方面，ALL(*)（由ANTLR使用）是一种使用类似正则表达式谓词的语法表示（类似于高级PEGs – 见 [练习](#Exercise-3:-PEG-Predicates)），而不是固定的前瞻。因此，ALL(*)可以接受比CFGs更广泛的语法类别。
- en: In terms of computational limits of parsing, the main CFG parsers have a complexity
    of $O(n^3)$ for arbitrary grammars. However, parsing with arbitrary *CFG* is reducible
    to boolean matrix multiplication [[Valiant *et al*, 1975](https://doi.org/10.1016/S0022-0000(75)80046-8)]
    (and the reverse [[Lee *et al*, 2002](https://doi.org/10.1145/505241.505242)]).
    This is at present bounded by $O(2^{23728639})$ [[Le Gall *et al*, 2014](https://doi.org/10.1145/2608628.2608664)].
    Hence, worse case complexity for parsing arbitrary CFG is likely to remain close
    to cubic.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析的计算限制方面，主要的CFG解析器对于任意语法具有$O(n^3)$的复杂度。然而，使用任意*CFG*进行解析可以简化为布尔矩阵乘法 [[Valiant等人，1975](https://doi.org/10.1016/S0022-0000(75)80046-8)]（以及反向操作
    [[Lee等人，2002](https://doi.org/10.1145/505241.505242)]）。目前，这被限制在$O(2^{23728639})$
    [[Le Gall等人，2014](https://doi.org/10.1145/2608628.2608664)]。因此，解析任意CFG的最坏情况复杂度可能仍然接近立方。
- en: Regarding PEGs, the actual class of languages that is expressible in *PEG* is
    currently unknown. In particular, we know that *PEGs* can express certain languages
    such as $a^n b^n c^n$. However, we do not know if there exist *CFLs* that are
    not expressible with *PEGs*. In Section 2.3, we provided an instance of a counter-intuitive
    PEG grammar. While important for our purposes (we use grammars for generation
    of inputs) this is not a criticism of parsing with PEGs. PEG focuses on writing
    grammars for recognizing a given language, and not necessarily in interpreting
    what language an arbitrary PEG might yield. Given a Context-Free Language to parse,
    it is almost always possible to write a grammar for it in PEG, and given that
    1) a PEG can parse any string in $O(n)$ time, and 2) at present we know of no
    CFL that can't be expressed as a PEG, and 3) compared with *LR* grammars, a PEG
    is often more intuitive because it allows top-down interpretation, when writing
    a parser for a language, PEGs should be under serious consideration.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 关于PEGs，目前尚不清楚可以用*PEG*表达的语言的实际类别。特别是，我们知道*PEGs*可以表达某些语言，例如$a^n b^n c^n$。然而，我们不知道是否存在不能用*PEGs*表达的*CFLs*。在2.3节中，我们提供了一个反直觉的PEG语法的例子。虽然这对于我们的目的很重要（我们使用语法来生成输入），但这并不是对使用PEG进行解析的批评。PEG专注于编写用于识别给定语言的语法，而不一定是解释任意PEG可能产生的语言。给定一个要解析的上下文无关语言，几乎总是可以为其编写一个PEG语法。鉴于1）一个PEG可以在$O(n)$时间内解析任何字符串，2）目前我们知道没有CFL不能表示为PEG，以及3）与*LR*语法相比，PEG通常更直观，因为它允许自顶向下的解释，在编写语言解析器时，应该认真考虑使用PEG。
- en: Lessons Learned
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经验教训
- en: Grammars can be used to generate derivation trees for a given string.
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法可以用来为给定的字符串生成推导树。
- en: Parsing Expression Grammars are intuitive, and easy to implement, but require
    care to write.
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析表达式语法直观且易于实现，但需要小心编写。
- en: Earley Parsers can parse arbitrary Context Free Grammars.
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Earley解析器可以解析任意的上下文无关语法。
- en: Next Steps
  id: totrans-638
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下一步
- en: Use parsed inputs to [recombine existing inputs](LangFuzzer.html)
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解析后的输入[重新组合现有输入](LangFuzzer.html)
- en: Exercises
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Exercise 1: An Alternative Packrat'
  id: totrans-641
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：另一种Packrat
- en: In the *Packrat* parser, we showed how one could implement a simple *PEG* parser.
    That parser kept track of the current location in the text using an index. Can
    you modify the parser so that it simply uses the current substring rather than
    tracking the index? That is, it should no longer have the `at` parameter.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Packrat* 解析器中，我们展示了如何实现一个简单的 *PEG* 解析器。该解析器使用索引跟踪文本中的当前位置。你能修改解析器，使其仅使用当前子串而不是跟踪索引吗？也就是说，它不再需要
    `at` 参数。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来练习习题并查看解决方案。'
- en: '**Solution.** Here is a possible solution:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**解答**。以下是一个可能的解决方案：'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Exercise 2: More PEG Syntax'
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题 2：更多 PEG 语法
- en: 'The *PEG* syntax provides a few notational conveniences reminiscent of regular
    expressions. For example, it supports the following operators (letters `T` and
    `A` represents tokens that can be either terminal or nonterminal. `ε` is an empty
    string, and `/` is the ordered choice operator similar to the non-ordered choice
    operator `|`):'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '*PEG* 语法提供了一些类似于正则表达式的记法便利。例如，它支持以下运算符（字母 `T` 和 `A` 代表可以是终结符或非终结符的标记。`ε` 是空字符串，而
    `/` 是有序选择运算符，类似于非有序选择运算符 `|`）：'
- en: '`T?` represents an optional greedy match of T and `A := T?` is equivalent to
    `A := T/ε`.'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T?` 表示 `T` 的可选贪婪匹配，`A := T?` 等价于 `A := T/ε`。'
- en: '`T*` represents zero or more greedy matches of `T` and `A := T*` is equivalent
    to `A := T A/ε`.'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T*` 表示 `T` 的零个或多个贪婪匹配，`A := T*` 等价于 `A := T A/ε`。'
- en: '`T+` represents one or more greedy matches – equivalent to `TT*`'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T+` 表示一个或多个贪婪匹配——等价于 `TT*`'
- en: If you look at the three notations above, each can be represented in the grammar
    in terms of basic syntax. Remember the exercise from [the chapter on grammars](Grammars.html)
    that developed `define_ex_grammar()` that can represent grammars as Python code?
    extend `define_ex_grammar()` to `define_peg()` to support the above notational
    conveniences. The decorator should rewrite a given grammar that contains these
    notations to an equivalent grammar in basic syntax.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看上述三种记法，每种都可以在语法中以基本语法的形式表示。记得 [语法章节](Grammars.html) 中的练习，它开发了 `define_ex_grammar()`，可以将语法表示为
    Python 代码？将 `define_ex_grammar()` 扩展为 `define_peg()` 以支持上述记法便利。装饰器应将包含这些记法的给定语法重写为等价的基本语法语法。
- en: 'Exercise 3: PEG Predicates'
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题 3：PEG 谓词
- en: Beyond these notational conveniences, it also supports two predicates that can
    provide a powerful lookahead facility that does not consume any input.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些记法便利之外，它还支持两个谓词，可以提供不消耗任何输入的强大前瞻功能。
- en: '`T&A` represents an *And-predicate* that matches `T` if `T` is matched, and
    it is immediately followed by `A`'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T&A` 表示一个 *And-谓词*，如果 `T` 匹配，并且它立即后面跟着 `A`'
- en: '`T!A` represents a *Not-predicate* that matches `T` if `T` is matched, and
    it is *not* immediately followed by `A`'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T!A` 表示一个 *Not-谓词*，如果 `T` 匹配，并且它不是立即后面跟着 `A`'
- en: Implement these predicates in our *PEG* parser.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 *PEG* 解析器中实现这些谓词。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Exercise 4: Earley Fill Chart'
  id: totrans-658
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题 4：Earley 填充图表
- en: In the `Earley Parser`, `Column` class, we keep the states both as a `list`
    and also as a `dict` even though `dict` is ordered. Can you explain why?
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Earley Parser` 的 `Column` 类中，我们既以 `list` 的形式也以 `dict` 的形式保存状态，尽管 `dict` 是有序的。你能解释一下为什么吗？
- en: '**Hint**: see the `fill_chart` method.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：查看 `fill_chart` 方法。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来练习习题并查看解决方案。'
- en: 'Exercise 5: Leo Parser'
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 习题 5：Leo 解析器
- en: One of the problems with the original Earley parser is that while it can parse
    strings using arbitrary *Context Free Gramamrs*, its performance on right-recursive
    grammars is quadratic. That is, it takes $O(n^2)$ runtime and space for parsing
    with right-recursive grammars. For example, consider the parsing of the following
    string by two different grammars `LR_GRAMMAR` and `RR_GRAMMAR`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 原始 Earley 解析器的一个问题是，虽然它可以使用任意的 *上下文无关文法* 解析字符串，但其对右递归文法的性能是二次的。也就是说，使用右递归文法解析需要
    $O(n^2)$ 的时间和空间。例如，考虑以下字符串通过两个不同的文法 `LR_GRAMMAR` 和 `RR_GRAMMAR` 的解析。
- en: '[PRE285]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: To see the problem, we need to enable logging. Here is the logged version of
    parsing with the `LR_GRAMMAR`
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个问题，我们需要启用日志记录。以下是使用 `LR_GRAMMAR` 进行解析的日志版本。
- en: '[PRE286]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Compare that to the parsing of `RR_GRAMMAR` as seen below:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下 `RR_GRAMMAR` 的解析进行比较：
- en: '[PRE288]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'As can be seen from the parsing log for each letter, the number of states with
    representation `<A>: a <A> ● (i, j)` increases at each stage, and these are simply
    a left over from the previous letter. They do not contribute anything more to
    the parse other than to simply complete these entries. However, they take up space,
    and require resources for inspection, contributing a factor of `n` in analysis.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '从每个字母的解析日志中可以看出，具有表示 `<A>: a <A> ● (i, j)` 的状态数量在每一阶段都会增加，这些状态仅仅是前一个字母的遗留。它们除了简单地完成这些条目外，对解析没有做出任何更多贡献。然而，它们占用空间，并需要资源进行检查，在分析中贡献了一个
    `n` 的因子。'
- en: Joop Leo [[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)]
    found that this inefficiency can be avoided by detecting right recursion. The
    idea is that before starting the `completion` step, check whether the current
    item has a *deterministic reduction path*. If such a path exists, add a copy of
    the topmost element of the *deteministic reduction path* to the current column,
    and return. If not, perform the original `completion` step.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Joop Leo [[Joop M.I.M. Leo, 1991](https://doi.org/10.1016/0304-3975(91)90180-A)]
    发现，通过检测右递归可以避免这种低效。想法是在开始 `completion` 步骤之前，检查当前项是否有 *确定性归约路径*。如果存在这样的路径，将 *确定性归约路径*
    的最顶层元素的一个副本添加到当前列，并返回。如果没有，执行原始的 `completion` 步骤。
- en: '**Definition 2.1**: An item is said to be on the deterministic reduction path
    above $[A \rightarrow \gamma., i]$ if it is $[B \rightarrow \alpha A ., k]$ with
    $[B \rightarrow \alpha . A, k]$ being the only item in $ I_i $ with the dot in
    front of A, or if it is on the deterministic reduction path above $[B \rightarrow
    \alpha A ., k]$. An item on such a path is called *topmost* one if there is no
    item on the deterministic reduction path above it[[Joop M.I.M. Leo, 1991](https://doi.org/https://doi.org/10.1016/0304-3975(91)90180-A)].'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义 2.1**：如果一个项位于 $[A \rightarrow \gamma., i]$ 上方的确定性归约路径上，如果它是 $[B \rightarrow
    \alpha A ., k]$，其中 $[B \rightarrow \alpha . A, k]$ 是 $ I_i $ 中唯一带有 A 前点的项，或者如果它位于
    $[B \rightarrow \alpha A ., k]$ 上方的确定性归约路径上。如果一个项位于这样的路径上，并且没有项位于其上方的确定性归约路径上，则称为
    *最顶层* 项[[Joop M.I.M. Leo, 1991](https://doi.org/10.1016/0304-3975(91)90180-A)]。'
- en: 'Finding a *deterministic reduction path* is as follows:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找一个 *确定性归约路径* 的方法如下：
- en: 'Given a complete state, represented by `<A> : seq_1 ● (s, e)` where `s` is
    the starting column for this rule, and `e` the current column, there is a *deterministic
    reduction path* **above** it if two constraints are satisfied.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个完整的状态，表示为 `<A> : seq_1 ● (s, e)`，其中 `s` 是此规则的起始列，`e` 是当前列，如果满足两个约束条件，则在其上方存在一个
    *确定性归约路径*。'
- en: 'There exist a *single* item in the form `<B> : seq_2 ● <A> (k, s)` in column
    `s`.'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在列 `s` 中存在一个形式为 `<B> : seq_2 ● <A> (k, s)` 的 *单个* 项。'
- en: That should be the *single* item in s with dot in front of `<A>`
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该是 `s` 中带有 `<A>` 前点的 *单个* 项
- en: 'The resulting item is of the form `<B> : seq_2 <A> ● (k, e)`, which is simply
    item from (1) advanced, and is considered above `<A>:.. (s, e)` in the deterministic
    reduction path. The `seq_1` and `seq_2` are arbitrary symbol sequences.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '结果项的形式为 `<B> : seq_2 <A> ● (k, e)`，这仅仅是 (1) 中的项的扩展，并且在确定性归约路径中被视为高于 `<A>:..
    (s, e)`。`seq_1` 和 `seq_2` 是任意的符号序列。'
- en: This forms the following chain of links, with `<A>:.. (s_1, e)` being the child
    of `<B>:.. (s_2, e)` etc.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 这形成以下链接链，其中 `<A>:.. (s_1, e)` 是 `<B>:.. (s_2, e)` 的子项等。
- en: 'Here is one way to visualize the chain:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一种可视化链的方法：
- en: '[PRE290]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: Essentially, what we want to do is to identify potential deterministic right
    recursion candidates, perform completion on them, and *throw away the result*.
    We do this until we reach the top. See Grune et al.~[Grune *et al*, 2008] for
    further information.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们想要做的是识别潜在的确定性右递归候选者，对它们进行完善，然后*丢弃结果*。我们这样做，直到达到最顶层。参见Grune等人~[Grune *et
    al*, 2008]以获取更多信息。
- en: 'Note that the completions are in the same column (`e`), with each candidate
    with constraints satisfied in further and further earlier columns (as shown below):'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，完善是在同一列（`e`）中进行的，每个候选者满足的约束在越来越早的列中（如下所示）：
- en: '[PRE291]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Following this chain, the topmost item is the item `<C>:.. (s_3, e)` that does
    not have a parent. The topmost item needs to be saved is called a *transitive*
    item by Leo, and it is associated with the non-terminal symbol that started the
    lookup. The transitive item needs to be added to each column we inspect.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这个链，最顶层的项是 `<C>:.. (s_3, e)`，它没有父项。需要保存的最顶层项被Leo称为*传递*项，它与开始查找的非终结符号相关联。传递项需要添加到我们检查的每一列中。
- en: Here is the skeleton for the parser `LeoParser`.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解析器`LeoParser`的框架。
- en: '[PRE292]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: Can you implement the `deterministic_reduction()` method to obtain the topmost
    element?
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 你能实现`deterministic_reduction()`方法以获取最顶层元素吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来处理练习并查看解决方案。'
- en: '**Solution.** Here is a possible solution:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案。**以下是一个可能的解决方案：'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来处理练习并查看解决方案。'
- en: '**Advanced:** We have fixed the complexity bounds. However, because we are
    saving only the topmost item of a right recursion, we need to fix our parser to
    be aware of our fix while extracting parse trees. Can you fix it?'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级:** 我们已经固定了复杂度界限。然而，因为我们只保存了右递归的最顶层项，所以我们需要调整我们的解析器，使其在提取解析树时意识到这一调整。你能修复它吗？'
- en: '**Hint:** Leo suggests simply transforming the Leo item sets to normal Earley
    sets, with the results from deterministic reduction expanded to their originals.
    For that, keep in mind the picture of constraint chain we drew earlier.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示:** Leo建议简单地将Leo项集转换为正常的Earley集，并将确定性归约的结果扩展到其原始形式。为此，请记住我们之前绘制的约束链图。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来处理练习并查看解决方案。'
- en: '**Solution.** Here is a possible solution.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案。**以下是一个可能的解决方案。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来处理练习并查看解决方案。'
- en: 'Exercise 6: Filtered Earley Parser'
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：过滤后的Earley解析器
- en: One of the problems with our Earley and Leo Parsers is that it can get stuck
    in infinite loops when parsing with grammars that contain token repetitions in
    alternatives. For example, consider the grammar below.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Earley和Leo解析器的一个问题是，当使用包含替代项中标记重复的语法进行解析时，它可能会陷入无限循环。例如，考虑以下语法。
- en: '[PRE293]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: With this grammar, one can produce an infinite chain of derivations of `<A>`,
    (direct recursion) or an infinite chain of derivations of `<B> -> <C> -> <B> ...`
    (indirect recursion). The problem is that, our implementation can get stuck trying
    to derive one of these infinite chains. One possibility is to use the `LazyExtractor`.
    Another, is to simply avoid generating such chains.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种语法，可以产生无限链的推导 `<A>`（直接递归）或无限链的推导 `<B> -> <C> -> <B> ...`（间接递归）。问题是，我们的实现可能会陷入试图推导这些无限链的困境。一种可能性是使用`LazyExtractor`。另一种可能性是简单地避免生成这样的链。
- en: '[PRE294]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: Can you implement a solution such that any tree that contains such a chain is
    discarded?
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你能实现一个解决方案，使得任何包含这种链的树都被丢弃吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来处理练习并查看解决方案。'
- en: '**Solution.** Here is a possible solution.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案。**以下是一个可能的解决方案。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 7: Iterative Earley Parser'
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 7：迭代 Earley 解析器
- en: Recursive algorithms are quite handy in some cases, but sometimes we might want
    to have iteration instead of recursion due to memory or speed problems.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，递归算法非常方便，但有时由于内存或速度问题，我们可能希望使用迭代而不是递归。
- en: Can you implement an iterative version of the `EarleyParser`?
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 你能实现一个 `EarleyParser` 的迭代版本吗？
- en: '**Hint:** In general, you can use a stack to replace a recursive algorithm
    with an iterative one. An easy way to do this is pushing the parameters onto a
    stack instead of passing them to the recursive function.'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示**：通常，你可以使用栈将递归算法替换为迭代算法。一种简单的方法是将参数推入栈中，而不是传递给递归函数。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: '**Solution.** Here is a possible solution.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**。这里是一个可能的解决方案。'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 8: First Set of a Nonterminal'
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 8：非终止符号的第一个集合
- en: We previously gave a way to extract the `nullable` (epsilon) set, which is often
    used for parsing. Along with `nullable`, parsing algorithms often use two other
    sets [`first` and `follow`](https://en.wikipedia.org/wiki/Canonical_LR_parser#FIRST_and_FOLLOW_sets).
    The first set of a terminal symbol is itself, and the first set of a nonterminal
    is composed of terminal symbols that can come at the beginning of any derivation
    of that nonterminal. The first set of any nonterminal that can derive the empty
    string should contain `EPSILON`. For example, using our `A1_GRAMMAR`, the first
    set of both `<expr>` and `<start>` is `{0,1,2,3,4,5,6,7,8,9}`. The extraction
    first set for any self-recursive nonterminal is simple enough. One simply has
    to recursively compute the first set of the first element of its choice expressions.
    The computation of `first` set for a self-recursive nonterminal is tricky. One
    has to recursively compute the first set until one is sure that no more terminals
    can be added to the first set.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提供了一种提取 `nullable`（epsilon）集的方法，这通常用于解析。除了 `nullable`，解析算法通常还会使用另外两个集合 `first`
    和 `follow`（[https://en.wikipedia.org/wiki/Canonical_LR_parser#FIRST_and_FOLLOW_sets](https://en.wikipedia.org/wiki/Canonical_LR_parser#FIRST_and_FOLLOW_sets)）。终止符号的第一个集合是其自身，非终止符号的第一个集合是由可以出现在该非终止符号任何推导开头的终止符号组成的。任何可以推导空字符串的非终止符号的第一个集合应包含
    `EPSILON`。例如，使用我们的 `A1_GRAMMAR`，`<expr>` 和 `<start>` 的第一个集合是 `{0,1,2,3,4,5,6,7,8,9}`。对于任何自递归非终止符号的第一个集合的提取是足够简单的。只需递归地计算其选择表达式中第一个元素的第一个集合即可。对于自递归非终止符号的第一个集合的计算是复杂的。必须递归地计算第一个集合，直到确定不再可以向第一个集合中添加更多的终止符号。
- en: Can you implement the `first` set using our `fixpoint()` decorator?
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 你能使用我们的 `fixpoint()` 装饰器实现 `first` 集合吗？
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    来完成练习并查看解决方案。'
- en: 'Exercise 9: Follow Set of a Nonterminal'
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 9：非终止符号的 follow 集合
- en: The follow set definition is similar to the first set. The follow set of a nonterminal
    is the set of terminals that can occur just after that nonterminal is used in
    any derivation. The follow set of the start symbol is `EOF`, and the follow set
    of any nonterminal is the super set of first sets of all symbols that come after
    it in any choice expression.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: follow 集合的定义与 first 集合类似。非终止符号的 follow 集合是在任何推导中使用该非终止符号之后可能出现的终止符号的集合。起始符号的
    follow 集合是 `EOF`，任何非终止符号的 follow 集合是任何选择表达式中跟在其后的所有符号的第一个集合的超集。
- en: For example, the follow set of `<expr>` in `A1_GRAMMAR` is the set `{EOF, +,
    -}`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`A1_GRAMMAR` 中 `<expr>` 的 follow 集合是集合 `{EOF, +, -}`。
- en: As in the previous exercise, implement the `followset()` using the `fixpoint()`
    decorator.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个练习类似，使用 `fixpoint()` 装饰器实现 `followset()`。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来完成练习并查看解决方案。'
- en: 'Exercise 10: A LL(1) Parser'
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 10：一个 LL(1) 解析器
- en: As we mentioned previously, there exist other kinds of parsers that operate
    left-to-right with right most derivation (*LR(k)*) or left-to-right with left
    most derivation (*LL(k)*) with *k* signifying the amount of lookahead the parser
    is permitted to use.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，存在其他类型的解析器，它们以从左到右的方式操作，使用最右推导（*LR(k)*）或最左推导（*LL(k)*），其中 *k* 表示解析器被允许使用的先行符的数量。
- en: What should one do with the lookahead? That lookahead can be used to determine
    which rule to apply. In the case of an *LL(1)* parser, the rule to apply is determined
    by looking at the *first* set of the different rules. We previously implemented
    `first_expr()` that takes an expression, the set of `nullables`, and computes
    the first set of that rule.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应该怎么做呢？这个先行符可以用来确定应用哪个规则。在 *LL(1)* 解析器的情况下，应用哪个规则是通过查看不同规则的 *first* 集合来确定的。我们之前实现了
    `first_expr()`，它接受一个表达式、`nullables` 集合，并计算该规则的第一个集合。
- en: If a rule can derive an empty set, then that rule may also be applicable if
    of sees the `follow()` set of the corresponding nonterminal.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个规则可以推导出空集，那么如果看到相应非终结符的 `follow()` 集合，该规则也可能适用。
- en: 'Part 1: A LL(1) Parsing Table'
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第一部分：一个 LL(1) 解析表
- en: The first part of this exercise is to implement the *parse table* that describes
    what action to take for an *LL(1)* parser on seeing a terminal symbol on lookahead.
    The table should be in the form of a *dictionary* such that the keys represent
    the nonterminal symbol, and the value should contain another dictionary with keys
    as terminal symbols and the particular rule to continue parsing as the value.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的第一部分是实现描述在看到先行符上的终结符时 *LL(1)* 解析器应采取什么操作的 *解析表*。该表应以 *字典* 的形式呈现，其中键代表非终结符，值应包含另一个字典，其键为终结符，值为继续解析的特定规则。
- en: 'Let us illustrate this table with an example. The `parse_table()` method populates
    a `self.table` data structure that should conform to the following requirements:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这个表格。`parse_table()` 方法填充一个 `self.table` 数据结构，该结构应符合以下要求：
- en: '[PRE297]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'On invocation of `LL1Parser(A2_GRAMMAR).show_table()` It should result in the
    following table:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `LL1Parser(A2_GRAMMAR).show_table()` 时，应该得到以下表格：
- en: '[PRE298]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '| Rule Name |  | + | - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| Rule Name |  | + | - | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- |'
- en: '| start |  |  |  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| start |  |  |  | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| expr |  |  |  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| expr |  |  |  | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |'
- en: '| expr_ |  | 2 | 3 |  |  |  |  |  |  |  |  |  |  |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| expr_ |  | 2 | 3 |  |  |  |  |  |  |  |  |  |  |'
- en: '| integer |  |  |  | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| integer |  |  |  | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 | 5 |'
- en: '| integer_ |  | 7 | 7 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| integer_ |  | 7 | 7 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 | 6 |'
- en: '| digit |  |  |  | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '| digit |  |  |  | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 |'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)来完成练习并查看解决方案。'
- en: 'Part 2: The Parser'
  id: totrans-744
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 第二部分：解析器
- en: 'Once we have the parse table, implementing the parser is as follows: Consider
    the first item from the sequence of tokens to parse, and seed the stack with the
    start symbol.'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了解析表，实现解析器的步骤如下：考虑要解析的标记序列中的第一个标记，并用起始符号初始化栈。
- en: While the stack is not empty, extract the first symbol from the stack, and if
    the symbol is a terminal, verify that the symbol matches the item from the input
    stream. If the symbol is a nonterminal, use the symbol and input item to look
    up the next rule from the parse table. Insert the rule thus found to the top of
    the stack. Keep track of the expressions being parsed to build up the parse table.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 当栈不为空时，从栈中提取第一个符号，如果该符号是终结符，则验证该符号是否与输入流中的项匹配。如果符号是非终结符，则使用该符号和输入项从解析表中查找下一个规则。将找到的规则插入到栈顶。跟踪正在解析的表达式以构建解析表。
- en: Use the parse table defined previously to implement the complete LL(1) parser.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前定义的解析表来实现完整的 LL(1) 解析器。
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)进行练习并查看解决方案。'
- en: '**Solution.** Here is the complete parser:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**。以下是完整的解析器：'
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)
    to work on the exercises and see solutions.'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用笔记本](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/Parser.ipynb#Exercises)进行练习并查看解决方案。'
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-11-09 17:07:29+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/Parser.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  id: totrans-751
  prefs: []
  type: TYPE_IMG
  zh: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    本项目的内容受[Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International
    License](https://creativecommons.org/licenses/by-nc-sa/4.0/)许可。作为内容一部分的源代码，以及用于格式化和显示该内容的源代码，均受[MIT
    License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license)许可。最后修改时间：2024-11-09
    17:07:29+01:00。[引用](#citation) · [版权信息](https://cispa.de/en/impressum)'
- en: How to Cite this Work
  id: totrans-752
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何引用本作品
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Parsing Inputs](https://www.fuzzingbook.org/html/Parser.html)". In Andreas
    Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "[The
    Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/Parser.html](https://www.fuzzingbook.org/html/Parser.html).
    Retrieved 2024-11-09 17:07:29+01:00.'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈亚斯·泽勒（Andreas Zeller）、拉胡尔·戈皮纳特（Rahul Gopinath）、马塞尔·博姆（Marcel Böhme）、戈登·弗朗西斯（Gordon
    Fraser）和克里斯蒂安·霍勒（Christian Holler）："[解析输入](https://www.fuzzingbook.org/html/Parser.html)"。收录于安德烈亚斯·泽勒、拉胡尔·戈皮纳特、马塞尔·博姆、戈登·弗朗西斯和克里斯蒂安·霍勒的《[模糊测试书](https://www.fuzzingbook.org/)[https://www.fuzzingbook.org/html/Parser.html](https://www.fuzzingbook.org/html/Parser.html)》中。检索时间：2024-11-09
    17:07:29+01:00。
- en: '[PRE300]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
