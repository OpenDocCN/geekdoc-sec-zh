- en: 5 Compiler introduced security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security vulnerabilities introduced by compilers have a long history. Thompson
    [@Thompson1984] provides one of the oldest and most popular examples in this area.
    In his paper, he talks about a compiler that can detect when it is compiling the
    login program and can insert a backdoor so that he can use the system as any user.
    However most common cases are where involuntary security vulnerabilities are added
    in the generated binary by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Explain how code that results in undefined behaviour can often work as the programmer
    expected until some optimisation is applied, and perhaps even talk a bit about
    why compilers rely on the absence of undefined behaviour in ways that appear aggressive
    in some occasions. [#202](https://github.com/llsoftsec/llsoftsecbook/issues/202)
  prefs: []
  type: TYPE_NORMAL
- en: When discussing compiler introduced security vulnerabilities, undefined behavior
    plays a major role. Its implications were thoroughly discussed by various works
    such as [@wang2012undefined] [@d2015correctness] [@dusilent]. By reading the works
    of these authors, one can see that even projects that went through careful testing,
    such as Linux, FreeBSD or PostgreSQL, could not escape from this class of vulnerabilities.
    To better understand them, this chapter contains several examples of such vulnerabilities,
    their implications and how they got fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The first example is a 15 years old vulnerability that affected the random number
    generator (RNG) in Mac OS X [@Wang2015]. At some point in the past, this vulnerability
    affected all *BSD operating systems, as they have a common ancestor with Mac OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the random number generator of the system, more specifically in `srandomdev(3)`,
    we can spot the following piece of code used in the seeding logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For generating a seed for the RNG, the code uses the current time and an uninitialized
    value from the stack, i.e. `junk`. This triggers undefined behavior as the C standard
    has no clear semantics for uninitialized loads. Because of that, there was a huge
    difference in the generated assembly code for two different Mac OS X releases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Mac OS X 10.6 the generated code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While for Mac OS X 10.7 the code looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the shorter version of the generated assembly code, the compiler dropped
    the whole argument of `srandom` as an optimization. While the optimised code respects
    the standard, it leaves room for an attacker to exploit the system because the
    seed of the RNG can now be predicted.
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, this problem has been resolved in FreeBSD [@FbsdJunk] and OpenBSD
    [@ObsdJunk].
  prefs: []
  type: TYPE_NORMAL
- en: Current solutions for detecting this class of vulnerabilities include LLVM’s
    MemorySanitizer and Valgrind.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example covers a new type of undefined behavior that can easily introduce
    security vulnerabilities. This time we talk about dereferencing NULL pointers
    and what might go wrong with this operation. The following piece of code is taken
    from Linux and introduces a vulnerability by dereferencing the `tun` pointer before
    it checks that the pointer is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Normally, this would cause a crash in the kernel or the function would return
    POLLERR if address 0 was mapped in the address space. However the compiler assumes
    that `tun` is a valid pointer when the execution reaches the if statement. This
    happens because it saw an earlier dereference just before the if statement. In
    this situation, the check is considered redundant and deleted from the final binary.
    This allows an attacker to continue executing code from `tun_chr_poll` when address
    0 is mapped.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate against this situation, GCC developers added a flag called `-fno-delete-null-pointer-checks`
    that Linux integrated in its compiler configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Linux was not the only project that suffered from this problem. Chromium [@ChromiumIssue]
    and Mozilla [@MozillaIssue] had problems in the past with this.
  prefs: []
  type: TYPE_NORMAL
- en: There are also cases of security vulnerabilities that are not introduced by
    undefined behavior, the following piece of code is such an example. This was taken
    from the Linux kernel. Because the compiler sees that the pointer hash is never
    used after this point, it decides to delete the memset operation. We call this
    dead store optimization (DSO). This has serious security implications because
    the intention of the programmer was to delete the `hash` information from memory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution Linux came with was to add a new function called `memzero_explicit`
    which under the hood looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It still uses `memset` to delete the associated security sensitive data, but
    it also tries to eliminate the risk of DSO by using the OPTIMIZER_HIDE_VAR macro.
    This, however, is not enough to fully eliminate dead stores [@MemZeroBarrier].
    In case of using LTO, the buffer `s` is still vulnerable. For this reason, Linux
    maintainers added a further hardening mechanism by using a compiler barrier instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is still room for improvement regarding the introduced barrier [@MemZeroDataBarrier].
    If the content of the buffer is present in registers, then the compiler blindly
    proves again that the DSO can be triggered and the `memset` will be again deleted.
    To mitigate against this, the following patch was proposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this patch we create a new barrier that will be guaranted to put the content
    of the buffer in memory so that DSO can take no further effect.
  prefs: []
  type: TYPE_NORMAL
- en: Similar efforts were conducted in other projects such as OpenSSL [@OpenSSLMemClr].
    The approach OpenSSL used is rather different but it achieves the same end goal,
    i.e. eliminating the effect of DSO. By making `memset_func` a volatile pointer
    to the actual implementation of `memset`, the compiler is forced to dereference
    the pointer to get to the actual `memset`, thus eliminating the risk of optimizing
    it out.
  prefs: []
  type: TYPE_NORMAL
- en: The C23 committee decided to tackle this problem from another angle, i.e. by
    adding a library function called `memset_explicit` [@MemSetProposal]. This function
    requires the compiler to not optimize the memory overwrite away. However it is
    not trivial to implement such a functionality, as GNU presents in [@GNUMemSet].
    The information may be present somewhere in the machine, even if it was erased
    from memory.
  prefs: []
  type: TYPE_NORMAL
