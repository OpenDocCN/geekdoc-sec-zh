- en: Fuzzing in the Large
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[http://www.fuzzingbook.org/html/FuzzingInTheLarge.html](http://www.fuzzingbook.org/html/FuzzingInTheLarge.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In the past chapters, we have always looked at fuzzing taking place on one machine
    for a few seconds only. In the real world, however, fuzzers are run on dozens
    or even thousands of machines; for hours, days and weeks; for one program or dozens
    of programs. In such contexts, one needs an *infrastructure* to *collect* failure
    data from the individual fuzzer runs, and to *aggregate* such data in a central
    repository. In this chapter, we will examine such an infrastructure, the *FuzzManager*
    framework from Mozilla.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter requires basic knowledge on testing, e.g. from the [Introduction
    to testing](Intro_Testing.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter requires basic knowledge on how fuzzers fork, e.g. from the [Introduction
    to fuzzing](Fuzzer.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Synopsis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To [use the code provided in this chapter](Importing.html), write
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: and then make use of the following features.
  prefs: []
  type: TYPE_NORMAL
- en: The Python `FuzzManager` package allows for programmatic submission of failures
    from a large number of (fuzzed) programs. One can query crashes and their details,
    collect them into buckets to ensure they will be treated the same, and also retrieve
    coverage information for debugging both programs and their tests.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting Crashes from Multiple Fuzzers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all our fuzzing scenarios have been *one* fuzzer on *one* machine testing
    *one* program. Failures would be shown immediately, and diagnosed quickly by the
    same person who started the fuzzer. Alas, testing in the real world is different.
    Fuzzing is still fully automated; but now, we are talking about *multiple* fuzzers
    running on *multiple* machines testing *multiple* programs (and versions thereof),
    producing *multiple* failures that have to be handled by *multiple* people. This
    raises the question of how to manage all these activities and their interplay.
  prefs: []
  type: TYPE_NORMAL
- en: A common means to coordinate several fuzzers is to have a central *repository*
    that collects all crashes as well as their crash information. Whenever a fuzzer
    detects a failure, it connects via the network to a *crash server*, which then
    stores the crash information in a database.
  prefs: []
  type: TYPE_NORMAL
- en: <svg width="578pt" height="188pt" viewBox="0.00 0.00 578.46 188.00" xmlns:xlink="http://www.w3.org/1999/xlink"><g
    id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 184)"><g
    id="node1" class="node"><title>Crash Database</title> <text text-anchor="middle"
    x="285.23" y="-11.82" font-family="Times,serif" font-size="14.00">Crash Database</text></g>
    <g id="node2" class="node"><title>Fuzzer 1</title> <text text-anchor="middle"
    x="40.23" y="-155.82" font-family="Times,serif" font-size="14.00">Fuzzer 1</text></g>
    <g id="node3" class="node"><title>Crash Server</title> <text text-anchor="middle"
    x="285.23" y="-83.83" font-family="Times,serif" font-size="14.00">Crash Server</text></g>
    <g id="edge1" class="edge"><title>Fuzzer 1->Crash Server</title></g> <g id="edge7"
    class="edge"><title>Crash Server->Crash Database</title></g> <g id="node4" class="node"><title>Fuzzer
    2</title> <text text-anchor="middle" x="138.23" y="-155.82" font-family="Times,serif"
    font-size="14.00">Fuzzer 2</text></g> <g id="edge2" class="edge"><title>Fuzzer
    2->Crash Server</title></g> <g id="node5" class="node"><title>Fuzzer 3</title>
    <text text-anchor="middle" x="236.23" y="-155.82" font-family="Times,serif" font-size="14.00">Fuzzer
    3</text></g> <g id="edge3" class="edge"><title>Fuzzer 3->Crash Server</title></g>
    <g id="node6" class="node"><title>Fuzzer 4</title> <text text-anchor="middle"
    x="334.23" y="-155.82" font-family="Times,serif" font-size="14.00">Fuzzer 4</text></g>
    <g id="edge4" class="edge"><title>Fuzzer 4->Crash Server</title></g> <g id="node7"
    class="node"><title>Fuzzer 5</title> <text text-anchor="middle" x="432.23" y="-155.82"
    font-family="Times,serif" font-size="14.00">Fuzzer 5</text></g> <g id="edge5"
    class="edge"><title>Fuzzer 5->Crash Server</title></g> <g id="node8" class="node"><title>Fuzzer
    6</title> <text text-anchor="middle" x="530.23" y="-155.82" font-family="Times,serif"
    font-size="14.00">Fuzzer 6</text></g> <g id="edge6" class="edge"><title>Fuzzer
    6->Crash Server</title></g></g></svg>
  prefs: []
  type: TYPE_NORMAL
- en: The resulting crash database can be *queried* to find out which failures have
    occurred – typically, using a Web interface. It can also be *integrated* with
    other process activities. Most importantly, entries in the crash database can
    be linked to the *bug database*, and vice versa, such that bugs (= crashes) can
    be assigned to individual developers.
  prefs: []
  type: TYPE_NORMAL
- en: In such an infrastructure, collecting crashes is not limited to fuzzers. Crashes
    and failures occurring in the wild can also be automatically reported to the crash
    server. In industry, it is not uncommon to have crash databases collecting thousands
    of crashes from production runs – especially if the software in question is used
    by millions of people every day.
  prefs: []
  type: TYPE_NORMAL
- en: What information is stored in such a database?
  prefs: []
  type: TYPE_NORMAL
- en: Most important is the *identifier* of the product – that is, the product name,
    version information as well as the platform and the operating system. Without
    this information, there is no way developers can tell whether the bug is still
    around in the latest version, or whether it already has been fixed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For debugging, the most helpful information for developers are the *steps to
    reproduce* – in a fuzzing scenario, this would be the *input* to the program in
    question. (In a production scenario, the user's input is not collected for obvious
    privacy reasons.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second most helpful for debugging is a *stack trace* such that developers can
    inspect which internal functionality was active in the moment of the failure.
    A *coverage* map also comes in handy, since developers can query which functions
    were executed and which were not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If general failures are collected, developers also need to know what the expected
    behavior was; for crashes, this is simple, as users do not expect their software
    to crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of this information can be collected automatically if the fuzzer (or the
    program in question) is set up accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore a platform that automates all these steps.
    The *FuzzManager* platform allows to
  prefs: []
  type: TYPE_NORMAL
- en: '*collect* failure data from failing runs,'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*enter* this data into a centralized server, and'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*query* the server via a Web interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this chapter, we will show how to conduct basic steps with FuzzManager, including
    crash submission and triage as well as coverage measurement tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Crash Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[FuzzManager](https://github.com/MozillaSecurity/FuzzManager) is a tool chain
    for managing large-scale fuzzing processes. It is *modular* in the sense that
    you can make use of those parts you need; it is *versatile* in the sense that
    it does not impose a particular process. It consists of a *server* whose task
    is to collect crash data, as well as of various *collector utilities* that collect
    crash data to send it to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-Setting-up-the-Server"><summary>Setting up the Server</summary>
  prefs: []
  type: TYPE_NORMAL
- en: To run the examples in this notebook, we need to run a *crash server* – that
    is, the *FuzzManager* server. You can either
  prefs: []
  type: TYPE_NORMAL
- en: Run your own server. To do so, you need to follow the installation steps listed
    under "Server Setup" on the [FuzzManager](https://github.com/MozillaSecurity/FuzzManager)
    page. The `FuzzManager` folder should be created in the same folder as this notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the notebook start (and stop) a server. The following commands following
    commands do this automatically. They are meant for the purposes of this notebook
    only, though; if you want to experiment with your own server, run it manually,
    as described above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We start with getting the fresh server code from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The base repository is `https://github.com/MozillaSecurity/FuzzManager`, but
    we use the `uds-se` repository as this repository has the `0.4.1` stable release
    of FuzzManager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We create a user named `demo` with a password `demo`, using [this handy trick](https://stackoverflow.com/questions/6244382/how-to-automate-createsuperuser-on-django).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We create a token for this user. This token will later be used by automatic
    commands for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The token is stored in `~/.fuzzmanagerconf` in our home folder. This is the
    full configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]</details> <details id="Excursion:-Starting-the-Server"><summary>Starting
    the Server</summary>'
  prefs: []
  type: TYPE_NORMAL
- en: Once the server is set up, we can start it. On the command line, we use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In our notebook, we can do this programmatically, using the `Process` framework
    introduced for [fuzzing Web servers](WebFuzzer.html). We let the FuzzManager server
    run in its own process, which we start in the background.
  prefs: []
  type: TYPE_NORMAL
- en: For multiprocessing, we use the `multiprocess` module - a variant of the standard
    Python `multiprocessing` module that also works in notebooks. If you are running
    this code outside a notebook, you can also use `multiprocessing` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: While the server is running, you will be able to see its output below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Logging In
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the server is up and running, *FuzzManager* can be reached on the local
    host using this URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To log in, use the username `demo` and the password `demo`. In this notebook,
    we do this programmatically, using the *Selenium* interface introduced in the
    [chapter on GUI fuzzing](GUIFuzzer.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For an interactive session, set `headless` to `False`; then you can interact
    with `FuzzManager` at the same time you are interacting with this notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the starting screen of `FuzzManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/9c1ad0557d47be56a420d59681d0cd53.png)'
  prefs: []
  type: TYPE_IMG
- en: We now log in by sending `demo` both as username and password, and then click
    on the `Login` button.
  prefs: []
  type: TYPE_NORMAL
- en: After login, we find an empty database. This is where crashes will appear, once
    we have collected them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/eb2c0019f0975d0b7790e9134f9c5183.png)'
  prefs: []
  type: TYPE_IMG
- en: Collecting Crashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fill our database, we need some crashes. Let us take a look at `simply-buggy`,
    an example repository containing trivial C++ programs for illustration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The make command compiles our target program, including our first target, the
    *simple-crash* example. Alongside the program, there is also a configuration file
    generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the `simple-crash` source code in `simple-crash.cpp`.
    As you can see, the source code is fairly simple: A forced crash by writing to
    a (near)-NULL pointer. This should immediately crash on most machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file `simple-crash.fuzzmanagerconf` generated for the the
    binary also contains some straightforward information, like the version of the
    program and other metadata that is required or at least useful later on when submitting
    crashes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us run the program! We immediately get a crash trace as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, what we would actually like to do is to run this binary from Python instead,
    detect that it crashed, collect the trace and submit it to the server. Let''s
    start with a simple script that would just run the program we give it and detect
    the presence of the ASan trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: With this script, we can now run the binary and indeed detect that it crashed.
    But how do we send this information to the crash server now? Let's add a few features
    from the *FuzzManager* toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Program Configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `ProgramConfiguration` is largely a container class storing various properties
    of the program, e.g. product name, the platform, version and runtime options.
    By default, it reads the information from the `.fuzzmanagerconf` file created
    for the program under test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Crash Info
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `CrashInfo` object stores all the necessary data about a crash, including
  prefs: []
  type: TYPE_NORMAL
- en: the stdout output of your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the stderr output of your program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: crash information as produced by GDB or AddressSanitizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `ProgramConfiguration` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s collect the information for the run of `simply-crash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This reads and parses our ASan trace into a more generic format, returning
    us a generic `CrashInfo` object that we can inspect and/or submit to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step is to send the crash info to our crash manager. A `Collector`
    is a feature to communicate with a CrashManager server. Collector provides an
    easy client interface that allows your clients to submit crashes as well as download
    and match existing signatures to avoid reporting frequent issues repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We instantiate the collector instance; this will be our entry point for talking
    to the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To submit the crash info, we use the collector''s `submit()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting Crashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now submitted something to our local FuzzManager demo instance. If you run
    the crash server on your local machine, you can go to [http://127.0.0.1:8000/crashmanager/crashes/](http://127.0.0.1:8000/crashmanager/crashes/)
    you should see the crash info just submitted. You can inquire the product, version,
    operating system, and further crash details.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/77dd2868d0c06654602fa4a8545f4a5f.png)'
  prefs: []
  type: TYPE_IMG
- en: If you click on the crash ID, you can further inspect the submitted data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/68144f5a1f8dc6decfa913a9c10ea345.png)'
  prefs: []
  type: TYPE_IMG
- en: Since `Collector`s can be called from any program (provided they are configured
    to talk to the correct server), you can now collect crashes from anywhere – fuzzers
    on remote machines, crashes occurring during beta testing, or even crashes during
    production.
  prefs: []
  type: TYPE_NORMAL
- en: Crash Buckets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One challenge with collecting crashes is that the *same crashes occur multiple
    times.* If a product is in the hands of millions of users, chances are that thousands
    of them will encounter the same bug, and thus the same crash. Therefore, the database
    will have thousands of entries that are all caused by the same one bug. Therefore,
    it is necessary to identify those failures that are *similar* and to group them
    together in a set called a *crash bucket* or *bucket* for short.
  prefs: []
  type: TYPE_NORMAL
- en: In *FuzzManager*, a bucket is defined through a *crash signature*, a list of
    predicates matching a set of bugs. Such a predicate can refer to a number of features,
    the most important being
  prefs: []
  type: TYPE_NORMAL
- en: the current *program counter*, reporting the instruction executed at the moment
    of the crash;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: elements from the *stack trace*, showing which functions were active at the
    moment of the crash.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can create such a signature right away when viewing a single crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/68144f5a1f8dc6decfa913a9c10ea345.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking the red `Create` button creates a bucket for this crash. A *crash
    signature* will be proposed to you for matching this and future crashes of the
    same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/7bf68c4fa036cc7b08edb35883b5a1c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Accept it by clicking *Save*.
  prefs: []
  type: TYPE_NORMAL
- en: You will be redirected to the newly created bucket, which shows you the size
    (how many crashes it holds), its bug report status (buckets can be linked to bugs
    in an external bug tracker like Bugzilla) and many other useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Crash Signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you click on the *Signatures* entry in the top menu, you should also see
    your newly created entry.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/c57a98f2ae8c942b4a6a3ae60f38429c.png)'
  prefs: []
  type: TYPE_IMG
- en: You see that this signature refers to a crash occurring in the function `crash()`
    (duh!) when called from `main()` when called from `start()` (an internal OS function).
    We also see the current crash address.
  prefs: []
  type: TYPE_NORMAL
- en: Buckets and their signatures are a central concept in FuzzManager. If you receive
    a lot of crash reports from various sources, bucketing allows you to easily group
    crashes and filter duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Coarse-Grained Signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The flexible signature system starts out with an initially proposed fine-grained
    signature, but it can be adjusted as needed to capture *variations* of the same
    bug and make tracking easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will look at a more complex example that reads data
    from a file and creates multiple crash signatures - a file `out-of-bounds.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This program looks way more elaborate compared to the last one, but don''t
    worry, it is not really doing a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `main()` function simply reads a file provided on the command
    line and puts its contents into a buffer that is passed to `validateAndPerformAction()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That `validateAndPerformAction()` function pulls out two bytes of the buffer
    (`action` and `count`) and considers the rest `data`. Depending on the value of
    `action`, it then calls either `printFirst()` or `printLast()`, which prints either
    the first or the last `count` bytes of `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this sounds pointless, that is because it is. The whole idea of this program
    is that the security check (that `count` is not larger than the length of `data`)
    is missing in `validateAndPerformAction()` but that the illegal access happens
    later in either of the two print functions. Hence, we would expect this program
    to generate at least two (slightly) different crash signatures - one with `printFirst()`
    and one with `printLast()`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it out with very simple fuzzing based on the last Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Since *FuzzManager* can have trouble with 8-bit characters in the input, we
    introduce an `escapelines()` function that converts text to printable ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: <details id="Excursion:-escapelines()-implementatipn"><summary>`escapelines()`
    implementatipn</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: Now to the actual script. As above, we set up a collector that collects and
    sends crash info whenever a crash occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this script, you will see its progress and notice that it produces
    quite a few crashes. And indeed, if you visit the [FuzzManager crashes page](http://127.0.0.1:8000/crashmanager/crashes/),
    you will notice a variety of crashes that have accumulated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/5c7a1ef0fef9dec3a5fca6521386cfb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Pick the first crash and create a bucket for it, like you did the last time.
    After saving, you will notice that not all of your crashes went into the bucket.
    The reason is that our program created several different stacks that are somewhat
    similar but not exactly identical. This is a common problem when fuzzing real
    world applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, there is an easy way to deal with this. While on the bucket page,
    hit the *Optimize* button for the bucket. FuzzManager will then automatically
    propose you to change your signature. Accept the change by hitting `Edit with
    Changes` and then `Save`. Repeat these steps until all crashes are part of the
    bucket. After 3 to 4 iterations, your signature will likely look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the `stackFrames` signature symptom, the `validateAndPerformAction`
    function is still present in the stack frame, because this function is common
    across all stack traces in all crashes; in fact, this is where the bug lives.
    But the lower stack parts have been generalized into arbitrary functions (`?`)
    because they vary across the set of submitted crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Optimize` function is designed to automate this process as much as possible:
    It attempts to broaden the signature by fitting it to untriaged crashes and then
    checks if the modified signature would touch other existing buckets. This works
    with the assumption that other buckets are indeed other bugs, i.e. if you had
    created two buckets from your crashes first, optimizing would not work anymore.
    Also, if the existing bucket data is sparse, and you have a lot of untriaged crashes,
    the algorithm could propose changes that include crashes of different bugs in
    the same bucket. There is no way to fully automatically detect and prevent this,
    hence the process is semi-automated and requires you to review all proposed changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Collecting Code Coverage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the [chapter on coverage](Coverage.html), we have seen how measuring code
    coverage can be beneficial to assess fuzzer performance. Holes in code coverage
    can reveal particularly hard-to-reach locations as well as bugs in the fuzzer
    itself. Because this is an important part of the overall fuzzing operations, FuzzManager
    supports visualizing *per-fuzzing code coverage* of repositories – that is, we
    can interactively *inspect* which code was covered during fuzzing, and which was
    not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate coverage collection and visualization in *FuzzManager*, we take
    a look at a another simple C++ program, the `maze.cpp` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all this program does is read some numbers from the command
    line, compare them to some magical constants and arbitrary criteria, and if everything
    works out, you reach one of the two secrets in the program. Reaching one of these
    secrets also triggers a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start to work on this program, we recompile the programs with coverage
    support. In order to emit code coverage with either Clang or GCC, programs typically
    need to be built and linked with special `CFLAGS` like `--coverage`. In our case,
    the Makefile does this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if we want to use FuzzManager to look at our code, we need to do the
    initial repository setup (essentially giving the server its own working copy of
    our *git* repository to pull the source from). Normally, the client and server
    run on different machines, so this involves checking out the repository on the
    server and telling it where to find it (and what version control system it uses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We now assume that we know some magic constants (like in practice, we sometimes
    know some things about the target, but might miss a detail) and we fuzz the program
    with that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with 1000 runs we found secret 1 a few times, but secret 2 (and
    the crash) are still missing. In order to determine how to improve this, we are
    now going to look at the *coverage data.*
  prefs: []
  type: TYPE_NORMAL
- en: We use [Mozilla's `grcov` tool](https://github.com/mozilla/grcov) to capture
    graphical coverage information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We can now go to the [FuzzManager coverage page](http://127.0.0.1:8000/covmanager/)
    to take a look at our source code and its coverage.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/3fdc79ae2d0b439b19c56b6a624979ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the first ID to browse the coverage data that you just submitted.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/911c1f0de8b4baa9597321c636a40ce9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will first see the full list of files in the `simply-buggy` repository,
    with all but the `maze.cpp` file showing 0% coverage (because we didn''t do anything
    with these binaries since we rebuilt them with coverage support). Now click on
    `maze.cpp` and inspect the coverage line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../Images/79b9ef8961e61c2ea074cb1f6a4994d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lines highlighted in *green* have been executed; the number in the green bar
    on the left tells how many times. Lines highlighted in *red* have *not* been executed.
    There are two observations to make:'
  prefs: []
  type: TYPE_NORMAL
- en: The if-statement in Line 34 is still covered, but the lines following after
    it are red. This is because our fuzzer misses the constant checked in that statement,
    so it is fairly obvious that we need to add to our constants list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From Line 26 to Line 27 there is a sudden drop in coverage. Both lines are covered,
    but the counters show that we fail that check in more than 95% of the cases. This
    explains why we find secret 1 so rarely. If this was a real program, we would
    now try to figure out how much additional code is behind that branch and adjust
    probabilities such that we hit it more often, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, the `maze` program is so small that one could see these issues with
    the bare eye. But in reality, with complex programs, it seldom obvious where a
    fuzzing tool gets stuck. Identifying these cases can greatly help to improve fuzzing
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, let''s rerun the program now with the missing
    constant added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we now found secret 2 including our crash.
  prefs: []
  type: TYPE_NORMAL
- en: Lessons Learned
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When fuzzing (a) with several machines, (b) several programs, (c) with several
    fuzzers, use a *crash server* such as *FuzzManager* to collect and store crashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crashes likely to be caused by the same failure should be collected in *buckets*
    to ensure they all can be treated the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Centrally collecting *fuzzer coverage* can help reveal issues with fuzzers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next Steps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to
  prefs: []
  type: TYPE_NORMAL
- en: estimate [how many bugs remain in the code and when we have tested enough](WhenToStopFuzzing.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter builds on the implementation of [FuzzManager](https://github.com/MozillaSecurity/FuzzManager).
    Its [GitHub page](https://github.com/MozillaSecurity/FuzzManager) contains plenty
    of additional information on how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The blog article ["Browser Fuzzing at Mozilla"](https://blog.mozilla.org/attack-and-defense/2021/05/20/browser-fuzzing-at-mozilla/)
    discusses the context of how FuzzManager is used at Mozilla for massive browser
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: The paper "What makes a good bug report?" [[Bettenburg *et al*, 2008](https://doi.org/10.1145/1453101.1453146)]
    lists essential information that developers expect from a bug report, how they
    use this information, and for which purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exercise 1: Automatic Crash Reporting'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a Python function that can be invoked at the beginning of a program to
    have it automatically report crashes and exceptions to a *FuzzManager* server.
    Have it track program name (and if possible, outputs) automatically; crashes (exceptions
    raised) should be converted into ASan format such that *FuzzManager* can read
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Use the notebook](https://mybinder.org/v2/gh/uds-se/fuzzingbook/HEAD?labpath=docs%2Fnotebooks/FuzzingInTheLarge.ipynb#Exercises)
    to work on the exercises and see solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creative Commons License](../Images/2f3faa36146c6fb38bbab67add09aa5f.png)
    The content of this project is licensed under the [Creative Commons Attribution-NonCommercial-ShareAlike
    4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).
    The source code that is part of the content, as well as the source code used to
    format and display that content is licensed under the [MIT License](https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license).
    [Last change: 2024-01-17 22:03:36+01:00](https://github.com/uds-se/fuzzingbook/commits/master/notebooks/FuzzingInTheLarge.ipynb)
    • [Cite](#citation) • [Imprint](https://cispa.de/en/impressum)'
  prefs: []
  type: TYPE_IMG
- en: How to Cite this Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler: "[Fuzzing in the Large](https://www.fuzzingbook.org/html/FuzzingInTheLarge.html)".
    In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian
    Holler, "[The Fuzzing Book](https://www.fuzzingbook.org/)", [https://www.fuzzingbook.org/html/FuzzingInTheLarge.html](https://www.fuzzingbook.org/html/FuzzingInTheLarge.html).
    Retrieved 2024-01-17 22:03:36+01:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
