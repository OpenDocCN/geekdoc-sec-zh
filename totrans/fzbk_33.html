<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Testing Compilers</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1>Testing Compilers</h1>
<blockquote>原文：<a href="http://www.fuzzingbook.org/html/PythonFuzzer.html">http://www.fuzzingbook.org/html/PythonFuzzer.html</a></blockquote>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In this chapter, we will make use of <a href="Grammars.html">grammars and grammar-based testing</a> to systematically generate <em>program code</em> – for instance, to test a compiler or an interpreter. Not very surprisingly, we use <em>Python</em> and the <em>Python interpreter</em> as our domain.</p>
<p>We chose Python not only because the rest of the book is also based on Python.
Most importantly, Python brings lots of built-in infrastructure we can leverage, especially</p>
<ul>
<li><em>parsers</em> that convert Python code into an abstract syntax tree (AST) representation and </li>
<li><em>unparsers</em> that take an AST and convert it back into Python code.</li>
</ul>
<p>This allows us to leverage grammars that operate on ASTs rather than concrete syntax, greatly reducing complexity.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">YouTubeVideo</span>
<span class="n">YouTubeVideo</span><span class="p">(</span><span class="s1">'Nr1xbKj_WRQ'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

        

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p><strong>Prerequisites</strong></p>
<ul>
<li>You must read the chapter on <a href="Grammars.html">Fuzzing with Grammars</a> to understand how grammars and grammar-based testing work.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><div class="synopsis"><h2 id="Synopsis">Synopsis</h2><!-- Automatically generated. Do not edit. -->

<p>To <a href="Importing.html">use the code provided in this chapter</a>, write</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="PythonFuzzer.html" class="import" target="_blank">fuzzingbook.PythonFuzzer</a></span> <span class="kn">import</span> <span class="o">&lt;</span><span class="n">identifier</span><span class="o">&gt;</span>
</pre></div>
<p>and then make use of the following features.</p>
<p>This chapter provides a <code>PythonFuzzer</code> class that allows producing arbitrary Python code elements:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">R</span><span class="p">():</span>
    <span class="k">break</span>
</pre></div>
<p>By default, <code>PythonFuzzer</code> produces a <em>function definition</em> – that is, a list of statements as above.
You can pass a <code>start_symbol</code> argument to state which Python element you'd like to have:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="s1">'&lt;While&gt;'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
<span class="k">while</span> <span class="p">{</span><span class="nb">set</span><span class="p">()[</span><span class="nb">set</span><span class="p">():</span><span class="nb">set</span><span class="p">():</span><span class="nb">set</span><span class="p">()]}:</span>
    <span class="n">C</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">D</span> <span class="o">@=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">break</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span>
</pre></div>
<p>Here is a list of all possible start symbols. Their names reflect the nonterminals from the <a href="https://docs.python.org/3/library/ast.html">Python <code>ast</code> module documentation</a>.</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
<span class="p">[</span><span class="s1">'&lt;Assert&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Assign&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Attribute&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;AugAssign&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;BinOp&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;BoolOp&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Break&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Call&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Compare&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Constant&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Continue&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Delete&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Dict&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;EmptySet&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;For&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;If&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;List&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Module&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Name&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Pass&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Return&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Set&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Slice&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Starred&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Subscript&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;Tuple&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;UnaryOp&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;While&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;With&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;arg&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;arg_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;args&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;args_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;arguments&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;bool&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;boolop&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;cmpop&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;cmpop_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;cmpops&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;decorator_list_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;defaults_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;digit&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;digits&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;expr_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;exprs&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;float&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;func&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;id&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;id_continue&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;id_start&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;identifier&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;integer&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;keyword&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;keyword_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;keywords&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;keywords_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;kw_defaults_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;kwarg&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;kwonlyargs_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_Attribute&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_List&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_Name&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_Starred&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_Subscript&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_Tuple&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_expr&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;lhs_exprs&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;literal&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;mod&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;none&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;nonempty_expr_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;nonempty_lhs_expr_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;nonempty_stmt_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;nonzerodigit&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;not_double_quotes&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;not_single_quotes&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;operator&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;orelse_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;posonlyargs_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;returns&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;start&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;stmt&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;stmt_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;stmts&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;string&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;type_comment&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;type_ignore&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;type_ignore_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;type_ignore_param&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;type_ignores&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;unaryop&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;vararg&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;withitem&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;withitem_list&gt;'</span><span class="p">,</span>
 <span class="s1">'&lt;withitems&gt;'</span><span class="p">]</span>
</pre></div>
<p>If you'd like more control over Python code generation, here is what is happening behind the scenes.
The EBNF grammar <code>PYTHON_AST_GRAMMAR</code> can parse and produce <em>abstract syntax trees</em> for Python.
To produce a Python module without <code>PythonFuzzer</code>, you would take these steps:</p>
<p><strong>Step 1:</strong> Create a non-EBNF grammar suitable for <code>ISLaSolver</code> (or any other grammar fuzzer):</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">python_ast_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">)</span>
</pre></div>
<p><strong>Step 2:</strong>  Feed the resulting grammar into a grammar fuzzer such as ISLa:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">)</span>
</pre></div>
<p><strong>Step 3:</strong>  Have the grammar fuzzer produce a string. This string represents an AST.</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">ast_string</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">ast_string</span>
<span class="s1">'FunctionDef(name=</span><span class="se">\'</span><span class="s1">y</span><span class="se">\'</span><span class="s1">, args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])'</span>
</pre></div>
<p><strong>Step 4:</strong>  Convert the AST into an actual Python AST data structure.</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/ast.html" class="import" target="_blank">ast</a></span> <span class="kn">import</span> <span class="o">*</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">abstract_syntax_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">ast_string</span><span class="p">)</span>
</pre></div>
<p><strong>Step 5:</strong> Finally, convert the AST structure back into readable Python code:</p>
<div class="highlight"><pre><span/><span class="o">&gt;&gt;&gt;</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">))</span>
<span class="nd">@set</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">y</span><span class="p">():</span>
    <span class="k">return</span>
</pre></div>
<p>The chapter has many more applications, including parsing and mutating Python code, evolutionary fuzzing, and more.</p>
<p>Here are the details on the <code>PythonFuzzer</code> constructor:</p>
<p><code>PythonFuzzer(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str] = None, **kw_params) -&gt; None</code></p>
<p>Produce Python code. Parameters are:</p>
<ul>
<li><code>start_symbol</code>: The grammatical entity to be generated (default: <code>&lt;FunctionDef&gt;</code>)</li>
<li><code>grammar</code>: The EBNF grammar to be used (default: <code>PYTHON__AST_GRAMMAR</code>); and</li>
<li><code>constraint</code> an ISLa constraint (if any).</li>
</ul>
<p>Additional keyword parameters are passed to the <code>ISLaSolver</code> superclass.</p><p>

<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="248pt" height="152pt" viewbox="0.00 0.00 248.12 152.25" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 148.25)">
<g id="a_graph0"><a xlink:title="PythonFuzzer class hierarchy">
<polygon fill="white" stroke="none" points="-4,4 -4,-148.25 244.12,-148.25 244.12,4 -4,4"/>
</a>
</g>
<!-- PythonFuzzer -->
<g id="node1" class="node">
<title>PythonFuzzer</title>
<g id="a_node1"><a xlink:href="#" xlink:title="class PythonFuzzer:&#10;Produce Python code.">
<polygon fill="none" stroke="black" points="0,-0.5 0,-60 103,-60 103,-0.5 0,-0.5"/>
<text text-anchor="start" x="8" y="-43.7" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">PythonFuzzer</text>
<polyline fill="none" stroke="black" points="0,-34 103,-34"/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="PythonFuzzer">
<g id="a_node1_1"><a xlink:href="#" xlink:title="__init__(self, start_symbol: Optional[str] = None, *, grammar: Optional[Dict[str, List[Union[str, Tuple[str, Dict[str, Any]]]]]] = None, constraint: Optional[str] = None, **kw_params) -&gt; None:&#10;Produce Python code. Parameters are:&#10;&#10;* `start_symbol`: The grammatical entity to be generated (default: `&lt;FunctionDef&gt;`)&#10;* `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and&#10;* `constraint` an ISLa constraint (if any).&#10;&#10;Additional keyword parameters are passed to the `ISLaSolver` superclass.">
<text text-anchor="start" x="21.5" y="-21.5" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="#" xlink:title="fuzz(self) -&gt; str:&#10;Produce a Python code string.">
<text text-anchor="start" x="21.5" y="-8.75" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">fuzz()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- ISLaSolver -->
<g id="node2" class="node">
<title>ISLaSolver</title>
<g id="a_node2"><a xlink:href="isla.solver.ipynb" xlink:title="class ISLaSolver:&#10;The solver class for ISLa formulas/constraints. Its top-level methods are&#10;&#10;:meth:`~isla.solver.ISLaSolver.solve`&#10;Use to generate solutions for an ISLa constraint.&#10;&#10;:meth:`~isla.solver.ISLaSolver.check`&#10;Use to check if an ISLa constraint is satisfied for a given input.&#10;&#10;:meth:`~isla.solver.ISLaSolver.parse`&#10;Use to parse and validate an input.&#10;&#10;:meth:`~isla.solver.ISLaSolver.repair`&#10;Use to repair an input such that it satisfies a constraint.&#10;&#10;:meth:`~isla.solver.ISLaSolver.mutate`&#10;Use to mutate an input such that the result satisfies a constraint.">
<polygon fill="none" stroke="black" points="10.88,-97 10.88,-143.75 92.12,-143.75 92.12,-97 10.88,-97"/>
<text text-anchor="start" x="18.88" y="-127.45" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text>
<polyline fill="none" stroke="black" points="10.88,-117.75 92.12,-117.75"/>
<g id="a_node2_3"><a xlink:href="#" xlink:title="ISLaSolver">
<g id="a_node2_4"><a xlink:href="isla.solver.ipynb" xlink:title="__init__(self, grammar: Union[Dict[str, List[str]], str], formula: Union[isla.language.Formula, str, NoneType] = None, structural_predicates: Set[isla.language.StructuralPredicate] = frozenset({StructuralPredicate(name='nth', arity=3, eval_fun=&lt;function is_nth&gt;), StructuralPredicate(name='inside', arity=2, eval_fun=&lt;function in_tree&gt;), StructuralPredicate(name='same_position', arity=2, eval_fun=&lt;function is_same_position&gt;), StructuralPredicate(name='consecutive', arity=2, eval_fun=&lt;function consecutive&gt;), StructuralPredicate(name='different_position', arity=2, eval_fun=&lt;function is_different_position&gt;), StructuralPredicate(name='before', arity=2, eval_fun=&lt;function is_before&gt;), StructuralPredicate(name='level', arity=4, eval_fun=&lt;function level_check&gt;), StructuralPredicate(name='direct_child', arity=2, eval_fun=&lt;function is_direct_child&gt;), StructuralPredicate(name='after', arity=2, eval_fun=&lt;function is_after&gt;)}), semantic_predicates: Set[isla.language.SemanticPredicate] = frozenset({SemanticPredicate(count, 3)}), max_number_free_instantiations: int = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results: int = 5, enforce_unique_trees_in_queue: bool = False, debug: bool = False, cost_computer: Optional[ForwardRef('CostComputer')] = None, timeout_seconds: Optional[int] = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate, ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Dict[str, List[str]]], isla.fuzzer.GrammarFuzzer] = &lt;function SolverDefaults.&lt;lambda&gt;&gt;, tree_insertion_methods: Optional[int] = None, activate_unsat_support: bool = False, grammar_unwinding_threshold: int = 4, initial_tree: isla.helpers.Maybe[isla.derivation_tree.DerivationTree] = Maybe(a=None), enable_optimized_z3_queries: bool = True, start_symbol: Optional[str] = None):&#10;The constructor of :class:`~isla.solver.ISLaSolver` accepts a large number of&#10;parameters. However, all but the first one, :code:`grammar`, are *optional.*&#10;&#10;The simplest way to construct an ISLa solver is by only providing it with a&#10;grammar only; it then works like a grammar fuzzer.&#10;&#10;&gt;&gt;&gt; import random&#10;&gt;&gt;&gt; random.seed(1)&#10;&#10;&gt;&gt;&gt; import string&#10;&gt;&gt;&gt; LANG_GRAMMAR = {&#10;...     &quot;&lt;start&gt;&quot;:&#10;...         [&quot;&lt;stmt&gt;&quot;],&#10;...     &quot;&lt;stmt&gt;&quot;:&#10;...         [&quot;&lt;assgn&gt; ; &lt;stmt&gt;&quot;, &quot;&lt;assgn&gt;&quot;],&#10;...     &quot;&lt;assgn&gt;&quot;:&#10;...         [&quot;&lt;var&gt; := &lt;rhs&gt;&quot;],&#10;...     &quot;&lt;rhs&gt;&quot;:&#10;...         [&quot;&lt;var&gt;&quot;, &quot;&lt;digit&gt;&quot;],&#10;...     &quot;&lt;var&gt;&quot;: list(string.ascii_lowercase),&#10;...     &quot;&lt;digit&gt;&quot;: list(string.digits)&#10;... }&#10;&gt;&gt;&gt;&#10;&gt;&gt;&gt; from isla.solver import ISLaSolver&#10;&gt;&gt;&gt; solver = ISLaSolver(LANG_GRAMMAR)&#10;&gt;&gt;&gt;&#10;&gt;&gt;&gt; str(solver.solve())&#10;'d := 9'&#10;&gt;&gt;&gt; str(solver.solve())&#10;'v := n ; s := r'&#10;&#10;:param grammar: The underlying grammar; either, as a &quot;Fuzzing Book&quot; dictionary&#10;or in BNF syntax.&#10;:param formula: The formula to solve; either a string or a readily parsed&#10;formula. If no formula is given, a default `true` constraint is assumed, and&#10;the solver falls back to a grammar fuzzer. The number of produced solutions&#10;will then be bound by `max_number_free_instantiations`.&#10;:param structural_predicates: Structural predicates to use when parsing a&#10;formula.&#10;:param semantic_predicates: Semantic predicates to use when parsing a formula.&#10;:param max_number_free_instantiations: Number of times that nonterminals that&#10;are not bound by any formula should be expanded by a coverage-based fuzzer.&#10;:param max_number_smt_instantiations: Number of solutions of SMT formulas that&#10;should be produced.&#10;:param max_number_tree_insertion_results: The maximum number of results when&#10;solving existential quantifiers by tree insertion.&#10;:param enforce_unique_trees_in_queue: If true, states with the same tree as an&#10;already existing tree in the queue are discarded, irrespectively of the&#10;constraint.&#10;:param debug: If true, debug information about the evolution of states is&#10;collected, notably in the field state_tree. The root of the tree is in the&#10;field state_tree_root. The field costs stores the computed cost values for&#10;all new nodes.&#10;:param cost_computer: The `CostComputer` class for computing the cost relevant&#10;to placing states in ISLa's queue.&#10;:param timeout_seconds: Number of seconds after which the solver will terminate.&#10;:param global_fuzzer: If set to True, only one coverage-guided grammar fuzzer&#10;object is used to finish off unconstrained open derivation trees throughout&#10;the whole generation time. This may be beneficial for some targets; e.g., we&#10;experienced that CSV works significantly faster. However, the achieved k-path&#10;coverage can be lower with that setting.&#10;:param predicates_unique_in_int_arg: This is needed in certain cases for&#10;instantiating universal integer quantifiers. The supplied predicates should&#10;have exactly one integer argument, and hold for exactly one integer value&#10;once all other parameters are fixed.&#10;:param fuzzer_factory: Constructor of the fuzzer to use for instantiating&#10;&quot;free&quot; nonterminals.&#10;:param tree_insertion_methods: Combination of methods to use for existential&#10;quantifier elimination by tree insertion. Full selection: `DIRECT_EMBEDDING &amp;&#10;SELF_EMBEDDING &amp; CONTEXT_ADDITION`.&#10;:param activate_unsat_support: Set to True if you assume that a formula might&#10;be unsatisfiable. This triggers additional tests for unsatisfiability that&#10;reduce input generation performance, but might ensure termination (with a&#10;negative solver result) for unsatisfiable problems for which the solver could&#10;otherwise diverge.&#10;:param grammar_unwinding_threshold: When querying the SMT solver, ISLa passes a&#10;regular expression for the syntax of the involved nonterminals. If this&#10;syntax is not regular, we unwind the respective part in the reference grammar&#10;up to a depth of `grammar_unwinding_threshold`. If this is too shallow, it can&#10;happen that an equation etc. cannot be solved; if it is too deep, it can&#10;negatively impact performance (and quite tremendously so).&#10;:param initial_tree: An initial input tree for the queue, if the solver shall&#10;not start from the tree `(&lt;start&gt;, None)`.&#10;:param enable_optimized_z3_queries: Enables preprocessing of Z3 queries (mainly&#10;numeric problems concerning things like length). This can improve performance&#10;significantly; however, it might happen that certain problems cannot be solved&#10;anymore. In that case, this option can/should be deactivated.&#10;:param start_symbol: This is an alternative to `initial_tree` for starting with&#10;a start symbol different form `&lt;start&gt;`. If `start_symbol` is provided, a tree&#10;consisting of a single root node with the value of `start_symbol` is chosen as&#10;initial tree.">
<text text-anchor="start" x="21.5" y="-105.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-style="italic" font-size="10.00">__init__()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- PythonFuzzer&#45;&gt;ISLaSolver -->
<g id="edge1" class="edge">
<title>PythonFuzzer-&gt;ISLaSolver</title>
<path fill="none" stroke="black" d="M51.5,-60.11C51.5,-68.16 51.5,-76.98 51.5,-85.3"/>
<polygon fill="none" stroke="black" points="48,-85.09 51.5,-95.09 55,-85.09 48,-85.09"/>
</g>
<!-- Legend -->
<g id="node3" class="node">
<title>Legend</title>
<text text-anchor="start" x="120.88" y="-46.25" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="120.88" y="-36.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-36.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="120.88" y="-26.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-26.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="120.88" y="-16.25" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="126.88" y="-16.25" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="120.88" y="-7.2" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
</p>
</div>
</div>
</div>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="A-Grammar-for-Concrete-Code">A Grammar for Concrete Code</h2><p>To <em>produce</em> code, it is fairly easy to write a grammar with <em>concrete</em> syntax. If we want to produce, say, arithmetic expressions, we can easily create a concrete grammar which does precisely that.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils.setup</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">Grammar</span>
<span class="kn">from</span> <span class="nn"><a href="Grammars.html" class="import" target="_blank">Grammars</a></span> <span class="kn">import</span> <span class="n">is_valid_grammar</span><span class="p">,</span> <span class="n">convert_ebnf_grammar</span><span class="p">,</span> <span class="n">extend_grammar</span><span class="p">,</span> <span class="n">trim_grammar</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/typing.html" class="import" target="_blank">typing</a></span> <span class="kn">import</span> <span class="n">Optional</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We use the <a href="https://www.fuzzingbook.org/html/Grammars.html">Fuzzingbook format for grammars</a>, in which grammars are represented as dictionaries from symbols to lists of expansion alternatives.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">EXPR_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">"&lt;start&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"&lt;expr&gt;"</span><span class="p">],</span>

    <span class="s2">"&lt;expr&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"&lt;term&gt; + &lt;expr&gt;"</span><span class="p">,</span> <span class="s2">"&lt;term&gt; - &lt;expr&gt;"</span><span class="p">,</span> <span class="s2">"&lt;term&gt;"</span><span class="p">],</span>

    <span class="s2">"&lt;term&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"&lt;factor&gt; * &lt;term&gt;"</span><span class="p">,</span> <span class="s2">"&lt;factor&gt; / &lt;term&gt;"</span><span class="p">,</span> <span class="s2">"&lt;factor&gt;"</span><span class="p">],</span>

    <span class="s2">"&lt;factor&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"+&lt;factor&gt;"</span><span class="p">,</span>
         <span class="s2">"-&lt;factor&gt;"</span><span class="p">,</span>
         <span class="s2">"(&lt;expr&gt;)"</span><span class="p">,</span>
         <span class="s2">"&lt;integer&gt;.&lt;integer&gt;"</span><span class="p">,</span>
         <span class="s2">"&lt;integer&gt;"</span><span class="p">],</span>

    <span class="s2">"&lt;integer&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"&lt;digit&gt;&lt;integer&gt;"</span><span class="p">,</span> <span class="s2">"&lt;digit&gt;"</span><span class="p">],</span>

    <span class="s2">"&lt;digit&gt;"</span><span class="p">:</span>
        <span class="p">[</span><span class="s2">"0"</span><span class="p">,</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"3"</span><span class="p">,</span> <span class="s2">"4"</span><span class="p">,</span> <span class="s2">"5"</span><span class="p">,</span> <span class="s2">"6"</span><span class="p">,</span> <span class="s2">"7"</span><span class="p">,</span> <span class="s2">"8"</span><span class="p">,</span> <span class="s2">"9"</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can use this grammar to produce syntactically valid arithmetic expressions.
We use the <a href="FuzzingWithConstraints.html">ISLa solver</a> as our generator, as it is the most powerful; but we could also use any other of our grammar fuzzers such as <a href="GrammarFuzzer.html">GrammarFuzzer</a> at this point.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://rindphi.github.io/isla/" class="import" target="_blank">isla.solver</a></span> <span class="kn">import</span> <span class="n">ISLaSolver</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here are some concrete inputs produced from the grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">EXPR_GRAMMAR</span><span class="p">)</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">expr_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>4.3 + 512 / -(7 / 6 - 0 / 9 * 1 * 1) * +8.3 / 7 * 4 / 6
(4 / 7 + 1) / (4) / 9 / 8 + 4 / (3 + 6 - 7)
+--(--(-9) * (4 * 7 + (4) + 4) + --(+(3)) - 6 + 0 / 7 + 7)
(2 * 6 + 0 - 5) * 4 - +1 * (2 - 2) / 8 / 6
(+-(0 - (1) * 7 / 3)) / ((1 * 3 + 8) + 9 - +1 / --0) - 5 * (-+939.491)
+2.9 * 0 / 501.19814 / --+--(6.05002)
+-8.8 / (1) * -+1 + -8 + 9 - 3 / 8 * 6 + 4 * 3 * 5
(+(8 / 9 - 1 - 7)) + ---06.30 / +4.39
8786.82 - +01.170 / 9.2 - +(7) + 1 * 9 - 0
+-6 * 0 / 5 * (-(1.7 * +(-1 / +4.9 * 5 * 1 * 2) + -4.2 + (6 + -5) / (4 * 3 + 4)))
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We could extend the grammar further to also produce assignments and other statements, and piece by piece cover the entire syntax of the programming language. However, this would be a not-so-great idea. Why?</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The problem is that when testing <em>compilers</em>, you not only want to be able to <em>produce</em> code, but also to <em>parse</em> code, such that you can mutate and manipulate it at will. And this is where our "concrete" syntax will give us problems. While we can easily parse code (or expressions) that exactly adheres to the syntax...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'2 + 2'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>True
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>... a single space will already suffice to make it fail...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'2 +  2'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Error parsing "2 +  2" starting with "&lt;start&gt;"
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>... as does the absence of spaces:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'2+2'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Error parsing "2+2" starting with "&lt;start&gt;"
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Indeed, spaces are optional in most programming languages. We <em>could</em> update our grammar such that it can handle optional spaces at all times (introducing a <code>&lt;space&gt;</code> nonterminal). But then, there are other features like <em>comments</em>...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'2 + 2    # should be 4'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Error parsing "2 + 2    # should be 4" starting with "&lt;start&gt;"
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>... or <em>continuation lines</em> ...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'2 + </span><span class="se">\\\n</span><span class="s1">2'</span><span class="p">)</span>  <span class="c1"># An expression split over two lines</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Error parsing "2 + \
2" starting with "&lt;start&gt;"
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>that our grammar would have to cover.</p>
<p>On top, there are language features that cannot be even represented properly in a context-free grammar:</p>
<ul>
<li>In the C programming language, for instance, the parser needs to know whether an identifier has been defined as a <em>type</em></li>
<li>In Python, <em>indentation</em> levels cannot be represented by a context-free grammar.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>For this reason, it is often a good idea to make use of a dedicated <em>parser</em> (or <em>preprocessor</em>) to turn input into a more <em>abstract</em> representation - typically a <em>tree</em> structure. In programming languages, such a tree is called an <em>abstract syntax tree</em> (AST); it is the data structure that compilers operate on.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Abstract-Syntax-Trees">Abstract Syntax Trees</h2><p>Abstract Syntax Trees (ASTs) that represent program code are among the most complex data structures in the world (if not <em>the</em> most complex data structures) - notably because they reflect all the complexity of the programming language and its features.
The good news is that in Python, working with ASTs is particularly easy - one can work with them using standard language features.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us illustrate ASTs using an example. Here is a piece of code that we'd like to work with:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Hello, world!"</span><span class="p">)</span>  <span class="c1"># A simple example</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Hello, world!
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us obtain the source code of this function:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/inspect.html" class="import" target="_blank">inspect</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">main_source</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">main</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">main_source</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def main():
    print("Hello, world!")  # A simple example
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We make use of the <a href="https://docs.python.org/3/library/ast.html">Python AST module</a> to convert this code string to an AST and back.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/ast.html" class="import" target="_blank">ast</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With <code>ast.parse()</code>, we can parse the <code>main()</code> source into an AST:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">main_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">main_source</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>This is what this tree looks like:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">show_ast</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">show_ast</span><span class="p">(</span><span class="n">main_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_image output_svg output_subarea ">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="369pt" height="332pt" viewbox="0.00 0.00 368.62 332.00">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
<polygon fill="white" stroke="none" points="-4,4 -4,-328 364.62,-328 364.62,4 -4,4"/>
<!-- 0 -->
<g id="node1" class="node">
<title>0</title>
<text text-anchor="start" x="83.38" y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">FunctionDef</text>
</g>
<!-- 1 -->
<g id="node2" class="node">
<title>1</title>
<text text-anchor="middle" x="32.75" y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"main"</text>
</g>
<!-- 0&#45;&#45;1 -->
<g id="edge1" class="edge">
<title>0--1</title>
<path fill="none" stroke="black" d="M128.75,-287C128.75,-287 91.95,-267.07 63.92,-251.88"/>
</g>
<!-- 2 -->
<g id="node3" class="node">
<title>2</title>
<text text-anchor="middle" x="128.75" y="-228.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">arguments</text>
</g>
<!-- 0&#45;&#45;2 -->
<g id="edge2" class="edge">
<title>0--2</title>
<path fill="none" stroke="black" d="M128.75,-287C128.75,-287 128.75,-266.94 128.75,-251.74"/>
</g>
<!-- 3 -->
<g id="node4" class="node">
<title>3</title>
<text text-anchor="start" x="202.25" y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Expr</text>
</g>
<!-- 0&#45;&#45;3 -->
<g id="edge3" class="edge">
<title>0--3</title>
<path fill="none" stroke="black" d="M128.75,-287C128.75,-287 165.69,-265.66 192.23,-250.32"/>
</g>
<!-- 4 -->
<g id="node5" class="node">
<title>4</title>
<text text-anchor="start" x="202.25" y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Call</text>
</g>
<!-- 3&#45;&#45;4 -->
<g id="edge4" class="edge">
<title>3--4</title>
<path fill="none" stroke="black" d="M218.75,-216.05C218.75,-205.05 218.75,-190.76 218.75,-179.79"/>
</g>
<!-- 5 -->
<g id="node6" class="node">
<title>5</title>
<text text-anchor="start" x="159.25" y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Name</text>
</g>
<!-- 4&#45;&#45;5 -->
<g id="edge5" class="edge">
<title>4--5</title>
<path fill="none" stroke="black" d="M219.75,-143C219.75,-143 202.78,-122.94 189.91,-107.74"/>
</g>
<!-- 8 -->
<g id="node9" class="node">
<title>8</title>
<text text-anchor="start" x="242.75" y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text>
</g>
<!-- 4&#45;&#45;8 -->
<g id="edge8" class="edge">
<title>4--8</title>
<path fill="none" stroke="black" d="M219.75,-143C219.75,-143 241.35,-122.94 257.72,-107.74"/>
</g>
<!-- 6 -->
<g id="node7" class="node">
<title>6</title>
<text text-anchor="middle" x="93.75" y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"print"</text>
</g>
<!-- 5&#45;&#45;6 -->
<g id="edge6" class="edge">
<title>5--6</title>
<path fill="none" stroke="black" d="M167.75,-71C167.75,-71 139.2,-50.94 117.57,-35.74"/>
</g>
<!-- 7 -->
<g id="node8" class="node">
<title>7</title>
<text text-anchor="middle" x="175.75" y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Load</text>
</g>
<!-- 5&#45;&#45;7 -->
<g id="edge7" class="edge">
<title>5--7</title>
<path fill="none" stroke="black" d="M167.75,-71C167.75,-71 170.84,-50.94 173.17,-35.74"/>
</g>
<!-- 9 -->
<g id="node10" class="node">
<title>9</title>
<text text-anchor="middle" x="290.75" y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">"Hello, world!"</text>
</g>
<!-- 8&#45;&#45;9 -->
<g id="edge9" class="edge">
<title>8--9</title>
<path fill="none" stroke="black" d="M279.38,-72.05C281.74,-61.05 284.8,-46.76 287.15,-35.79"/>
</g>
</g>
</svg>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see how the function definition has become a <code>FunctionDef</code> node, whose third child is an <code>Expr</code> node, which in turn becomes a <code>Call</code> – of the <code>"print"</code> function with an argument of <code>"Hello, world!"</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Each of these AST nodes comes as a <em>constructor</em> – that is, we can invoke <code>FunctionDef()</code> to obtain a function definition node, or <code>Call()</code> to obtain a call node.
These constructors take the AST <em>children</em> as arguments, but also lots of <em>optional</em> arguments (which we did not use so far). The <em>dump</em> of the AST into a string reveals all the arguments for each constructor:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">main_tree</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        FunctionDef(
            name='main',
            args=arguments(
                posonlyargs=[],
                args=[],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[]),
            body=[
                Expr(
                    value=Call(
                        func=Name(id='print', ctx=Load()),
                        args=[
                            Constant(value='Hello, world!')],
                        keywords=[]))],
            decorator_list=[])],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The <a href="https://docs.python.org/3/library/ast.html">Python ast documentation</a> lists all these constructors, which make up the abstract syntax. There are more than 100 individual constructors! (We said that ASTs are complex, right?)</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The nice thing about the above string representation is that we can take it <em>as is</em> and turn it into a tree again:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://docs.python.org/3/library/ast.html" class="import" target="_blank">ast</a></span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">my_main_tree</span> <span class="o">=</span> <span class="n">Module</span><span class="p">(</span>
    <span class="n">body</span><span class="o">=</span><span class="p">[</span>
        <span class="n">FunctionDef</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s1">'main'</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span>
                <span class="n">posonlyargs</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">args</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">kwonlyargs</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">kw_defaults</span><span class="o">=</span><span class="p">[],</span>
                <span class="n">defaults</span><span class="o">=</span><span class="p">[]),</span>
            <span class="n">body</span><span class="o">=</span><span class="p">[</span>
                <span class="n">Expr</span><span class="p">(</span>
                    <span class="n">value</span><span class="o">=</span><span class="n">Call</span><span class="p">(</span>
                        <span class="n">func</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s1">'print'</span><span class="p">,</span> <span class="n">ctx</span><span class="o">=</span><span class="n">Load</span><span class="p">()),</span>
                        <span class="n">args</span><span class="o">=</span><span class="p">[</span>
                            <span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="s1">'Hello, world!'</span><span class="p">)],</span>
                        <span class="n">keywords</span><span class="o">=</span><span class="p">[]))],</span>
            <span class="n">decorator_list</span><span class="o">=</span><span class="p">[])],</span>
    <span class="n">type_ignores</span><span class="o">=</span><span class="p">[])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can take this tree and compile it into executable code:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">my_main_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">)</span>  <span class="c1"># required for trees built from constructors</span>
<span class="n">my_main_code</span> <span class="o">=</span> <span class="nb">compile</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">'&lt;unknown&gt;'</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'exec'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">del</span> <span class="n">main</span>  <span class="c1"># This deletes the definition of main()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">exec</span><span class="p">(</span><span class="n">my_main_code</span><span class="p">)</span>  <span class="c1"># This defines main() again from `code`</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">main</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Hello, world!
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can also <em>unparse</em> the tree (= turn it into source code again). (Note how the comment got lost during parsing.)</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">my_main_tree</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def main():
    print('Hello, world!')
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Hence, we can</p>
<ol>
<li><em>Parse</em> concrete code into ASTs (with <code>ast.parse()</code>)</li>
<li><em>Generate</em> new ASTs and <em>mutate</em> existing ones</li>
<li><em>Unparse</em> ASTs to obtain concrete code again (with <code>ast.unparse()</code>)</li>
</ol>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To <em>generate</em> and <em>mutate</em> ASTs (step #2, above), we need means to produce <em>correct</em> ASTs, invoking all constructors with the correct arguments.
The plan is thus to have a <em>grammar</em> for ASTs, which produces (and parses) ASTs as we like.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="A-Grammar-for-ASTs">A Grammar for ASTs</h2><p>Programming language grammars are among the most complicated formal grammars around, and ASTs reflect much of this complexity. We will use the <a href="https://docs.python.org/3/library/ast.html">abstract AST grammar</a> as specified in the Python documentation as base, and build a formal context-free grammar step by step.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Constants">Constants</h3><p>We will start with simple constants – strings and integers. Again, we use the <code>fuzzingbook</code> syntax for grammars, as it allows for easier extension.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">import</span> <span class="nn"><a href="https://docs.python.org/3/library/string.html" class="import" target="_blank">string</a></span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">+</span> <span class="s1">' '</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'"'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
<span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span> <span class="o">=</span> <span class="p">(</span><span class="n">string</span><span class="o">.</span><span class="n">digits</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">punctuation</span> <span class="o">+</span> <span class="s1">' '</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'</span><span class="se">\\</span><span class="s1">'</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;'()*+,-./:;&lt;=&gt;?@[]^_`{|}~ "
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;()*+,-./:;&lt;=&gt;?@[]^_`{|}~ '
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;expr&gt;'</span> <span class="p">],</span>

    <span class="c1"># Expressions</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;Constant&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Expr&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;Expr&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Expr(value=&lt;expr&gt;)'</span> <span class="p">],</span>

    <span class="c1"># Constants</span>
    <span class="s1">'&lt;Constant&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Constant(value=&lt;literal&gt;)'</span> <span class="p">],</span>
    <span class="s1">'&lt;literal&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;string&gt;'</span><span class="p">,</span> <span class="s1">'&lt;integer&gt;'</span><span class="p">,</span> <span class="s1">'&lt;float&gt;'</span><span class="p">,</span> <span class="s1">'&lt;bool&gt;'</span><span class="p">,</span> <span class="s1">'&lt;none&gt;'</span> <span class="p">],</span>

    <span class="c1"># Strings</span>
    <span class="s1">'&lt;string&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'"&lt;not_double_quotes&gt;*"'</span><span class="p">,</span> <span class="s2">"'&lt;not_single_quotes&gt;*'"</span> <span class="p">],</span>
    <span class="s1">'&lt;not_double_quotes&gt;'</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANYTHING_BUT_DOUBLE_QUOTES_AND_BACKSLASH</span><span class="p">),</span>
    <span class="s1">'&lt;not_single_quotes&gt;'</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ANYTHING_BUT_SINGLE_QUOTES_AND_BACKSLASH</span><span class="p">),</span>
    <span class="c1"># FIXME: The actual rules for Python strings are also more complex:</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals</span>

    <span class="c1"># Numbers</span>
    <span class="s1">'&lt;integer&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;digit&gt;'</span><span class="p">,</span> <span class="s1">'&lt;nonzerodigit&gt;&lt;digits&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;float&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;integer&gt;.&lt;integer&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;nonzerodigit&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">,</span> <span class="s1">'5'</span><span class="p">,</span> <span class="s1">'6'</span><span class="p">,</span> <span class="s1">'7'</span><span class="p">,</span> <span class="s1">'8'</span><span class="p">,</span> <span class="s1">'9'</span><span class="p">],</span>
    <span class="s1">'&lt;digits&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;digit&gt;&lt;digits&gt;'</span><span class="p">,</span> <span class="s1">'&lt;digit&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;digit&gt;'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">'2'</span><span class="p">,</span> <span class="s1">'3'</span><span class="p">,</span> <span class="s1">'4'</span><span class="p">,</span> <span class="s1">'5'</span><span class="p">,</span> <span class="s1">'6'</span><span class="p">,</span> <span class="s1">'7'</span><span class="p">,</span> <span class="s1">'8'</span><span class="p">,</span> <span class="s1">'9'</span><span class="p">],</span>
    <span class="c1"># FIXME: There are _many_ more ways to express numbers in Python; see</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#numeric-literals</span>

    <span class="c1"># More</span>
    <span class="s1">'&lt;bool&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'True'</span><span class="p">,</span> <span class="s1">'False'</span> <span class="p">],</span>
    <span class="s1">'&lt;none&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'None'</span> <span class="p">],</span>

    <span class="c1"># FIXME: Not supported: bytes, format strings, regex strings...</span>
<span class="p">}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Note that we use <em>extended Backus-Naur form</em> in our grammars (here: <code>&lt;string&gt;</code>):</p>
<ul>
<li><code>&lt;elem&gt;+</code> stands for one or more instances of <code>&lt;elem&gt;</code>;</li>
<li><code>&lt;elem&gt;*</code> stands for zero or more instances of <code>&lt;elem&gt;</code>;</li>
<li><code>&lt;elem&gt;?</code> stands for one or zero instances of <code>&lt;elem&gt;</code>.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>A call to <code>is_valid_grammar()</code> ensures our grammar is free of common mistakes. Don't write grammars without it!</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">constants_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
<span class="n">constants_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constants_tree_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">constants_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="n">constants_tree_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Expr(value=Constant(value=None))
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can create an AST from this expression and turn it into Python code (well, a literal):</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">constants_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">constants_tree_str</span><span class="p">)</span>
<span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">constants_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'None'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let's do this a number of times:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">test_samples</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">start_symbol</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">log</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="n">max_number_free_instantiations</span><span class="o">=</span><span class="n">iterations</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
        <span class="n">tree_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">tree_str</span><span class="p">)</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
            <span class="n">code</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">code</span><span class="si">:</span><span class="s1">40</span><span class="si">}</span><span class="s1"> # </span><span class="si">{</span><span class="n">tree_str</span><span class="si">}</span><span class="s1">'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>False                                    # Expr(value=Constant(value=False))
2                                        # Constant(value=2)
None                                     # Constant(value=None)
'#'                                      # Constant(value="#")
550.81                                   # Constant(value=550.81)
True                                     # Constant(value=True)
'.'                                      # Constant(value='.')
467                                      # Constant(value=467)
7894                                     # Constant(value=7894)
263                                      # Constant(value=263)
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our grammar can also <em>parse</em> ASTs obtained from concrete code.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sample_constant_code</span> <span class="o">=</span> <span class="s2">"4711"</span>
<span class="n">sample_constant_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sample_constant_code</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the `Expr` node</span>
<span class="n">sample_constant_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sample_constant_ast</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Expr(value=Constant(value=4711))
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">constant_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constant_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>True
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us now come up with a quiz question: <em>Does our grammar support negative numbers?</em>
For this, let's first find out if the <code>Constant()</code> constructor also take a <em>negative</em> number as an argument? It turns out it can:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'-1'
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>But what happens if we parse a negative number, say <code>-1</code>? One might assume that this simply results in a <code>Constant(-1)</code>, right? Try it out yourself!</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="https://github.com/uds-se/fuzzingbook//tree/master/notebooks/shared/bookutils" class="import" target="_blank">bookutils</a></span> <span class="kn">import</span> <span class="n">quiz</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_html rendered_html output_subarea output_execute_result">

    

    <div class="quiz">
    <h3 class="quiz_title">Quiz</h3>
    <p>
    </p><div class="quiz_question">If we parse a negative number, do we obtain </div>
    
    <p>
    </p><div class="quiz_options" title="Pick a choice.">

        <input type="radio" name="c848bd34-d89c-11ef-9697-6298cf1a5790" id="c848bd34-d89c-11ef-9697-6298cf1a5790-1" onclick="clear_selection('c848bd34-d89c-11ef-9697-6298cf1a5790')"/>
        <label id="c848bd34-d89c-11ef-9697-6298cf1a5790-1-label" for="c848bd34-d89c-11ef-9697-6298cf1a5790-1">a <code>Constant()</code> with a negative value, or</label><br/>

        <input type="radio" name="c848bd34-d89c-11ef-9697-6298cf1a5790" id="c848bd34-d89c-11ef-9697-6298cf1a5790-2" onclick="clear_selection('c848bd34-d89c-11ef-9697-6298cf1a5790')"/>
        <label id="c848bd34-d89c-11ef-9697-6298cf1a5790-2-label" for="c848bd34-d89c-11ef-9697-6298cf1a5790-2">a unary <code>-</code> operator applied to a positive value?</label><br/>

    </div>
    
    <input id="c848bd34-d89c-11ef-9697-6298cf1a5790-submit" type="submit" value="Submit" onclick="check_selection('c848bd34-d89c-11ef-9697-6298cf1a5790', 4, 0, '')"/>
    <span class="quiz_hint" id="c848bd34-d89c-11ef-9697-6298cf1a5790-hint"/>
    </div>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The answer is that parsing <code>-1</code> yields a unary minus <code>USub()</code> applied to a positive value:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">'-1'</span><span class="p">)))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(body=[Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))], type_ignores=[])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As unary operators are not part of our grammar (yet), it cannot handle negative numbers:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sample_constant_code</span> <span class="o">=</span> <span class="s2">"-1"</span>
<span class="n">sample_constant_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sample_constant_code</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># get the `Expr` node</span>
<span class="n">sample_constant_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sample_constant_ast</span><span class="p">)</span>
<span class="n">constant_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">constants_grammar</span><span class="p">)</span>
<span class="n">constant_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sample_constant_ast_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Error parsing "Expr(value=UnaryOp(op=USub(), operand=Constant(value=1)))" starting with "&lt;start&gt;"
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In the next sections, we will gradually expand our grammar with more and more Python features, eventually covering (almost) the entire language.</p>
</div>
</div>
</div>
</div>

<details id="Excursion:-Composites">
<summary>Composites</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us add composite constants – lists, dictionaries, tuples, etc. Here is how these are represented in an AST:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"{ 'a': set() }"</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        Expr(
            value=Dict(
                keys=[
                    Constant(value='a')],
                values=[
                    Call(
                        func=Name(id='set', ctx=Load()),
                        args=[],
                        keywords=[])]))],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us encode these into a grammar, again using the definitions from the <a href="https://docs.python.org/3/library/ast.html">abstract AST grammar</a>.
All these structures also take <em>contexts</em> in which identifiers are used – <code>Load()</code> if they are used for evaluation, <code>Store()</code> if they appear on the left-hand side of an assignment (yes, in Python, you can have a tuple on the left-hand side of an assignment, say <code>(x, y) = (1, 2)</code>), and <code>Del()</code> if they are used as operands in a <code>del</code> statement. Right now, we only use <code>Load()</code> and <code>Del()</code> interchangeably.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span>
    <span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_CONSTANTS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">'&lt;Dict&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Set&gt;'</span><span class="p">,</span> <span class="s1">'&lt;List&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Tuple&gt;'</span>
    <span class="p">],</span>

    <span class="s1">'&lt;Dict&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Dict(keys=&lt;expr_list&gt;, values=&lt;expr_list&gt;)'</span> <span class="p">],</span>
    <span class="s1">'&lt;Set&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Set(elts=&lt;nonempty_expr_list&gt;)'</span><span class="p">,</span> <span class="s1">'&lt;EmptySet&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;EmptySet&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])'</span> <span class="p">],</span>
    <span class="s1">'&lt;List&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'List(elts=&lt;expr_list&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'List(elts=&lt;expr_list&gt;, ctx=Del())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;Tuple&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Tuple(elts=&lt;expr_list&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'Tuple(elts=&lt;expr_list&gt;, ctx=Del())'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Lists of expressions</span>
    <span class="s1">'&lt;expr_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;exprs&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;nonempty_expr_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;exprs&gt;]'</span> <span class="p">],</span>
    <span class="s1">'&lt;exprs&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;expr&gt;'</span><span class="p">,</span> <span class="s1">'&lt;exprs&gt;, &lt;expr&gt;'</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;Constant&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Dict&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Set&gt;'</span><span class="p">,</span> <span class="s1">'&lt;List&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Tuple&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Constant&gt;
'c'                                      # Constant(value='c')
96.7                                     # Constant(value=96.7)
None                                     # Constant(value=None)
False                                    # Constant(value=False)
505                                      # Constant(value=505)
'U'                                      # Constant(value="U")
True                                     # Constant(value=True)
41398                                    # Constant(value=41398)
24                                       # Constant(value=24)
72                                       # Constant(value=72)

&lt;Dict&gt;
{}                                       # Dict(keys=[], values=[List(elts=[Dict(keys=[List(elts=[Constant(value=9.63)], ctx=Load())], values=[Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Set(elts=[Constant(value=True), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])], ctx=Load())]), Constant(value=2), Tuple(elts=[Constant(value=''), Constant(value=False), Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), Expr(value=List(elts=[Constant(value=None)], ctx=Load())), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Del())])
{577: ''}                                # Dict(keys=[Constant(value=577), Constant(value=34), Constant(value=286), Constant(value=7051)], values=[Constant(value="")])
{90: 14}                                 # Dict(keys=[Constant(value=90)], values=[Constant(value=14), Constant(value=88), Constant(value=435)])
{"nF}[ (^{bXBrwzf-P@geW'.]~G&gt;;O2i&amp;/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|&lt;Y6lD+%I": 'Gym]A&amp;K;70{jJLC"DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F&gt;_&lt;a}kI2norf9H[T,lXt=w6@Z*1$xs`"R3'} # Dict(keys=[Constant(value="nF}[ (^{bXBrwzf-P@geW'.]~G&gt;;O2i&amp;/t7Cc5:QU1jR4q_8VJ)Hsxd#o*aT3Sv!$ku?IhMpmA,EL0ZN=`9yK|&lt;Y6lD+%I")], values=[Constant(value='Gym]A&amp;K;70{jJLC"DV)/Y S.eNMEQq^%?i+-b!hz|gcUBvW485O#pPu~d:(F&gt;_&lt;a}kI2norf9H[T,lXt=w6@Z*1$xs`"R3')])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=True), Constant(value=687596.53), Dict(keys=[Set(elts=[Expr(value=Set(elts=[Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), Constant(value=34.676)]))])], values=[Set(elts=[Set(elts=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())], ctx=Del())])])]), List(elts=[], ctx=Load())])
{}                                       # Dict(keys=[], values=[])
{}                                       # Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], values=[])
{}                                       # Dict(keys=[Tuple(elts=[], ctx=Del())], values=[])

&lt;Set&gt;
{
[], 79.2}                              # Set(elts=[Expr(value=List(elts=[], ctx=Del())), Constant(value=79.2)])
set()                                    # Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])
{{{False: [set()], None: []}, (({20: set()},),)}} # Set(elts=[Set(elts=[Dict(keys=[Constant(value=False), Constant(value=None)], values=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), List(elts=[], ctx=Del())]), Tuple(elts=[Tuple(elts=[Dict(keys=[Constant(value=20)], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=True), List(elts=[], ctx=Del())])], ctx=Load())], ctx=Del())])])
{'Z'}                                    # Set(elts=[Constant(value='Z')])
{3763, ''}                               # Set(elts=[Constant(value=3763), Constant(value="")])
{475, 136, 95, 841, 58}                  # Set(elts=[Constant(value=475), Constant(value=136), Constant(value=95), Constant(value=841), Constant(value=58)])
{"F3Ye]1UZz&amp;sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ'h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK&lt;9A*#i}yTx&gt;{."} # Set(elts=[Constant(value="F3Ye]1UZz&amp;sPrG:D-R`k?5d+SM,/4b!uE fW;L$)@oQ'h^qI[(lXgN0wmt=~Jav86|Vp%72CcOBj_nHK&lt;9A*#i}yTx&gt;{.")])
{66, 7}                                  # Set(elts=[Constant(value=66), Constant(value=7)])
{set(), '', None, '_P[', 'L}w,6'}        # Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=''), Constant(value=None), Constant(value='_P['), Constant(value='L}w,6')])
{'51I{Ef&amp;u;kThXbRo]cV/8)Q@W&gt;4|=J7lHge"+^y%(rv&lt;q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY'} # Set(elts=[Constant(value='51I{Ef&amp;u;kThXbRo]cV/8)Q@W&gt;4|=J7lHge"+^y%(rv&lt;q.DM:najxi9OUG?!KS zsd2t-Fm3NApB#0$~C`*PY')])

&lt;List&gt;
[[], {831.3: (7, set(), {('1',)})}]      # List(elts=[List(elts=[], ctx=Load()), Dict(keys=[Constant(value=831.30), Constant(value=None), Expr(value=Tuple(elts=[Constant(value=""), Constant(value=True), Constant(value=False)], ctx=Del()))], values=[Tuple(elts=[Constant(value=7), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Set(elts=[Tuple(elts=[Constant(value='1')], ctx=Load())])], ctx=Load())])], ctx=Del())
[22]                                     # List(elts=[Constant(value=22)], ctx=Load())
[64]                                     # List(elts=[Constant(value=64)], ctx=Load())
[56]                                     # List(elts=[Constant(value=56)], ctx=Del())
[9589]                                   # List(elts=[Constant(value=9589)], ctx=Load())
[780]                                    # List(elts=[Constant(value=780)], ctx=Del())
[164, 47]                                # List(elts=[Constant(value=164), Constant(value=47)], ctx=Load())
["^dG@0 N26zE73qSfX,&gt;xhPlW#j.1cQO4bF+A:LZR'CT=$i_", 'tJI`]gD_M/8yu!%&lt;n~&amp;H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO'] # List(elts=[Constant(value="^dG@0 N26zE73qSfX,&gt;xhPlW#j.1cQO4bF+A:LZR'CT=$i_"), Constant(value="tJI`]gD_M/8yu!%&lt;n~&amp;H|9w*)Ur5sk(e}[vap?V-oK{BYm;eccmO")], ctx=Load())
['e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw"li|Mq?_UI45$)zNh#gDcs;!-d[,(~{&gt;bYrE&lt;.RQ27}&amp;moSk+vjP=6y9'] # List(elts=[Constant(value='e]@JX9LBnA:0Ha^3KVf OWuFT%*8ZGtp/x`Cw"li|Mq?_UI45$)zNh#gDcs;!-d[,(~{&gt;bYrE&lt;.RQ27}&amp;moSk+vjP=6y9')], ctx=Load())
[set(), set()]                           # List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())

&lt;Tuple&gt;
()                                       # Tuple(elts=[], ctx=Load())
(set(),)                                 # Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())
(set(), [], 
1.4, [[None], True], {set(): (False, {set()})}) # Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Del()), Expr(value=Constant(value=1.4)), List(elts=[List(elts=[Constant(value=None)], ctx=Load()), Constant(value=True)], ctx=Load()), Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), Expr(value=Constant(value=False))], values=[Tuple(elts=[Constant(value=False), Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])], ctx=Load())])], ctx=Del())
('',)                                    # Tuple(elts=[Constant(value="")], ctx=Load())
(93,)                                    # Tuple(elts=[Constant(value=93)], ctx=Load())
(28371613, 51, 892, 45, 10678, '')       # Tuple(elts=[Constant(value=28371613), Constant(value=51), Constant(value=892), Constant(value=45), Constant(value=10678), Constant(value='')], ctx=Del())
(72, 632)                                # Tuple(elts=[Constant(value=72), Constant(value=632)], ctx=Load())
('p[R#U', '5JRh~3', 'aAI&gt;V+LBk60Ogp')    # Tuple(elts=[Constant(value='p[R#U'), Constant(value="5JRh~3"), Constant(value="aAI&gt;V+LBk60Ogp")], ctx=Load())
(363,)                                   # Tuple(elts=[Constant(value=363)], ctx=Del())
('a*wyz!$CcJ.TDj?&lt;8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&amp;B(PbH1_ZInkimvSV4x&gt; u{+2gs)h"e9NA;76]=E-0;',) # Tuple(elts=[Constant(value='a*wyz!$CcJ.TDj?&lt;8Q`o}|fG~3%FX/O:r@YW5dK,MqLt^l&amp;B(PbH1_ZInkimvSV4x&gt; u{+2gs)h"e9NA;76]=E-0;')], ctx=Load())
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>You may encounter a number of uncommon expressions here. For instance:</p>
<ol>
<li><code>()</code> is an empty tuple.</li>
<li><code>(1,)</code> is a tuple with one element.</li>
<li><code>{}</code> is an empty dictionary; <code>{1}</code> is a set with one element.</li>
<li>An empty set is denoted by <code>set()</code>.</li>
</ol>
<p>The fact that we use <code>set()</code> to represent empty sets is actually a feature of our <code>PYTHON_AST_COMPOSITES_GRAMMAR</code> grammar.
If we invoke the <code>Set()</code> AST constructor without any elements, we obtain this beautiful expression...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">Set</span><span class="p">(</span><span class="n">elts</span><span class="o">=</span><span class="p">[])))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>{*()}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>... which indeed evaluates into an empty set.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="p">{</span><span class="o">*</span><span class="p">()}</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>set()
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Technically speaking, all of this is correct, but we'd like to stick to (somewhat) more readable code. If you want to confuse your programmer friends, always use <code>{*()}</code> instead of <code>set()</code>.</p>
</div>
</div>
</div>
</div>

</details>

<details id="Excursion:-Expressions">
<summary>Expressions</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us extend our grammar with <em>expressions</em>. The Python parser already takes care of precedence rules, so we can treat all unary and binary operators in a similar fashion.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"2 + 2 is not False"</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        Expr(
            value=Compare(
                left=BinOp(
                    left=Constant(value=2),
                    op=Add(),
                    right=Constant(value=2)),
                ops=[
                    IsNot()],
                comparators=[
                    Constant(value=False)]))],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_COMPOSITES_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">'&lt;BoolOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;BinOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;UnaryOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Compare&gt;'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Booleans: and or</span>
    <span class="s1">'&lt;BoolOp&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'BoolOp(op=&lt;boolop&gt;, values=&lt;expr_list&gt;)'</span> <span class="p">],</span>
    <span class="s1">'&lt;boolop&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'And()'</span><span class="p">,</span> <span class="s1">'Or()'</span> <span class="p">],</span>

    <span class="c1"># Binary operators: + - * ...</span>
    <span class="s1">'&lt;BinOp&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'BinOp(left=&lt;expr&gt;, op=&lt;operator&gt;, right=&lt;expr&gt;)'</span> <span class="p">],</span>
    <span class="s1">'&lt;operator&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Add()'</span><span class="p">,</span> <span class="s1">'Sub()'</span><span class="p">,</span> <span class="s1">'Mult()'</span><span class="p">,</span> <span class="s1">'MatMult()'</span><span class="p">,</span>
                   <span class="s1">'Div()'</span><span class="p">,</span> <span class="s1">'Mod()'</span><span class="p">,</span> <span class="s1">'Pow()'</span><span class="p">,</span>
                   <span class="s1">'LShift()'</span><span class="p">,</span> <span class="s1">'RShift()'</span><span class="p">,</span> <span class="s1">'BitOr()'</span><span class="p">,</span> <span class="s1">'BitXor()'</span><span class="p">,</span> <span class="s1">'BitAnd()'</span><span class="p">,</span>
                   <span class="s1">'FloorDiv()'</span> <span class="p">],</span>

    <span class="c1"># Unary operators: not + - ...</span>
    <span class="s1">'&lt;UnaryOp&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'UnaryOp(op=&lt;unaryop&gt;, operand=&lt;expr&gt;)'</span><span class="p">],</span>
    <span class="s1">'&lt;unaryop&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Invert()'</span><span class="p">,</span> <span class="s1">'Not()'</span><span class="p">,</span> <span class="s1">'UAdd()'</span><span class="p">,</span> <span class="s1">'USub()'</span> <span class="p">],</span>

    <span class="c1"># Comparisons: == != &lt; &lt;= &gt; &gt;= is in ...</span>
    <span class="s1">'&lt;Compare&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Compare(left=&lt;expr&gt;, ops=&lt;cmpop_list&gt;, comparators=&lt;expr_list&gt;)'</span><span class="p">],</span>
    <span class="s1">'&lt;cmpop_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;cmpops&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;cmpops&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;cmpop&gt;'</span><span class="p">,</span> <span class="s1">'&lt;cmpop&gt;, &lt;cmpops&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;cmpop&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Eq()'</span><span class="p">,</span> <span class="s1">'NotEq()'</span><span class="p">,</span> <span class="s1">'Lt()'</span><span class="p">,</span> <span class="s1">'LtE()'</span><span class="p">,</span> <span class="s1">'Gt()'</span><span class="p">,</span> <span class="s1">'GtE()'</span><span class="p">,</span>
                 <span class="s1">'Is()'</span><span class="p">,</span> <span class="s1">'IsNot()'</span><span class="p">,</span> <span class="s1">'In()'</span><span class="p">,</span> <span class="s1">'NotIn()'</span> <span class="p">],</span>

    <span class="c1"># FIXME: There's a few more expressions: GeneratorExp, Await, YieldFrom, ...</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;BoolOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;BinOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;UnaryOp&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Compare&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;BoolOp&gt;
() and {-([]) / (set(), set()), {
True: set()}} # BoolOp(op=And(), values=[BoolOp(op=Or(), values=[]), Set(elts=[BinOp(left=UnaryOp(op=USub(), operand=Compare(left=List(elts=[], ctx=Del()), ops=[], comparators=[])), op=Div(), right=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())), Dict(keys=[Expr(value=Constant(value=True))], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), List(elts=[], ctx=Load())])])])
(set(), set(), set() @ set() | set() + set()) and set() ** (set() ^ set()) * set() # BoolOp(op=And(), values=[Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitOr(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))], ctx=Del()), BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
set() % (set() &gt;&gt; set()) - (set() &lt;&lt; set()) or set() &amp; set() # BoolOp(op=Or(), values=[BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Sub(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
'8' or 6                                 # BoolOp(op=Or(), values=[Constant(value='8'), Constant(value=6)])
~+123.95                                 # BoolOp(op=Or(), values=[UnaryOp(op=Invert(), operand=UnaryOp(op=UAdd(), operand=Constant(value=123.95)))])
not False // None                        # BoolOp(op=Or(), values=[UnaryOp(op=Not(), operand=BinOp(left=Constant(value=False), op=FloorDiv(), right=Constant(value=None)))])
'S' and 6180 in 397494                   # BoolOp(op=And(), values=[Constant(value="S"), Compare(left=Constant(value=6180), ops=[In()], comparators=[Constant(value=397494)])])
41                                       # BoolOp(op=And(), values=[Constant(value=41)])
214                                      # BoolOp(op=Or(), values=[Constant(value=214)])
5818 and "N1qoR6ak 2UJTWyh&gt;!B)/#YKe0]=w{E.-Q`F[5'&amp;^9cA~&lt;V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT" and 70 and 884 # BoolOp(op=And(), values=[Constant(value=5818), Constant(value="N1qoR6ak 2UJTWyh&gt;!B)/#YKe0]=w{E.-Q`F[5'&amp;^9cA~&lt;V+M$bnLu%H8I3;g*D?rz7Xj:}pPvif_GOtx4,(ZCdmls|@YiT"), Constant(value=70), Constant(value=884)])

&lt;BinOp&gt;
{} - 33                                  # BinOp(left=Expr(value=Dict(keys=[], values=[Tuple(elts=[UnaryOp(op=Invert(), operand=List(elts=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), Tuple(elts=[], ctx=Del()), BoolOp(op=And(), values=[Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load())])], ctx=Del())), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]))], ctx=Del())])), op=Sub(), right=Constant(value=33))
set() / (set() &lt;&lt; set()) * (set() &gt;&gt; set()) // (set() @ set() &amp; set()) # BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Mult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=FloorDiv(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))
None ^ False                             # BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))
-'' + +7719.5                            # BinOp(left=UnaryOp(op=USub(), operand=Constant(value="")), op=Add(), right=UnaryOp(op=UAdd(), operand=Constant(value=7719.5)))
(set() or 906) &gt;&gt; ('F') | (not (True)) % ((set() and set()) &lt;&lt; False) # BinOp(left=BinOp(left=BoolOp(op=Or(), values=[Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Constant(value=906)]), op=RShift(), right=BoolOp(op=Or(), values=[Constant(value='F')])), op=BitOr(), right=BinOp(left=UnaryOp(op=Not(), operand=BoolOp(op=Or(), values=[Constant(value=True)])), op=Mod(), right=BinOp(left=BoolOp(op=And(), values=[Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])]), op=LShift(), right=Constant(value=False))))
((set()) &gt; None != set()) | ((set()))    # BinOp(left=Compare(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Gt(), NotEq()], comparators=[Constant(value=None), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), op=BitOr(), right=Compare(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[Constant(value=True)]))
524 - 188                                # BinOp(left=Constant(value=524), op=Sub(), right=Constant(value=188))
6214 / 81                                # BinOp(left=Constant(value=6214), op=Div(), right=Constant(value=81))
26 / 43                                  # BinOp(left=Constant(value=26), op=Div(), right=Constant(value=43))
"s85;3Rw?ST!NI]_-eJ(x7'kG|z}C^&amp;fWLnY[Z,rV*Qj.`Ed%:4&lt;t" ^ '/$ao6 U{2cim@hHtF&gt;b+vX)KBg1l=qyMDp~O0#A9uPa+l' # BinOp(left=Constant(value="s85;3Rw?ST!NI]_-eJ(x7'kG|z}C^&amp;fWLnY[Z,rV*Qj.`Ed%:4&lt;t"), op=BitXor(), right=Constant(value="/$ao6 U{2cim@hHtF&gt;b+vX)KBg1l=qyMDp~O0#A9uPa+l"))

&lt;UnaryOp&gt;
+(set(), 
[])                            # UnaryOp(op=UAdd(), operand=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Expr(value=List(elts=[], ctx=Del()))], ctx=Del()))
~(None)                                  # UnaryOp(op=Invert(), operand=BoolOp(op=Or(), values=[Constant(value=None)]))
-(((not {set(), set()})) &amp; {set(): set(), (): set()}) # UnaryOp(op=USub(), operand=BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), op=BitAnd(), right=Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())])))
-((set() + set()) % ((set() &lt;&lt; set()) / (set() ^ set()))) ** (set() // set() &gt;&gt; set() * set()) # UnaryOp(op=USub(), operand=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))), op=Pow(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))))
-True                                    # UnaryOp(op=USub(), operand=Constant(value=True))
+(4.3 @ (823 - '&amp;') | '')                # UnaryOp(op=UAdd(), operand=BinOp(left=BinOp(left=Constant(value=4.30), op=MatMult(), right=BinOp(left=Constant(value=823), op=Sub(), right=Constant(value='&amp;'))), op=BitOr(), right=Constant(value="")))
~(False &lt;= 51 not in 959)                # UnaryOp(op=Invert(), operand=BoolOp(op=And(), values=[Compare(left=Constant(value=False), ops=[LtE(), NotIn()], comparators=[Constant(value=51), Constant(value=959)])]))
~17                                      # UnaryOp(op=Invert(), operand=Constant(value=17))
not 26                                   # UnaryOp(op=Not(), operand=Constant(value=26))
-68                                      # UnaryOp(op=USub(), operand=Constant(value=68))

&lt;Compare&gt;
()                                       # Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[Expr(value=Constant(value=8)), Tuple(elts=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], values=[]), Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Del())]), UnaryOp(op=UAdd(), operand=BinOp(left=Compare(left=Tuple(elts=[], ctx=Load()), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), op=Add(), right=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())))], ctx=Del())])
(set() &amp; set()) / (set() @ (set() - set())) not in set() ^ set() # Compare(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))), ops=[NotIn()], comparators=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
set() % set() // None &lt;&lt; (set() - set() &gt;&gt; set() ** set()) &lt;= set() | set() &gt; set() + set() # Compare(left=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Constant(value=None)), op=LShift(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))), ops=[LtE(), Gt()], comparators=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Constant(value=True)])
-632.86 != (not ~(not ('')))             # Compare(left=UnaryOp(op=USub(), operand=Constant(value=632.860)), ops=[NotEq()], comparators=[UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=UnaryOp(op=Not(), operand=BoolOp(op=And(), values=[Constant(value='')]))))])
'' &gt;= 717 is not False                   # Compare(left=Constant(value=""), ops=[GtE(), IsNot(), Eq()], comparators=[Constant(value=717), Constant(value=False)])
15 &lt; 39                                  # Compare(left=Constant(value=15), ops=[Lt(), Is(), Gt(), In()], comparators=[Constant(value=39)])
548 != 934688                            # Compare(left=Constant(value=548), ops=[NotEq(), LtE()], comparators=[Constant(value=934688)])
"w-xSGA8TI{%pRcq6e!_E:}P]9LM/&amp;b1+7*lBDnvu)[o`3dY|Oj~JU&lt;#Z'rH;g,f&gt;@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ " in 425 # Compare(left=Constant(value="w-xSGA8TI{%pRcq6e!_E:}P]9LM/&amp;b1+7*lBDnvu)[o`3dY|Oj~JU&lt;#Z'rH;g,f&gt;@Q0tKk4N$iVaFhzW52y=(C.? sXm^{ "), ops=[In()], comparators=[Constant(value=425), Constant(value=21270)])
'H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf&amp; E`uG}w?PY:' &gt;= 'nCALds|1zjq4BZ$"ab*@_(e&lt;!rT=iUW~05+,Q&gt;oNSxRVpF' # Compare(left=Constant(value='H]3Ky.2p-:#6F%9V{X^8)lMD[;7Otk/hgImvcJf&amp; E`uG}w?PY:'), ops=[GtE(), Gt(), NotIn(), IsNot(), GtE()], comparators=[Constant(value='nCALds|1zjq4BZ$"ab*@_(e&lt;!rT=iUW~05+,Q&gt;oNSxRVpF')])
6.3                                      # Compare(left=Constant(value=6.3), ops=[], comparators=[])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Not all of these expressions are <em>type-correct</em>. For instance, <code>set() * set()</code> raises a type error at runtime. They <em>can</em> be properly parsed, though.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>How good is our grammar at this point? Let us create 20 expressions and check how many of these</p>
<ol>
<li>parse without <code>SyntaxError</code></li>
<li>evaluate without <code>TypeError</code>.</li>
</ol>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">expr_iterations</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">bad_syntax</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">bad_type</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">ast_exprs_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">)</span>
<span class="n">expr_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_exprs_grammar</span><span class="p">,</span> <span class="n">max_number_free_instantiations</span><span class="o">=</span><span class="n">expr_iterations</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">expr_iterations</span><span class="p">):</span>
    <span class="n">expr_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">expr_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()))</span>
    <span class="n">expr_tree</span> <span class="o">=</span> <span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">expr_tree</span><span class="p">)</span>
    <span class="n">expr_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">expr_tree</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">expr_str</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># insert parsing code here</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">bad_syntax</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">bad_type</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># &lt;-- insert evaluation code here</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">bad_type</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span> <span class="ne">SyntaxError</span><span class="p">:</span>
        <span class="n">bad_syntax</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Bad syntax: </span><span class="si">{</span><span class="n">bad_syntax</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">expr_iterations</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Bad type: </span><span class="si">{</span><span class="n">bad_type</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">expr_iterations</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>0 set()
1 
2 [
~(False,) &gt;&gt; {635: (set() @ set() &amp; set(),), 99.1 not in set() ** set(): {[set() ^ set()]}}]
3 (set() * set() - (set() + set())) / ((set() ^ set()) % set() | set() &lt;&lt; set() % set())
4 not None
5 -+(True and '#' and 'x')
6 (8876 &gt; 46 in 36 != 50)
7 24
8 "LfDW-kSM|tpB&amp;+V*RgQ7U]3xq)zh~n^`wTdie5jvPN: A2K?$ZGJ(X;%@sr9mcIu!}OC/1&gt;&lt;b=y'0H8o_.4lFYa{6[,&gt;E?"
9 'o,awXihgeM[581Bln"RA60^k2N_L=d$C`7U~f)(&amp;ZG]#m+DqF|PjpIQ&lt;.4ur@ T!-W}Vs:Y{*zOEJb3StHK&gt;?y%c/;iv9'
10 ((set()) &lt; set() is set()) &gt;= ((set()))
11 ((set())) == ((set()) &lt;= set())
12 
13 
14 set()
15 set()
16 []
17 
18 ((() or 'k5'))
19 () | []
Bad syntax: 0/20
Bad type: 0/20
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We're not doing too bad here.
It is possible, in principle, to use ISLa constraints such that the resulting code will be properly typed - but this would take hundreds to thousands of rules. We will leave this exercise to the reader.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Note that you should <em>not</em> repeat this experiment once <em>identifiers</em> come into play. There is a remote chance that the fuzzer synthesizes a call like <code>os.remove("/")</code> – and away goes your file system!</p>
</div>
</div>
</div>
</div>

</details>

<details id="Excursion:-Names-and-Function-Calls">
<summary>Names and Function Calls</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us add some <em>identifiers</em> such that we can call <em>functions</em>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ID_START</span> <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_letters</span> <span class="o">+</span> <span class="s1">'_'</span>
<span class="n">ID_CONTINUE</span> <span class="o">=</span> <span class="n">ID_START</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">digits</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ID_CONTINUE</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"xyzzy(a, b=c)"</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        Expr(
            value=Call(
                func=Name(id='xyzzy', ctx=Load()),
                args=[
                    Name(id='a', ctx=Load())],
                keywords=[
                    keyword(
                        arg='b',
                        value=Name(id='c', ctx=Load()))]))],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_EXPRS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">'&lt;Name&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Call&gt;'</span>
    <span class="p">],</span>

    <span class="c1"># Identifiers</span>
    <span class="s1">'&lt;Name&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Name(id=&lt;identifier&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'Name(id=&lt;identifier&gt;, ctx=Del())'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;identifier&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s2">"'&lt;id&gt;'"</span> <span class="p">],</span>
    <span class="s1">'&lt;id&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;id_start&gt;&lt;id_continue&gt;*'</span> <span class="p">],</span>
    <span class="s1">'&lt;id_start&gt;'</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ID_START</span><span class="p">),</span>
    <span class="s1">'&lt;id_continue&gt;'</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">ID_CONTINUE</span><span class="p">),</span>
    <span class="c1"># FIXME: Actual rules are a bit more complex; see</span>
    <span class="c1"># https://docs.python.org/3/reference/lexical_analysis.html#identifiers</span>

    <span class="c1"># Function Calls</span>
    <span class="s1">'&lt;Call&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Call(func=&lt;func&gt;&lt;args_param&gt;&lt;keywords_param&gt;)'</span> <span class="p">],</span>
    <span class="s1">'&lt;args_param&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', args=&lt;expr_list&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;keywords_param&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', keywords=&lt;keyword_list&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;func&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;expr&gt;'</span> <span class="p">],</span>  <span class="c1"># Actually &lt;Expr&gt;, but this is more readable and parses 90%</span>
    <span class="s1">'&lt;keyword_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;keywords&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;keywords&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;keyword&gt;'</span><span class="p">,</span> <span class="s1">'&lt;keyword&gt;, &lt;keywords&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;keyword&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'keyword(arg=&lt;identifier&gt;, value=&lt;expr&gt;)'</span> <span class="p">]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, args and keywords parameters are optional</span>
        <span class="s1">'&lt;Call&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Call(func=&lt;func&gt;&lt;args_param&gt;?&lt;keywords_param&gt;?)'</span> <span class="p">],</span>
    <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;Name&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Call&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Name&gt;
n                                        # Name(id='n', ctx=Load())
vmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz # Name(id='vmGtKyT3Oq1gBC_srAIRaeQw6Dh8V5oLdj9FcvHfb4MpPZiNuEJ27WYU0lnkSxX9Lz', ctx=Del())
h                                        # Name(id='h', ctx=Load())
L                                        # Name(id='L', ctx=Del())
M                                        # Name(id='M', ctx=Load())
g                                        # Name(id='g', ctx=Del())
P                                        # Name(id='P', ctx=Del())
It                                       # Name(id='It', ctx=Del())
jGn7g                                    # Name(id='jGn7g', ctx=Load())
psj                                      # Name(id='psj', ctx=Del())

&lt;Call&gt;
{{set(): set()}(+set())}(m7K, (), u=[set() // set()]) # Call(func=Set(elts=[Call(func=Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), args=[UnaryOp(op=UAdd(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], keywords=[])]), args=[Name(id='m7K', ctx=Del()), Tuple(elts=[], ctx=Load())], keywords=[keyword(arg='u', value=List(elts=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load()))])
(())(set(), None, 
U, j=False, i=set())  # Call(func=Compare(left=BoolOp(op=Or(), values=[]), ops=[], comparators=[BoolOp(op=And(), values=[])]), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=None), Expr(value=Name(id='U', ctx=Load()))], keywords=[keyword(arg='j', value=Constant(value=False)), keyword(arg='i', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
[set(), set(), set()](set(), (set(),), T=set(), L=set(), y=set()) # Call(func=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())], keywords=[keyword(arg='T', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='L', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='y', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
(set() - set() ** set() % (set() @ set()))(set() * set(), set() &lt;&lt; set(), W=set() / set()) # Call(func=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))), args=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='W', value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))])
(set() &gt;&gt; set())((set() | set()) ^ set(), g=set() &amp; set(), B=set() + set()) # Call(func=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), args=[BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='g', value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), keyword(arg='B', value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))])
''(-(not 48.9), Q=~70, FmD=True, h=set()) # Call(func=Constant(value=''), args=[UnaryOp(op=USub(), operand=UnaryOp(op=Not(), operand=Constant(value=48.9)))], keywords=[keyword(arg='Q', value=UnaryOp(op=Invert(), operand=Constant(value=70))), keyword(arg='FmD', value=Constant(value=True)), keyword(arg='h', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
((set() in set()) &gt; set())(None, v=set()) # Call(func=Compare(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[In()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), ops=[Gt()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), args=[Compare(left=Constant(value=None), ops=[], comparators=[])], keywords=[keyword(arg='v', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
''(set(), V, l, t, _, zM=H)              # Call(func=Constant(value=""), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Name(id='V', ctx=Load()), Name(id='l', ctx=Load()), Name(id='t', ctx=Del()), Name(id='_', ctx=Load())], keywords=[keyword(arg='zM', value=Name(id='H', ctx=Load()))])
xTzqJe5gQ(n80d, qkw=b)                   # Call(func=Name(id='xTzqJe5gQ', ctx=Del()), args=[Name(id='n80d', ctx=Load())], keywords=[keyword(arg='qkw', value=Name(id='b', ctx=Del()))])
k(set(), set(), set(), E, o=c)           # Call(func=Name(id='k', ctx=Load()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Name(id='E', ctx=Load())], keywords=[keyword(arg='o', value=Name(id='c', ctx=Load()))])
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast_ids_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">id_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">'&lt;id&gt;'</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">id_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'open'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">name_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">name_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">"Name(id='open', ctx=Load())"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">call_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="s1">'&lt;keyword_list&gt;'</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">call_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s1">'[]'</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">call_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s1">'open("foo.txt", "r")'</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">call_str</span><span class="p">)</span>
<span class="n">call_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">ast_ids_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">call_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">call_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Call(func=Name(id='open', ctx=Load()), args=[Constant(value='foo.txt'), Constant(value='r')], keywords=[])
</pre>
</div>

</div>

</details>

<details id="Excursion:-Attributes-and-Subscripts">
<summary>Attributes and Subscripts</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us add attributes and subscripts.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"a[b].c"</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        Expr(
            value=Attribute(
                value=Subscript(
                    value=Name(id='a', ctx=Load()),
                    slice=Name(id='b', ctx=Load()),
                    ctx=Load()),
                attr='c',
                ctx=Load()))],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;expr&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_IDS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">'&lt;Attribute&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Subscript&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Starred&gt;'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Attributes</span>
    <span class="s1">'&lt;Attribute&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Attribute(value=&lt;expr&gt;, attr=&lt;identifier&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'Attribute(value=&lt;expr&gt;, attr=&lt;identifier&gt;, ctx=Del())'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Subscripts</span>
    <span class="s1">'&lt;Subscript&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Subscript(value=&lt;expr&gt;, slice=&lt;Slice&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'Subscript(value=&lt;expr&gt;, slice=&lt;Slice&gt;, ctx=Del())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;Slice&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Slice()'</span><span class="p">,</span>
        <span class="s1">'Slice(&lt;expr&gt;)'</span><span class="p">,</span>
        <span class="s1">'Slice(&lt;expr&gt;, &lt;expr&gt;)'</span><span class="p">,</span>
        <span class="s1">'Slice(&lt;expr&gt;, &lt;expr&gt;, &lt;expr&gt;)'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Starred</span>
    <span class="s1">'&lt;Starred&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Starred(value=&lt;expr&gt;, ctx=Load())'</span><span class="p">,</span>
        <span class="s1">'Starred(value=&lt;expr&gt;, ctx=Del())'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># We're extending the set of callers a bit</span>
    <span class="s1">'&lt;func&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;Name&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Attribute&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Subscript&gt;'</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;Attribute&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Subscript&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Starred&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Attribute&gt;
{}.zZ                                    # Attribute(value=Dict(keys=[BoolOp(op=Or(), values=[Expr(value=UnaryOp(op=UAdd(), operand=Call(func=Name(id='e', ctx=Del()), args=[], keywords=[]))), BinOp(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]), Starred(value=Attribute(value=Tuple(elts=[Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())])], ctx=Load()), attr='HV', ctx=Load()), ctx=Del())], values=[]), attr='zZ', ctx=Del())
OON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp._Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP # Attribute(value=Name(id='OON6Q9X8m1yqSkYJtGPI_bADfjMTaIhp', ctx=Load()), attr='_Rr5dHs2n7UwzFoLulcei3KCgW4EvxB60jmPP', ctx=Del())
175 .M                                   # Attribute(value=Constant(value=175), attr='M', ctx=Del())
*[set() * set() + set() / set()][(set() &lt;&lt; set(), set() % set(), set() ** (set() &amp; set())):].Wn # Attribute(value=Starred(value=Subscript(value=List(elts=[BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Add(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))], ctx=Load()), slice=Slice(Tuple(elts=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))], ctx=Del())), ctx=Load()), ctx=Load()), attr='Wn', ctx=Del())
((-+set()[:]()[set():set():set()] | (not ~set().E())) @ '' // (None ^ False)).B # Attribute(value=BinOp(left=BinOp(left=BinOp(left=UnaryOp(op=USub(), operand=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Del()))), op=BitOr(), right=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='E', ctx=Del()), args=[], keywords=[])))), op=MatMult(), right=Constant(value='')), op=FloorDiv(), right=BinOp(left=Constant(value=None), op=BitXor(), right=Constant(value=False))), attr='B', ctx=Load())
((99.8) &gt;&gt; (True)['HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK&lt;{c~*3}f$OandqF1%&amp;4IJ"MjZ&gt;^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z':'S']).yM # Attribute(value=BinOp(left=BoolOp(op=And(), values=[Constant(value=99.8)]), op=RShift(), right=Subscript(value=BoolOp(op=And(), values=[Constant(value=True)]), slice=Slice(Constant(value='HAVsYE|,]@bXz!hguQimRwL0)2=W-8PteTK&lt;{c~*3}f$OandqF1%&amp;4IJ"MjZ&gt;^k`pv;/U_?B.7[+y#(G 9S5CDoNrlx:6Z'), Constant(value="S")), ctx=Del())), attr='yM', ctx=Del())
(((set()) &lt; set() == set()) not in set()).l # Attribute(value=Compare(left=Compare(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[Lt(), Eq()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), ops=[NotIn()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id='c', ctx=Del())]), attr='l', ctx=Del())
vlL.CZ                                   # Attribute(value=Name(id='vlL', ctx=Load()), attr='CZ', ctx=Del())
w.nyuCk                                  # Attribute(value=Name(id='w', ctx=Del()), attr='nyuCk', ctx=Load())
Js.Za                                    # Attribute(value=Name(id='Js', ctx=Load()), attr='Za', ctx=Load())

&lt;Subscript&gt;
{279.0 &gt;&gt; [], -*set()[:][:](set(), set(), ())}[{}:] # Subscript(value=Set(elts=[BinOp(left=Constant(value=279.0), op=RShift(), right=List(elts=[BoolOp(op=And(), values=[])], ctx=Del())), UnaryOp(op=USub(), operand=Call(func=Subscript(value=Subscript(value=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(), ctx=Del()), slice=Slice(), ctx=Load()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Tuple(elts=[], ctx=Load())], keywords=[]))]), slice=Slice(Dict(keys=[], values=[Name(id='U', ctx=Load())])), ctx=Del())
(set()).y[():b:
set()]                   # Subscript(value=Attribute(value=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), attr='y', ctx=Load()), slice=Slice(Tuple(elts=[], ctx=Del()), Name(id='b', ctx=Del()), Expr(value=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]))), ctx=Del())
(set() &lt;&lt; set() - set()).c[[set() @ set() // set()]:*(set() &amp; set()).z] # Subscript(value=Attribute(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), attr='c', ctx=Load()), slice=Slice(List(elts=[BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load()), Starred(value=Attribute(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), attr='z', ctx=Del()), ctx=Del())), ctx=Load())
((set() | set()) ^ set() ** set())[set() * set():(set() + set()) / set()] # Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Load())
None['t':]                               # Subscript(value=Constant(value=None), slice=Slice(Constant(value="t")), ctx=Load())
(not set().H(~set(), N=set()))[M():n():set()] # Subscript(value=UnaryOp(op=Not(), operand=Call(func=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='H', ctx=Del()), args=[UnaryOp(op=Invert(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], keywords=[keyword(arg='N', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])), slice=Slice(Call(func=Name(id='M', ctx=Load()), args=[], keywords=[]), Call(func=Name(id='n', ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Del())
False[1632:]                             # Subscript(value=Constant(value=False), slice=Slice(Constant(value=1632)), ctx=Del())
(('') % +(94 or True))[True or ((t)) is set() &lt;= Q:] # Subscript(value=BinOp(left=BoolOp(op=Or(), values=[Constant(value='')]), op=Mod(), right=UnaryOp(op=UAdd(), operand=BoolOp(op=Or(), values=[Constant(value=94), Constant(value=True)]))), slice=Slice(BoolOp(op=Or(), values=[Constant(value=True), Compare(left=Compare(left=Compare(left=Name(id='t', ctx=Load()), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), ops=[Is(), LtE()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Name(id='Q', ctx=Load()), Name(id='r', ctx=Del())])])), ctx=Load())
l7oUAETh5yCvxmRcgJ8[vtk3XeH:midn6Wa4]    # Subscript(value=Name(id='l7oUAETh5yCvxmRcgJ8', ctx=Load()), slice=Slice(Name(id='vtk3XeH', ctx=Load()), Name(id='midn6Wa4', ctx=Load())), ctx=Load())
JN0GQSzfYw1MLI2up6[gD9VZbsK_lqjrPOFB:]   # Subscript(value=Name(id='JN0GQSzfYw1MLI2up6', ctx=Load()), slice=Slice(Name(id='gD9VZbsK_lqjrPOFB', ctx=Del())), ctx=Load())

&lt;Starred&gt;
*[]                                      # Starred(value=List(elts=[], ctx=Del()), ctx=Load())
*(
{{set().j(K.J, Q=set()): (+*(set())[set():set():set()],)}, 440.7}) &gt;&gt; i # Starred(value=BinOp(left=BoolOp(op=And(), values=[Expr(value=Set(elts=[Dict(keys=[Call(func=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='j', ctx=Del()), args=[Attribute(value=Name(id='K', ctx=Del()), attr='J', ctx=Load())], keywords=[keyword(arg='Q', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])], values=[Tuple(elts=[UnaryOp(op=UAdd(), operand=Starred(value=Subscript(value=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Load()), ctx=Load()))], ctx=Del())]), Constant(value=440.7)]))]), op=RShift(), right=Name(id='i', ctx=Load())), ctx=Del())
*[set(), set(), set() @ set()][(set(), set() - set(), set() % set() / set() ** set()):] # Starred(value=Subscript(value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load()), slice=Slice(Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Div(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))], ctx=Load())), ctx=Del()), ctx=Load())
*(set() ^ set()) &amp; (set() &lt;&lt; set()) + set() | set() * set() # Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=BitOr(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Del())
*'g'                                     # Starred(value=Constant(value='g'), ctx=Load())
*-None                                   # Starred(value=UnaryOp(op=USub(), operand=Constant(value=None)), ctx=Del())
*9523[:](set(), -set(), not ~set(), (not not set())[-(set() // set()):]) # Starred(value=Call(func=Subscript(value=Constant(value=9523), slice=Slice(), ctx=Del()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), UnaryOp(op=USub(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Not(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), slice=Slice(UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), BoolOp(op=Or(), values=[])), ctx=Load())], keywords=[]), ctx=Del())
*False                                   # Starred(value=Constant(value=False), ctx=Load())
*X(Y(q=set()), I=U(), D=set())           # Starred(value=Call(func=Name(id='X', ctx=Load()), args=[Call(func=Name(id='Y', ctx=Load()), args=[], keywords=[keyword(arg='q', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])], keywords=[keyword(arg='I', value=Call(func=Name(id='U', ctx=Load()), args=[], keywords=[])), keyword(arg='D', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]), ctx=Del())
*'#'                                     # Starred(value=Constant(value="#"), ctx=Del())
</pre>
</div>

</div>

</details>

<details id="Excursion:-Variable-Assignments">
<summary>Variable Assignments</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now for variable assignments. These make things more complex, as we have a restricted set of expressions on the left hand side of an assignment.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ATTRS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;stmt&gt;'</span> <span class="p">],</span>

    <span class="s1">'&lt;stmt&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'&lt;Assign&gt;'</span><span class="p">,</span> <span class="s1">'&lt;AugAssign&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;Expr&gt;'</span>
    <span class="p">],</span>

    <span class="c1"># Assignments</span>
    <span class="s1">'&lt;Assign&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Assign(targets=&lt;nonempty_lhs_expr_list&gt;, value=&lt;expr&gt;&lt;type_comment&gt;?)'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;type_comment&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', type_comment=&lt;string&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;AugAssign&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'AugAssign(target=&lt;lhs_expr&gt;, op=&lt;operator&gt;, value=&lt;expr&gt;)'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Lists of left-hand side expressions</span>
    <span class="c1"># '&lt;lhs_expr_list&gt;': [ '[&lt;lhs_exprs&gt;?]' ],</span>
    <span class="s1">'&lt;nonempty_lhs_expr_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;lhs_exprs&gt;]'</span> <span class="p">],</span>
    <span class="s1">'&lt;lhs_exprs&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;lhs_expr&gt;'</span><span class="p">,</span> <span class="s1">'&lt;lhs_exprs&gt;, &lt;lhs_expr&gt;'</span> <span class="p">],</span>

    <span class="c1"># On the left-hand side of assignments, we allow a number of structures</span>
    <span class="s1">'&lt;lhs_expr&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'&lt;lhs_Name&gt;'</span><span class="p">,</span>  <span class="c1"># Most common</span>
        <span class="s1">'&lt;lhs_List&gt;'</span><span class="p">,</span> <span class="s1">'&lt;lhs_Tuple&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;lhs_Attribute&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;lhs_Subscript&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;lhs_Starred&gt;'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="s1">'&lt;lhs_Name&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Name(id=&lt;identifier&gt;, ctx=Store())'</span><span class="p">,</span> <span class="p">],</span>

    <span class="s1">'&lt;lhs_List&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'List(elts=&lt;nonempty_lhs_expr_list&gt;, ctx=Store())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;lhs_Tuple&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Tuple(elts=&lt;nonempty_lhs_expr_list&gt;, ctx=Store())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;lhs_Attribute&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Attribute(value=&lt;lhs_expr&gt;, attr=&lt;identifier&gt;, ctx=Store())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;lhs_Subscript&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Subscript(value=&lt;lhs_expr&gt;, slice=&lt;Slice&gt;, ctx=Store())'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;lhs_Starred&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Starred(value=&lt;lhs_expr&gt;, ctx=Store())'</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">'&lt;Assign&gt;'</span><span class="p">,</span> <span class="s1">'&lt;AugAssign&gt;'</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Assign&gt;
*[(r,), (V, C[set():set()]), Z[set():].WDY3i] = () # type: * # Assign(targets=[Starred(value=List(elts=[Tuple(elts=[Name(id='r', ctx=Store())], ctx=Store()), Tuple(elts=[Name(id='V', ctx=Store()), Subscript(value=Name(id='C', ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], ctx=Store()), Attribute(value=Subscript(value=Name(id='Z', ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), attr='WDY3i', ctx=Store())], ctx=Store()), ctx=Store())], value=Tuple(elts=[], ctx=Load()), type_comment='*')
h[set():set():set()][set():*set():set()[:]()][:] = [set()].Yzt # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='h', ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Load()), Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(), ctx=Store())], value=Attribute(value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), attr='Yzt', ctx=Load()))
N[:][:][set():set():set()][{}:][:] = 
ExcXjv1h # type: R # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Name(id='N', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(Dict(keys=[], values=[])), ctx=Store()), slice=Slice(BoolOp(op=Or(), values=[])), ctx=Store())], value=Expr(value=Name(id='ExcXjv1h', ctx=Del())), type_comment="R")
H[:][:][set():set():set()] = -set() # type: y{ # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='H', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=UnaryOp(op=USub(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), type_comment='y{')
K[:][:] = a[:][set():set()] = False # type: USsF # Assign(targets=[Subscript(value=Subscript(value=Name(id='K', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='a', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Constant(value=False), type_comment="USsF")
B[set():set()] = set()[:] &lt;&lt; (set()[:]) # type: K # Assign(targets=[Subscript(value=Name(id='B', ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=BinOp(left=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), op=LShift(), right=Compare(left=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[])), type_comment='K')
sKC = fm = (*set().y, *{set()}) # type: L^}3QF # Assign(targets=[Name(id='sKC', ctx=Store()), Name(id='fm', ctx=Store())], value=Tuple(elts=[Starred(value=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='y', ctx=Del()), ctx=Del()), Starred(value=Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), ctx=Load())], ctx=Del()), type_comment='L^}3QF')
S = n = I = [set(), set(), F] # type: 8-h # Assign(targets=[Name(id='S', ctx=Store()), Name(id='n', ctx=Store()), Name(id='I', ctx=Store())], value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Name(id='F', ctx=Load())], ctx=Load()), type_comment="8-h")
gy = set() % set() @ set() - (set() &amp; set()) # type: .~ # Assign(targets=[Name(id='gy', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), type_comment=".~")
cnoOWRu = set() * (set() &gt;&gt; set() ^ set() + set()) # type: ['Ox# # Assign(targets=[Name(id='cnoOWRu', ctx=Store())], value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))), type_comment="['Ox#")

&lt;AugAssign&gt;
K &lt;&lt;= set()                              # AugAssign(target=Name(id='K', ctx=Store()), op=LShift(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))
(_, [A]).H ^= (*{}.a[set() | set():set():], False) # AugAssign(target=Attribute(value=Tuple(elts=[Name(id='_', ctx=Store()), List(elts=[Name(id='A', ctx=Store())], ctx=Store())], ctx=Store()), attr='H', ctx=Store()), op=BitXor(), value=Tuple(elts=[Subscript(value=Attribute(value=Starred(value=Dict(keys=[], values=[]), ctx=Del()), attr='a', ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BoolOp(op=Or(), values=[])), ctx=Load()), Constant(value=False)], ctx=Load()))
*i[:][:][y():set()] -= [~(
set())]       # AugAssign(target=Subscript(value=Starred(value=Subscript(value=Subscript(value=Name(id='i', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), ctx=Store()), slice=Slice(Call(func=Name(id='y', ctx=Del()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), op=Sub(), value=List(elts=[UnaryOp(op=Invert(), operand=Compare(left=Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ops=[], comparators=[]))], ctx=Load()))
t3lmH[(set(), set()):] //= oxNerA8       # AugAssign(target=Subscript(value=Name(id='t3lmH', ctx=Store()), slice=Slice(Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())), ctx=Store()), op=FloorDiv(), value=Name(id='oxNerA8', ctx=Load()))
pdnk2WaQFLs @= {*[set()].Qc[set().x:]}   # AugAssign(target=Name(id='pdnk2WaQFLs', ctx=Store()), op=MatMult(), value=Set(elts=[Subscript(value=Starred(value=Attribute(value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), attr='Qc', ctx=Load()), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='x', ctx=Load())), ctx=Del())]))
YMy **= (set() + (set() &amp; set())) / (None % (set() &gt;&gt; set())) # AugAssign(target=Name(id='YMy', ctx=Store()), op=Pow(), value=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Constant(value=None), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))))
rXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15 *= +'h' # AugAssign(target=Name(id='rXvE0_VP7puUYSIJwg4qDZt9z6RjiChKGTofbBO15', ctx=Store()), op=Mult(), value=UnaryOp(op=UAdd(), operand=Constant(value="h")))
PFUN += not True[set():](991.2, J=None, k=False) # AugAssign(target=Name(id='PFUN', ctx=Store()), op=Add(), value=UnaryOp(op=Not(), operand=Call(func=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[Constant(value=991.2)], keywords=[keyword(arg='J', value=Constant(value=None)), keyword(arg='k', value=Constant(value=False))])))
g ^= (-set()).m(set(), , u=-set(), h=set()) # AugAssign(target=Name(id='g', ctx=Store()), op=BitXor(), value=Call(func=Attribute(value=UnaryOp(op=USub(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), attr='m', ctx=Load()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BoolOp(op=And(), values=[])], keywords=[keyword(arg='u', value=UnaryOp(op=USub(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), keyword(arg='h', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]))
Ce |= 448                                # AugAssign(target=Name(id='Ce', ctx=Store()), op=BitOr(), value=Constant(value=448))
</pre>
</div>

</div>

</details>

<details id="Excursion:-Statements">
<summary>Statements</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now for statements. There's quite a lot of these.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;stmt&gt;'</span> <span class="p">],</span>

    <span class="s1">'&lt;stmt&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_ASSIGNMENTS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;stmt&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span>
        <span class="s1">'&lt;For&gt;'</span><span class="p">,</span> <span class="s1">'&lt;While&gt;'</span><span class="p">,</span> <span class="s1">'&lt;If&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;Return&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Delete&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Assert&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;Pass&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Break&gt;'</span><span class="p">,</span> <span class="s1">'&lt;Continue&gt;'</span><span class="p">,</span>
        <span class="s1">'&lt;With&gt;'</span>
    <span class="p">],</span>

    <span class="c1"># Control structures</span>
    <span class="s1">'&lt;For&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'For(target=&lt;lhs_expr&gt;, iter=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;, orelse=&lt;stmt_list&gt;&lt;type_comment&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;stmt_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;stmts&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;nonempty_stmt_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;stmts&gt;]'</span> <span class="p">],</span>
    <span class="s1">'&lt;stmts&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;stmt&gt;'</span><span class="p">,</span> <span class="s1">'&lt;stmt&gt;, &lt;stmts&gt;'</span> <span class="p">],</span>

    <span class="s1">'&lt;While&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'While(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;, orelse=&lt;stmt_list&gt;)'</span>
    <span class="p">],</span>

    <span class="s1">'&lt;If&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'If(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;&lt;orelse_param&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;orelse_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', orelse=&lt;stmt_list&gt;'</span>
    <span class="p">],</span>

    <span class="s1">'&lt;With&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'With(items=&lt;withitem_list&gt;, body=&lt;nonempty_stmt_list&gt;&lt;type_comment&gt;?)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;withitem_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;withitems&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;withitems&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;withitem&gt;'</span><span class="p">,</span> <span class="s1">'&lt;withitems&gt;, &lt;withitem&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;withitem&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'withitem(context_expr=&lt;expr&gt;)'</span><span class="p">,</span>
        <span class="s1">'withitem(context_expr=&lt;expr&gt;, optional_vars=&lt;lhs_expr&gt;)'</span><span class="p">,</span>
    <span class="p">],</span>

    <span class="c1"># Other statements</span>
    <span class="s1">'&lt;Return&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Return()'</span><span class="p">,</span>
        <span class="s1">'Return(value=&lt;expr&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;Delete&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Delete(targets=&lt;expr_list&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;Assert&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'Assert(test=&lt;expr&gt;)'</span><span class="p">,</span>
        <span class="s1">'Assert(test=&lt;expr&gt;, msg=&lt;expr&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;Pass&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Pass()'</span><span class="p">],</span>
    <span class="s1">'&lt;Break&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Break()'</span> <span class="p">],</span>
    <span class="s1">'&lt;Continue&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Continue()'</span><span class="p">]</span>

    <span class="c1"># FIXME: A few more: AsyncFor, AsyncWith, Match, Try, TryStar</span>
    <span class="c1"># Import, ImportFrom, Global, Nonlocal...</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> \
        <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, orelse is optional</span>
        <span class="s1">'&lt;If&gt;'</span><span class="p">:</span> <span class="p">[</span>
            <span class="s1">'If(test=&lt;expr&gt;, body=&lt;nonempty_stmt_list&gt;&lt;orelse_param&gt;?)'</span>
        <span class="p">],</span>
    <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;stmt&gt;'</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Assign&gt;
*[v[:][:][:]][{}:+*set()[:]()] = (XDBoW_Av,).L4 = (32.6,) # type:  # Assign(targets=[Starred(value=Subscript(value=List(elts=[Subscript(value=Subscript(value=Subscript(value=Name(id='v', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(), ctx=Store())], ctx=Store()), slice=Slice(Dict(keys=[], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), UnaryOp(op=UAdd(), operand=Starred(value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]), ctx=Load()))), ctx=Store()), ctx=Store()), Attribute(value=Tuple(elts=[Name(id='XDBoW_Av', ctx=Store())], ctx=Store()), attr='L4', ctx=Store())], value=Tuple(elts=[Constant(value=32.6)], ctx=Load()), type_comment="")
g[:][set():][[]::set()] = set()[:]       # Assign(targets=[Subscript(value=Subscript(value=Subscript(value=Name(id='g', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), BoolOp(op=And(), values=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Compare(left=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), ops=[], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]))
W[:] = y[:][set():set():set()] = 
K18E # type: N # Assign(targets=[Subscript(value=Name(id='W', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='y', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store())], value=Expr(value=Name(id='K18E', ctx=Load())), type_comment='N')
V = _ = (set() | set()).E # type: i0     # Assign(targets=[Name(id='V', ctx=Store()), Name(id='_', ctx=Store())], value=Attribute(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), attr='E', ctx=Del()), type_comment="i0")
cZIujm3gC = eMePLrNVy9z2 # type: Wd~OC6+v02ey # Assign(targets=[Name(id='cZIujm3gC', ctx=Store())], value=Name(id='eMePLrNVy9z2', ctx=Del()), type_comment='Wd~OC6+v02ey')
Yf0lcOSaT = *[{set()}.b, (set(), set())] # type: *H&lt;u&amp;~|  # Assign(targets=[Name(id='Yf0lcOSaT', ctx=Store())], value=Starred(value=List(elts=[Attribute(value=Set(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), attr='b', ctx=Load()), Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())], ctx=Load()), ctx=Del()), type_comment="*H&lt;u&amp;~| ")
N = i = ((set() ^ set()) &amp; set()) * (set() + set()) # type: +ps # Assign(targets=[Name(id='N', ctx=Store()), Name(id='i', ctx=Store())], value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), type_comment="+ps")
m = P = set() @ set() &lt;&lt; set() // set() # type: ]J # Assign(targets=[Name(id='m', ctx=Store()), Name(id='P', ctx=Store())], value=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), type_comment=']J')
j = O = 18 % (set() / set()) # type: R?$6 # Assign(targets=[Name(id='j', ctx=Store()), Name(id='O', ctx=Store())], value=BinOp(left=Constant(value=18), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), type_comment="R?$6")
TGFJsqKdXkwb65xYnpHRh7UtQi4u = False # type: q(Q&gt;GHPBsa!|bUV9&amp;$w`Su.8-hAi3}7)#=LDx@5"?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F&lt; # Assign(targets=[Name(id='TGFJsqKdXkwb65xYnpHRh7UtQi4u', ctx=Store())], value=Constant(value=False), type_comment='q(Q&gt;GHPBsa!|bUV9&amp;$w`Su.8-hAi3}7)#=LDx@5"?Kgjkz,pt_r%XT1m/f{c*;^ZlIE: YRnoM4[F&lt;')

&lt;AugAssign&gt;
(*krT_.qL2x,)[~[
set(), None, {}[:]].L:] //= (,) # AugAssign(target=Subscript(value=Tuple(elts=[Attribute(value=Starred(value=Name(id='krT_', ctx=Store()), ctx=Store()), attr='qL2x', ctx=Store())], ctx=Store()), slice=Slice(UnaryOp(op=Invert(), operand=Attribute(value=List(elts=[Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Constant(value=None), Subscript(value=Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], values=[]), slice=Slice(), ctx=Del())], ctx=Load()), attr='L', ctx=Load()))), ctx=Store()), op=FloorDiv(), value=Tuple(elts=[BoolOp(op=And(), values=[])], ctx=Del()))
[h[:], F[:], l[:][set():Z]] -= U(*set() | set()) # AugAssign(target=List(elts=[Subscript(value=Name(id='h', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Name(id='F', ctx=Store()), slice=Slice(), ctx=Store()), Subscript(value=Subscript(value=Name(id='l', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), Name(id='Z', ctx=Load())), ctx=Store())], ctx=Store()), op=Sub(), value=Call(func=Name(id='U', ctx=Del()), args=[BinOp(left=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Del()), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], keywords=[]))
Q[[]:set()][[]:set()[:]:set()[:]] &amp;= *(set(),).b # AugAssign(target=Subscript(value=Subscript(value=Name(id='Q', ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), slice=Slice(List(elts=[], ctx=Del()), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())), ctx=Store()), op=BitAnd(), value=Starred(value=Attribute(value=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), attr='b', ctx=Del()), ctx=Load()))
wnBzQMG &lt;&lt;= {set() @ set() ^ set() ** set() / set()} # AugAssign(target=Name(id='wnBzQMG', ctx=Store()), op=LShift(), value=Set(elts=[BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=BitXor(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))]))
Psdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6 *= 48.5 # AugAssign(target=Name(id='Psdhpk1YVICRcN0J4wDPjqZmE856iFUbKf9oASWlXgvtyH7Oeua3Lyt6', ctx=Store()), op=Mult(), value=Constant(value=48.5))
a %= ''                                  # AugAssign(target=Name(id='a', ctx=Store()), op=Mod(), value=Constant(value=""))
J += -True                               # AugAssign(target=Name(id='J', ctx=Store()), op=Add(), value=UnaryOp(op=USub(), operand=Constant(value=True)))
oU &gt;&gt;= set()[set():set():set()](E=set(), H=set()) # AugAssign(target=Name(id='oU', ctx=Store()), op=RShift(), value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Del()), args=[], keywords=[keyword(arg='E', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='H', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]))
N //= not +(not 7927416330)              # AugAssign(target=Name(id='N', ctx=Store()), op=FloorDiv(), value=UnaryOp(op=Not(), operand=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Constant(value=7927416330)))))
s += '' or False or 8888 .W((set()), v=set(), Y=set()) # AugAssign(target=Name(id='s', ctx=Store()), op=Add(), value=BoolOp(op=Or(), values=[Constant(value=''), Constant(value=False), Call(func=Attribute(value=Constant(value=8888), attr='W', ctx=Load()), args=[Compare(left=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), ops=[], comparators=[])], keywords=[keyword(arg='v', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='Y', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])]))

&lt;Expr&gt;

*{(None, n, [] &lt;&lt; +R()[{}.r::set().I])} # Expr(value=Expr(value=Starred(value=Set(elts=[Tuple(elts=[Constant(value=None), Name(id='n', ctx=Load()), BinOp(left=List(elts=[], ctx=Del()), op=LShift(), right=UnaryOp(op=UAdd(), operand=Subscript(value=Call(func=Name(id='R', ctx=Del()), args=[], keywords=[]), slice=Slice(Attribute(value=Dict(keys=[], values=[]), attr='r', ctx=Del()), BoolOp(op=Or(), values=[]), Compare(left=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='I', ctx=Load()), ops=[], comparators=[])), ctx=Del())))], ctx=Load())]), ctx=Del())))
(*((set() ^ set()) - (set() | set())) / (set() % set()), [set(), set() &gt;&gt; set(), set() // set(), set() + set()])[:] # Expr(value=Subscript(value=Tuple(elts=[Starred(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Sub(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Div(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Load()), List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load())], ctx=Del()), slice=Slice(), ctx=Load()))
851648.62 * True &amp; 0                     # Expr(value=BinOp(left=BinOp(left=Constant(value=851648.62), op=Mult(), right=Constant(value=True)), op=BitAnd(), right=Constant(value=0)))
not -((set() @ set()) ** set()[:]())[set().z(_=set()):] # Expr(value=UnaryOp(op=Not(), operand=UnaryOp(op=USub(), operand=Subscript(value=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Pow(), right=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])), slice=Slice(Call(func=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='z', ctx=Del()), args=[], keywords=[keyword(arg='_', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])), ctx=Load()))))
'N'                                      # Expr(value=BoolOp(op=And(), values=[Constant(value="N")]))
(not ~'f')[~False:+(17 == ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6)] # Expr(value=Subscript(value=UnaryOp(op=Not(), operand=UnaryOp(op=Invert(), operand=Constant(value='f'))), slice=Slice(UnaryOp(op=Invert(), operand=Constant(value=False)), UnaryOp(op=UAdd(), operand=Compare(left=Constant(value=17), ops=[Eq()], comparators=[Name(id='ZAEPSYo_lKJHf6my8xTR2wg9b3d71qBeC5Mj6', ctx=Load()), Name(id='FcVkWZ0hQsONnpzGLrXut4vFIDiUBa', ctx=Load())]))), ctx=Del()))
i                                        # Expr(value=Name(id='i', ctx=Load()))
o2                                       # Expr(value=Name(id='o2', ctx=Del()))
AR                                       # Expr(value=Name(id='AR', ctx=Load()))
Y                                        # Expr(value=Name(id='Y', ctx=Del()))

&lt;For&gt;
for U, [D, I] in []: # type: j
    set()
    m /= set() # For(target=Tuple(elts=[Name(id='U', ctx=Store()), List(elts=[Name(id='D', ctx=Store()), Name(id='I', ctx=Store())], ctx=Store())], ctx=Store()), iter=Compare(left=List(elts=[], ctx=Load()), ops=[Eq()], comparators=[]), body=[Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='m', ctx=Store()), op=Div(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[], type_comment="j")
for *O.s in {}: # type: }
    with :
        break
    assert set()
else:
    pass
    return # For(target=Starred(value=Attribute(value=Name(id='O', ctx=Store()), attr='s', ctx=Store()), ctx=Store()), iter=Dict(keys=[], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), body=[With(items=[], body=[Break()]), Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[Pass(), Return()], type_comment='}')
for q[:][set():set():set()] in *set(): # type: 
    return
    return
else:
    continue
    continue # For(target=Subscript(value=Subscript(value=Name(id='q', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Load()), body=[Return(), Return()], orelse=[Continue(), Continue()], type_comment="")
for g[:][set():] in 
set(): # type: 
    return
else:
    l = set()
    return # For(target=Subscript(value=Subscript(value=Name(id='g', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), body=[Return()], orelse=[Assign(targets=[Name(id='l', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()], type_comment="")
for v in set().F(): # type: 
    if set():
        return
    return # For(target=Name(id='v', ctx=Store()), iter=Call(func=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Load()), args=[], keywords=[]), body=[If(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return()], orelse=[], type_comment="")
for Z[:] in +set(): # type: 
    del 
    return
else:
    while set():
        return # For(target=Subscript(value=Name(id='Z', ctx=Store()), slice=Slice(), ctx=Store()), iter=UnaryOp(op=UAdd(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), body=[Delete(targets=[]), Return()], orelse=[While(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], type_comment="")
for z[set():set()] in (): # type: L
    for o in set(): # type: 
        return
else:
    return
    return # For(target=Subscript(value=Name(id='z', ctx=Store()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Store()), iter=Tuple(elts=[], ctx=Load()), body=[For(target=Name(id='o', ctx=Store()), iter=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment='')], orelse=[Return(), Return()], type_comment="L")
for G[:] in True .KA: # type: 
    assert set(), set()
else:
    return # For(target=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), iter=Attribute(value=Constant(value=True), attr='KA', ctx=Del()), body=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[Return()], type_comment='')
for b[:][set() ^ set():] in e[set():]: # type: #
    return
else:
    return # For(target=Subscript(value=Subscript(value=Name(id='b', ctx=Store()), slice=Slice(), ctx=Store()), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BoolOp(op=And(), values=[])), ctx=Store()), iter=Subscript(value=Name(id='e', ctx=Load()), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Load()), body=[Return()], orelse=[Return()], type_comment='#')
for LNx in *wu: # type: ckM&lt;v
    return k
else:
    return # For(target=Name(id='LNx', ctx=Store()), iter=Starred(value=Name(id='wu', ctx=Del()), ctx=Del()), body=[Return(value=Name(id='k', ctx=Del()))], orelse=[Return()], type_comment="ckM&lt;v")

&lt;While&gt;
while 
k:
    pass                       # While(test=BoolOp(op=Or(), values=[Expr(value=Name(id='k', ctx=Load()))]), body=[Pass()], orelse=[])
while *set()[set().e:]:
    del 
    with :
        return
    return
    continue
else:
    break
    return # While(test=Subscript(value=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Load()), slice=Slice(Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='e', ctx=Load())), ctx=Load()), body=[Delete(targets=[]), With(items=[], body=[Return()]), Return(), Continue()], orelse=[Break(), Return()])
while {}:
    for H[:] in set(): # type: 
        return
    else:
        return
else:
    l |= set()
    while set():
        return # While(test=Dict(keys=[], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), body=[For(target=Subscript(value=Name(id='H', ctx=Store()), slice=Slice(), ctx=Store()), iter=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[Return()], type_comment='')], orelse=[AugAssign(target=Name(id='l', ctx=Store()), op=BitOr(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), While(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])])
while 'C':
    set()
    return
else:
    t = set()
    if set():
        return
    return
    return # While(test=Constant(value="C"), body=[Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assign(targets=[Name(id='t', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), If(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()])
while (not set()) == set():
    assert set()
    return
else:
    assert set(), set()
    return # While(test=Compare(left=UnaryOp(op=Not(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ops=[Eq()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()])
while () @ set():
    return [set(), set()]
    return
    return
    return
else:
    return set()[:]() # While(test=BinOp(left=Tuple(elts=[], ctx=Del()), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), body=[Return(value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())), Return(), Return(), Return()], orelse=[Return(value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]))])
while *(set(),):
    (h,) //= X
    E &lt;&lt;= set()
else:
    P *= set().W # While(test=Starred(value=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), body=[AugAssign(target=Tuple(elts=[Name(id='h', ctx=Store())], ctx=Store()), op=FloorDiv(), value=Name(id='X', ctx=Del())), AugAssign(target=Name(id='E', ctx=Store()), op=LShift(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id='P', ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='W', ctx=Del()))])
while [{set() + set()}]:
    *[u] ^= {set() &amp; set() &gt;&gt; set(), set() / set()}
else:
    s.N %= set()
    m **= set() # While(test=List(elts=[Set(elts=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])], ctx=Load()), body=[AugAssign(target=Starred(value=List(elts=[Name(id='u', ctx=Store())], ctx=Store()), ctx=Store()), op=BitXor(), value=Set(elts=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]))], orelse=[AugAssign(target=Attribute(value=Name(id='s', ctx=Store()), attr='N', ctx=Store()), op=Mod(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='m', ctx=Store()), op=Pow(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
while False:
    with set(), set(): # type: ^B
        x -= set()
else:
    v = +5 # type: % # While(test=Constant(value=False), body=[With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Name(id='x', ctx=Store()), op=Sub(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], type_comment='^B')], orelse=[Assign(targets=[Name(id='v', ctx=Store())], value=UnaryOp(op=UAdd(), operand=Constant(value=5)), type_comment='%')])
while ~Y():
    T = set()
    return
    return
else:
    p = set()[:]() # While(test=UnaryOp(op=Invert(), operand=Call(func=Name(id='Y', ctx=Del()), args=[], keywords=[])), body=[Assign(targets=[Name(id='T', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return(), Return()], orelse=[Assign(targets=[Name(id='p', ctx=Store())], value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[]))])

&lt;If&gt;
if :
    return
    for [a] in set(): # type: 
        break
    pass
    continue
    return
else:
    del set()[:] # If(test=BoolOp(op=Or(), values=[]), body=[Return(), For(target=List(elts=[Name(id='a', ctx=Store())], ctx=Store()), iter=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Break()], orelse=[], type_comment=""), Pass(), Continue(), Return()], orelse=[Delete(targets=[Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())])])
if set()[:]():
    set()
    u %= set()
    return
else:
    return
    return # If(test=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), body=[Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='u', ctx=Store()), op=Mod(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()], orelse=[Return(), Return()])
if None &gt;= set():
    assert set(), set().q
    return
    return
else:
    return # If(test=Compare(left=Constant(value=None), ops=[GtE()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), body=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), msg=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='q', ctx=Del())), Return(), Return()], orelse=[Return()])
if +va:
    while set():
        return
    if set():
        return
else:
    Z = *set() # If(test=UnaryOp(op=UAdd(), operand=Name(id='va', ctx=Load())), body=[While(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), If(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[])], orelse=[Assign(targets=[Name(id='Z', ctx=Store())], value=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Del()))])
if 
set() &lt;&lt; []:
    with :
        return
    assert ()
else:
    j &amp;= set()
    return set() # If(test=Expr(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=List(elts=[], ctx=Load()))), body=[With(items=[], body=[Return()]), Assert(test=Tuple(elts=[], ctx=Del()))], orelse=[AugAssign(target=Name(id='j', ctx=Store()), op=BitAnd(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
if {set(): set()}:
    G[:] **= set()
else:
    (Q,) += set() # If(test=Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), body=[AugAssign(target=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), op=Pow(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Tuple(elts=[Name(id='Q', ctx=Store())], ctx=Store()), op=Add(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
if *(set(),):
    h |= set()
    D &gt;&gt;= set()
else:
    *W /= r # If(test=Starred(value=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Load()), body=[AugAssign(target=Name(id='h', ctx=Store()), op=BitOr(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='D', ctx=Store()), op=RShift(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Starred(value=Name(id='W', ctx=Store()), ctx=Store()), op=Div(), value=Name(id='r', ctx=Del()))])
if {[set(), set(), set()]}:
    w[:].N ^= set().F
else:
    L[:].z *= set().C # If(test=Set(elts=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del())]), body=[AugAssign(target=Attribute(value=Subscript(value=Name(id='w', ctx=Store()), slice=Slice(), ctx=Store()), attr='N', ctx=Store()), op=BitXor(), value=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Load()))], orelse=[AugAssign(target=Attribute(value=Subscript(value=Name(id='L', ctx=Store()), slice=Slice(), ctx=Store()), attr='z', ctx=Store()), op=Mult(), value=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='C', ctx=Load()))])
if 192:
    return
    k //= set()
else:
    y -= set()
    d @= set() # If(test=Constant(value=192), body=[Return(), AugAssign(target=Name(id='k', ctx=Store()), op=FloorDiv(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], orelse=[AugAssign(target=Name(id='y', ctx=Store()), op=Sub(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='d', ctx=Store()), op=MatMult(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
if not True[set():set()]:
    S = False
else:
    E = J = set() # If(test=UnaryOp(op=Not(), operand=Subscript(value=Constant(value=True), slice=Slice(Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Load())), body=[Assign(targets=[Name(id='S', ctx=Store())], value=Constant(value=False))], orelse=[Assign(targets=[Name(id='E', ctx=Store()), Name(id='J', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])

&lt;Return&gt;
return ()                                # Return(value=Tuple(elts=[], ctx=Load()))
return                                   # Return()
return *[{set(): g(), set().k: set()[:], set(): False}, set()] # Return(value=Starred(value=List(elts=[Dict(keys=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='k', ctx=Load()), Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])], values=[Call(func=Name(id='g', ctx=Load()), args=[], keywords=[]), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Constant(value=False)]), BoolOp(op=Or(), values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])], ctx=Del()), ctx=Load()))
return O2sIF9wuGDe5hBzM10X7a &gt;&gt; (not 
{[*(set(), set())[set() ^ set():set() % set()]].idboHj}) # Return(value=BinOp(left=Name(id='O2sIF9wuGDe5hBzM10X7a', ctx=Del()), op=RShift(), right=UnaryOp(op=Not(), operand=Expr(value=Set(elts=[Attribute(value=List(elts=[Starred(value=Subscript(value=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Load()), ctx=Del())], ctx=Load()), attr='idboHj', ctx=Del())])))))
return ((set() | set()) &lt;&lt; set() - set()) @ (set() ** set() * (set() / set())) # Return(value=BinOp(left=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=LShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=MatMult(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))))
return 7.33                              # Return(value=Constant(value=7.33))
return 'G'                               # Return(value=Constant(value="G"))
return ~-None &amp; set()[:](set(), X=set()) // +set()[:].c(set()[:], set()[:], l=set(), Q=set()) # Return(value=BinOp(left=UnaryOp(op=Invert(), operand=UnaryOp(op=USub(), operand=Constant(value=None))), op=BitAnd(), right=BinOp(left=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='X', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]), op=FloorDiv(), right=UnaryOp(op=UAdd(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr='c', ctx=Del()), args=[Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load())], keywords=[keyword(arg='l', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='Q', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])))))
return (set() + set() and 24)[''[set() | set():set() % set():set()]:] # Return(value=Subscript(value=BoolOp(op=And(), values=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Constant(value=24)]), slice=Slice(Subscript(value=Constant(value=''), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Load())), ctx=Load()))
return (oiLk &lt; set() != set()) &gt; 496 &lt;= True # Return(value=Compare(left=Compare(left=Name(id='oiLk', ctx=Del()), ops=[Lt(), NotEq()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Name(id='f8', ctx=Del())]), ops=[Gt(), LtE()], comparators=[Constant(value=496), Constant(value=True)]))

&lt;Delete&gt;
del ((not {(set()[:]().PTA2)[*set():
{}]})) // True, [] # Delete(targets=[BinOp(left=Compare(left=UnaryOp(op=Not(), operand=Set(elts=[Subscript(value=BoolOp(op=And(), values=[Attribute(value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[]), attr='PTA2', ctx=Load())]), slice=Slice(Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Del()), Expr(value=Dict(keys=[], values=[]))), ctx=Load())])), ops=[], comparators=[Tuple(elts=[Name(id='G', ctx=Load())], ctx=Load())]), op=FloorDiv(), right=Constant(value=True)), List(elts=[], ctx=Del())])
del [set(), set(), set() / set()], *().QD, y4iFkwX # Delete(targets=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load()), Attribute(value=Starred(value=Tuple(elts=[], ctx=Del()), ctx=Load()), attr='QD', ctx=Del()), Name(id='y4iFkwX', ctx=Del())])
del set(), set(), set() ^ set(), set() % set() &gt;&gt; set() - set() @ set() # Delete(targets=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=RShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=MatMult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))))])
del set() &lt;&lt; set(), set() | set(), set() ** set(), set() * (set() + set()) # Delete(targets=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))])
del 6                                    # Delete(targets=[Constant(value=6)])
del '_'                                  # Delete(targets=[Constant(value='_')])
del ~50.413, +-set()[:][set() &amp; set():].F_(set() + set(), set()[:], L=set(), Z=set()) # Delete(targets=[UnaryOp(op=Invert(), operand=Constant(value=50.413)), UnaryOp(op=UAdd(), operand=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), slice=Slice(BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Load()), attr='F_', ctx=Del()), args=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Add(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del())], keywords=[keyword(arg='L', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), keyword(arg='Z', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])))])
del set() or None or z(), (set() and set())[False:c():T()] # Delete(targets=[BoolOp(op=Or(), values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=None), Call(func=Name(id='z', ctx=Del()), args=[], keywords=[])]), Subscript(value=BoolOp(op=And(), values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), slice=Slice(Constant(value=False), Call(func=Name(id='c', ctx=Del()), args=[], keywords=[]), Call(func=Name(id='T', ctx=Load()), args=[], keywords=[])), ctx=Del())])
del ''                                   # Delete(targets=[Constant(value="")])
del k5vofh3xGZH == R1rc                  # Delete(targets=[Compare(left=Name(id='k5vofh3xGZH', ctx=Load()), ops=[Eq()], comparators=[Name(id='R1rc', ctx=Del()), Name(id='HPJup', ctx=Del())])])

&lt;Assert&gt;
assert {}                                # Assert(test=Dict(keys=[], values=[List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Constant(value=6.7), Attribute(value=BoolOp(op=Or(), values=[]), attr='Q', ctx=Del()), Compare(left=Expr(value=UnaryOp(op=Invert(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ops=[NotIn()], comparators=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])], ctx=Del())]))
assert Z4mcX(set(), o=set()), ICkz[*(set() ^ set(),):] # Assert(test=Call(func=Name(id='Z4mcX', ctx=Del()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], keywords=[keyword(arg='o', value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))]), msg=Subscript(value=Name(id='ICkz', ctx=Load()), slice=Slice(Starred(value=Tuple(elts=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitXor(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], ctx=Load()), ctx=Load())), ctx=Load()))
assert [().H, {().h}, *(set(),)[*set() / set():set() // set()]] # Assert(test=List(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr='H', ctx=Del()), Set(elts=[Attribute(value=Tuple(elts=[], ctx=Del()), attr='h', ctx=Load())]), Subscript(value=Starred(value=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load()), ctx=Del()), slice=Slice(Starred(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Div(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Load()), BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=FloorDiv(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Del())], ctx=Load()))
assert set() ** set() % (set() - set()), (set() &gt;&gt; (set() &amp; set())) + (set() | set()) * (set() &lt;&lt; set()) # Assert(test=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Sub(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), msg=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=RShift(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), op=Add(), right=BinOp(left=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitOr(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), op=Mult(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=LShift(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))))
assert None                              # Assert(test=Constant(value=None))
assert True                              # Assert(test=Constant(value=True))
assert not 331                           # Assert(test=UnaryOp(op=Not(), operand=Constant(value=331)))
assert -set()[:].x(set(), set()), +(not (set()[:]())[:]) # Assert(test=UnaryOp(op=USub(), operand=Call(func=Attribute(value=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), attr='x', ctx=Load()), args=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], keywords=[])), msg=UnaryOp(op=UAdd(), operand=UnaryOp(op=Not(), operand=Subscript(value=BoolOp(op=And(), values=[Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Load()), args=[], keywords=[])]), slice=Slice(), ctx=Load()))))
assert 'X' @ (set())[False:set()]['':][False:][9:'Rbw':'m'] # Assert(test=BinOp(left=Constant(value='X'), op=MatMult(), right=Subscript(value=Subscript(value=Subscript(value=Subscript(value=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(Constant(value=False), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), ctx=Del()), slice=Slice(Constant(value="")), ctx=Load()), slice=Slice(Constant(value=False)), ctx=Load()), slice=Slice(Constant(value=9), Constant(value="Rbw"), Constant(value="m")), ctx=Del())))
assert bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd # Assert(test=Name(id='bwxOpNKPEWF6yVnaubG5BIrJ2lt3AiD97QMsvf_LjYeSZHqohR0g81TUd', ctx=Del()))

&lt;Pass&gt;
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()
pass                                     # Pass()

&lt;Break&gt;
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()
break                                    # Break()

&lt;Continue&gt;
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()
continue                                 # Continue()

&lt;With&gt;
with :
    [c, (y,)] //= {}
    with set(), set(): # type: t
        return # With(items=[], body=[AugAssign(target=List(elts=[Name(id='c', ctx=Store()), Tuple(elts=[Name(id='y', ctx=Store())], ctx=Store())], ctx=Store()), op=FloorDiv(), value=Dict(keys=[], values=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='e', ctx=Load())])), With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], body=[Return()], type_comment='t')])
with set() as C, *set() as *P: # type: 
    while (set())[:]:
        break # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='C', ctx=Store())), withitem(context_expr=Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Del()), optional_vars=Starred(value=Name(id='P', ctx=Store()), ctx=Store()))], body=[While(test=Subscript(value=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[]), slice=Slice(), ctx=Load()), body=[Break()], orelse=[])], type_comment="")
with '' as G[:]._: # type: H!
    del set(), set(), set()
    set()
    pass
    continue # With(items=[withitem(context_expr=Constant(value=''), optional_vars=Attribute(value=Subscript(value=Name(id='G', ctx=Store()), slice=Slice(), ctx=Store()), attr='_', ctx=Store()))], body=[Delete(targets=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])]), Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Pass(), Continue()], type_comment="H!")
with : # type: |S9vg
    for B in set(): # type: 
        return # With(items=[withitem(context_expr=BoolOp(op=And(), values=[]))], body=[For(target=Name(id='B', ctx=Store()), iter=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[], type_comment="")], type_comment='|S9vg')
with () as Y[:]: # type: t&gt;A
    b = E = set() # With(items=[withitem(context_expr=Tuple(elts=[], ctx=Load()), optional_vars=Subscript(value=Name(id='Y', ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assign(targets=[Name(id='b', ctx=Store()), Name(id='E', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], type_comment="t&gt;A")
with set(), set() as K[:]: # type: f
    if set():
        return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id='K', ctx=Store()), slice=Slice(), ctx=Store()))], body=[If(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), Return(), Return()], type_comment="f")
with set(), set(), [], set() as r[:]: # type: n
    assert set()
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), withitem(context_expr=List(elts=[], ctx=Del())), withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), optional_vars=Subscript(value=Name(id='r', ctx=Store()), slice=Slice(), ctx=Store()))], body=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return(), Return()], type_comment='n')
with set() as v: # type: $5a?@c
    assert set(), set()
    return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='v', ctx=Store()))], body=[Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return(), Return(), Return()], type_comment="$5a?@c")
with set() as j: # type:  j
    return set()[:]()
    return
    return
    return # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), optional_vars=Name(id='j', ctx=Store()))], body=[Return(value=Call(func=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), args=[], keywords=[])), Return(), Return(), Return()], type_comment=' j')
with set(): # type: 
    J[:] &amp;= set() * set()
    h /= I
    return # With(items=[withitem(context_expr=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], body=[AugAssign(target=Subscript(value=Name(id='J', ctx=Store()), slice=Slice(), ctx=Store()), op=BitAnd(), value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), AugAssign(target=Name(id='h', ctx=Store()), op=Div(), value=Name(id='I', ctx=Load())), Return()], type_comment='')
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us see if we can also <em>parse</em> code properly. Here is a sample:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">with_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">with open('foo.txt') as myfile:</span>
<span class="s2">    content = myfile.readlines()</span>
<span class="s2">    if content is not None:</span>
<span class="s2">        print(content)</span>
<span class="s2">"""</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_stmts_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">)</span>
<span class="n">with_tree_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">with_tree</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># get the `With(...)` subtree</span>
<span class="nb">print</span><span class="p">(</span><span class="n">with_tree_str</span><span class="p">)</span>
<span class="n">with_solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_stmts_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">with_solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">with_tree_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>With(items=[withitem(context_expr=Call(func=Name(id='open', ctx=Load()), args=[Constant(value='foo.txt')], keywords=[]), optional_vars=Name(id='myfile', ctx=Store()))], body=[Assign(targets=[Name(id='content', ctx=Store())], value=Call(func=Attribute(value=Name(id='myfile', ctx=Load()), attr='readlines', ctx=Load()), args=[], keywords=[])), If(test=Compare(left=Name(id='content', ctx=Load()), ops=[IsNot()], comparators=[Constant(value=None)]), body=[Expr(value=Call(func=Name(id='print', ctx=Load()), args=[Name(id='content', ctx=Load())], keywords=[]))], orelse=[])])
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>It seems our grammar can also parse non-trivial code properly. We are doing well!</p>
</div>
</div>
</div>
</div>

</details>

<details id="Excursion:-Function-Definitions">
<summary>Function Definitions</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now for function definitions.
Not too many surprises here.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"""</span>
<span class="s2">def f(a, b=1):</span>
<span class="s2">    pass</span>
<span class="s2">"""</span>
<span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Module(
    body=[
        FunctionDef(
            name='f',
            args=arguments(
                posonlyargs=[],
                args=[
                    arg(arg='a'),
                    arg(arg='b')],
                kwonlyargs=[],
                kw_defaults=[],
                defaults=[
                    Constant(value=1)]),
            body=[
                Pass()],
            decorator_list=[])],
    type_ignores=[])
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;stmt&gt;'</span><span class="p">:</span> <span class="n">PYTHON_AST_STMTS_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;stmt&gt;'</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span> <span class="s1">'&lt;FunctionDef&gt;'</span> <span class="p">],</span>

    <span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;decorator_list_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', decorator_list=&lt;expr_list&gt;'</span>
    <span class="p">],</span>

    <span class="s1">'&lt;arguments&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'arguments(&lt;posonlyargs_param&gt;args=&lt;arg_list&gt;&lt;vararg&gt;?&lt;kwonlyargs_param&gt;&lt;kw_defaults_param&gt;&lt;kwarg&gt;?&lt;defaults_param&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;posonlyargs_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'posonlyargs=&lt;arg_list&gt;, '</span>
    <span class="p">],</span>
    <span class="s1">'&lt;kwonlyargs_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', kwonlyargs=&lt;arg_list&gt;'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;kw_defaults_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', kw_defaults=&lt;expr_list&gt;'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;defaults_param&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', defaults=&lt;expr_list&gt;'</span>
    <span class="p">],</span>

    <span class="s1">'&lt;arg_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;args&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;args&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;arg&gt;'</span><span class="p">,</span> <span class="s1">'&lt;arg&gt;, &lt;arg&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;arg&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'arg(arg=&lt;identifier&gt;)'</span> <span class="p">],</span>

    <span class="s1">'&lt;vararg&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', vararg=&lt;arg&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;kwarg&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', kwarg=&lt;arg&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;returns&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', returns=&lt;expr&gt;'</span> <span class="p">],</span>

    <span class="c1"># FIXME: Not handled: AsyncFunctionDef, ClassDef</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In Python 3.12 and later, function definitions also have a <code>type_param</code> field:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">12</span><span class="p">):</span>
    <span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?&lt;type_params&gt;?)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;type_params&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">', type_params=&lt;type_param_list&gt;'</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="s1">'&lt;type_param_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;type_param&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;type_param&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;TypeVar&gt;'</span><span class="p">,</span> <span class="s1">'&lt;ParamSpec&gt;'</span><span class="p">,</span> <span class="s1">'&lt;TypeVarTuple&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;TypeVar&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'TypeVar(name=&lt;identifier&gt;(, bound=&lt;expr&gt;)?)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;ParamSpec&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'ParamSpec(name=&lt;identifier&gt;)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;TypeVarTuple&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'TypeVarTuple(name=&lt;identifier&gt;)'</span>
    <span class="p">]</span>
    <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In Python 3.13 and later, several <code>&lt;FunctionDef&gt;</code> and <code>&lt;arguments&gt;</code> attributes are optional:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;?&lt;returns&gt;?&lt;type_comment&gt;?&lt;type_params&gt;?)'</span>
    <span class="p">],</span>
    <span class="s1">'&lt;arguments&gt;'</span><span class="p">:</span> <span class="p">[</span>
        <span class="s1">'arguments(&lt;posonlyargs_param&gt;?args=&lt;arg_list&gt;&lt;vararg&gt;?&lt;kwonlyargs_param&gt;?&lt;kw_defaults_param&gt;?&lt;kwarg&gt;?&lt;defaults_param&gt;?)'</span>
    <span class="p">],</span>
    <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;arguments&gt;'</span><span class="p">,</span> <span class="s1">'&lt;FunctionDef&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;arguments&gt;
i, /, Wr, x                              # arguments(posonlyargs=[arg(arg='i')], args=[arg(arg='Wr'), arg(arg='x')], kwonlyargs=[], kw_defaults=[List(elts=[UnaryOp(op=UAdd(), operand=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Dict(keys=[], values=[]), Name(id='P', ctx=Load())], ctx=Load())], defaults=[])
G, /, h=, *e, u=set(), **R3              # arguments(posonlyargs=[arg(arg='G')], args=[arg(arg='h')], vararg=arg(arg='e'), kwonlyargs=[arg(arg='u')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Starred(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ctx=Del())], kwarg=arg(arg='R3'), defaults=[BoolOp(op=Or(), values=[])])
n, C, /, s, T=set(), *S, L=set(), **j    # arguments(posonlyargs=[arg(arg='n'), arg(arg='C')], args=[arg(arg='s'), arg(arg='T')], vararg=arg(arg='S'), kwonlyargs=[arg(arg='L')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='j'), defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])
F, z, /, Q, N, *Y, X=set(), **g          # arguments(posonlyargs=[arg(arg='F'), arg(arg='z')], args=[arg(arg='Q'), arg(arg='N')], vararg=arg(arg='Y'), kwonlyargs=[arg(arg='X'), arg(arg='I')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='g'), defaults=[])
A=set(), /, B=set(), f=set(), *O6, K=set(), **Z # arguments(posonlyargs=[arg(arg='A')], args=[arg(arg='B'), arg(arg='f')], vararg=arg(arg='O6'), kwonlyargs=[arg(arg='K')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='Z'), defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])
p, y=set(), /, H=
set(), *l, Jo=set(), **V # arguments(posonlyargs=[arg(arg='p'), arg(arg='y')], args=[arg(arg='H')], vararg=arg(arg='l'), kwonlyargs=[arg(arg='Jo')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='V'), defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Expr(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
m, /, U, c, *w, **o                      # arguments(posonlyargs=[arg(arg='m')], args=[arg(arg='U'), arg(arg='c')], vararg=arg(arg='w'), kwonlyargs=[arg(arg='b'), arg(arg='q')], kw_defaults=[], kwarg=arg(arg='o'), defaults=[])
k, v, /, E, t=set() % set(), *_, **rR    # arguments(posonlyargs=[arg(arg='k'), arg(arg='v')], args=[arg(arg='E'), arg(arg='t')], vararg=arg(arg='_'), kwonlyargs=[], kw_defaults=[], kwarg=arg(arg='rR'), defaults=[BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))])
M, /, D, *d, a=set(), **Z                # arguments(posonlyargs=[arg(arg='M')], args=[arg(arg='D')], vararg=arg(arg='d'), kwonlyargs=[arg(arg='a')], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='F', ctx=Del())], kwarg=arg(arg='Z'), defaults=[])
n, Y, /, g, y=set(), *z, **U             # arguments(posonlyargs=[arg(arg='n'), arg(arg='Y')], args=[arg(arg='g'), arg(arg='y')], vararg=arg(arg='z'), kwonlyargs=[], kw_defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], kwarg=arg(arg='U'), defaults=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])])

&lt;FunctionDef&gt;
def U():
    return                      # FunctionDef(name='U', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])
def F():
    pass                        # FunctionDef(name='F', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])
def u() -&gt; set(): # type: 
    continue  # FunctionDef(name='u', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment="")
def D() -&gt; set(): # type: 
    break     # FunctionDef(name='D', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment='')
def w(): # type: 
    return             # FunctionDef(name='w', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment='')
def g() -&gt; set(): # type: 
    return    # FunctionDef(name='g', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment='')
def q() -&gt; set(): # type: 
    return    # FunctionDef(name='q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment='')
def W() -&gt; set():
    return             # FunctionDef(name='W', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))
def I() -&gt; set():
    return             # FunctionDef(name='I', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))
def n() -&gt; set(): # type: 
    return    # FunctionDef(name='n', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment="")
</pre>
</div>

</div>

</details>

<details id="Excursion:-Modules">
<summary>Modules</summary>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We close with <em>modules</em> – sequences of definitions.
After all the other definitions, this is now fairly straightforward.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_DEFS_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
    <span class="s1">'&lt;start&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;mod&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;mod&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;Module&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;Module&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;)'</span><span class="p">],</span>

    <span class="s1">'&lt;type_ignore_param&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">', type_ignores=&lt;type_ignore_list&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;type_ignore_list&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'[&lt;type_ignores&gt;?]'</span> <span class="p">],</span>
    <span class="s1">'&lt;type_ignores&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'&lt;type_ignore&gt;'</span><span class="p">,</span> <span class="s1">'&lt;type_ignore&gt;, &lt;type_ignore&gt;'</span> <span class="p">],</span>
    <span class="s1">'&lt;type_ignore&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'TypeIgnore(lineno=&lt;integer&gt;, tag=&lt;string&gt;)'</span> <span class="p">],</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># do import this unconditionally</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">13</span><span class="p">):</span>
    <span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> \
        <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">,</span> <span class="p">{</span>
        <span class="c1"># As of 3.13, the type_ignore parameter is optional</span>
        <span class="s1">'&lt;Module&gt;'</span><span class="p">:</span> <span class="p">[</span> <span class="s1">'Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;?)'</span><span class="p">],</span>
    <span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;Module&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_MODULE_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;Module&gt;
EESc9e.w @ {
[*(not set())[y():set():{}]], } # Module(body=[Expr(value=BinOp(left=Attribute(value=Name(id='EESc9e', ctx=Del()), attr='w', ctx=Load()), op=MatMult(), right=Set(elts=[Expr(value=List(elts=[Starred(value=Subscript(value=UnaryOp(op=Not(), operand=Compare(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), ops=[], comparators=[])), slice=Slice(Call(func=Name(id='y', ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Dict(keys=[], values=[])), ctx=Load()), ctx=Load())], ctx=Del())), BoolOp(op=And(), values=[])])))], type_ignores=[])
while (None, ''):
    m = set()
    del 
    return
else:
    break
    with :
        return
    pass
return
continue # Module(body=[While(test=Tuple(elts=[Constant(value=None), Constant(value='')], ctx=Load()), body=[Assign(targets=[Name(id='m', ctx=Store())], value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Delete(targets=[]), Return()], orelse=[Break(), With(items=[], body=[Return()]), Pass()]), Return(), Continue()], type_ignores=[TypeIgnore(lineno=27, tag=''), TypeIgnore(lineno=2, tag="h")])
for I.V in set()[:]: # type: 
    return # Module(body=[For(target=Attribute(value=Name(id='I', ctx=Store()), attr='V', ctx=Store()), iter=Subscript(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), slice=Slice(), ctx=Del()), body=[Return()], orelse=[], type_comment="")], type_ignores=[TypeIgnore(lineno=131, tag='[bm')])
def Q():
    return
assert set().a
return # Module(body=[FunctionDef(name='Q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[]), Assert(test=Attribute(value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), attr='a', ctx=Del())), Return()], type_ignores=[TypeIgnore(lineno=56, tag="M")])
if set():
    return
*h &lt;&lt;= set()        # Module(body=[If(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), body=[Return()], orelse=[]), AugAssign(target=Starred(value=Name(id='h', ctx=Store()), ctx=Store()), op=LShift(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=8, tag=""), TypeIgnore(lineno=5, tag="")])
return [set()]
assert (set(), set()), [] # Module(body=[Return(value=List(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Load())), Assert(test=Tuple(elts=[Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])], ctx=Del()), msg=List(elts=[], ctx=Del()))], type_ignores=[TypeIgnore(lineno=89, tag=""), TypeIgnore(lineno=0, tag="Q")])
D |= set()                               # Module(body=[AugAssign(target=Name(id='D', ctx=Store()), op=BitOr(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))], type_ignores=[TypeIgnore(lineno=74, tag='1'), TypeIgnore(lineno=90, tag="")])
[o, j] += *set() % set() ** set()        # Module(body=[AugAssign(target=List(elts=[Name(id='o', ctx=Store()), Name(id='j', ctx=Store())], ctx=Store()), op=Add(), value=Starred(value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mod(), right=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Pow(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))), ctx=Del()))], type_ignores=[TypeIgnore(lineno=3980, tag="7'Z")])
x[:] /= set()
i -= set() &amp; set()         # Module(body=[AugAssign(target=Subscript(value=Name(id='x', ctx=Store()), slice=Slice(), ctx=Store()), op=Div(), value=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), AugAssign(target=Name(id='i', ctx=Store()), op=Sub(), value=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=BitAnd(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])))], type_ignores=[TypeIgnore(lineno=40, tag='W2j')])
s //= -(set() * set())                   # Module(body=[AugAssign(target=Name(id='s', ctx=Store()), op=FloorDiv(), value=UnaryOp(op=USub(), operand=BinOp(left=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), op=Mult(), right=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))))], type_ignores=[TypeIgnore(lineno=665, tag=""), TypeIgnore(lineno=5, tag="")])
</pre>
</div>

</div>

</details>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>At this point, we have covered (almost) all AST elements of Python.
There would be a few more Python elements to consider (marked as <code>FIXME</code>, above), but we'll leave these to the reader.
Let us define <code>PYTHON_AST_GRAMMAR</code> as the official grammar coming out of this chapter.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_GRAMMAR</span> <span class="o">=</span> <span class="n">PYTHON_AST_MODULE_GRAMMAR</span>
<span class="n">python_ast_grammar</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here are a few (very weird) examples of Python functions we can produce.
All of these are valid, but only <em>syntactically</em> – very few of the code samples produced this way will actually result in something meaningful.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">'&lt;FunctionDef&gt;'</span> <span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
    <span class="n">test_samples</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">elt</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>&lt;FunctionDef&gt;
def w():
    pass                        # FunctionDef(name='w', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Pass()], decorator_list=[])
def a():
    break                       # FunctionDef(name='a', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Break()], decorator_list=[])
def o():
    return                      # FunctionDef(name='o', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[])
def v(): # type: 
    continue           # FunctionDef(name='v', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Continue()], decorator_list=[], type_comment='')
def j(): # type: 
    return             # FunctionDef(name='j', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment="")
def k():
    return
    return           # FunctionDef(name='k', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Return()], decorator_list=[])
def Q() -&gt; set(): # type: 
    return    # FunctionDef(name='Q', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), type_comment='')
def d() -&gt; None:
    return
    assert set(), set()
    return # FunctionDef(name='d', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return(), Assert(test=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]), msg=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[])), Return()], decorator_list=[], returns=Constant(value=None))
def K() -&gt; set():
    return             # FunctionDef(name='K', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], returns=Call(func=Name(id="set", ctx=Load()), args=[], keywords=[]))
def y(): # type: 
    return             # FunctionDef(name='y', args=arguments(posonlyargs=[], args=[], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Return()], decorator_list=[], type_comment='')
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="A-Class-for-Fuzzing-Python">A Class for Fuzzing Python</h2><p>For convenience, let us introduce a class <code>PythonFuzzer</code> that makes use of the above grammar in order to produce Python code. This will be fairly easy to use.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">class</span> <span class="nc">PythonFuzzer</span><span class="p">(</span><span class="n">ISLaSolver</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Produce Python code."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">start_symbol</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
                 <span class="n">grammar</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Grammar</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">constraint</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Produce Python code. Parameters are:</span>

<span class="sd">        * `start_symbol`: The grammatical entity to be generated (default: `&lt;FunctionDef&gt;`)</span>
<span class="sd">        * `grammar`: The EBNF grammar to be used (default: `PYTHON__AST_GRAMMAR`); and</span>
<span class="sd">        * `constraint` an ISLa constraint (if any).</span>

<span class="sd">        Additional keyword parameters are passed to the `ISLaSolver` superclass.</span>
<span class="sd">        """</span>
        <span class="k">if</span> <span class="n">start_symbol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_symbol</span> <span class="o">=</span> <span class="s1">'&lt;FunctionDef&gt;'</span>
        <span class="k">if</span> <span class="n">grammar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grammar</span> <span class="o">=</span> <span class="n">PYTHON_AST_GRAMMAR</span>
        <span class="k">assert</span> <span class="n">start_symbol</span> <span class="ow">in</span> <span class="n">grammar</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">convert_ebnf_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">start_symbol</span><span class="o">=</span><span class="n">start_symbol</span><span class="p">,</span> <span class="o">**</span><span class="n">kw_params</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fuzz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">"""Produce a Python code string."""</span>
        <span class="n">abstract_syntax_tree</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">solve</span><span class="p">()))</span>
        <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">abstract_syntax_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>By default, the <code>PythonFuzzer</code> will produce a <em>function definition</em> - that is, a function header and body.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def L():
    continue
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>By passing a start symbol as parameter, you can have <code>PythonFuzzer</code> produce arbitrary Python elements:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="s1">'&lt;While&gt;'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>while (set()[set():set()], *(set())):
    if {}:
        while set():
            continue
        break
    else:
        del 
        return
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here is a list of all possible start symbols:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;Assert&gt;',
 '&lt;Assign&gt;',
 '&lt;Attribute&gt;',
 '&lt;AugAssign&gt;',
 '&lt;BinOp&gt;',
 '&lt;BoolOp&gt;',
 '&lt;Break&gt;',
 '&lt;Call&gt;',
 '&lt;Compare&gt;',
 '&lt;Constant&gt;',
 '&lt;Continue&gt;',
 '&lt;Delete&gt;',
 '&lt;Dict&gt;',
 '&lt;EmptySet&gt;',
 '&lt;Expr&gt;',
 '&lt;For&gt;',
 '&lt;FunctionDef&gt;',
 '&lt;If&gt;',
 '&lt;List&gt;',
 '&lt;Module&gt;',
 '&lt;Name&gt;',
 '&lt;Pass&gt;',
 '&lt;Return&gt;',
 '&lt;Set&gt;',
 '&lt;Slice&gt;',
 '&lt;Starred&gt;',
 '&lt;Subscript&gt;',
 '&lt;Tuple&gt;',
 '&lt;UnaryOp&gt;',
 '&lt;While&gt;',
 '&lt;With&gt;',
 '&lt;arg&gt;',
 '&lt;arg_list&gt;',
 '&lt;args&gt;',
 '&lt;args_param&gt;',
 '&lt;arguments&gt;',
 '&lt;bool&gt;',
 '&lt;boolop&gt;',
 '&lt;cmpop&gt;',
 '&lt;cmpop_list&gt;',
 '&lt;cmpops&gt;',
 '&lt;decorator_list_param&gt;',
 '&lt;defaults_param&gt;',
 '&lt;digit&gt;',
 '&lt;digits&gt;',
 '&lt;expr&gt;',
 '&lt;expr_list&gt;',
 '&lt;exprs&gt;',
 '&lt;float&gt;',
 '&lt;func&gt;',
 '&lt;id&gt;',
 '&lt;id_continue&gt;',
 '&lt;id_start&gt;',
 '&lt;identifier&gt;',
 '&lt;integer&gt;',
 '&lt;keyword&gt;',
 '&lt;keyword_list&gt;',
 '&lt;keywords&gt;',
 '&lt;keywords_param&gt;',
 '&lt;kw_defaults_param&gt;',
 '&lt;kwarg&gt;',
 '&lt;kwonlyargs_param&gt;',
 '&lt;lhs_Attribute&gt;',
 '&lt;lhs_List&gt;',
 '&lt;lhs_Name&gt;',
 '&lt;lhs_Starred&gt;',
 '&lt;lhs_Subscript&gt;',
 '&lt;lhs_Tuple&gt;',
 '&lt;lhs_expr&gt;',
 '&lt;lhs_exprs&gt;',
 '&lt;literal&gt;',
 '&lt;mod&gt;',
 '&lt;none&gt;',
 '&lt;nonempty_expr_list&gt;',
 '&lt;nonempty_lhs_expr_list&gt;',
 '&lt;nonempty_stmt_list&gt;',
 '&lt;nonzerodigit&gt;',
 '&lt;not_double_quotes&gt;',
 '&lt;not_single_quotes&gt;',
 '&lt;operator&gt;',
 '&lt;orelse_param&gt;',
 '&lt;posonlyargs_param&gt;',
 '&lt;returns&gt;',
 '&lt;start&gt;',
 '&lt;stmt&gt;',
 '&lt;stmt_list&gt;',
 '&lt;stmts&gt;',
 '&lt;string&gt;',
 '&lt;type_comment&gt;',
 '&lt;type_ignore&gt;',
 '&lt;type_ignore_list&gt;',
 '&lt;type_ignore_param&gt;',
 '&lt;type_ignores&gt;',
 '&lt;unaryop&gt;',
 '&lt;vararg&gt;',
 '&lt;withitem&gt;',
 '&lt;withitem_list&gt;',
 '&lt;withitems&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Customizing-the-Python-Fuzzer">Customizing the Python Fuzzer</h2><p>When fuzzing, you may be interested in <em>specific</em> properties of the produced output. How can we influence the code that <code>PythonFuzzer</code> produces? We explore two ways:</p>
<ul>
<li>By adjusting the <em>grammar</em> to our needs</li>
<li>By adding <em>constraints</em> that customize the output for us.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Adjusting-the-Grammar">Adjusting the Grammar</h3><p>A simple way to adjust output generation is to <em>adapt the grammar</em>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us assume you'd like to have function definitions without decorators.
To achieve this, you can <em>alter the rule that produces function definitions</em>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">[</span><span class="s1">'&lt;FunctionDef&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;&lt;decorator_list_param&gt;&lt;returns&gt;?&lt;type_comment&gt;?)']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As any AST rule, it comes in <em>abstract syntax</em>, so we first have to identify the element we'd like to adjust.
In our case, this is <code>decorator_list</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Since decorator_list is a list, we can alter the rule to produce empty lists only.
To create a new adapted grammar, we do not alter the existing <code>PYTHON_AST_GRAMMAR</code>.
Instead, we use the <code>extend_grammar()</code> function to create a new grammar with a new, adapted rule for <code>&lt;FunctionDef&gt;</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_grammar_without_decorators</span><span class="p">:</span> <span class="n">Grammar</span> <span class="o">=</span> <span class="n">extend_grammar</span><span class="p">(</span><span class="n">PYTHON_AST_GRAMMAR</span><span class="p">,</span>
<span class="p">{</span>
    <span class="s1">'&lt;FunctionDef&gt;'</span> <span class="p">:</span>
        <span class="p">[</span><span class="s1">'FunctionDef(name=&lt;identifier&gt;, args=&lt;arguments&gt;, body=&lt;nonempty_stmt_list&gt;, decorator_list=[])'</span><span class="p">]</span>
<span class="p">})</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>However, we're not done yet.
We also need to ensure that our grammar is <em>valid</em>, as any misspelled nonterminal identifier will result in problems during production.
For this, we use the <code>is_valid_grammar()</code> function:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="ExpectError.html" class="import" target="_blank">ExpectError</a></span> <span class="kn">import</span> <span class="n">ExpectError</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">with</span> <span class="n">ExpectError</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>'&lt;decorator_list_param&gt;': defined, but not used. Consider applying trim_grammar() on the grammar
'&lt;returns&gt;': defined, but not used. Consider applying trim_grammar() on the grammar
'&lt;decorator_list_param&gt;': unreachable from &lt;start&gt;. Consider applying trim_grammar() on the grammar
'&lt;returns&gt;': unreachable from &lt;start&gt;. Consider applying trim_grammar() on the grammar
Traceback (most recent call last):
  File "/var/folders/n2/xd9445p97rb3xh7m1dfx8_4h0006ts/T/ipykernel_17604/3611578183.py", line 2, in &lt;module&gt;
    assert is_valid_grammar(python_ast_grammar_without_decorators)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
AssertionError (expected)
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that with our change, our grammar has an <em>orphaned rule</em>: The <code>&lt;returns&gt;</code> rule is no longer used.
This is because <code>&lt;returns&gt;</code> is part of the <code>&lt;type_annotation&gt;</code> we just have deleted.
(<code>&lt;type_annotation&gt;</code> is still used when defining types for variables.)</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To fix this, we need to delete the <code>&lt;returns&gt;</code> rule from our grammar.
Fortunately, we have a function <code>trim_grammar()</code>, which deletes all orphaned rules:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_grammar_without_decorators</span> <span class="o">=</span> <span class="n">trim_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With this, our grammar becomes valid...</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">is_valid_grammar</span><span class="p">(</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>... and we can use it for fuzzing - now without decorators:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">grammar</span><span class="o">=</span><span class="n">python_ast_grammar_without_decorators</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def X():
    break
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Adjusting the grammar is straightforward once you understood the grammar structure, but the AST grammar is complex; also, your changes and extensions tie you closely to the grammar structure.
Carefully study how the individual rules are defined, above.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Using-Constraints-for-Customizing">Using Constraints for Customizing</h3><p>A more elegant alternative to altering the grammar is to make use of <em>constraints</em> that tune the grammar to your needs.
Since <code>PythonFuzzer</code> is derived from <code>ISLaSolver</code>, we can pass a <code>constraint</code> argument constraining the grammar, as discussed in the chapter on <a href="FuzzingWithConstraints.html">fuzzing with constraints</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we want to have a function definition with 10 characters in each identifier, we make use of an ISLa constraint:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">'str.len(&lt;id&gt;) = 10'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def yWOOLwypwp(): # type: 
    return
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can also constrain individual children – say, the actual identifier of the function.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># Also works (the &lt;identifier&gt; has quotes)</span>
<span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">'&lt;FunctionDef&gt;.&lt;identifier&gt; = "</span><span class="se">\'</span><span class="s1">my_favorite_function</span><span class="se">\'</span><span class="s1">"'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>@[set(), set()]
@set() | {}
@(-*set())[set():():
set()[:]()]
def my_favorite_function(dlFf=Qr, l1M=set(), *) -&gt; 942.5:
    return
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Assume we want to test how the compiler handles large numbers. Let us define a constraint such that the function body (<code>&lt;nonempty_stmt_list&gt;</code>) contains at least one integer (<code>&lt;integer&gt;</code>) with a value of at least 1000:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span>
<span class="sd">"""</span>
<span class="sd">    exists &lt;integer&gt; x:</span>
<span class="sd">        (inside(x, &lt;nonempty_stmt_list&gt;) and str.to.int(x) &gt; 1000)</span>
<span class="sd">"""</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>@[set(), +set(), 
set()]
@{set(): set(), set(): set()}
@(set(), *set() &amp; set())
def l(r, a, /, *uXLV, _=set()[:], **Z) -&gt; sdTYWE9b or {set(), set().R}.Vy != z1vw([]):
    del 1007
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Assume we'd like to test compilers with non-trivial functions. Here's how to define a constraint such that the function body has exactly <em>three</em> statements (<code>&lt;stmt&gt;</code>). Note that this can take more than a minute to resolve, but the result definitely is a nontrivial function.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="c1"># This will not work with ISLa 2</span>
<span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s2">"""</span>
<span class="s2">    forall &lt;FunctionDef&gt; def: count(def, "&lt;stmt&gt;", "3")</span>
<span class="s2">"""</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>@3.91
def V8(w, /, *, t=set(), C5D=set(), **foT6):
    if *{}.S[:] - ((set()) not in set() in set()):
        pass
    else:
        return
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>And finally, if we want the decorator list to be empty, as in our grammar-altering example, we can constrain the decorator list to be empty:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">fuzzer</span> <span class="o">=</span> <span class="n">PythonFuzzer</span><span class="p">(</span><span class="n">constraint</span><span class="o">=</span><span class="s1">'&lt;FunctionDef&gt;..&lt;expr_list&gt; = "[]"'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fuzzer</span><span class="o">.</span><span class="n">fuzz</span><span class="p">())</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def l(Jws4IzSPx_O2ajk687obQB3mflULCTJWnAv9GHg0YRtVNycueKFDMihZ5rXd1pqEo, /, *, **g):
    return
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Mutating-Code">Mutating Code</h2><p>When producing code for compilers (or actually, producing inputs in general), it is often a good idea to not just create <em>everything</em> from scratch, but rather to <em>mutate</em> existing inputs. This way, one can achieve a better balance between <em>common</em> inputs (the ones to mutate) and <em>uncommon inputs</em> (the new parts added via mutation).</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Parsing-Inputs">Parsing Inputs</h3><p>To <em>mutate</em> inputs, we first need to be able to <em>parse</em> them. This is where a grammar is really put to test - can it really parse all possible code? This is why relying on an <em>existing</em> parser that is tried and proven (in our case the Python parser) and operating on an <em>abstraction</em> (in our case the AST) is really handy.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We already have seen how to parse code into an AST, using <code>ast.parse()</code>:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>    <span class="c1"># A simple example</span>
    <span class="n">the_sum</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">the_sum</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_source</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsource</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>
<span class="n">sum_tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sum_source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
<span class="n">sum_str</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>"Module(body=[FunctionDef(name='sum', args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='the_sum', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load()))), Return(value=Name(id='the_sum', ctx=Load()))], decorator_list=[])], type_ignores=[])"
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our grammar is able to parse this (non_trivial) string:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">solver</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="n">sum_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To mutate the input, we first have to parse it into a <em>derivation tree</em> structure. This is (again) a tree representation of the code, but this time, using the elements of <em>our</em> grammar.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">sum_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us inspect what a derivation tree looks like. Alas, the string representation is very long and not that useful:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">len</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>8737
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">repr</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)[:</span><span class="mi">200</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>"DerivationTree('&lt;start&gt;', (DerivationTree('&lt;mod&gt;', (DerivationTree('&lt;Module&gt;', (DerivationTree('Module(body=', (), id=495073), DerivationTree('&lt;nonempty_stmt_list&gt;', (DerivationTree('[', (), id=495071"
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>However, we can <em>visualize</em> the derivation tree:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="GrammarFuzzer.html" class="import" target="_blank">GrammarFuzzer</a></span> <span class="kn">import</span> <span class="n">display_tree</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">display_tree</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_image output_svg output_subarea output_execute_result">


<!-- Generated by graphviz version 12.2.1 (20241206.2353)
 -->
<!-- Pages: 1 -->
<svg width="2150pt" height="1228pt" viewbox="0.00 0.00 2150.25 1228.25" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 1224.25)">
<polygon fill="white" stroke="none" points="-4,4 -4,-1224.25 2146.25,-1224.25 2146.25,4 -4,4"/>
<!-- 0 -->
<g id="node1" class="node">
<title>0</title>
<text text-anchor="middle" x="1188.5" y="-1206.95" font-family="Times,serif" font-size="14.00">&lt;start&gt;</text>
</g>
<!-- 1 -->
<g id="node2" class="node">
<title>1</title>
<text text-anchor="middle" x="1188.5" y="-1156.7" font-family="Times,serif" font-size="14.00">&lt;mod&gt;</text>
</g>
<!-- 0&#45;&gt;1 -->
<g id="edge1" class="edge">
<title>0-&gt;1</title>
<path fill="none" stroke="black" d="M1188.5,-1206.21C1188.5,-1199.99 1188.5,-1189.9 1188.5,-1181.14"/>
<polygon fill="black" stroke="black" points="1192,-1181.35 1188.5,-1171.35 1185,-1181.35 1192,-1181.35"/>
</g>
<!-- 2 -->
<g id="node3" class="node">
<title>2</title>
<text text-anchor="middle" x="1188.5" y="-1106.45" font-family="Times,serif" font-size="14.00">&lt;Module&gt;</text>
</g>
<!-- 1&#45;&gt;2 -->
<g id="edge2" class="edge">
<title>1-&gt;2</title>
<path fill="none" stroke="black" d="M1188.5,-1155.96C1188.5,-1149.74 1188.5,-1139.65 1188.5,-1130.89"/>
<polygon fill="black" stroke="black" points="1192,-1131.1 1188.5,-1121.1 1185,-1131.1 1192,-1131.1"/>
</g>
<!-- 3 -->
<g id="node4" class="node">
<title>3</title>
<text text-anchor="middle" x="995.5" y="-1056.2" font-family="Times,serif" font-size="14.00">Module(body=</text>
</g>
<!-- 2&#45;&gt;3 -->
<g id="edge3" class="edge">
<title>2-&gt;3</title>
<path fill="none" stroke="black" d="M1164.06,-1105.51C1130.27,-1097.07 1069.1,-1081.77 1030.47,-1072.12"/>
<polygon fill="black" stroke="black" points="1031.76,-1068.83 1021.21,-1069.8 1030.07,-1075.62 1031.76,-1068.83"/>
</g>
<!-- 4 -->
<g id="node5" class="node">
<title>4</title>
<text text-anchor="middle" x="1117.5" y="-1056.2" font-family="Times,serif" font-size="14.00">&lt;nonempty_stmt_list&gt;</text>
</g>
<!-- 2&#45;&gt;4 -->
<g id="edge4" class="edge">
<title>2-&gt;4</title>
<path fill="none" stroke="black" d="M1179.51,-1105.51C1168.46,-1098 1149.45,-1085.09 1135.38,-1075.53"/>
<polygon fill="black" stroke="black" points="1137.69,-1072.86 1127.45,-1070.14 1133.75,-1078.65 1137.69,-1072.86"/>
</g>
<!-- 200 -->
<g id="node201" class="node">
<title>200</title>
<text text-anchor="middle" x="1259.5" y="-1056.2" font-family="Times,serif" font-size="14.00">&lt;type_ignore_param&gt;</text>
</g>
<!-- 2&#45;&gt;200 -->
<g id="edge200" class="edge">
<title>2-&gt;200</title>
<path fill="none" stroke="black" d="M1197.49,-1105.51C1208.54,-1098 1227.55,-1085.09 1241.62,-1075.53"/>
<polygon fill="black" stroke="black" points="1243.25,-1078.65 1249.55,-1070.14 1239.31,-1072.86 1243.25,-1078.65"/>
</g>
<!-- 206 -->
<g id="node207" class="node">
<title>206</title>
<text text-anchor="middle" x="1354.5" y="-1056.2" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 2&#45;&gt;206 -->
<g id="edge206" class="edge">
<title>2-&gt;206</title>
<path fill="none" stroke="black" d="M1209.52,-1105.51C1239.83,-1096.71 1295.74,-1080.46 1328.56,-1070.91"/>
<polygon fill="black" stroke="black" points="1329.44,-1074.3 1338.07,-1068.15 1327.49,-1067.58 1329.44,-1074.3"/>
</g>
<!-- 5 -->
<g id="node6" class="node">
<title>5</title>
<text text-anchor="middle" x="1061.5" y="-1005.95" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 4&#45;&gt;5 -->
<g id="edge5" class="edge">
<title>4-&gt;5</title>
<path fill="none" stroke="black" d="M1110.63,-1055.46C1102.32,-1048.3 1088.07,-1036.01 1077.05,-1026.52"/>
<polygon fill="black" stroke="black" points="1079.43,-1023.95 1069.57,-1020.08 1074.86,-1029.26 1079.43,-1023.95"/>
</g>
<!-- 6 -->
<g id="node7" class="node">
<title>6</title>
<text text-anchor="middle" x="1117.5" y="-1005.95" font-family="Times,serif" font-size="14.00">&lt;stmts&gt;</text>
</g>
<!-- 4&#45;&gt;6 -->
<g id="edge6" class="edge">
<title>4-&gt;6</title>
<path fill="none" stroke="black" d="M1117.5,-1055.46C1117.5,-1049.24 1117.5,-1039.15 1117.5,-1030.39"/>
<polygon fill="black" stroke="black" points="1121,-1030.6 1117.5,-1020.6 1114,-1030.6 1121,-1030.6"/>
</g>
<!-- 199 -->
<g id="node200" class="node">
<title>199</title>
<text text-anchor="middle" x="1173.5" y="-1005.95" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 4&#45;&gt;199 -->
<g id="edge199" class="edge">
<title>4-&gt;199</title>
<path fill="none" stroke="black" d="M1124.37,-1055.46C1132.68,-1048.3 1146.93,-1036.01 1157.95,-1026.52"/>
<polygon fill="black" stroke="black" points="1160.14,-1029.26 1165.43,-1020.08 1155.57,-1023.95 1160.14,-1029.26"/>
</g>
<!-- 7 -->
<g id="node8" class="node">
<title>7</title>
<text text-anchor="middle" x="1117.5" y="-955.7" font-family="Times,serif" font-size="14.00">&lt;stmt&gt;</text>
</g>
<!-- 6&#45;&gt;7 -->
<g id="edge7" class="edge">
<title>6-&gt;7</title>
<path fill="none" stroke="black" d="M1117.5,-1005.21C1117.5,-998.99 1117.5,-988.9 1117.5,-980.14"/>
<polygon fill="black" stroke="black" points="1121,-980.35 1117.5,-970.35 1114,-980.35 1121,-980.35"/>
</g>
<!-- 8 -->
<g id="node9" class="node">
<title>8</title>
<text text-anchor="middle" x="1117.5" y="-905.45" font-family="Times,serif" font-size="14.00">&lt;FunctionDef&gt;</text>
</g>
<!-- 7&#45;&gt;8 -->
<g id="edge8" class="edge">
<title>7-&gt;8</title>
<path fill="none" stroke="black" d="M1117.5,-954.96C1117.5,-948.74 1117.5,-938.65 1117.5,-929.89"/>
<polygon fill="black" stroke="black" points="1121,-930.1 1117.5,-920.1 1114,-930.1 1121,-930.1"/>
</g>
<!-- 9 -->
<g id="node10" class="node">
<title>9</title>
<text text-anchor="middle" x="61.5" y="-855.2" font-family="Times,serif" font-size="14.00">FunctionDef(name=</text>
</g>
<!-- 8&#45;&gt;9 -->
<g id="edge9" class="edge">
<title>8-&gt;9</title>
<path fill="none" stroke="black" d="M1075.4,-909.64C939.78,-906.28 501.97,-894.12 128.3,-868.64"/>
<polygon fill="black" stroke="black" points="128.71,-865.16 118.5,-867.97 128.23,-872.15 128.71,-865.16"/>
</g>
<!-- 10 -->
<g id="node11" class="node">
<title>10</title>
<text text-anchor="middle" x="167.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 8&#45;&gt;10 -->
<g id="edge10" class="edge">
<title>8-&gt;10</title>
<path fill="none" stroke="black" d="M1075.14,-908.47C918.12,-900.5 370.13,-872.67 211.09,-864.59"/>
<polygon fill="black" stroke="black" points="211.57,-861.11 201.4,-864.1 211.21,-868.1 211.57,-861.11"/>
</g>
<!-- 23 -->
<g id="node24" class="node">
<title>23</title>
<text text-anchor="middle" x="681.5" y="-855.2" font-family="Times,serif" font-size="14.00">, args=</text>
</g>
<!-- 8&#45;&gt;23 -->
<g id="edge23" class="edge">
<title>8-&gt;23</title>
<path fill="none" stroke="black" d="M1075.3,-907.84C1002.98,-902.73 850.53,-890.47 711.67,-868.61"/>
<polygon fill="black" stroke="black" points="712.34,-865.18 701.92,-867.06 711.24,-872.09 712.34,-865.18"/>
</g>
<!-- 24 -->
<g id="node25" class="node">
<title>24</title>
<text text-anchor="middle" x="755.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;arguments&gt;</text>
</g>
<!-- 8&#45;&gt;24 -->
<g id="edge24" class="edge">
<title>8-&gt;24</title>
<path fill="none" stroke="black" d="M1075.27,-905C1007.42,-895.95 874.58,-878.25 803.34,-868.75"/>
<polygon fill="black" stroke="black" points="803.91,-865.3 793.54,-867.44 802.99,-872.24 803.91,-865.3"/>
</g>
<!-- 81 -->
<g id="node82" class="node">
<title>81</title>
<text text-anchor="middle" x="1066.5" y="-855.2" font-family="Times,serif" font-size="14.00">, body=</text>
</g>
<!-- 8&#45;&gt;81 -->
<g id="edge81" class="edge">
<title>8-&gt;81</title>
<path fill="none" stroke="black" d="M1111.25,-904.71C1103.75,-897.62 1090.96,-885.51 1080.96,-876.06"/>
<polygon fill="black" stroke="black" points="1083.57,-873.71 1073.9,-869.38 1078.76,-878.79 1083.57,-873.71"/>
</g>
<!-- 82 -->
<g id="node83" class="node">
<title>82</title>
<text text-anchor="middle" x="1168.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;nonempty_stmt_list&gt;</text>
</g>
<!-- 8&#45;&gt;82 -->
<g id="edge82" class="edge">
<title>8-&gt;82</title>
<path fill="none" stroke="black" d="M1123.75,-904.71C1131.25,-897.62 1144.04,-885.51 1154.04,-876.06"/>
<polygon fill="black" stroke="black" points="1156.24,-878.79 1161.1,-869.38 1151.43,-873.71 1156.24,-878.79"/>
</g>
<!-- 190 -->
<g id="node191" class="node">
<title>190</title>
<text text-anchor="middle" x="1315.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;decorator_list_param&gt;</text>
</g>
<!-- 8&#45;&gt;190 -->
<g id="edge190" class="edge">
<title>8-&gt;190</title>
<path fill="none" stroke="black" d="M1142.58,-904.51C1177.24,-896.07 1240,-880.77 1279.62,-871.12"/>
<polygon fill="black" stroke="black" points="1280.27,-874.56 1289.16,-868.79 1278.61,-867.76 1280.27,-874.56"/>
</g>
<!-- 196 -->
<g id="node197" class="node">
<title>196</title>
<text text-anchor="middle" x="1432.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;returns-1&gt;</text>
</g>
<!-- 8&#45;&gt;196 -->
<g id="edge196" class="edge">
<title>8-&gt;196</title>
<path fill="none" stroke="black" d="M1157.39,-904.51C1216.65,-895.44 1327.51,-878.46 1388.86,-869.06"/>
<polygon fill="black" stroke="black" points="1389.22,-872.54 1398.58,-867.57 1388.16,-865.63 1389.22,-872.54"/>
</g>
<!-- 197 -->
<g id="node198" class="node">
<title>197</title>
<text text-anchor="middle" x="1537.5" y="-855.2" font-family="Times,serif" font-size="14.00">&lt;type_comment-3&gt;</text>
</g>
<!-- 8&#45;&gt;197 -->
<g id="edge197" class="edge">
<title>8-&gt;197</title>
<path fill="none" stroke="black" d="M1159.69,-905.78C1233.35,-897.32 1385.84,-879.8 1472.88,-869.8"/>
<polygon fill="black" stroke="black" points="1473.16,-873.29 1482.69,-868.67 1472.36,-866.34 1473.16,-873.29"/>
</g>
<!-- 198 -->
<g id="node199" class="node">
<title>198</title>
<text text-anchor="middle" x="1625.5" y="-855.2" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 8&#45;&gt;198 -->
<g id="edge198" class="edge">
<title>8-&gt;198</title>
<path fill="none" stroke="black" d="M1159.55,-909.27C1242.05,-906.12 1431.01,-896.46 1599.05,-868.55"/>
<polygon fill="black" stroke="black" points="1599.58,-872.01 1608.85,-866.89 1598.41,-865.11 1599.58,-872.01"/>
</g>
<!-- 11 -->
<g id="node12" class="node">
<title>11</title>
<text text-anchor="middle" x="75.5" y="-804.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 10&#45;&gt;11 -->
<g id="edge11" class="edge">
<title>10-&gt;11</title>
<path fill="none" stroke="black" d="M155.85,-854.26C141.12,-846.54 115.49,-833.1 97.14,-823.47"/>
<polygon fill="black" stroke="black" points="98.88,-820.43 88.4,-818.89 95.63,-826.63 98.88,-820.43"/>
</g>
<!-- 12 -->
<g id="node13" class="node">
<title>12</title>
<text text-anchor="middle" x="121.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 10&#45;&gt;12 -->
<g id="edge12" class="edge">
<title>10-&gt;12</title>
<path fill="none" stroke="black" d="M161.86,-854.46C155.24,-847.51 144.03,-835.75 135.1,-826.39"/>
<polygon fill="black" stroke="black" points="137.66,-824.01 128.23,-819.19 132.6,-828.84 137.66,-824.01"/>
</g>
<!-- 22 -->
<g id="node23" class="node">
<title>22</title>
<text text-anchor="middle" x="167.5" y="-804.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 10&#45;&gt;22 -->
<g id="edge22" class="edge">
<title>10-&gt;22</title>
<path fill="none" stroke="black" d="M167.5,-854.46C167.5,-848.24 167.5,-838.15 167.5,-829.39"/>
<polygon fill="black" stroke="black" points="171,-829.6 167.5,-819.6 164,-829.6 171,-829.6"/>
</g>
<!-- 13 -->
<g id="node14" class="node">
<title>13</title>
<text text-anchor="middle" x="28.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 12&#45;&gt;13 -->
<g id="edge13" class="edge">
<title>12-&gt;13</title>
<path fill="none" stroke="black" d="M109.72,-804.01C94.84,-796.29 68.93,-782.85 50.37,-773.22"/>
<polygon fill="black" stroke="black" points="52.01,-770.13 41.53,-768.63 48.79,-776.35 52.01,-770.13"/>
</g>
<!-- 15 -->
<g id="node16" class="node">
<title>15</title>
<text text-anchor="middle" x="121.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 12&#45;&gt;15 -->
<g id="edge15" class="edge">
<title>12-&gt;15</title>
<path fill="none" stroke="black" d="M121.5,-804.21C121.5,-797.99 121.5,-787.9 121.5,-779.14"/>
<polygon fill="black" stroke="black" points="125,-779.35 121.5,-769.35 118,-779.35 125,-779.35"/>
</g>
<!-- 14 -->
<g id="node15" class="node">
<title>14</title>
<text text-anchor="middle" x="26.5" y="-704.45" font-family="Times,serif" font-size="14.00">s (115)</text>
</g>
<!-- 13&#45;&gt;14 -->
<g id="edge14" class="edge">
<title>13-&gt;14</title>
<path fill="none" stroke="black" d="M28.25,-753.96C28,-747.74 27.58,-737.65 27.22,-728.89"/>
<polygon fill="black" stroke="black" points="30.72,-728.95 26.81,-719.1 23.73,-729.24 30.72,-728.95"/>
</g>
<!-- 16 -->
<g id="node17" class="node">
<title>16</title>
<text text-anchor="middle" x="103.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 15&#45;&gt;16 -->
<g id="edge16" class="edge">
<title>15-&gt;16</title>
<path fill="none" stroke="black" d="M119.29,-753.96C116.92,-747.59 113.03,-737.18 109.71,-728.28"/>
<polygon fill="black" stroke="black" points="113.03,-727.15 106.25,-719.01 106.47,-729.6 113.03,-727.15"/>
</g>
<!-- 18 -->
<g id="node19" class="node">
<title>18</title>
<text text-anchor="middle" x="207.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 15&#45;&gt;18 -->
<g id="edge18" class="edge">
<title>15-&gt;18</title>
<path fill="none" stroke="black" d="M132.39,-753.76C146.09,-746.08 169.89,-732.72 187.03,-723.11"/>
<polygon fill="black" stroke="black" points="188.37,-726.37 195.38,-718.43 184.94,-720.27 188.37,-726.37"/>
</g>
<!-- 17 -->
<g id="node18" class="node">
<title>17</title>
<text text-anchor="middle" x="103.5" y="-654.2" font-family="Times,serif" font-size="14.00">u (117)</text>
</g>
<!-- 16&#45;&gt;17 -->
<g id="edge17" class="edge">
<title>16-&gt;17</title>
<path fill="none" stroke="black" d="M103.5,-703.71C103.5,-697.49 103.5,-687.4 103.5,-678.64"/>
<polygon fill="black" stroke="black" points="107,-678.85 103.5,-668.85 100,-678.85 107,-678.85"/>
</g>
<!-- 19 -->
<g id="node20" class="node">
<title>19</title>
<text text-anchor="middle" x="189.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 18&#45;&gt;19 -->
<g id="edge19" class="edge">
<title>18-&gt;19</title>
<path fill="none" stroke="black" d="M205.29,-703.71C202.92,-697.34 199.03,-686.93 195.71,-678.03"/>
<polygon fill="black" stroke="black" points="199.03,-676.9 192.25,-668.76 192.47,-679.35 199.03,-676.9"/>
</g>
<!-- 21 -->
<g id="node22" class="node">
<title>21</title>
<text text-anchor="middle" x="293.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 18&#45;&gt;21 -->
<g id="edge21" class="edge">
<title>18-&gt;21</title>
<path fill="none" stroke="black" d="M218.39,-703.51C232.09,-695.83 255.89,-682.47 273.03,-672.86"/>
<polygon fill="black" stroke="black" points="274.37,-676.12 281.38,-668.18 270.94,-670.02 274.37,-676.12"/>
</g>
<!-- 20 -->
<g id="node21" class="node">
<title>20</title>
<text text-anchor="middle" x="189.5" y="-603.95" font-family="Times,serif" font-size="14.00">m (109)</text>
</g>
<!-- 19&#45;&gt;20 -->
<g id="edge20" class="edge">
<title>19-&gt;20</title>
<path fill="none" stroke="black" d="M189.5,-653.46C189.5,-647.24 189.5,-637.15 189.5,-628.39"/>
<polygon fill="black" stroke="black" points="193,-628.6 189.5,-618.6 186,-628.6 193,-628.6"/>
</g>
<!-- 25 -->
<g id="node26" class="node">
<title>25</title>
<text text-anchor="middle" x="230.5" y="-804.95" font-family="Times,serif" font-size="14.00">arguments(</text>
</g>
<!-- 24&#45;&gt;25 -->
<g id="edge25" class="edge">
<title>24-&gt;25</title>
<path fill="none" stroke="black" d="M718.86,-855.33C715.7,-854.94 712.54,-854.58 709.5,-854.25 518.03,-833.68 466.24,-841.19 272.28,-818.48"/>
<polygon fill="black" stroke="black" points="272.97,-815.03 262.63,-817.33 272.15,-821.98 272.97,-815.03"/>
</g>
<!-- 26 -->
<g id="node27" class="node">
<title>26</title>
<text text-anchor="middle" x="340.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;posonlyargs_param&gt;</text>
</g>
<!-- 24&#45;&gt;26 -->
<g id="edge26" class="edge">
<title>24-&gt;26</title>
<path fill="none" stroke="black" d="M718.85,-855.43C715.69,-855.02 712.54,-854.63 709.5,-854.25 604.2,-841.23 481.81,-827.54 407.81,-819.43"/>
<polygon fill="black" stroke="black" points="408.63,-816 398.31,-818.39 407.87,-822.95 408.63,-816"/>
</g>
<!-- 33 -->
<g id="node34" class="node">
<title>33</title>
<text text-anchor="middle" x="435.5" y="-804.95" font-family="Times,serif" font-size="14.00">args=</text>
</g>
<!-- 24&#45;&gt;33 -->
<g id="edge33" class="edge">
<title>24-&gt;33</title>
<path fill="none" stroke="black" d="M719.02,-855.41C651.7,-846.22 510.94,-826.84 461.77,-818.32"/>
<polygon fill="black" stroke="black" points="462.64,-814.92 452.17,-816.54 461.36,-821.8 462.64,-814.92"/>
</g>
<!-- 34 -->
<g id="node35" class="node">
<title>34</title>
<text text-anchor="middle" x="497.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;arg_list&gt;</text>
</g>
<!-- 24&#45;&gt;34 -->
<g id="edge34" class="edge">
<title>24-&gt;34</title>
<path fill="none" stroke="black" d="M722.82,-854.26C675.53,-845.42 588.09,-829.07 537.16,-819.54"/>
<polygon fill="black" stroke="black" points="537.92,-816.12 527.44,-817.73 536.63,-823 537.92,-816.12"/>
</g>
<!-- 60 -->
<g id="node61" class="node">
<title>60</title>
<text text-anchor="middle" x="575.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;vararg-1&gt;</text>
</g>
<!-- 24&#45;&gt;60 -->
<g id="edge60" class="edge">
<title>24-&gt;60</title>
<path fill="none" stroke="black" d="M732.7,-854.26C701.46,-845.89 645.12,-830.79 609.05,-821.12"/>
<polygon fill="black" stroke="black" points="610.14,-817.79 599.57,-818.58 608.33,-824.55 610.14,-817.79"/>
</g>
<!-- 61 -->
<g id="node62" class="node">
<title>61</title>
<text text-anchor="middle" x="685.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;kwonlyargs_param&gt;</text>
</g>
<!-- 24&#45;&gt;61 -->
<g id="edge61" class="edge">
<title>24-&gt;61</title>
<path fill="none" stroke="black" d="M746.63,-854.26C735.85,-846.83 717.36,-834.09 703.53,-824.56"/>
<polygon fill="black" stroke="black" points="705.54,-821.69 695.32,-818.89 701.57,-827.45 705.54,-821.69"/>
</g>
<!-- 67 -->
<g id="node68" class="node">
<title>67</title>
<text text-anchor="middle" x="825.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;kw_defaults_param&gt;</text>
</g>
<!-- 24&#45;&gt;67 -->
<g id="edge67" class="edge">
<title>24-&gt;67</title>
<path fill="none" stroke="black" d="M764.37,-854.26C775.15,-846.83 793.64,-834.09 807.47,-824.56"/>
<polygon fill="black" stroke="black" points="809.43,-827.45 815.68,-818.89 805.46,-821.69 809.43,-827.45"/>
</g>
<!-- 73 -->
<g id="node74" class="node">
<title>73</title>
<text text-anchor="middle" x="936.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;kwarg-1&gt;</text>
</g>
<!-- 24&#45;&gt;73 -->
<g id="edge73" class="edge">
<title>24-&gt;73</title>
<path fill="none" stroke="black" d="M778.42,-854.26C809.84,-845.89 866.5,-830.79 902.76,-821.12"/>
<polygon fill="black" stroke="black" points="903.54,-824.53 912.3,-818.58 901.74,-817.77 903.54,-824.53"/>
</g>
<!-- 74 -->
<g id="node75" class="node">
<title>74</title>
<text text-anchor="middle" x="1035.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;defaults_param&gt;</text>
</g>
<!-- 24&#45;&gt;74 -->
<g id="edge74" class="edge">
<title>24-&gt;74</title>
<path fill="none" stroke="black" d="M790.96,-854.26C841.24,-845.6 933.33,-829.73 989.02,-820.13"/>
<polygon fill="black" stroke="black" points="989.57,-823.59 998.83,-818.44 988.39,-816.69 989.57,-823.59"/>
</g>
<!-- 80 -->
<g id="node81" class="node">
<title>80</title>
<text text-anchor="middle" x="1119.5" y="-804.95" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 24&#45;&gt;80 -->
<g id="edge80" class="edge">
<title>24-&gt;80</title>
<path fill="none" stroke="black" d="M791.84,-857.26C852.17,-851.79 977.01,-839.19 1093.03,-818.22"/>
<polygon fill="black" stroke="black" points="1093.53,-821.69 1102.74,-816.44 1092.27,-814.8 1093.53,-821.69"/>
</g>
<!-- 27 -->
<g id="node28" class="node">
<title>27</title>
<text text-anchor="middle" x="258.5" y="-754.7" font-family="Times,serif" font-size="14.00">posonlyargs=</text>
</g>
<!-- 26&#45;&gt;27 -->
<g id="edge27" class="edge">
<title>26-&gt;27</title>
<path fill="none" stroke="black" d="M330.11,-804.01C317.18,-796.4 294.79,-783.23 278.48,-773.63"/>
<polygon fill="black" stroke="black" points="280.5,-770.76 270.11,-768.7 276.95,-776.79 280.5,-770.76"/>
</g>
<!-- 28 -->
<g id="node29" class="node">
<title>28</title>
<text text-anchor="middle" x="341.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;arg_list&gt;</text>
</g>
<!-- 26&#45;&gt;28 -->
<g id="edge28" class="edge">
<title>26-&gt;28</title>
<path fill="none" stroke="black" d="M340.62,-804.21C340.75,-797.99 340.96,-787.9 341.14,-779.14"/>
<polygon fill="black" stroke="black" points="344.64,-779.42 341.35,-769.35 337.64,-779.28 344.64,-779.42"/>
</g>
<!-- 32 -->
<g id="node33" class="node">
<title>32</title>
<text text-anchor="middle" x="391.5" y="-754.7" font-family="Times,serif" font-size="14.00">, </text>
</g>
<!-- 26&#45;&gt;32 -->
<g id="edge32" class="edge">
<title>26-&gt;32</title>
<path fill="none" stroke="black" d="M346.75,-804.21C354.9,-796.5 369.3,-782.88 379.57,-773.16"/>
<polygon fill="black" stroke="black" points="381.84,-775.83 386.7,-766.41 377.03,-770.74 381.84,-775.83"/>
</g>
<!-- 29 -->
<g id="node30" class="node">
<title>29</title>
<text text-anchor="middle" x="286.5" y="-704.45" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 28&#45;&gt;29 -->
<g id="edge29" class="edge">
<title>28-&gt;29</title>
<path fill="none" stroke="black" d="M334.76,-753.96C326.59,-746.8 312.59,-734.51 301.77,-725.02"/>
<polygon fill="black" stroke="black" points="304.26,-722.55 294.44,-718.59 299.65,-727.81 304.26,-722.55"/>
</g>
<!-- 30 -->
<g id="node31" class="node">
<title>30</title>
<text text-anchor="middle" x="345.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;args-1&gt;</text>
</g>
<!-- 28&#45;&gt;30 -->
<g id="edge30" class="edge">
<title>28-&gt;30</title>
<path fill="none" stroke="black" d="M341.99,-753.96C342.51,-747.74 343.34,-737.65 344.07,-728.89"/>
<polygon fill="black" stroke="black" points="347.54,-729.35 344.88,-719.1 340.57,-728.77 347.54,-729.35"/>
</g>
<!-- 31 -->
<g id="node32" class="node">
<title>31</title>
<text text-anchor="middle" x="404.5" y="-704.45" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 28&#45;&gt;31 -->
<g id="edge31" class="edge">
<title>28-&gt;31</title>
<path fill="none" stroke="black" d="M349.48,-753.76C359.09,-746.4 375.5,-733.84 387.9,-724.34"/>
<polygon fill="black" stroke="black" points="389.77,-727.31 395.58,-718.46 385.51,-721.76 389.77,-727.31"/>
</g>
<!-- 35 -->
<g id="node36" class="node">
<title>35</title>
<text text-anchor="middle" x="435.5" y="-754.7" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 34&#45;&gt;35 -->
<g id="edge35" class="edge">
<title>34-&gt;35</title>
<path fill="none" stroke="black" d="M489.65,-804.01C480.19,-796.65 464.04,-784.09 451.83,-774.59"/>
<polygon fill="black" stroke="black" points="454.33,-772.09 444.29,-768.71 450.03,-777.62 454.33,-772.09"/>
</g>
<!-- 36 -->
<g id="node37" class="node">
<title>36</title>
<text text-anchor="middle" x="494.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;args-1&gt;</text>
</g>
<!-- 34&#45;&gt;36 -->
<g id="edge36" class="edge">
<title>34-&gt;36</title>
<path fill="none" stroke="black" d="M497.13,-804.21C496.75,-797.99 496.12,-787.9 495.57,-779.14"/>
<polygon fill="black" stroke="black" points="499.08,-779.11 494.96,-769.35 492.09,-779.55 499.08,-779.11"/>
</g>
<!-- 59 -->
<g id="node60" class="node">
<title>59</title>
<text text-anchor="middle" x="553.5" y="-754.7" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 34&#45;&gt;59 -->
<g id="edge59" class="edge">
<title>34-&gt;59</title>
<path fill="none" stroke="black" d="M504.37,-804.21C512.68,-797.05 526.93,-784.76 537.95,-775.27"/>
<polygon fill="black" stroke="black" points="540.14,-778.01 545.43,-768.83 535.57,-772.7 540.14,-778.01"/>
</g>
<!-- 37 -->
<g id="node38" class="node">
<title>37</title>
<text text-anchor="middle" x="494.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;args&gt;</text>
</g>
<!-- 36&#45;&gt;37 -->
<g id="edge37" class="edge">
<title>36-&gt;37</title>
<path fill="none" stroke="black" d="M494.5,-753.96C494.5,-747.74 494.5,-737.65 494.5,-728.89"/>
<polygon fill="black" stroke="black" points="498,-729.1 494.5,-719.1 491,-729.1 498,-729.1"/>
</g>
<!-- 38 -->
<g id="node39" class="node">
<title>38</title>
<text text-anchor="middle" x="408.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;arg&gt;</text>
</g>
<!-- 37&#45;&gt;38 -->
<g id="edge38" class="edge">
<title>37-&gt;38</title>
<path fill="none" stroke="black" d="M483.61,-703.51C469.91,-695.83 446.11,-682.47 428.97,-672.86"/>
<polygon fill="black" stroke="black" points="431.06,-670.02 420.62,-668.18 427.63,-676.12 431.06,-670.02"/>
</g>
<!-- 48 -->
<g id="node49" class="node">
<title>48</title>
<text text-anchor="middle" x="494.5" y="-654.2" font-family="Times,serif" font-size="14.00">, </text>
</g>
<!-- 37&#45;&gt;48 -->
<g id="edge48" class="edge">
<title>37-&gt;48</title>
<path fill="none" stroke="black" d="M494.5,-703.71C494.5,-697.49 494.5,-687.4 494.5,-678.64"/>
<polygon fill="black" stroke="black" points="498,-678.85 494.5,-668.85 491,-678.85 498,-678.85"/>
</g>
<!-- 49 -->
<g id="node50" class="node">
<title>49</title>
<text text-anchor="middle" x="559.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;arg&gt;</text>
</g>
<!-- 37&#45;&gt;49 -->
<g id="edge49" class="edge">
<title>37-&gt;49</title>
<path fill="none" stroke="black" d="M502.73,-703.51C512.65,-696.15 529.58,-683.59 542.37,-674.09"/>
<polygon fill="black" stroke="black" points="544.38,-676.96 550.32,-668.19 540.21,-671.34 544.38,-676.96"/>
</g>
<!-- 39 -->
<g id="node40" class="node">
<title>39</title>
<text text-anchor="middle" x="301.5" y="-603.95" font-family="Times,serif" font-size="14.00">arg(arg=</text>
</g>
<!-- 38&#45;&gt;39 -->
<g id="edge39" class="edge">
<title>38-&gt;39</title>
<path fill="none" stroke="black" d="M394.95,-653.26C377.42,-645.36 346.61,-631.46 325.17,-621.8"/>
<polygon fill="black" stroke="black" points="326.88,-618.73 316.32,-617.81 324,-625.11 326.88,-618.73"/>
</g>
<!-- 40 -->
<g id="node41" class="node">
<title>40</title>
<text text-anchor="middle" x="375.5" y="-603.95" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 38&#45;&gt;40 -->
<g id="edge40" class="edge">
<title>38-&gt;40</title>
<path fill="none" stroke="black" d="M404.45,-653.46C399.9,-646.8 392.33,-635.73 386.06,-626.57"/>
<polygon fill="black" stroke="black" points="388.97,-624.62 380.43,-618.34 383.19,-628.57 388.97,-624.62"/>
</g>
<!-- 47 -->
<g id="node48" class="node">
<title>47</title>
<text text-anchor="middle" x="441.5" y="-603.95" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 38&#45;&gt;47 -->
<g id="edge47" class="edge">
<title>38-&gt;47</title>
<path fill="none" stroke="black" d="M412.55,-653.46C417.1,-646.8 424.67,-635.73 430.94,-626.57"/>
<polygon fill="black" stroke="black" points="433.81,-628.57 436.57,-618.34 428.03,-624.62 433.81,-628.57"/>
</g>
<!-- 41 -->
<g id="node42" class="node">
<title>41</title>
<text text-anchor="middle" x="329.5" y="-553.7" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 40&#45;&gt;41 -->
<g id="edge41" class="edge">
<title>40-&gt;41</title>
<path fill="none" stroke="black" d="M369.86,-603.21C363.24,-596.26 352.03,-584.5 343.1,-575.14"/>
<polygon fill="black" stroke="black" points="345.66,-572.76 336.23,-567.94 340.6,-577.59 345.66,-572.76"/>
</g>
<!-- 42 -->
<g id="node43" class="node">
<title>42</title>
<text text-anchor="middle" x="375.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 40&#45;&gt;42 -->
<g id="edge42" class="edge">
<title>40-&gt;42</title>
<path fill="none" stroke="black" d="M375.5,-603.21C375.5,-596.99 375.5,-586.9 375.5,-578.14"/>
<polygon fill="black" stroke="black" points="379,-578.35 375.5,-568.35 372,-578.35 379,-578.35"/>
</g>
<!-- 46 -->
<g id="node47" class="node">
<title>46</title>
<text text-anchor="middle" x="421.5" y="-553.7" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 40&#45;&gt;46 -->
<g id="edge46" class="edge">
<title>40-&gt;46</title>
<path fill="none" stroke="black" d="M381.14,-603.21C387.76,-596.26 398.97,-584.5 407.9,-575.14"/>
<polygon fill="black" stroke="black" points="410.4,-577.59 414.77,-567.94 405.34,-572.76 410.4,-577.59"/>
</g>
<!-- 43 -->
<g id="node44" class="node">
<title>43</title>
<text text-anchor="middle" x="329.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 42&#45;&gt;43 -->
<g id="edge43" class="edge">
<title>42-&gt;43</title>
<path fill="none" stroke="black" d="M369.86,-552.96C363.24,-546.01 352.03,-534.25 343.1,-524.89"/>
<polygon fill="black" stroke="black" points="345.66,-522.51 336.23,-517.69 340.6,-527.34 345.66,-522.51"/>
</g>
<!-- 45 -->
<g id="node46" class="node">
<title>45</title>
<text text-anchor="middle" x="421.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 42&#45;&gt;45 -->
<g id="edge45" class="edge">
<title>42-&gt;45</title>
<path fill="none" stroke="black" d="M381.14,-552.96C387.76,-546.01 398.97,-534.25 407.9,-524.89"/>
<polygon fill="black" stroke="black" points="410.4,-527.34 414.77,-517.69 405.34,-522.51 410.4,-527.34"/>
</g>
<!-- 44 -->
<g id="node45" class="node">
<title>44</title>
<text text-anchor="middle" x="329.5" y="-453.2" font-family="Times,serif" font-size="14.00">a (97)</text>
</g>
<!-- 43&#45;&gt;44 -->
<g id="edge44" class="edge">
<title>43-&gt;44</title>
<path fill="none" stroke="black" d="M329.5,-502.71C329.5,-496.49 329.5,-486.4 329.5,-477.64"/>
<polygon fill="black" stroke="black" points="333,-477.85 329.5,-467.85 326,-477.85 333,-477.85"/>
</g>
<!-- 50 -->
<g id="node51" class="node">
<title>50</title>
<text text-anchor="middle" x="498.5" y="-603.95" font-family="Times,serif" font-size="14.00">arg(arg=</text>
</g>
<!-- 49&#45;&gt;50 -->
<g id="edge50" class="edge">
<title>49-&gt;50</title>
<path fill="none" stroke="black" d="M551.77,-653.26C542.56,-645.97 526.89,-633.58 514.93,-624.12"/>
<polygon fill="black" stroke="black" points="517.17,-621.43 507.16,-617.97 512.83,-626.92 517.17,-621.43"/>
</g>
<!-- 51 -->
<g id="node52" class="node">
<title>51</title>
<text text-anchor="middle" x="572.5" y="-603.95" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 49&#45;&gt;51 -->
<g id="edge51" class="edge">
<title>49-&gt;51</title>
<path fill="none" stroke="black" d="M561.09,-653.46C562.79,-647.16 565.55,-636.92 567.93,-628.08"/>
<polygon fill="black" stroke="black" points="571.28,-629.12 570.5,-618.55 564.52,-627.3 571.28,-629.12"/>
</g>
<!-- 58 -->
<g id="node59" class="node">
<title>58</title>
<text text-anchor="middle" x="638.5" y="-603.95" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 49&#45;&gt;58 -->
<g id="edge58" class="edge">
<title>49-&gt;58</title>
<path fill="none" stroke="black" d="M569.51,-653.26C581.85,-645.72 603.13,-632.73 618.8,-623.16"/>
<polygon fill="black" stroke="black" points="620.57,-626.17 627.28,-617.98 616.93,-620.2 620.57,-626.17"/>
</g>
<!-- 52 -->
<g id="node53" class="node">
<title>52</title>
<text text-anchor="middle" x="526.5" y="-553.7" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 51&#45;&gt;52 -->
<g id="edge52" class="edge">
<title>51-&gt;52</title>
<path fill="none" stroke="black" d="M566.86,-603.21C560.24,-596.26 549.03,-584.5 540.1,-575.14"/>
<polygon fill="black" stroke="black" points="542.66,-572.76 533.23,-567.94 537.6,-577.59 542.66,-572.76"/>
</g>
<!-- 53 -->
<g id="node54" class="node">
<title>53</title>
<text text-anchor="middle" x="572.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 51&#45;&gt;53 -->
<g id="edge53" class="edge">
<title>51-&gt;53</title>
<path fill="none" stroke="black" d="M572.5,-603.21C572.5,-596.99 572.5,-586.9 572.5,-578.14"/>
<polygon fill="black" stroke="black" points="576,-578.35 572.5,-568.35 569,-578.35 576,-578.35"/>
</g>
<!-- 57 -->
<g id="node58" class="node">
<title>57</title>
<text text-anchor="middle" x="618.5" y="-553.7" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 51&#45;&gt;57 -->
<g id="edge57" class="edge">
<title>51-&gt;57</title>
<path fill="none" stroke="black" d="M578.14,-603.21C584.76,-596.26 595.97,-584.5 604.9,-575.14"/>
<polygon fill="black" stroke="black" points="607.4,-577.59 611.77,-567.94 602.34,-572.76 607.4,-577.59"/>
</g>
<!-- 54 -->
<g id="node55" class="node">
<title>54</title>
<text text-anchor="middle" x="543.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 53&#45;&gt;54 -->
<g id="edge54" class="edge">
<title>53-&gt;54</title>
<path fill="none" stroke="black" d="M568.94,-552.96C564.99,-546.37 558.43,-535.47 552.96,-526.37"/>
<polygon fill="black" stroke="black" points="556.02,-524.66 547.86,-517.89 550.02,-528.26 556.02,-524.66"/>
</g>
<!-- 56 -->
<g id="node57" class="node">
<title>56</title>
<text text-anchor="middle" x="635.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 53&#45;&gt;56 -->
<g id="edge56" class="edge">
<title>53-&gt;56</title>
<path fill="none" stroke="black" d="M580.48,-552.76C590.09,-545.4 606.5,-532.84 618.9,-523.34"/>
<polygon fill="black" stroke="black" points="620.77,-526.31 626.58,-517.46 616.51,-520.76 620.77,-526.31"/>
</g>
<!-- 55 -->
<g id="node56" class="node">
<title>55</title>
<text text-anchor="middle" x="543.5" y="-453.2" font-family="Times,serif" font-size="14.00">b (98)</text>
</g>
<!-- 54&#45;&gt;55 -->
<g id="edge55" class="edge">
<title>54-&gt;55</title>
<path fill="none" stroke="black" d="M543.5,-502.71C543.5,-496.49 543.5,-486.4 543.5,-477.64"/>
<polygon fill="black" stroke="black" points="547,-477.85 543.5,-467.85 540,-477.85 547,-477.85"/>
</g>
<!-- 62 -->
<g id="node63" class="node">
<title>62</title>
<text text-anchor="middle" x="626.5" y="-754.7" font-family="Times,serif" font-size="14.00">, kwonlyargs=</text>
</g>
<!-- 61&#45;&gt;62 -->
<g id="edge62" class="edge">
<title>61-&gt;62</title>
<path fill="none" stroke="black" d="M678.27,-804.21C669.42,-796.97 654.19,-784.52 642.53,-774.98"/>
<polygon fill="black" stroke="black" points="644.92,-772.42 634.97,-768.8 640.49,-777.84 644.92,-772.42"/>
</g>
<!-- 63 -->
<g id="node64" class="node">
<title>63</title>
<text text-anchor="middle" x="712.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;arg_list&gt;</text>
</g>
<!-- 61&#45;&gt;63 -->
<g id="edge63" class="edge">
<title>61-&gt;63</title>
<path fill="none" stroke="black" d="M688.81,-804.21C692.49,-797.62 698.6,-786.72 703.69,-777.62"/>
<polygon fill="black" stroke="black" points="706.59,-779.6 708.42,-769.16 700.49,-776.18 706.59,-779.6"/>
</g>
<!-- 64 -->
<g id="node65" class="node">
<title>64</title>
<text text-anchor="middle" x="653.5" y="-704.45" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 63&#45;&gt;64 -->
<g id="edge64" class="edge">
<title>63-&gt;64</title>
<path fill="none" stroke="black" d="M705.27,-753.96C696.42,-746.72 681.19,-734.27 669.53,-724.73"/>
<polygon fill="black" stroke="black" points="671.92,-722.17 661.97,-718.55 667.49,-727.59 671.92,-722.17"/>
</g>
<!-- 65 -->
<g id="node66" class="node">
<title>65</title>
<text text-anchor="middle" x="712.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;args-1&gt;</text>
</g>
<!-- 63&#45;&gt;65 -->
<g id="edge65" class="edge">
<title>63-&gt;65</title>
<path fill="none" stroke="black" d="M712.5,-753.96C712.5,-747.74 712.5,-737.65 712.5,-728.89"/>
<polygon fill="black" stroke="black" points="716,-729.1 712.5,-719.1 709,-729.1 716,-729.1"/>
</g>
<!-- 66 -->
<g id="node67" class="node">
<title>66</title>
<text text-anchor="middle" x="771.5" y="-704.45" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 63&#45;&gt;66 -->
<g id="edge66" class="edge">
<title>63-&gt;66</title>
<path fill="none" stroke="black" d="M719.73,-753.96C728.58,-746.72 743.81,-734.27 755.47,-724.73"/>
<polygon fill="black" stroke="black" points="757.51,-727.59 763.03,-718.55 753.08,-722.17 757.51,-727.59"/>
</g>
<!-- 68 -->
<g id="node69" class="node">
<title>68</title>
<text text-anchor="middle" x="799.5" y="-754.7" font-family="Times,serif" font-size="14.00">, kw_defaults=</text>
</g>
<!-- 67&#45;&gt;68 -->
<g id="edge68" class="edge">
<title>67-&gt;68</title>
<path fill="none" stroke="black" d="M822.31,-804.21C818.8,-797.7 813.01,-786.96 808.15,-777.92"/>
<polygon fill="black" stroke="black" points="811.26,-776.32 803.43,-769.17 805.09,-779.64 811.26,-776.32"/>
</g>
<!-- 69 -->
<g id="node70" class="node">
<title>69</title>
<text text-anchor="middle" x="890.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;expr_list&gt;</text>
</g>
<!-- 67&#45;&gt;69 -->
<g id="edge69" class="edge">
<title>67-&gt;69</title>
<path fill="none" stroke="black" d="M833.73,-804.01C843.65,-796.65 860.58,-784.09 873.37,-774.59"/>
<polygon fill="black" stroke="black" points="875.38,-777.46 881.32,-768.69 871.21,-771.84 875.38,-777.46"/>
</g>
<!-- 70 -->
<g id="node71" class="node">
<title>70</title>
<text text-anchor="middle" x="826.5" y="-704.45" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 69&#45;&gt;70 -->
<g id="edge70" class="edge">
<title>69-&gt;70</title>
<path fill="none" stroke="black" d="M882.39,-753.76C872.63,-746.4 855.96,-733.84 843.36,-724.34"/>
<polygon fill="black" stroke="black" points="845.64,-721.67 835.55,-718.45 841.43,-727.26 845.64,-721.67"/>
</g>
<!-- 71 -->
<g id="node72" class="node">
<title>71</title>
<text text-anchor="middle" x="888.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;exprs-1&gt;</text>
</g>
<!-- 69&#45;&gt;71 -->
<g id="edge71" class="edge">
<title>69-&gt;71</title>
<path fill="none" stroke="black" d="M890.25,-753.96C890,-747.74 889.58,-737.65 889.22,-728.89"/>
<polygon fill="black" stroke="black" points="892.72,-728.95 888.81,-719.1 885.73,-729.24 892.72,-728.95"/>
</g>
<!-- 72 -->
<g id="node73" class="node">
<title>72</title>
<text text-anchor="middle" x="950.5" y="-704.45" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 69&#45;&gt;72 -->
<g id="edge72" class="edge">
<title>69-&gt;72</title>
<path fill="none" stroke="black" d="M897.86,-753.96C906.85,-746.72 922.35,-734.27 934.2,-724.73"/>
<polygon fill="black" stroke="black" points="936.3,-727.53 941.9,-718.54 931.92,-722.08 936.3,-727.53"/>
</g>
<!-- 75 -->
<g id="node76" class="node">
<title>75</title>
<text text-anchor="middle" x="982.5" y="-754.7" font-family="Times,serif" font-size="14.00">, defaults=</text>
</g>
<!-- 74&#45;&gt;75 -->
<g id="edge75" class="edge">
<title>74-&gt;75</title>
<path fill="none" stroke="black" d="M1029,-804.21C1021.21,-797.12 1007.91,-785.01 997.53,-775.56"/>
<polygon fill="black" stroke="black" points="999.92,-773 990.17,-768.86 995.21,-778.18 999.92,-773"/>
</g>
<!-- 76 -->
<g id="node77" class="node">
<title>76</title>
<text text-anchor="middle" x="1061.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;expr_list&gt;</text>
</g>
<!-- 74&#45;&gt;76 -->
<g id="edge76" class="edge">
<title>74-&gt;76</title>
<path fill="none" stroke="black" d="M1038.69,-804.21C1042.2,-797.7 1047.99,-786.96 1052.85,-777.92"/>
<polygon fill="black" stroke="black" points="1055.91,-779.64 1057.57,-769.17 1049.74,-776.32 1055.91,-779.64"/>
</g>
<!-- 77 -->
<g id="node78" class="node">
<title>77</title>
<text text-anchor="middle" x="999.5" y="-704.45" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 76&#45;&gt;77 -->
<g id="edge77" class="edge">
<title>76-&gt;77</title>
<path fill="none" stroke="black" d="M1053.65,-753.76C1044.19,-746.4 1028.04,-733.84 1015.83,-724.34"/>
<polygon fill="black" stroke="black" points="1018.33,-721.84 1008.29,-718.46 1014.03,-727.37 1018.33,-721.84"/>
</g>
<!-- 78 -->
<g id="node79" class="node">
<title>78</title>
<text text-anchor="middle" x="1061.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;exprs-1&gt;</text>
</g>
<!-- 76&#45;&gt;78 -->
<g id="edge78" class="edge">
<title>76-&gt;78</title>
<path fill="none" stroke="black" d="M1061.5,-753.96C1061.5,-747.74 1061.5,-737.65 1061.5,-728.89"/>
<polygon fill="black" stroke="black" points="1065,-729.1 1061.5,-719.1 1058,-729.1 1065,-729.1"/>
</g>
<!-- 79 -->
<g id="node80" class="node">
<title>79</title>
<text text-anchor="middle" x="1123.5" y="-704.45" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 76&#45;&gt;79 -->
<g id="edge79" class="edge">
<title>76-&gt;79</title>
<path fill="none" stroke="black" d="M1069.35,-753.76C1078.81,-746.4 1094.96,-733.84 1107.17,-724.34"/>
<polygon fill="black" stroke="black" points="1108.97,-727.37 1114.71,-718.46 1104.67,-721.84 1108.97,-727.37"/>
</g>
<!-- 83 -->
<g id="node84" class="node">
<title>83</title>
<text text-anchor="middle" x="1168.5" y="-804.95" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 82&#45;&gt;83 -->
<g id="edge83" class="edge">
<title>82-&gt;83</title>
<path fill="none" stroke="black" d="M1168.5,-854.46C1168.5,-848.24 1168.5,-838.15 1168.5,-829.39"/>
<polygon fill="black" stroke="black" points="1172,-829.6 1168.5,-819.6 1165,-829.6 1172,-829.6"/>
</g>
<!-- 84 -->
<g id="node85" class="node">
<title>84</title>
<text text-anchor="middle" x="1224.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;stmts&gt;</text>
</g>
<!-- 82&#45;&gt;84 -->
<g id="edge84" class="edge">
<title>82-&gt;84</title>
<path fill="none" stroke="black" d="M1175.37,-854.46C1183.68,-847.3 1197.93,-835.01 1208.95,-825.52"/>
<polygon fill="black" stroke="black" points="1211.14,-828.26 1216.43,-819.08 1206.57,-822.95 1211.14,-828.26"/>
</g>
<!-- 189 -->
<g id="node190" class="node">
<title>189</title>
<text text-anchor="middle" x="1280.5" y="-804.95" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 82&#45;&gt;189 -->
<g id="edge189" class="edge">
<title>82-&gt;189</title>
<path fill="none" stroke="black" d="M1182.68,-854.26C1201.11,-846.32 1233.58,-832.34 1256.03,-822.67"/>
<polygon fill="black" stroke="black" points="1257.24,-825.96 1265.04,-818.79 1254.47,-819.53 1257.24,-825.96"/>
</g>
<!-- 85 -->
<g id="node86" class="node">
<title>85</title>
<text text-anchor="middle" x="1183.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;stmt&gt;</text>
</g>
<!-- 84&#45;&gt;85 -->
<g id="edge85" class="edge">
<title>84-&gt;85</title>
<path fill="none" stroke="black" d="M1219.47,-804.21C1213.63,-797.34 1203.79,-785.75 1195.87,-776.43"/>
<polygon fill="black" stroke="black" points="1198.69,-774.35 1189.55,-768.99 1193.36,-778.88 1198.69,-774.35"/>
</g>
<!-- 154 -->
<g id="node155" class="node">
<title>154</title>
<text text-anchor="middle" x="1225.5" y="-754.7" font-family="Times,serif" font-size="14.00">, </text>
</g>
<!-- 84&#45;&gt;154 -->
<g id="edge154" class="edge">
<title>84-&gt;154</title>
<path fill="none" stroke="black" d="M1224.62,-804.21C1224.75,-797.99 1224.96,-787.9 1225.14,-779.14"/>
<polygon fill="black" stroke="black" points="1228.64,-779.42 1225.35,-769.35 1221.64,-779.28 1228.64,-779.42"/>
</g>
<!-- 155 -->
<g id="node156" class="node">
<title>155</title>
<text text-anchor="middle" x="1302.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;stmts&gt;</text>
</g>
<!-- 84&#45;&gt;155 -->
<g id="edge155" class="edge">
<title>84-&gt;155</title>
<path fill="none" stroke="black" d="M1234.38,-804.01C1246.64,-796.43 1267.81,-783.33 1283.3,-773.75"/>
<polygon fill="black" stroke="black" points="1285,-776.82 1291.66,-768.58 1281.31,-770.87 1285,-776.82"/>
</g>
<!-- 86 -->
<g id="node87" class="node">
<title>86</title>
<text text-anchor="middle" x="1183.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;Assign&gt;</text>
</g>
<!-- 85&#45;&gt;86 -->
<g id="edge86" class="edge">
<title>85-&gt;86</title>
<path fill="none" stroke="black" d="M1183.5,-753.96C1183.5,-747.74 1183.5,-737.65 1183.5,-728.89"/>
<polygon fill="black" stroke="black" points="1187,-729.1 1183.5,-719.1 1180,-729.1 1187,-729.1"/>
</g>
<!-- 87 -->
<g id="node88" class="node">
<title>87</title>
<text text-anchor="middle" x="873.5" y="-654.2" font-family="Times,serif" font-size="14.00">Assign(targets=</text>
</g>
<!-- 86&#45;&gt;87 -->
<g id="edge87" class="edge">
<title>86-&gt;87</title>
<path fill="none" stroke="black" d="M1156.77,-705.03C1153.65,-704.51 1150.5,-703.99 1147.5,-703.5 1070.32,-691 980.76,-677.4 925.61,-669.13"/>
<polygon fill="black" stroke="black" points="926.29,-665.7 915.88,-667.68 925.25,-672.62 926.29,-665.7"/>
</g>
<!-- 88 -->
<g id="node89" class="node">
<title>88</title>
<text text-anchor="middle" x="1008.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;nonempty_lhs_expr_list&gt;</text>
</g>
<!-- 86&#45;&gt;88 -->
<g id="edge88" class="edge">
<title>86-&gt;88</title>
<path fill="none" stroke="black" d="M1161.34,-703.51C1131.09,-695.18 1076.66,-680.17 1041.58,-670.49"/>
<polygon fill="black" stroke="black" points="1042.51,-667.12 1031.94,-667.84 1040.65,-673.87 1042.51,-667.12"/>
</g>
<!-- 121 -->
<g id="node122" class="node">
<title>121</title>
<text text-anchor="middle" x="1122.5" y="-654.2" font-family="Times,serif" font-size="14.00">, value=</text>
</g>
<!-- 86&#45;&gt;121 -->
<g id="edge121" class="edge">
<title>86-&gt;121</title>
<path fill="none" stroke="black" d="M1175.77,-703.51C1166.56,-696.22 1150.89,-683.83 1138.93,-674.37"/>
<polygon fill="black" stroke="black" points="1141.17,-671.68 1131.16,-668.22 1136.83,-677.17 1141.17,-671.68"/>
</g>
<!-- 122 -->
<g id="node123" class="node">
<title>122</title>
<text text-anchor="middle" x="1183.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;expr&gt;</text>
</g>
<!-- 86&#45;&gt;122 -->
<g id="edge122" class="edge">
<title>86-&gt;122</title>
<path fill="none" stroke="black" d="M1183.5,-703.71C1183.5,-697.49 1183.5,-687.4 1183.5,-678.64"/>
<polygon fill="black" stroke="black" points="1187,-678.85 1183.5,-668.85 1180,-678.85 1187,-678.85"/>
</g>
<!-- 152 -->
<g id="node153" class="node">
<title>152</title>
<text text-anchor="middle" x="1276.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;type_comment-1&gt;</text>
</g>
<!-- 86&#45;&gt;152 -->
<g id="edge152" class="edge">
<title>86-&gt;152</title>
<path fill="none" stroke="black" d="M1195.28,-703.51C1210.16,-695.79 1236.07,-682.35 1254.63,-672.72"/>
<polygon fill="black" stroke="black" points="1256.21,-675.85 1263.47,-668.13 1252.99,-669.63 1256.21,-675.85"/>
</g>
<!-- 153 -->
<g id="node154" class="node">
<title>153</title>
<text text-anchor="middle" x="1364.5" y="-654.2" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 86&#45;&gt;153 -->
<g id="edge153" class="edge">
<title>86-&gt;153</title>
<path fill="none" stroke="black" d="M1206.42,-703.51C1240.1,-694.54 1302.77,-677.83 1338.25,-668.37"/>
<polygon fill="black" stroke="black" points="1338.93,-671.81 1347.69,-665.86 1337.13,-665.05 1338.93,-671.81"/>
</g>
<!-- 89 -->
<g id="node90" class="node">
<title>89</title>
<text text-anchor="middle" x="906.5" y="-603.95" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 88&#45;&gt;89 -->
<g id="edge89" class="edge">
<title>88-&gt;89</title>
<path fill="none" stroke="black" d="M995.58,-653.26C979.03,-645.43 950.04,-631.72 929.63,-622.07"/>
<polygon fill="black" stroke="black" points="931.22,-618.95 920.68,-617.83 928.22,-625.27 931.22,-618.95"/>
</g>
<!-- 90 -->
<g id="node91" class="node">
<title>90</title>
<text text-anchor="middle" x="974.5" y="-603.95" font-family="Times,serif" font-size="14.00">&lt;lhs_exprs&gt;</text>
</g>
<!-- 88&#45;&gt;90 -->
<g id="edge90" class="edge">
<title>88-&gt;90</title>
<path fill="none" stroke="black" d="M1004.33,-653.46C999.59,-646.73 991.67,-635.48 985.18,-626.27"/>
<polygon fill="black" stroke="black" points="988.2,-624.49 979.57,-618.33 982.47,-628.52 988.2,-624.49"/>
</g>
<!-- 120 -->
<g id="node121" class="node">
<title>120</title>
<text text-anchor="middle" x="1042.5" y="-603.95" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 88&#45;&gt;120 -->
<g id="edge120" class="edge">
<title>88-&gt;120</title>
<path fill="none" stroke="black" d="M1012.67,-653.46C1017.41,-646.73 1025.33,-635.48 1031.82,-626.27"/>
<polygon fill="black" stroke="black" points="1034.53,-628.52 1037.43,-618.33 1028.8,-624.49 1034.53,-628.52"/>
</g>
<!-- 91 -->
<g id="node92" class="node">
<title>91</title>
<text text-anchor="middle" x="864.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;lhs_expr&gt;</text>
</g>
<!-- 90&#45;&gt;91 -->
<g id="edge91" class="edge">
<title>90-&gt;91</title>
<path fill="none" stroke="black" d="M960.57,-603.01C942.55,-595.11 910.87,-581.21 888.84,-571.55"/>
<polygon fill="black" stroke="black" points="890.27,-568.36 879.7,-567.54 887.46,-574.77 890.27,-568.36"/>
</g>
<!-- 92 -->
<g id="node93" class="node">
<title>92</title>
<text text-anchor="middle" x="859.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;lhs_Name&gt;</text>
</g>
<!-- 91&#45;&gt;92 -->
<g id="edge92" class="edge">
<title>91-&gt;92</title>
<path fill="none" stroke="black" d="M863.89,-552.96C863.24,-546.74 862.2,-536.65 861.29,-527.89"/>
<polygon fill="black" stroke="black" points="864.79,-527.68 860.27,-518.1 857.82,-528.4 864.79,-527.68"/>
</g>
<!-- 93 -->
<g id="node94" class="node">
<title>93</title>
<text text-anchor="middle" x="736.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text>
</g>
<!-- 92&#45;&gt;93 -->
<g id="edge93" class="edge">
<title>92-&gt;93</title>
<path fill="none" stroke="black" d="M843.92,-502.51C823.4,-494.47 787.04,-480.2 762.37,-470.52"/>
<polygon fill="black" stroke="black" points="763.95,-467.38 753.36,-466.99 761.39,-473.9 763.95,-467.38"/>
</g>
<!-- 94 -->
<g id="node95" class="node">
<title>94</title>
<text text-anchor="middle" x="815.5" y="-453.2" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 92&#45;&gt;94 -->
<g id="edge94" class="edge">
<title>92-&gt;94</title>
<path fill="none" stroke="black" d="M854.1,-502.71C847.77,-495.76 837.05,-484 828.51,-474.64"/>
<polygon fill="black" stroke="black" points="831.28,-472.49 821.96,-467.46 826.11,-477.21 831.28,-472.49"/>
</g>
<!-- 119 -->
<g id="node120" class="node">
<title>119</title>
<text text-anchor="middle" x="903.5" y="-453.2" font-family="Times,serif" font-size="14.00">, ctx=Store())</text>
</g>
<!-- 92&#45;&gt;119 -->
<g id="edge119" class="edge">
<title>92-&gt;119</title>
<path fill="none" stroke="black" d="M864.9,-502.71C871.23,-495.76 881.95,-484 890.49,-474.64"/>
<polygon fill="black" stroke="black" points="892.89,-477.21 897.04,-467.46 887.72,-472.49 892.89,-477.21"/>
</g>
<!-- 95 -->
<g id="node96" class="node">
<title>95</title>
<text text-anchor="middle" x="769.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 94&#45;&gt;95 -->
<g id="edge95" class="edge">
<title>94-&gt;95</title>
<path fill="none" stroke="black" d="M809.86,-452.46C803.24,-445.51 792.03,-433.75 783.1,-424.39"/>
<polygon fill="black" stroke="black" points="785.66,-422.01 776.23,-417.19 780.6,-426.84 785.66,-422.01"/>
</g>
<!-- 96 -->
<g id="node97" class="node">
<title>96</title>
<text text-anchor="middle" x="815.5" y="-402.95" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 94&#45;&gt;96 -->
<g id="edge96" class="edge">
<title>94-&gt;96</title>
<path fill="none" stroke="black" d="M815.5,-452.46C815.5,-446.24 815.5,-436.15 815.5,-427.39"/>
<polygon fill="black" stroke="black" points="819,-427.6 815.5,-417.6 812,-427.6 819,-427.6"/>
</g>
<!-- 118 -->
<g id="node119" class="node">
<title>118</title>
<text text-anchor="middle" x="861.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 94&#45;&gt;118 -->
<g id="edge118" class="edge">
<title>94-&gt;118</title>
<path fill="none" stroke="black" d="M821.14,-452.46C827.76,-445.51 838.97,-433.75 847.9,-424.39"/>
<polygon fill="black" stroke="black" points="850.4,-426.84 854.77,-417.19 845.34,-422.01 850.4,-426.84"/>
</g>
<!-- 97 -->
<g id="node98" class="node">
<title>97</title>
<text text-anchor="middle" x="742.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 96&#45;&gt;97 -->
<g id="edge97" class="edge">
<title>96-&gt;97</title>
<path fill="none" stroke="black" d="M806.25,-402.01C794.89,-394.5 775.35,-381.59 760.88,-372.03"/>
<polygon fill="black" stroke="black" points="762.98,-369.21 752.7,-366.62 759.12,-375.05 762.98,-369.21"/>
</g>
<!-- 99 -->
<g id="node100" class="node">
<title>99</title>
<text text-anchor="middle" x="834.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 96&#45;&gt;99 -->
<g id="edge99" class="edge">
<title>96-&gt;99</title>
<path fill="none" stroke="black" d="M817.83,-402.21C820.34,-395.84 824.44,-385.43 827.94,-376.53"/>
<polygon fill="black" stroke="black" points="831.19,-377.84 831.6,-367.25 824.68,-375.27 831.19,-377.84"/>
</g>
<!-- 98 -->
<g id="node99" class="node">
<title>98</title>
<text text-anchor="middle" x="742.5" y="-302.45" font-family="Times,serif" font-size="14.00">t (116)</text>
</g>
<!-- 97&#45;&gt;98 -->
<g id="edge98" class="edge">
<title>97-&gt;98</title>
<path fill="none" stroke="black" d="M742.5,-351.96C742.5,-345.74 742.5,-335.65 742.5,-326.89"/>
<polygon fill="black" stroke="black" points="746,-327.1 742.5,-317.1 739,-327.1 746,-327.1"/>
</g>
<!-- 100 -->
<g id="node101" class="node">
<title>100</title>
<text text-anchor="middle" x="826.5" y="-302.45" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 99&#45;&gt;100 -->
<g id="edge100" class="edge">
<title>99-&gt;100</title>
<path fill="none" stroke="black" d="M833.52,-351.96C832.49,-345.74 830.82,-335.65 829.36,-326.89"/>
<polygon fill="black" stroke="black" points="832.83,-326.38 827.74,-317.08 825.92,-327.52 832.83,-326.38"/>
</g>
<!-- 102 -->
<g id="node103" class="node">
<title>102</title>
<text text-anchor="middle" x="930.5" y="-302.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 99&#45;&gt;102 -->
<g id="edge102" class="edge">
<title>99-&gt;102</title>
<path fill="none" stroke="black" d="M846.66,-351.76C862.09,-344.01 889.02,-330.47 908.19,-320.84"/>
<polygon fill="black" stroke="black" points="909.72,-323.98 917.09,-316.37 906.58,-317.73 909.72,-323.98"/>
</g>
<!-- 101 -->
<g id="node102" class="node">
<title>101</title>
<text text-anchor="middle" x="826.5" y="-252.2" font-family="Times,serif" font-size="14.00">h (104)</text>
</g>
<!-- 100&#45;&gt;101 -->
<g id="edge101" class="edge">
<title>100-&gt;101</title>
<path fill="none" stroke="black" d="M826.5,-301.71C826.5,-295.49 826.5,-285.4 826.5,-276.64"/>
<polygon fill="black" stroke="black" points="830,-276.85 826.5,-266.85 823,-276.85 830,-276.85"/>
</g>
<!-- 103 -->
<g id="node104" class="node">
<title>103</title>
<text text-anchor="middle" x="917.5" y="-252.2" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 102&#45;&gt;103 -->
<g id="edge103" class="edge">
<title>102-&gt;103</title>
<path fill="none" stroke="black" d="M928.91,-301.71C927.21,-295.41 924.45,-285.17 922.07,-276.33"/>
<polygon fill="black" stroke="black" points="925.48,-275.55 919.5,-266.8 918.72,-277.37 925.48,-275.55"/>
</g>
<!-- 105 -->
<g id="node106" class="node">
<title>105</title>
<text text-anchor="middle" x="1021.5" y="-252.2" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 102&#45;&gt;105 -->
<g id="edge105" class="edge">
<title>102-&gt;105</title>
<path fill="none" stroke="black" d="M942.03,-301.51C956.59,-293.79 981.94,-280.35 1000.1,-270.72"/>
<polygon fill="black" stroke="black" points="1001.54,-273.92 1008.73,-266.15 998.26,-267.74 1001.54,-273.92"/>
</g>
<!-- 104 -->
<g id="node105" class="node">
<title>104</title>
<text text-anchor="middle" x="917.5" y="-201.95" font-family="Times,serif" font-size="14.00">e (101)</text>
</g>
<!-- 103&#45;&gt;104 -->
<g id="edge104" class="edge">
<title>103-&gt;104</title>
<path fill="none" stroke="black" d="M917.5,-251.46C917.5,-245.24 917.5,-235.15 917.5,-226.39"/>
<polygon fill="black" stroke="black" points="921,-226.6 917.5,-216.6 914,-226.6 921,-226.6"/>
</g>
<!-- 106 -->
<g id="node107" class="node">
<title>106</title>
<text text-anchor="middle" x="1008.5" y="-201.95" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 105&#45;&gt;106 -->
<g id="edge106" class="edge">
<title>105-&gt;106</title>
<path fill="none" stroke="black" d="M1019.91,-251.46C1018.21,-245.16 1015.45,-234.92 1013.07,-226.08"/>
<polygon fill="black" stroke="black" points="1016.48,-225.3 1010.5,-216.55 1009.72,-227.12 1016.48,-225.3"/>
</g>
<!-- 108 -->
<g id="node109" class="node">
<title>108</title>
<text text-anchor="middle" x="1112.5" y="-201.95" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 105&#45;&gt;108 -->
<g id="edge108" class="edge">
<title>105-&gt;108</title>
<path fill="none" stroke="black" d="M1033.03,-251.26C1047.59,-243.54 1072.94,-230.1 1091.1,-220.47"/>
<polygon fill="black" stroke="black" points="1092.54,-223.67 1099.73,-215.9 1089.26,-217.49 1092.54,-223.67"/>
</g>
<!-- 107 -->
<g id="node108" class="node">
<title>107</title>
<text text-anchor="middle" x="1008.5" y="-151.7" font-family="Times,serif" font-size="14.00">_ (95)</text>
</g>
<!-- 106&#45;&gt;107 -->
<g id="edge107" class="edge">
<title>106-&gt;107</title>
<path fill="none" stroke="black" d="M1008.5,-201.21C1008.5,-194.99 1008.5,-184.9 1008.5,-176.14"/>
<polygon fill="black" stroke="black" points="1012,-176.35 1008.5,-166.35 1005,-176.35 1012,-176.35"/>
</g>
<!-- 109 -->
<g id="node110" class="node">
<title>109</title>
<text text-anchor="middle" x="1098.5" y="-151.7" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 108&#45;&gt;109 -->
<g id="edge109" class="edge">
<title>108-&gt;109</title>
<path fill="none" stroke="black" d="M1110.78,-201.21C1108.96,-194.91 1105.98,-184.67 1103.42,-175.83"/>
<polygon fill="black" stroke="black" points="1106.8,-174.92 1100.65,-166.29 1100.08,-176.87 1106.8,-174.92"/>
</g>
<!-- 111 -->
<g id="node112" class="node">
<title>111</title>
<text text-anchor="middle" x="1202.5" y="-151.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 108&#45;&gt;111 -->
<g id="edge111" class="edge">
<title>108-&gt;111</title>
<path fill="none" stroke="black" d="M1123.9,-201.01C1138.23,-193.33 1163.14,-179.97 1181.08,-170.36"/>
<polygon fill="black" stroke="black" points="1182.7,-173.46 1189.86,-165.65 1179.39,-167.29 1182.7,-173.46"/>
</g>
<!-- 110 -->
<g id="node111" class="node">
<title>110</title>
<text text-anchor="middle" x="1098.5" y="-101.45" font-family="Times,serif" font-size="14.00">s (115)</text>
</g>
<!-- 109&#45;&gt;110 -->
<g id="edge110" class="edge">
<title>109-&gt;110</title>
<path fill="none" stroke="black" d="M1098.5,-150.96C1098.5,-144.74 1098.5,-134.65 1098.5,-125.89"/>
<polygon fill="black" stroke="black" points="1102,-126.1 1098.5,-116.1 1095,-126.1 1102,-126.1"/>
</g>
<!-- 112 -->
<g id="node113" class="node">
<title>112</title>
<text text-anchor="middle" x="1188.5" y="-101.45" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 111&#45;&gt;112 -->
<g id="edge112" class="edge">
<title>111-&gt;112</title>
<path fill="none" stroke="black" d="M1200.78,-150.96C1198.96,-144.66 1195.98,-134.42 1193.42,-125.58"/>
<polygon fill="black" stroke="black" points="1196.8,-124.67 1190.65,-116.04 1190.08,-126.62 1196.8,-124.67"/>
</g>
<!-- 114 -->
<g id="node115" class="node">
<title>114</title>
<text text-anchor="middle" x="1292.5" y="-101.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 111&#45;&gt;114 -->
<g id="edge114" class="edge">
<title>111-&gt;114</title>
<path fill="none" stroke="black" d="M1213.9,-150.76C1228.23,-143.08 1253.14,-129.72 1271.08,-120.11"/>
<polygon fill="black" stroke="black" points="1272.7,-123.21 1279.86,-115.4 1269.39,-117.04 1272.7,-123.21"/>
</g>
<!-- 113 -->
<g id="node114" class="node">
<title>113</title>
<text text-anchor="middle" x="1188.5" y="-51.2" font-family="Times,serif" font-size="14.00">u (117)</text>
</g>
<!-- 112&#45;&gt;113 -->
<g id="edge113" class="edge">
<title>112-&gt;113</title>
<path fill="none" stroke="black" d="M1188.5,-100.71C1188.5,-94.49 1188.5,-84.4 1188.5,-75.64"/>
<polygon fill="black" stroke="black" points="1192,-75.85 1188.5,-65.85 1185,-75.85 1192,-75.85"/>
</g>
<!-- 115 -->
<g id="node116" class="node">
<title>115</title>
<text text-anchor="middle" x="1279.5" y="-51.2" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 114&#45;&gt;115 -->
<g id="edge115" class="edge">
<title>114-&gt;115</title>
<path fill="none" stroke="black" d="M1290.91,-100.71C1289.21,-94.41 1286.45,-84.17 1284.07,-75.33"/>
<polygon fill="black" stroke="black" points="1287.48,-74.55 1281.5,-65.8 1280.72,-76.37 1287.48,-74.55"/>
</g>
<!-- 117 -->
<g id="node118" class="node">
<title>117</title>
<text text-anchor="middle" x="1383.5" y="-51.2" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 114&#45;&gt;117 -->
<g id="edge117" class="edge">
<title>114-&gt;117</title>
<path fill="none" stroke="black" d="M1304.03,-100.51C1318.59,-92.79 1343.94,-79.35 1362.1,-69.72"/>
<polygon fill="black" stroke="black" points="1363.54,-72.92 1370.73,-65.15 1360.26,-66.74 1363.54,-72.92"/>
</g>
<!-- 116 -->
<g id="node117" class="node">
<title>116</title>
<text text-anchor="middle" x="1279.5" y="-0.95" font-family="Times,serif" font-size="14.00">m (109)</text>
</g>
<!-- 115&#45;&gt;116 -->
<g id="edge116" class="edge">
<title>115-&gt;116</title>
<path fill="none" stroke="black" d="M1279.5,-50.46C1279.5,-44.24 1279.5,-34.15 1279.5,-25.39"/>
<polygon fill="black" stroke="black" points="1283,-25.6 1279.5,-15.6 1276,-25.6 1283,-25.6"/>
</g>
<!-- 123 -->
<g id="node124" class="node">
<title>123</title>
<text text-anchor="middle" x="1183.5" y="-603.95" font-family="Times,serif" font-size="14.00">&lt;BinOp&gt;</text>
</g>
<!-- 122&#45;&gt;123 -->
<g id="edge123" class="edge">
<title>122-&gt;123</title>
<path fill="none" stroke="black" d="M1183.5,-653.46C1183.5,-647.24 1183.5,-637.15 1183.5,-628.39"/>
<polygon fill="black" stroke="black" points="1187,-628.6 1183.5,-618.6 1180,-628.6 1187,-628.6"/>
</g>
<!-- 124 -->
<g id="node125" class="node">
<title>124</title>
<text text-anchor="middle" x="995.5" y="-553.7" font-family="Times,serif" font-size="14.00">BinOp(left=</text>
</g>
<!-- 123&#45;&gt;124 -->
<g id="edge124" class="edge">
<title>123-&gt;124</title>
<path fill="none" stroke="black" d="M1159.69,-603.01C1126.92,-594.6 1067.7,-579.4 1030.05,-569.74"/>
<polygon fill="black" stroke="black" points="1031.14,-566.41 1020.58,-567.31 1029.4,-573.19 1031.14,-566.41"/>
</g>
<!-- 125 -->
<g id="node126" class="node">
<title>125</title>
<text text-anchor="middle" x="1067.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;expr&gt;</text>
</g>
<!-- 123&#45;&gt;125 -->
<g id="edge125" class="edge">
<title>123-&gt;125</title>
<path fill="none" stroke="black" d="M1168.81,-603.01C1149.63,-595.04 1115.78,-580.96 1092.53,-571.29"/>
<polygon fill="black" stroke="black" points="1094.05,-568.13 1083.47,-567.52 1091.36,-574.59 1094.05,-568.13"/>
</g>
<!-- 136 -->
<g id="node137" class="node">
<title>136</title>
<text text-anchor="middle" x="1120.5" y="-553.7" font-family="Times,serif" font-size="14.00">, op=</text>
</g>
<!-- 123&#45;&gt;136 -->
<g id="edge136" class="edge">
<title>123-&gt;136</title>
<path fill="none" stroke="black" d="M1175.52,-603.01C1165.91,-595.65 1149.5,-583.09 1137.1,-573.59"/>
<polygon fill="black" stroke="black" points="1139.49,-571.01 1129.42,-567.71 1135.23,-576.56 1139.49,-571.01"/>
</g>
<!-- 137 -->
<g id="node138" class="node">
<title>137</title>
<text text-anchor="middle" x="1183.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;operator&gt;</text>
</g>
<!-- 123&#45;&gt;137 -->
<g id="edge137" class="edge">
<title>123-&gt;137</title>
<path fill="none" stroke="black" d="M1183.5,-603.21C1183.5,-596.99 1183.5,-586.9 1183.5,-578.14"/>
<polygon fill="black" stroke="black" points="1187,-578.35 1183.5,-568.35 1180,-578.35 1187,-578.35"/>
</g>
<!-- 139 -->
<g id="node140" class="node">
<title>139</title>
<text text-anchor="middle" x="1252.5" y="-553.7" font-family="Times,serif" font-size="14.00">, right=</text>
</g>
<!-- 123&#45;&gt;139 -->
<g id="edge139" class="edge">
<title>123-&gt;139</title>
<path fill="none" stroke="black" d="M1192.24,-603.01C1202.87,-595.58 1221.09,-582.84 1234.72,-573.31"/>
<polygon fill="black" stroke="black" points="1236.62,-576.25 1242.81,-567.65 1232.61,-570.52 1236.62,-576.25"/>
</g>
<!-- 140 -->
<g id="node141" class="node">
<title>140</title>
<text text-anchor="middle" x="1311.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;expr&gt;</text>
</g>
<!-- 123&#45;&gt;140 -->
<g id="edge140" class="edge">
<title>123-&gt;140</title>
<path fill="none" stroke="black" d="M1199.71,-603.01C1221.16,-594.93 1259.24,-580.57 1284.93,-570.89"/>
<polygon fill="black" stroke="black" points="1285.88,-574.27 1294,-567.47 1283.41,-567.72 1285.88,-574.27"/>
</g>
<!-- 151 -->
<g id="node152" class="node">
<title>151</title>
<text text-anchor="middle" x="1365.5" y="-553.7" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 123&#45;&gt;151 -->
<g id="edge151" class="edge">
<title>123-&gt;151</title>
<path fill="none" stroke="black" d="M1206.55,-603.01C1240.58,-593.99 1304.07,-577.16 1339.64,-567.73"/>
<polygon fill="black" stroke="black" points="1340.32,-571.17 1349.09,-565.23 1338.53,-564.4 1340.32,-571.17"/>
</g>
<!-- 126 -->
<g id="node127" class="node">
<title>126</title>
<text text-anchor="middle" x="1066.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;Name&gt;</text>
</g>
<!-- 125&#45;&gt;126 -->
<g id="edge126" class="edge">
<title>125-&gt;126</title>
<path fill="none" stroke="black" d="M1067.38,-552.96C1067.25,-546.74 1067.04,-536.65 1066.86,-527.89"/>
<polygon fill="black" stroke="black" points="1070.36,-528.03 1066.65,-518.1 1063.36,-528.17 1070.36,-528.03"/>
</g>
<!-- 127 -->
<g id="node128" class="node">
<title>127</title>
<text text-anchor="middle" x="986.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text>
</g>
<!-- 126&#45;&gt;127 -->
<g id="edge127" class="edge">
<title>126-&gt;127</title>
<path fill="none" stroke="black" d="M1056.37,-502.51C1043.74,-494.9 1021.9,-481.73 1005.99,-472.13"/>
<polygon fill="black" stroke="black" points="1008.22,-469.39 997.85,-467.22 1004.6,-475.38 1008.22,-469.39"/>
</g>
<!-- 128 -->
<g id="node129" class="node">
<title>128</title>
<text text-anchor="middle" x="1065.5" y="-453.2" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 126&#45;&gt;128 -->
<g id="edge128" class="edge">
<title>126-&gt;128</title>
<path fill="none" stroke="black" d="M1066.38,-502.71C1066.25,-496.49 1066.04,-486.4 1065.86,-477.64"/>
<polygon fill="black" stroke="black" points="1069.36,-477.78 1065.65,-467.85 1062.36,-477.92 1069.36,-477.78"/>
</g>
<!-- 135 -->
<g id="node136" class="node">
<title>135</title>
<text text-anchor="middle" x="1152.5" y="-453.2" font-family="Times,serif" font-size="14.00">, ctx=Load())</text>
</g>
<!-- 126&#45;&gt;135 -->
<g id="edge135" class="edge">
<title>126-&gt;135</title>
<path fill="none" stroke="black" d="M1077.39,-502.51C1091.09,-494.83 1114.89,-481.47 1132.03,-471.86"/>
<polygon fill="black" stroke="black" points="1133.37,-475.12 1140.38,-467.18 1129.94,-469.02 1133.37,-475.12"/>
</g>
<!-- 129 -->
<g id="node130" class="node">
<title>129</title>
<text text-anchor="middle" x="1019.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 128&#45;&gt;129 -->
<g id="edge129" class="edge">
<title>128-&gt;129</title>
<path fill="none" stroke="black" d="M1059.86,-452.46C1053.24,-445.51 1042.03,-433.75 1033.1,-424.39"/>
<polygon fill="black" stroke="black" points="1035.66,-422.01 1026.23,-417.19 1030.6,-426.84 1035.66,-422.01"/>
</g>
<!-- 130 -->
<g id="node131" class="node">
<title>130</title>
<text text-anchor="middle" x="1065.5" y="-402.95" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 128&#45;&gt;130 -->
<g id="edge130" class="edge">
<title>128-&gt;130</title>
<path fill="none" stroke="black" d="M1065.5,-452.46C1065.5,-446.24 1065.5,-436.15 1065.5,-427.39"/>
<polygon fill="black" stroke="black" points="1069,-427.6 1065.5,-417.6 1062,-427.6 1069,-427.6"/>
</g>
<!-- 134 -->
<g id="node135" class="node">
<title>134</title>
<text text-anchor="middle" x="1111.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 128&#45;&gt;134 -->
<g id="edge134" class="edge">
<title>128-&gt;134</title>
<path fill="none" stroke="black" d="M1071.14,-452.46C1077.76,-445.51 1088.97,-433.75 1097.9,-424.39"/>
<polygon fill="black" stroke="black" points="1100.4,-426.84 1104.77,-417.19 1095.34,-422.01 1100.4,-426.84"/>
</g>
<!-- 131 -->
<g id="node132" class="node">
<title>131</title>
<text text-anchor="middle" x="1047.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 130&#45;&gt;131 -->
<g id="edge131" class="edge">
<title>130-&gt;131</title>
<path fill="none" stroke="black" d="M1063.29,-402.21C1060.92,-395.84 1057.03,-385.43 1053.71,-376.53"/>
<polygon fill="black" stroke="black" points="1057.03,-375.4 1050.25,-367.26 1050.47,-377.85 1057.03,-375.4"/>
</g>
<!-- 133 -->
<g id="node134" class="node">
<title>133</title>
<text text-anchor="middle" x="1139.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 130&#45;&gt;133 -->
<g id="edge133" class="edge">
<title>130-&gt;133</title>
<path fill="none" stroke="black" d="M1074.87,-402.01C1086.39,-394.5 1106.2,-381.59 1120.86,-372.03"/>
<polygon fill="black" stroke="black" points="1122.7,-375.01 1129.17,-366.61 1118.88,-369.14 1122.7,-375.01"/>
</g>
<!-- 132 -->
<g id="node133" class="node">
<title>132</title>
<text text-anchor="middle" x="1047.5" y="-302.45" font-family="Times,serif" font-size="14.00">a (97)</text>
</g>
<!-- 131&#45;&gt;132 -->
<g id="edge132" class="edge">
<title>131-&gt;132</title>
<path fill="none" stroke="black" d="M1047.5,-351.96C1047.5,-345.74 1047.5,-335.65 1047.5,-326.89"/>
<polygon fill="black" stroke="black" points="1051,-327.1 1047.5,-317.1 1044,-327.1 1051,-327.1"/>
</g>
<!-- 138 -->
<g id="node139" class="node">
<title>138</title>
<text text-anchor="middle" x="1183.5" y="-503.45" font-family="Times,serif" font-size="14.00">Add()</text>
</g>
<!-- 137&#45;&gt;138 -->
<g id="edge138" class="edge">
<title>137-&gt;138</title>
<path fill="none" stroke="black" d="M1183.5,-552.96C1183.5,-546.74 1183.5,-536.65 1183.5,-527.89"/>
<polygon fill="black" stroke="black" points="1187,-528.1 1183.5,-518.1 1180,-528.1 1187,-528.1"/>
</g>
<!-- 141 -->
<g id="node142" class="node">
<title>141</title>
<text text-anchor="middle" x="1312.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;Name&gt;</text>
</g>
<!-- 140&#45;&gt;141 -->
<g id="edge141" class="edge">
<title>140-&gt;141</title>
<path fill="none" stroke="black" d="M1311.62,-552.96C1311.75,-546.74 1311.96,-536.65 1312.14,-527.89"/>
<polygon fill="black" stroke="black" points="1315.64,-528.17 1312.35,-518.1 1308.64,-528.03 1315.64,-528.17"/>
</g>
<!-- 142 -->
<g id="node143" class="node">
<title>142</title>
<text text-anchor="middle" x="1235.5" y="-453.2" font-family="Times,serif" font-size="14.00">Name(id=</text>
</g>
<!-- 141&#45;&gt;142 -->
<g id="edge142" class="edge">
<title>141-&gt;142</title>
<path fill="none" stroke="black" d="M1302.75,-502.51C1290.65,-494.93 1269.75,-481.83 1254.45,-472.25"/>
<polygon fill="black" stroke="black" points="1256.55,-469.43 1246.21,-467.09 1252.83,-475.36 1256.55,-469.43"/>
</g>
<!-- 143 -->
<g id="node144" class="node">
<title>143</title>
<text text-anchor="middle" x="1314.5" y="-453.2" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 141&#45;&gt;143 -->
<g id="edge143" class="edge">
<title>141-&gt;143</title>
<path fill="none" stroke="black" d="M1312.75,-502.71C1313,-496.49 1313.42,-486.4 1313.78,-477.64"/>
<polygon fill="black" stroke="black" points="1317.27,-477.99 1314.19,-467.85 1310.28,-477.7 1317.27,-477.99"/>
</g>
<!-- 150 -->
<g id="node151" class="node">
<title>150</title>
<text text-anchor="middle" x="1401.5" y="-453.2" font-family="Times,serif" font-size="14.00">, ctx=Load())</text>
</g>
<!-- 141&#45;&gt;150 -->
<g id="edge150" class="edge">
<title>141-&gt;150</title>
<path fill="none" stroke="black" d="M1323.77,-502.51C1337.95,-494.83 1362.58,-481.47 1380.32,-471.86"/>
<polygon fill="black" stroke="black" points="1381.87,-475 1388.99,-467.16 1378.53,-468.85 1381.87,-475"/>
</g>
<!-- 144 -->
<g id="node145" class="node">
<title>144</title>
<text text-anchor="middle" x="1268.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 143&#45;&gt;144 -->
<g id="edge144" class="edge">
<title>143-&gt;144</title>
<path fill="none" stroke="black" d="M1308.86,-452.46C1302.24,-445.51 1291.03,-433.75 1282.1,-424.39"/>
<polygon fill="black" stroke="black" points="1284.66,-422.01 1275.23,-417.19 1279.6,-426.84 1284.66,-422.01"/>
</g>
<!-- 145 -->
<g id="node146" class="node">
<title>145</title>
<text text-anchor="middle" x="1314.5" y="-402.95" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 143&#45;&gt;145 -->
<g id="edge145" class="edge">
<title>143-&gt;145</title>
<path fill="none" stroke="black" d="M1314.5,-452.46C1314.5,-446.24 1314.5,-436.15 1314.5,-427.39"/>
<polygon fill="black" stroke="black" points="1318,-427.6 1314.5,-417.6 1311,-427.6 1318,-427.6"/>
</g>
<!-- 149 -->
<g id="node150" class="node">
<title>149</title>
<text text-anchor="middle" x="1360.5" y="-402.95" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 143&#45;&gt;149 -->
<g id="edge149" class="edge">
<title>143-&gt;149</title>
<path fill="none" stroke="black" d="M1320.14,-452.46C1326.76,-445.51 1337.97,-433.75 1346.9,-424.39"/>
<polygon fill="black" stroke="black" points="1349.4,-426.84 1353.77,-417.19 1344.34,-422.01 1349.4,-426.84"/>
</g>
<!-- 146 -->
<g id="node147" class="node">
<title>146</title>
<text text-anchor="middle" x="1282.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 145&#45;&gt;146 -->
<g id="edge146" class="edge">
<title>145-&gt;146</title>
<path fill="none" stroke="black" d="M1310.58,-402.21C1306.16,-395.55 1298.82,-384.48 1292.74,-375.32"/>
<polygon fill="black" stroke="black" points="1295.74,-373.5 1287.29,-367.1 1289.9,-377.37 1295.74,-373.5"/>
</g>
<!-- 148 -->
<g id="node149" class="node">
<title>148</title>
<text text-anchor="middle" x="1374.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 145&#45;&gt;148 -->
<g id="edge148" class="edge">
<title>145-&gt;148</title>
<path fill="none" stroke="black" d="M1321.86,-402.21C1330.85,-394.97 1346.35,-382.52 1358.2,-372.98"/>
<polygon fill="black" stroke="black" points="1360.3,-375.78 1365.9,-366.79 1355.92,-370.33 1360.3,-375.78"/>
</g>
<!-- 147 -->
<g id="node148" class="node">
<title>147</title>
<text text-anchor="middle" x="1282.5" y="-302.45" font-family="Times,serif" font-size="14.00">b (98)</text>
</g>
<!-- 146&#45;&gt;147 -->
<g id="edge147" class="edge">
<title>146-&gt;147</title>
<path fill="none" stroke="black" d="M1282.5,-351.96C1282.5,-345.74 1282.5,-335.65 1282.5,-326.89"/>
<polygon fill="black" stroke="black" points="1286,-327.1 1282.5,-317.1 1279,-327.1 1286,-327.1"/>
</g>
<!-- 156 -->
<g id="node157" class="node">
<title>156</title>
<text text-anchor="middle" x="1379.5" y="-704.45" font-family="Times,serif" font-size="14.00">&lt;stmt&gt;</text>
</g>
<!-- 155&#45;&gt;156 -->
<g id="edge156" class="edge">
<title>155-&gt;156</title>
<path fill="none" stroke="black" d="M1312.25,-753.76C1324.35,-746.18 1345.25,-733.08 1360.55,-723.5"/>
<polygon fill="black" stroke="black" points="1362.17,-726.61 1368.79,-718.34 1358.45,-720.68 1362.17,-726.61"/>
</g>
<!-- 157 -->
<g id="node158" class="node">
<title>157</title>
<text text-anchor="middle" x="1455.5" y="-654.2" font-family="Times,serif" font-size="14.00">&lt;Return&gt;</text>
</g>
<!-- 156&#45;&gt;157 -->
<g id="edge157" class="edge">
<title>156-&gt;157</title>
<path fill="none" stroke="black" d="M1389.13,-703.51C1401.07,-695.93 1421.7,-682.83 1436.8,-673.25"/>
<polygon fill="black" stroke="black" points="1438.35,-676.41 1444.91,-668.1 1434.59,-670.5 1438.35,-676.41"/>
</g>
<!-- 158 -->
<g id="node159" class="node">
<title>158</title>
<text text-anchor="middle" x="1385.5" y="-603.95" font-family="Times,serif" font-size="14.00">Return(value=</text>
</g>
<!-- 157&#45;&gt;158 -->
<g id="edge158" class="edge">
<title>157-&gt;158</title>
<path fill="none" stroke="black" d="M1446.63,-653.26C1435.85,-645.83 1417.36,-633.09 1403.53,-623.56"/>
<polygon fill="black" stroke="black" points="1405.54,-620.69 1395.32,-617.89 1401.57,-626.45 1405.54,-620.69"/>
</g>
<!-- 159 -->
<g id="node160" class="node">
<title>159</title>
<text text-anchor="middle" x="1463.5" y="-603.95" font-family="Times,serif" font-size="14.00">&lt;expr&gt;</text>
</g>
<!-- 157&#45;&gt;159 -->
<g id="edge159" class="edge">
<title>157-&gt;159</title>
<path fill="none" stroke="black" d="M1456.48,-653.46C1457.51,-647.24 1459.18,-637.15 1460.64,-628.39"/>
<polygon fill="black" stroke="black" points="1464.08,-629.02 1462.26,-618.58 1457.17,-627.88 1464.08,-629.02"/>
</g>
<!-- 188 -->
<g id="node189" class="node">
<title>188</title>
<text text-anchor="middle" x="1517.5" y="-603.95" font-family="Times,serif" font-size="14.00">) (41)</text>
</g>
<!-- 157&#45;&gt;188 -->
<g id="edge188" class="edge">
<title>157-&gt;188</title>
<path fill="none" stroke="black" d="M1463.35,-653.26C1472.81,-645.9 1488.96,-633.34 1501.17,-623.84"/>
<polygon fill="black" stroke="black" points="1502.97,-626.87 1508.71,-617.96 1498.67,-621.34 1502.97,-626.87"/>
</g>
<!-- 160 -->
<g id="node161" class="node">
<title>160</title>
<text text-anchor="middle" x="1478.5" y="-553.7" font-family="Times,serif" font-size="14.00">&lt;Name&gt;</text>
</g>
<!-- 159&#45;&gt;160 -->
<g id="edge160" class="edge">
<title>159-&gt;160</title>
<path fill="none" stroke="black" d="M1465.34,-603.21C1467.3,-596.91 1470.48,-586.67 1473.23,-577.83"/>
<polygon fill="black" stroke="black" points="1476.57,-578.87 1476.2,-568.29 1469.89,-576.8 1476.57,-578.87"/>
</g>
<!-- 161 -->
<g id="node162" class="node">
<title>161</title>
<text text-anchor="middle" x="1408.5" y="-503.45" font-family="Times,serif" font-size="14.00">Name(id=</text>
</g>
<!-- 160&#45;&gt;161 -->
<g id="edge161" class="edge">
<title>160-&gt;161</title>
<path fill="none" stroke="black" d="M1469.63,-552.76C1458.85,-545.33 1440.36,-532.59 1426.53,-523.06"/>
<polygon fill="black" stroke="black" points="1428.54,-520.19 1418.32,-517.39 1424.57,-525.95 1428.54,-520.19"/>
</g>
<!-- 162 -->
<g id="node163" class="node">
<title>162</title>
<text text-anchor="middle" x="1487.5" y="-503.45" font-family="Times,serif" font-size="14.00">&lt;identifier&gt;</text>
</g>
<!-- 160&#45;&gt;162 -->
<g id="edge162" class="edge">
<title>160-&gt;162</title>
<path fill="none" stroke="black" d="M1479.6,-552.96C1480.76,-546.74 1482.65,-536.65 1484.28,-527.89"/>
<polygon fill="black" stroke="black" points="1487.72,-528.55 1486.11,-518.08 1480.84,-527.27 1487.72,-528.55"/>
</g>
<!-- 187 -->
<g id="node188" class="node">
<title>187</title>
<text text-anchor="middle" x="1574.5" y="-503.45" font-family="Times,serif" font-size="14.00">, ctx=Load())</text>
</g>
<!-- 160&#45;&gt;187 -->
<g id="edge187" class="edge">
<title>160-&gt;187</title>
<path fill="none" stroke="black" d="M1490.66,-552.76C1506.09,-545.01 1533.02,-531.47 1552.19,-521.84"/>
<polygon fill="black" stroke="black" points="1553.72,-524.98 1561.09,-517.37 1550.58,-518.73 1553.72,-524.98"/>
</g>
<!-- 163 -->
<g id="node164" class="node">
<title>163</title>
<text text-anchor="middle" x="1470.5" y="-453.2" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 162&#45;&gt;163 -->
<g id="edge163" class="edge">
<title>162-&gt;163</title>
<path fill="none" stroke="black" d="M1485.42,-502.71C1483.17,-496.34 1479.5,-485.93 1476.37,-477.03"/>
<polygon fill="black" stroke="black" points="1479.73,-476.04 1473.1,-467.77 1473.13,-478.36 1479.73,-476.04"/>
</g>
<!-- 164 -->
<g id="node165" class="node">
<title>164</title>
<text text-anchor="middle" x="1516.5" y="-453.2" font-family="Times,serif" font-size="14.00">&lt;id&gt;</text>
</g>
<!-- 162&#45;&gt;164 -->
<g id="edge164" class="edge">
<title>162-&gt;164</title>
<path fill="none" stroke="black" d="M1491.06,-502.71C1495.01,-496.12 1501.57,-485.22 1507.04,-476.12"/>
<polygon fill="black" stroke="black" points="1509.98,-478.01 1512.14,-467.64 1503.98,-474.41 1509.98,-478.01"/>
</g>
<!-- 186 -->
<g id="node187" class="node">
<title>186</title>
<text text-anchor="middle" x="1562.5" y="-453.2" font-family="Times,serif" font-size="14.00">' (39)</text>
</g>
<!-- 162&#45;&gt;186 -->
<g id="edge186" class="edge">
<title>162-&gt;186</title>
<path fill="none" stroke="black" d="M1497,-502.51C1508.78,-494.93 1529.14,-481.83 1544.04,-472.25"/>
<polygon fill="black" stroke="black" points="1545.52,-475.46 1552.04,-467.1 1541.74,-469.57 1545.52,-475.46"/>
</g>
<!-- 165 -->
<g id="node166" class="node">
<title>165</title>
<text text-anchor="middle" x="1456.5" y="-402.95" font-family="Times,serif" font-size="14.00">&lt;id_start&gt;</text>
</g>
<!-- 164&#45;&gt;165 -->
<g id="edge165" class="edge">
<title>164-&gt;165</title>
<path fill="none" stroke="black" d="M1509.14,-452.46C1500.15,-445.22 1484.65,-432.77 1472.8,-423.23"/>
<polygon fill="black" stroke="black" points="1475.08,-420.58 1465.1,-417.04 1470.7,-426.03 1475.08,-420.58"/>
</g>
<!-- 167 -->
<g id="node168" class="node">
<title>167</title>
<text text-anchor="middle" x="1548.5" y="-402.95" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 164&#45;&gt;167 -->
<g id="edge167" class="edge">
<title>164-&gt;167</title>
<path fill="none" stroke="black" d="M1520.42,-452.46C1524.84,-445.8 1532.18,-434.73 1538.26,-425.57"/>
<polygon fill="black" stroke="black" points="1541.1,-427.62 1543.71,-417.35 1535.26,-423.75 1541.1,-427.62"/>
</g>
<!-- 166 -->
<g id="node167" class="node">
<title>166</title>
<text text-anchor="middle" x="1456.5" y="-352.7" font-family="Times,serif" font-size="14.00">t (116)</text>
</g>
<!-- 165&#45;&gt;166 -->
<g id="edge166" class="edge">
<title>165-&gt;166</title>
<path fill="none" stroke="black" d="M1456.5,-402.21C1456.5,-395.99 1456.5,-385.9 1456.5,-377.14"/>
<polygon fill="black" stroke="black" points="1460,-377.35 1456.5,-367.35 1453,-377.35 1460,-377.35"/>
</g>
<!-- 168 -->
<g id="node169" class="node">
<title>168</title>
<text text-anchor="middle" x="1540.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 167&#45;&gt;168 -->
<g id="edge168" class="edge">
<title>167-&gt;168</title>
<path fill="none" stroke="black" d="M1547.52,-402.21C1546.49,-395.99 1544.82,-385.9 1543.36,-377.14"/>
<polygon fill="black" stroke="black" points="1546.83,-376.63 1541.74,-367.33 1539.92,-377.77 1546.83,-376.63"/>
</g>
<!-- 170 -->
<g id="node171" class="node">
<title>170</title>
<text text-anchor="middle" x="1644.5" y="-352.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 167&#45;&gt;170 -->
<g id="edge170" class="edge">
<title>167-&gt;170</title>
<path fill="none" stroke="black" d="M1560.66,-402.01C1576.09,-394.26 1603.02,-380.72 1622.19,-371.09"/>
<polygon fill="black" stroke="black" points="1623.72,-374.23 1631.09,-366.62 1620.58,-367.98 1623.72,-374.23"/>
</g>
<!-- 169 -->
<g id="node170" class="node">
<title>169</title>
<text text-anchor="middle" x="1540.5" y="-302.45" font-family="Times,serif" font-size="14.00">h (104)</text>
</g>
<!-- 168&#45;&gt;169 -->
<g id="edge169" class="edge">
<title>168-&gt;169</title>
<path fill="none" stroke="black" d="M1540.5,-351.96C1540.5,-345.74 1540.5,-335.65 1540.5,-326.89"/>
<polygon fill="black" stroke="black" points="1544,-327.1 1540.5,-317.1 1537,-327.1 1544,-327.1"/>
</g>
<!-- 171 -->
<g id="node172" class="node">
<title>171</title>
<text text-anchor="middle" x="1631.5" y="-302.45" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 170&#45;&gt;171 -->
<g id="edge171" class="edge">
<title>170-&gt;171</title>
<path fill="none" stroke="black" d="M1642.91,-351.96C1641.21,-345.66 1638.45,-335.42 1636.07,-326.58"/>
<polygon fill="black" stroke="black" points="1639.48,-325.8 1633.5,-317.05 1632.72,-327.62 1639.48,-325.8"/>
</g>
<!-- 173 -->
<g id="node174" class="node">
<title>173</title>
<text text-anchor="middle" x="1735.5" y="-302.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 170&#45;&gt;173 -->
<g id="edge173" class="edge">
<title>170-&gt;173</title>
<path fill="none" stroke="black" d="M1656.03,-351.76C1670.59,-344.04 1695.94,-330.6 1714.1,-320.97"/>
<polygon fill="black" stroke="black" points="1715.54,-324.17 1722.73,-316.4 1712.26,-317.99 1715.54,-324.17"/>
</g>
<!-- 172 -->
<g id="node173" class="node">
<title>172</title>
<text text-anchor="middle" x="1631.5" y="-252.2" font-family="Times,serif" font-size="14.00">e (101)</text>
</g>
<!-- 171&#45;&gt;172 -->
<g id="edge172" class="edge">
<title>171-&gt;172</title>
<path fill="none" stroke="black" d="M1631.5,-301.71C1631.5,-295.49 1631.5,-285.4 1631.5,-276.64"/>
<polygon fill="black" stroke="black" points="1635,-276.85 1631.5,-266.85 1628,-276.85 1635,-276.85"/>
</g>
<!-- 174 -->
<g id="node175" class="node">
<title>174</title>
<text text-anchor="middle" x="1722.5" y="-252.2" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 173&#45;&gt;174 -->
<g id="edge174" class="edge">
<title>173-&gt;174</title>
<path fill="none" stroke="black" d="M1733.91,-301.71C1732.21,-295.41 1729.45,-285.17 1727.07,-276.33"/>
<polygon fill="black" stroke="black" points="1730.48,-275.55 1724.5,-266.8 1723.72,-277.37 1730.48,-275.55"/>
</g>
<!-- 176 -->
<g id="node177" class="node">
<title>176</title>
<text text-anchor="middle" x="1826.5" y="-252.2" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 173&#45;&gt;176 -->
<g id="edge176" class="edge">
<title>173-&gt;176</title>
<path fill="none" stroke="black" d="M1747.03,-301.51C1761.59,-293.79 1786.94,-280.35 1805.1,-270.72"/>
<polygon fill="black" stroke="black" points="1806.54,-273.92 1813.73,-266.15 1803.26,-267.74 1806.54,-273.92"/>
</g>
<!-- 175 -->
<g id="node176" class="node">
<title>175</title>
<text text-anchor="middle" x="1722.5" y="-201.95" font-family="Times,serif" font-size="14.00">_ (95)</text>
</g>
<!-- 174&#45;&gt;175 -->
<g id="edge175" class="edge">
<title>174-&gt;175</title>
<path fill="none" stroke="black" d="M1722.5,-251.46C1722.5,-245.24 1722.5,-235.15 1722.5,-226.39"/>
<polygon fill="black" stroke="black" points="1726,-226.6 1722.5,-216.6 1719,-226.6 1726,-226.6"/>
</g>
<!-- 177 -->
<g id="node178" class="node">
<title>177</title>
<text text-anchor="middle" x="1811.5" y="-201.95" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 176&#45;&gt;177 -->
<g id="edge177" class="edge">
<title>176-&gt;177</title>
<path fill="none" stroke="black" d="M1824.66,-251.46C1822.7,-245.16 1819.52,-234.92 1816.77,-226.08"/>
<polygon fill="black" stroke="black" points="1820.11,-225.05 1813.8,-216.54 1813.43,-227.12 1820.11,-225.05"/>
</g>
<!-- 179 -->
<g id="node180" class="node">
<title>179</title>
<text text-anchor="middle" x="1915.5" y="-201.95" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 176&#45;&gt;179 -->
<g id="edge179" class="edge">
<title>176-&gt;179</title>
<path fill="none" stroke="black" d="M1837.77,-251.26C1851.95,-243.58 1876.58,-230.22 1894.32,-220.61"/>
<polygon fill="black" stroke="black" points="1895.87,-223.75 1902.99,-215.91 1892.53,-217.6 1895.87,-223.75"/>
</g>
<!-- 178 -->
<g id="node179" class="node">
<title>178</title>
<text text-anchor="middle" x="1811.5" y="-151.7" font-family="Times,serif" font-size="14.00">s (115)</text>
</g>
<!-- 177&#45;&gt;178 -->
<g id="edge178" class="edge">
<title>177-&gt;178</title>
<path fill="none" stroke="black" d="M1811.5,-201.21C1811.5,-194.99 1811.5,-184.9 1811.5,-176.14"/>
<polygon fill="black" stroke="black" points="1815,-176.35 1811.5,-166.35 1808,-176.35 1815,-176.35"/>
</g>
<!-- 180 -->
<g id="node181" class="node">
<title>180</title>
<text text-anchor="middle" x="1901.5" y="-151.7" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 179&#45;&gt;180 -->
<g id="edge180" class="edge">
<title>179-&gt;180</title>
<path fill="none" stroke="black" d="M1913.78,-201.21C1911.96,-194.91 1908.98,-184.67 1906.42,-175.83"/>
<polygon fill="black" stroke="black" points="1909.8,-174.92 1903.65,-166.29 1903.08,-176.87 1909.8,-174.92"/>
</g>
<!-- 182 -->
<g id="node183" class="node">
<title>182</title>
<text text-anchor="middle" x="2005.5" y="-151.7" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 179&#45;&gt;182 -->
<g id="edge182" class="edge">
<title>179-&gt;182</title>
<path fill="none" stroke="black" d="M1926.9,-201.01C1941.23,-193.33 1966.14,-179.97 1984.08,-170.36"/>
<polygon fill="black" stroke="black" points="1985.7,-173.46 1992.86,-165.65 1982.39,-167.29 1985.7,-173.46"/>
</g>
<!-- 181 -->
<g id="node182" class="node">
<title>181</title>
<text text-anchor="middle" x="1901.5" y="-101.45" font-family="Times,serif" font-size="14.00">u (117)</text>
</g>
<!-- 180&#45;&gt;181 -->
<g id="edge181" class="edge">
<title>180-&gt;181</title>
<path fill="none" stroke="black" d="M1901.5,-150.96C1901.5,-144.74 1901.5,-134.65 1901.5,-125.89"/>
<polygon fill="black" stroke="black" points="1905,-126.1 1901.5,-116.1 1898,-126.1 1905,-126.1"/>
</g>
<!-- 183 -->
<g id="node184" class="node">
<title>183</title>
<text text-anchor="middle" x="1992.5" y="-101.45" font-family="Times,serif" font-size="14.00">&lt;id_continue&gt;</text>
</g>
<!-- 182&#45;&gt;183 -->
<g id="edge183" class="edge">
<title>182-&gt;183</title>
<path fill="none" stroke="black" d="M2003.91,-150.96C2002.21,-144.66 1999.45,-134.42 1997.07,-125.58"/>
<polygon fill="black" stroke="black" points="2000.48,-124.8 1994.5,-116.05 1993.72,-126.62 2000.48,-124.8"/>
</g>
<!-- 185 -->
<g id="node186" class="node">
<title>185</title>
<text text-anchor="middle" x="2096.5" y="-101.45" font-family="Times,serif" font-size="14.00">&lt;id_continue-1&gt;</text>
</g>
<!-- 182&#45;&gt;185 -->
<g id="edge185" class="edge">
<title>182-&gt;185</title>
<path fill="none" stroke="black" d="M2017.03,-150.76C2031.59,-143.04 2056.94,-129.6 2075.1,-119.97"/>
<polygon fill="black" stroke="black" points="2076.54,-123.17 2083.73,-115.4 2073.26,-116.99 2076.54,-123.17"/>
</g>
<!-- 184 -->
<g id="node185" class="node">
<title>184</title>
<text text-anchor="middle" x="1992.5" y="-51.2" font-family="Times,serif" font-size="14.00">m (109)</text>
</g>
<!-- 183&#45;&gt;184 -->
<g id="edge184" class="edge">
<title>183-&gt;184</title>
<path fill="none" stroke="black" d="M1992.5,-100.71C1992.5,-94.49 1992.5,-84.4 1992.5,-75.64"/>
<polygon fill="black" stroke="black" points="1996,-75.85 1992.5,-65.85 1989,-75.85 1996,-75.85"/>
</g>
<!-- 191 -->
<g id="node192" class="node">
<title>191</title>
<text text-anchor="middle" x="1358.5" y="-804.95" font-family="Times,serif" font-size="14.00">, decorator_list=</text>
</g>
<!-- 190&#45;&gt;191 -->
<g id="edge191" class="edge">
<title>190-&gt;191</title>
<path fill="none" stroke="black" d="M1320.77,-854.46C1326.9,-847.59 1337.22,-836 1345.53,-826.68"/>
<polygon fill="black" stroke="black" points="1348.14,-829.01 1352.18,-819.22 1342.91,-824.36 1348.14,-829.01"/>
</g>
<!-- 192 -->
<g id="node193" class="node">
<title>192</title>
<text text-anchor="middle" x="1453.5" y="-804.95" font-family="Times,serif" font-size="14.00">&lt;expr_list&gt;</text>
</g>
<!-- 190&#45;&gt;192 -->
<g id="edge192" class="edge">
<title>190-&gt;192</title>
<path fill="none" stroke="black" d="M1332.98,-854.26C1356.31,-846.11 1397.9,-831.57 1425.59,-821.88"/>
<polygon fill="black" stroke="black" points="1426.45,-825.29 1434.74,-818.69 1424.14,-818.68 1426.45,-825.29"/>
</g>
<!-- 193 -->
<g id="node194" class="node">
<title>193</title>
<text text-anchor="middle" x="1391.5" y="-754.7" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 192&#45;&gt;193 -->
<g id="edge193" class="edge">
<title>192-&gt;193</title>
<path fill="none" stroke="black" d="M1445.65,-804.01C1436.19,-796.65 1420.04,-784.09 1407.83,-774.59"/>
<polygon fill="black" stroke="black" points="1410.33,-772.09 1400.29,-768.71 1406.03,-777.62 1410.33,-772.09"/>
</g>
<!-- 194 -->
<g id="node195" class="node">
<title>194</title>
<text text-anchor="middle" x="1453.5" y="-754.7" font-family="Times,serif" font-size="14.00">&lt;exprs-1&gt;</text>
</g>
<!-- 192&#45;&gt;194 -->
<g id="edge194" class="edge">
<title>192-&gt;194</title>
<path fill="none" stroke="black" d="M1453.5,-804.21C1453.5,-797.99 1453.5,-787.9 1453.5,-779.14"/>
<polygon fill="black" stroke="black" points="1457,-779.35 1453.5,-769.35 1450,-779.35 1457,-779.35"/>
</g>
<!-- 195 -->
<g id="node196" class="node">
<title>195</title>
<text text-anchor="middle" x="1515.5" y="-754.7" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 192&#45;&gt;195 -->
<g id="edge195" class="edge">
<title>192-&gt;195</title>
<path fill="none" stroke="black" d="M1461.35,-804.01C1470.81,-796.65 1486.96,-784.09 1499.17,-774.59"/>
<polygon fill="black" stroke="black" points="1500.97,-777.62 1506.71,-768.71 1496.67,-772.09 1500.97,-777.62"/>
</g>
<!-- 201 -->
<g id="node202" class="node">
<title>201</title>
<text text-anchor="middle" x="1254.5" y="-1005.95" font-family="Times,serif" font-size="14.00">, type_ignores=</text>
</g>
<!-- 200&#45;&gt;201 -->
<g id="edge201" class="edge">
<title>200-&gt;201</title>
<path fill="none" stroke="black" d="M1258.89,-1055.46C1258.24,-1049.24 1257.2,-1039.15 1256.29,-1030.39"/>
<polygon fill="black" stroke="black" points="1259.79,-1030.18 1255.27,-1020.6 1252.82,-1030.9 1259.79,-1030.18"/>
</g>
<!-- 202 -->
<g id="node203" class="node">
<title>202</title>
<text text-anchor="middle" x="1367.5" y="-1005.95" font-family="Times,serif" font-size="14.00">&lt;type_ignore_list&gt;</text>
</g>
<!-- 200&#45;&gt;202 -->
<g id="edge202" class="edge">
<title>200-&gt;202</title>
<path fill="none" stroke="black" d="M1273.18,-1055.26C1290.87,-1047.36 1321.97,-1033.46 1343.61,-1023.8"/>
<polygon fill="black" stroke="black" points="1344.85,-1027.08 1352.55,-1019.8 1341.99,-1020.69 1344.85,-1027.08"/>
</g>
<!-- 203 -->
<g id="node204" class="node">
<title>203</title>
<text text-anchor="middle" x="1285.5" y="-955.7" font-family="Times,serif" font-size="14.00">[ (91)</text>
</g>
<!-- 202&#45;&gt;203 -->
<g id="edge203" class="edge">
<title>202-&gt;203</title>
<path fill="none" stroke="black" d="M1357.11,-1005.01C1344.18,-997.4 1321.79,-984.23 1305.48,-974.63"/>
<polygon fill="black" stroke="black" points="1307.5,-971.76 1297.11,-969.7 1303.95,-977.79 1307.5,-971.76"/>
</g>
<!-- 204 -->
<g id="node205" class="node">
<title>204</title>
<text text-anchor="middle" x="1367.5" y="-955.7" font-family="Times,serif" font-size="14.00">&lt;type_ignores-1&gt;</text>
</g>
<!-- 202&#45;&gt;204 -->
<g id="edge204" class="edge">
<title>202-&gt;204</title>
<path fill="none" stroke="black" d="M1367.5,-1005.21C1367.5,-998.99 1367.5,-988.9 1367.5,-980.14"/>
<polygon fill="black" stroke="black" points="1371,-980.35 1367.5,-970.35 1364,-980.35 1371,-980.35"/>
</g>
<!-- 205 -->
<g id="node206" class="node">
<title>205</title>
<text text-anchor="middle" x="1449.5" y="-955.7" font-family="Times,serif" font-size="14.00">] (93)</text>
</g>
<!-- 202&#45;&gt;205 -->
<g id="edge205" class="edge">
<title>202-&gt;205</title>
<path fill="none" stroke="black" d="M1377.89,-1005.01C1390.82,-997.4 1413.21,-984.23 1429.52,-974.63"/>
<polygon fill="black" stroke="black" points="1431.05,-977.79 1437.89,-969.7 1427.5,-971.76 1431.05,-977.79"/>
</g>
</g>
</svg>

</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We see that a derivation tree consists of <em>nonterminal</em> nodes whose children make up an <em>expansion</em> from the grammar.
For instance, at the very top, we see that a <code>&lt;start&gt;</code> nonterminal expands into a <code>&lt;mod&gt;</code> nonterminal, which again expands into a <code>&lt;Module&gt;</code> nonterminal.
This comes right from the grammar rules</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;start&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;mod&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>and</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;mod&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['&lt;Module&gt;']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The child of <code>&lt;mod&gt;</code> is a <code>&lt;Module&gt;</code>, which expands into the nodes</p>
<ul>
<li><code>(body=</code></li>
<li><code>&lt;nonempty_stmt_list&gt;</code></li>
<li><code>, type_ignores=</code></li>
<li><code>&lt;type_ignore_list&gt;</code></li>
<li><code>)</code></li>
</ul>
<p>Here, nodes like <code>(body=</code> or <code>, type_ignores=</code> are called <em>terminal</em> nodes (because they have no more elements to expand).
The nonterminals like <code>&lt;nonempty_stmt_list&gt;</code> get expanded further below – notably, <code>&lt;nonempty_stmt_list&gt;</code> expands into a <code>&lt;FunctionDef&gt;</code> node that represents the <code>sum()</code> definition.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Again, the structure exactly follows the <code>&lt;Module&gt;</code> definition in our grammar:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;Module&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>['Module(body=&lt;nonempty_stmt_list&gt;&lt;type_ignore_param&gt;)']
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we traverse the tree depth-first, left to right, and only collect the terminal symbols, we obtain the original string we parsed.
Applying the <code>str()</code> function to the derivation tree gets us exactly that string:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">str</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>"Module(body=[FunctionDef(name='sum', args=arguments(posonlyargs=[], args=[arg(arg='a'), arg(arg='b')], kwonlyargs=[], kw_defaults=[], defaults=[]), body=[Assign(targets=[Name(id='the_sum', ctx=Store())], value=BinOp(left=Name(id='a', ctx=Load()), op=Add(), right=Name(id='b', ctx=Load()))), Return(value=Name(id='the_sum', ctx=Load()))], decorator_list=[])], type_ignores=[])"
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>And again, we can convert this string into an AST and thus obtain our original function:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_ast</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Mutating-Inputs">Mutating Inputs</h3></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>With derivation trees, we can have a <em>structured</em> representation of our input. In our case, we already have that with ASTs, so why bother introducing a new one? The answer is simple: Derivation trees also allow us to <em>synthesize</em> new inputs, because we have a <em>grammar</em> that describes their structure.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Most notably, we can mutate inputs as follows:</p>
<ol>
<li>Parse the input into a derivation tree, as shown above.</li>
<li>Randomly choose some node <code>&lt;symbol&gt;</code> in the derivation tree to be mutated.</li>
<li>Use the grammar to produce a new expansion for <code>&lt;symbol&gt;</code>.</li>
<li>Replace the children of <code>&lt;symbol&gt;</code> by the expansion just generated.</li>
<li>Repeat the process as often as needed.</li>
</ol>
<p>This is a decent programming task, and if you'd like a blueprint, have a look at the <code>FragmentMutator</code> in this tutorial on <a href="https://www.fuzzingbook.org/html/GreyboxGrammarFuzzer.html">greybox fuzzing with grammars</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Fortunately, ISLa already provides us with functionality that does exactly this.
The <code>ISLaSolver.mutate()</code> method takes an input and mutates it according to the rules in the grammar.
The input to mutate can be given as a derivation tree, or as a string; its output is a derivation tree (which can again be converted into a string).</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us apply <code>mutate()</code> on our <code>sum()</code> function. The <code>min_mutations</code> and <code>max_mutations</code> parameters define how many mutation steps should be performed; we set both to 1 in order to have exactly one mutation.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_mutated_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">sum_str</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_mutated_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_mutated_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_mutated_ast</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def sum(a, b):
    the_sum = a + b
    return the_sum
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Toy with the above to see the effect of a mutation.
Note if one of the top-level nodes (like <code>&lt;FunctionDef&gt;</code> or <code>&lt;Module&gt;</code>) is selected for mutation, then <code>sum()</code> will be replaced by something entirely different. Otherwise, though, the code will still be pretty similar to the original <code>sum()</code> code.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Of course, the more we increase the number of mutations, the more different the code will look like:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_mutated_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">sum_str</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_mutated_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sum_mutated_tree</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">sum_mutated_ast</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def sum(a, b):
    the_9GuWCvL4cpgyi37K5I_ = a + b
    return the_jXHPe1oqMG
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>By toying with the <code>mutate()</code> parameters, we can control how <em>common</em> and how <em>uncommon</em> our input should be.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="How-Effective-is-Mutation?">How Effective is Mutation?</h3></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Does mutating existing code help us in finding bugs?
Let us assume we have a buggy compiler that generates bad code for an expression of the form <code>&lt;elem&gt; * (&lt;elem&gt; + &lt;elem&gt;)</code>.
The code in <code>has_distributive_law()</code> checks an AST for the presence of this bug:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">has_distributive_law</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>  <span class="c1"># iterate over all nodes in `tree`</span>
        <span class="c1"># print(node)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Mult</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">BinOp</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">ast</span><span class="o">.</span><span class="n">Add</span><span class="p">):</span>
                        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>To understand how this works, a visualization of the AST comes in handy:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">show_ast</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 + (2 * 3)"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_image output_svg output_subarea ">
<svg xmlns:xlink="http://www.w3.org/1999/xlink" width="342pt" height="332pt" viewbox="0.00 0.00 342.00 332.00">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 328)">
<polygon fill="white" stroke="none" points="-4,4 -4,-328 338,-328 338,4 -4,4"/>
<!-- 0 -->
<g id="node1" class="node">
<title>0</title>
<text text-anchor="start" x="113.5" y="-301.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Expr</text>
</g>
<!-- 1 -->
<g id="node2" class="node">
<title>1</title>
<text text-anchor="start" x="109.38" y="-229.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">BinOp</text>
</g>
<!-- 0&#45;&#45;1 -->
<g id="edge1" class="edge">
<title>0--1</title>
<path fill="none" stroke="black" d="M130,-288.05C130,-277.05 130,-262.76 130,-251.79"/>
</g>
<!-- 2 -->
<g id="node3" class="node">
<title>2</title>
<text text-anchor="start" x="8" y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text>
</g>
<!-- 1&#45;&#45;2 -->
<g id="edge2" class="edge">
<title>1--2</title>
<path fill="none" stroke="black" d="M130,-215C130,-215 95.67,-194.94 69.65,-179.74"/>
</g>
<!-- 4 -->
<g id="node5" class="node">
<title>4</title>
<text text-anchor="middle" x="130" y="-156.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Add</text>
</g>
<!-- 1&#45;&#45;4 -->
<g id="edge4" class="edge">
<title>1--4</title>
<path fill="none" stroke="black" d="M130,-215C130,-215 130,-194.94 130,-179.74"/>
</g>
<!-- 5 -->
<g id="node6" class="node">
<title>5</title>
<text text-anchor="start" x="184.38" y="-157.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">BinOp</text>
</g>
<!-- 1&#45;&#45;5 -->
<g id="edge5" class="edge">
<title>1--5</title>
<path fill="none" stroke="black" d="M130,-215C130,-215 158.93,-194.94 180.86,-179.74"/>
</g>
<!-- 3 -->
<g id="node4" class="node">
<title>3</title>
<text text-anchor="middle" x="35" y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">1</text>
</g>
<!-- 2&#45;&#45;3 -->
<g id="edge3" class="edge">
<title>2--3</title>
<path fill="none" stroke="black" d="M39.55,-144.05C38.6,-133.05 37.38,-118.76 36.44,-107.79"/>
</g>
<!-- 6 -->
<g id="node7" class="node">
<title>6</title>
<text text-anchor="start" x="88" y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text>
</g>
<!-- 5&#45;&#45;6 -->
<g id="edge6" class="edge">
<title>5--6</title>
<path fill="none" stroke="black" d="M205,-143C205,-143 172.6,-122.94 148.04,-107.74"/>
</g>
<!-- 8 -->
<g id="node9" class="node">
<title>8</title>
<text text-anchor="middle" x="207" y="-84.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">Mult</text>
</g>
<!-- 5&#45;&#45;8 -->
<g id="edge8" class="edge">
<title>5--8</title>
<path fill="none" stroke="black" d="M205,-143C205,-143 205.77,-122.94 206.36,-107.74"/>
</g>
<!-- 9 -->
<g id="node10" class="node">
<title>9</title>
<text text-anchor="start" x="260" y="-85.95" font-family="Courier,monospace" font-weight="bold" font-size="14.00" fill="#004080">Constant</text>
</g>
<!-- 5&#45;&#45;9 -->
<g id="edge9" class="edge">
<title>5--9</title>
<path fill="none" stroke="black" d="M205,-143C205,-143 238.95,-122.94 264.67,-107.74"/>
</g>
<!-- 7 -->
<g id="node8" class="node">
<title>7</title>
<text text-anchor="middle" x="121" y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">2</text>
</g>
<!-- 6&#45;&#45;7 -->
<g id="edge7" class="edge">
<title>6--7</title>
<path fill="none" stroke="black" d="M121,-72.05C121,-61.05 121,-46.76 121,-35.79"/>
</g>
<!-- 10 -->
<g id="node11" class="node">
<title>10</title>
<text text-anchor="middle" x="293" y="-12.95" font-family="Courier,monospace" font-size="14.00" fill="#008040">3</text>
</g>
<!-- 9&#45;&#45;10 -->
<g id="edge10" class="edge">
<title>9--10</title>
<path fill="none" stroke="black" d="M293,-72.05C293,-61.05 293,-46.76 293,-35.79"/>
</g>
</g>
</svg>

</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 * (2 + 3)"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>True
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"(1 + 2) * 3"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>True
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 + (2 * 3)"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>False
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">has_distributive_law</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"def f(a, b):</span><span class="se">\n</span><span class="s2">    return a * (b + 10)"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>True
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>How many attempts does it take for each until we find a mutation that triggers the bug in <code>has_distributive_law()</code>? 
Let us write a function that computes this number.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">how_many_mutations</span><span class="p">(</span><span class="n">code</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>

    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">code_ast_str</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">code_derivation_tree</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">code_ast_str</span><span class="p">)</span>
    <span class="n">mutations</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">mutated_code_ast</span> <span class="o">=</span> <span class="n">code_ast</span>

    <span class="k">while</span> <span class="ow">not</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">mutated_code_ast</span><span class="p">):</span>
        <span class="n">mutations</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">mutations</span> <span class="o">%</span> <span class="mi">100</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">'</span><span class="si">{</span><span class="n">mutations</span><span class="si">}</span><span class="s1">...'</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>

        <span class="n">mutated_code_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">code_derivation_tree</span><span class="p">))</span>
        <span class="n">mutated_code_ast</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">mutated_code_str</span><span class="p">)</span>
        <span class="c1"># mutated_code_ast = ast.fix_missing_locations(mutated_code_ast)</span>
        <span class="c1"># print(ast.dump(mutated_code_ast))</span>
        <span class="c1"># print(ast.unparse(mutated_code_ast))</span>

    <span class="k">return</span> <span class="n">mutations</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>If we pass an input that already exhibits the bug, we do not need any mutation:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">'1 * (2 + 3)'</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>However, the further we are away from the bug, the more mutations (and the more time) it takes to find it.
Notably, mutating <code>2 + 2</code> until we have a distributive law still is much faster than mutating <code>2</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">'2 + 2'</span><span class="p">)</span>    <span class="c1"># &lt;-- Note: this can take a minute</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>54
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">how_many_mutations</span><span class="p">(</span><span class="s1">'2'</span><span class="p">)</span>  <span class="c1"># &lt;-- Note: this can take several minutes</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>100...200...300...400...500...600...700...800...900...1000...1100...1200...1300...1400...1500...1600...1700...1800...1900...2000...2100...2200...2300...2400...2500...
</pre>
</div>

</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>2500
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We conclude that mutating existing code can indeed be helpful, especially if it is syntactically <em>close to inputs that trigger bugs</em>.
If you want to have a good chance in finding bugs, focus on <em>inputs that have triggered bugs before</em> – sometimes a simple mutation of these already helps finding a new bug.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Evolutionary-Fuzzing">Evolutionary Fuzzing</h2><p>One interesting application of mutating inputs is to use mutations for <em>evolutionary fuzzing</em>.
The idea is to have a population of inputs, to apply <em>mutations</em> on them, and to check whether they improve on a particular goal (mostly code coverage).
Those inputs that <em>do</em> improve are being retained ("survival of the fittest") as the next generation, and evolved further.
By repeating this process often enough, we may obtain inputs that cover large parts of code and thus improve chances to uncover bugs.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Let us assume we have a buggy compiler that generates bad code for an expression of the form <code>&lt;elem&gt; * (&lt;elem&gt; + &lt;elem&gt;)</code>.
The function <code>has_distributive_law()</code>, above, checks an AST for the presence of this bug.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our aim is to detect this bug via fuzzing. But if we simply generate random inputs from scratch, it may take a long time until we generate the exact copmbination of operators that triggers the bug.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Getting-Coverage">Getting Coverage</h3><p>To have our fuzzers guided by coverage, we first need to <em>measure</em> code coverage.
We make use of the <a href="https://www.fuzzingbook.org/html/Coverage.html">Coverage module from the Fuzzing Book</a>, which is particularly easy to use.
It simply uses a <code>with</code> clause to obtain coverage from the code in the <code>with</code> body.
Here is how to obtain coverage for our <code>has_distributive_law()</code> code, above:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="kn">from</span> <span class="nn"><a href="Coverage.html" class="import" target="_blank">Coverage</a></span> <span class="kn">import</span> <span class="n">Coverage</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">mult_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 * 2"</span><span class="p">)</span>
<span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
    <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">mult_ast</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The <code>coverage()</code> method tells us which lines in the code actually have been reached.
This includes lines from <code>has_distributive_law()</code>, but also lines from other functions called.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>{('_handle_fromlist', 1217),
 ('_handle_fromlist', 1218),
 ('_handle_fromlist', 1225),
 ('_handle_fromlist', 1229),
 ('_handle_fromlist', 1241),
 ('has_distributive_law', 2),
 ('has_distributive_law', 4),
 ('has_distributive_law', 5),
 ('has_distributive_law', 6),
 ('has_distributive_law', 10),
 ('has_distributive_law', 14),
 ('iter_child_nodes', 272),
 ('iter_child_nodes', 273),
 ('iter_child_nodes', 274),
 ('iter_child_nodes', 275),
 ('iter_child_nodes', 276),
 ('iter_child_nodes', 277),
 ('iter_child_nodes', 278),
 ('iter_fields', 260),
 ('iter_fields', 261),
 ('iter_fields', 262),
 ('walk', 386),
 ('walk', 387),
 ('walk', 388),
 ('walk', 389),
 ('walk', 390),
 ('walk', 391)}
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Which are the lines executed? 
With a bit of code inspection, we can easily visualize the covered lines:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">show_coverage</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">fun</span><span class="p">):</span>
    <span class="n">fun_lines</span><span class="p">,</span> <span class="n">fun_start</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getsourcelines</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span>
    <span class="n">fun_name</span> <span class="o">=</span> <span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">coverage</span> <span class="o">=</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">fun_lines</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fun_name</span><span class="p">,</span> <span class="n">line</span> <span class="o">+</span> <span class="n">fun_start</span><span class="p">)</span> <span class="ow">in</span> <span class="n">coverage</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'# '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>  <span class="c1"># covered lines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'  '</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>  <span class="c1"># uncovered lines</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">fun_start</span><span class="p">,</span> <span class="n">fun_lines</span><span class="p">[</span><span class="n">line</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s1">''</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">show_coverage</span><span class="p">(</span><span class="n">cov</span><span class="p">,</span> <span class="n">has_distributive_law</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>  1 def has_distributive_law(tree) -&gt; bool:
# 2     for node in walk(tree):  # iterate over all nodes in `tree`
  3         # print(node)
# 4         if isinstance(node, ast.BinOp):
# 5             if isinstance(node.op, ast.Mult):
# 6                 if isinstance(node.right, ast.BinOp):
  7                     if isinstance(node.right.op, ast.Add):
  8                         return True
  9 
# 10                 if isinstance(node.left, ast.BinOp):
  11                     if isinstance(node.left.op, ast.Add):
  12                         return True
  13 
# 14     return False
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>In this listing, a <code>#</code> indicates that the code has been executed (covered).
We see that our input "1 * 2" satisfies the conditions in Lines 4 and 5, but does not satisfy the conditions in later lines.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Fitness">Fitness</h3><p>Let us now use coverage as a <em>fitness function</em> to guide evolution.
The higher the fitness (the coverage), the higher the chances of an input to be retained for further evolution.
Our <code>ast_fitness()</code> function simply counts the number of lines covered in <code>has_distributive_law()</code>.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">ast_fitness</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">with</span> <span class="n">Coverage</span><span class="p">()</span> <span class="k">as</span> <span class="n">cov</span><span class="p">:</span>
        <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="ow">in</span> <span class="n">cov</span><span class="o">.</span><span class="n">coverage</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">has_distributive_law</span><span class="o">.</span><span class="vm">__name__</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Here is the fitness of a number of given inputs:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>3
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 + 1"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>4
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 * 2"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>6
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">ast_fitness</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="s2">"1 * (2 + 3)"</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>6
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Now, let's set up a fitness function that takes derivation trees.
Essentially, our <code>tree_fitness()</code> function is based on the <code>ast_fitness()</code> function, above;
however, we also add a small component <code>1 / len(code_str)</code> to give extra fitness to shorter inputs.
Otherwise, our inputs may grow and keep on growing, making mutations inefficient.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">tree_fitness</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="n">code_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">code_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">code_str</span><span class="p">))</span>
    <span class="n">fitness</span> <span class="o">=</span> <span class="n">ast_fitness</span><span class="p">(</span><span class="n">code_ast</span><span class="p">)</span>
    <span class="c1"># print(ast.unparse(code_ast), f"\n=&gt; Fitness = {fitness}\n")</span>
    <span class="k">return</span> <span class="n">fitness</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">code_str</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">tree_fitness</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>4.002666666666666
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Evolving-Inputs">Evolving Inputs</h3><p>Let us now make use of our fitness function to implement a simple evolutionary fuzzing algorithm.
We start with <em>evolution</em> – that is, taking a population and adding offspring via mutations.
Our initial population consists of a single candidate – in our case, <code>sum_tree</code> reflecting the <code>sum()</code> function, above.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">initial_population</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span> <span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tree_fitness</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span> <span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">initial_population</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>1
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Our <code>evolve()</code> function adds two new children to each population member.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">OFFSPRING</span> <span class="o">=</span> <span class="mi">2</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">evolve</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">min_fitness</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">ISLaSolver</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">)</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">OFFSPRING</span><span class="p">):</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">mutate</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">min_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_mutations</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">child_fitness</span> <span class="o">=</span> <span class="n">tree_fitness</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child_fitness</span> <span class="o">&gt;</span> <span class="n">min_fitness</span><span class="p">:</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">child_fitness</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">population</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>3
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As we can evolve all these, too, we get an exponential growth.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>9
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>27
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>81
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>243
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Survival-of-the-Fittest">Survival of the Fittest</h3><p>No population can expand forever and still survive.
Let us thus limit the population to a certain size.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">POPULATION_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>The <code>select()</code> function implements survival of the fittest: It limits the population to at most <code>POPULATION_SIZE</code> elements, sorting them by their fitness (highest to lowest).
Members with low fitness beyond <code>POPULATION_SIZE</code> do not survive.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">def</span> <span class="nf">get_fitness</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
    <span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">fitness</span><span class="p">)</span> <span class="o">=</span> <span class="n">elem</span>
    <span class="k">return</span> <span class="n">fitness</span>

<span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="n">population</span><span class="p">):</span>
    <span class="n">population</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">get_fitness</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">population</span> <span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="n">POPULATION_SIZE</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">population</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>We can use the following call to trim our <code>sum_population</code> to the fittest members:</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">sum_population</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
<span class="nb">len</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>100
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Evolution">Evolution</h3><p>We now have everything in place:</p>
<ul>
<li>We have a <em>population</em> (say, <code>sum_population</code>)</li>
<li>We can evolve the population (using <code>evolve()</code>)</li>
<li>We can have only the fittest survive (using <code>select()</code>)</li>
</ul>
<p>Let us repeat this process over several generations.
We track whenever we have found a new "best" candidate and log them.
If we find a candidate that triggers the bug, we stop.
Note that this may take a long time, and not necessarily yield a perfect result.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>As common in search-based approaches, we stop and restart the search if we have not found a sufficient solution after a number of generations (here: <code>GENERATIONS</code>).
Other than that, we keep searching until we have a solution.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">GENERATIONS</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Upper bound</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="n">trial</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
    <span class="n">sum_population</span> <span class="o">=</span> <span class="n">initial_population</span><span class="p">(</span><span class="n">sum_tree</span><span class="p">)</span>
    <span class="n">prev_best_fitness</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">generation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">GENERATIONS</span><span class="p">):</span>
        <span class="n">sum_population</span> <span class="o">=</span> <span class="n">evolve</span><span class="p">(</span><span class="n">sum_population</span><span class="p">,</span> <span class="n">min_fitness</span><span class="o">=</span><span class="n">prev_best_fitness</span><span class="p">)</span>
        <span class="n">sum_population</span> <span class="o">=</span> <span class="n">select</span><span class="p">(</span><span class="n">sum_population</span><span class="p">)</span>
        <span class="n">best_candidate</span><span class="p">,</span> <span class="n">best_fitness</span> <span class="o">=</span> <span class="n">sum_population</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">best_fitness</span> <span class="o">&gt;</span> <span class="n">prev_best_fitness</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Generation </span><span class="si">{</span><span class="n">generation</span><span class="si">}</span><span class="s2">: found new best candidate (fitness=</span><span class="si">{</span><span class="n">best_fitness</span><span class="si">}</span><span class="s2">):"</span><span class="p">)</span>
            <span class="n">best_ast</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">fix_missing_locations</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">best_candidate</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">best_ast</span><span class="p">))</span>
            <span class="n">prev_best_fitness</span> <span class="o">=</span> <span class="n">best_fitness</span>

            <span class="k">if</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">best_ast</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Done!"</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

    <span class="n">trial</span> <span class="o">=</span> <span class="n">trial</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">Restarting; trial #</span><span class="si">{</span><span class="n">trial</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Generation 0: found new best candidate (fitness=4.002666666666666):
def sum(a, b):
    the_sum = a + b
    return the_sum
Generation 1: found new best candidate (fitness=4.0027027027027025):
def sum(a, b):
    the_sum = a + b
    return FE
Generation 4: found new best candidate (fitness=4.002865329512894):
def sum():
    the_sum = a + b
    return the_sum
Generation 5: found new best candidate (fitness=6.00094696969697):
if set()[:] * *set():

    def sum(a, b):
        mc = a + b
        return FE
else:
    M = set()
continue

set().f[set():set()]()
Generation 7: found new best candidate (fitness=7.002364066193853):
def sum(a, b):
    mc = (a + b) * ()
    return FE
Done!

Restarting; trial #2
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Success! We found a piece of code that triggers the bug. Check for occurrences of the distributive law.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">unparse</span><span class="p">(</span><span class="n">best_ast</span><span class="p">))</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>def sum(a, b):
    mc = (a + b) * ()
    return FE
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="n">has_distributive_law</span><span class="p">(</span><span class="n">best_ast</span><span class="p">)</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>You may note that not all of the code is required to trigger the bug.
We could run our evolutionary fuzzer a bit longer to see whether it can be further reduced,
or use a dedicated input reduction technique such as <a href="https://www.fuzzingbook.org/html/Reducer.html">Delta Debugging</a>.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h3 id="Chances-of-Evolutionary-Fuzzing">Chances of Evolutionary Fuzzing</h3></div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>Could the bug in <code>distributive_law()</code> have been found without evolutionary guidance - i.e., simply by applying one mutation to <code>sum()</code>?</p>
<p>When producing an expression (<code>&lt;expr&gt;</code>), we calculate how big the chances are to</p>
<ul>
<li>Produce a binary operator, and</li>
<li>Produce a <code>*</code>, and</li>
<li>Produce another binary operator as one child, and</li>
<li>Produce a <code>+</code></li>
</ul>
<p>Let's do a few queries on our grammar to compute the chances.</p>
</div>
</div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="s1">'&lt;BinOp&gt;'</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>15
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="k">assert</span> <span class="s1">'Add()'</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;operator&gt;'</span><span class="p">]</span>
<span class="k">assert</span> <span class="s1">'Mult()'</span> <span class="ow">in</span> <span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;operator&gt;'</span><span class="p">]</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;operator&gt;'</span><span class="p">])</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>13
</pre>
</div>

</div>

<div class="input_code">
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span/><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">])</span>       <span class="c1"># chances of choosing a `BinOp`</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;operator&gt;'</span><span class="p">])</span>  <span class="c1"># chances of choosing a `*`</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;expr&gt;'</span><span class="p">])</span>      <span class="c1"># chances of choosing a `BinOp` as a child</span>
<span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">python_ast_grammar</span><span class="p">[</span><span class="s1">'&lt;operator&gt;'</span><span class="p">])</span>  <span class="c1"># chances of choosing a `+`</span>
<span class="o">/</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># two chances - one for the left child, one for the right</span>
</pre></div>

</div>
</div></div>
</div>
</div>

<div class="output_area">

<div class="output_text output_subarea output_execute_result">
<pre>19012.5
</pre>
</div>

</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><p>On average, it would take about 19000 (non-evolutionary) runs until we have an expression that triggers the distributive law.
So it is definitely better to make use of additional information (say, coverage) in order to guide mutations towards a goal.</p>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Lessons-Learned">Lessons Learned</h2><ul>
<li>When creating and processing complex inputs such as program code,<ul>
<li>try to rely on existing infrastructure to <em>parse</em> inputs into some <em>abstract syntax</em>, and then</li>
<li>have your grammars <em>process that abstract syntax</em> rather than the concrete syntax.</li>
</ul>
</li>
<li>Specifically, program code is normally converted into <em>abstract syntax trees</em> before being compiled or interpreted, and you can (and should) make use of such conversions.</li>
<li>Once program code is turned into an AST, it is fairly easy to generate, mutate, and evolve despite its complexity.</li>
</ul>
</div>
</div>
</div>
</div>

<div class="input_markdown">
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html"><h2 id="Background">Background</h2><p>The seminal work on compiler testing is <em>Csmith</em> [<a href="https://doi.org/10.1145/1993498.1993532">Yang <em>et al</em>, 2011</a>], a generator of C programs.
Csmith has been used to thoroughly test compilers such as Clang or GCC; beyond producing code that is syntactically correct, it also aims at <em>semantic</em> correctness as well as avoiding undefined and unspecified behaviors.
This is a must read for anyone in the field in compiler testing.</p>
</div>
</div>
</div>
</div>

        
<p class="imprint">
<img style="float:right" src="../Images/2f3faa36146c6fb38bbab67add09aa5f.png" alt="Creative Commons License" data-original-src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png"/>
The content of this project is licensed under the
<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.
The source code that is part of the content, as well as the source code used to format and display that content is licensed under the <a href="https://github.com/uds-se/fuzzingbook/blob/master/LICENSE.md#mit-license">MIT License</a>.
<a href="https://github.com/uds-se/fuzzingbook/commits/master/notebooks/PythonFuzzer.ipynb" target="_blank)">Last change: 2024-11-24 21:37:28+01:00</a> • 
<a href="#citation" id="cite" onclick="revealCitation()">Cite</a> •
<a href="https://cispa.de/en/impressum" target="_blank">Imprint</a>
</p>



<div id="citation" class="citation" style="display: none;">
<a name="citation"/>
<h2>How to Cite this Work</h2>
<p>
Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler: "<a href="https://www.fuzzingbook.org/html/PythonFuzzer.html">Testing Compilers</a>".  In Andreas Zeller, Rahul Gopinath, Marcel Böhme, Gordon Fraser, and Christian Holler, "<a href="https://www.fuzzingbook.org/">The Fuzzing Book</a>", <a href="https://www.fuzzingbook.org/html/PythonFuzzer.html">https://www.fuzzingbook.org/html/PythonFuzzer.html</a>.  Retrieved 2024-11-24 21:37:28+01:00.
</p>
<pre>
@incollection{fuzzingbook2024:PythonFuzzer,
    author = {Andreas Zeller and Rahul Gopinath and Marcel B{\"o}hme and Gordon Fraser and Christian Holler},
    booktitle = {The Fuzzing Book},
    title = {Testing Compilers},
    year = {2024},
    publisher = {CISPA Helmholtz Center for Information Security},
    howpublished = {\url{https://www.fuzzingbook.org/html/PythonFuzzer.html}},
    note = {Retrieved 2024-11-24 21:37:28+01:00},
    url = {https://www.fuzzingbook.org/html/PythonFuzzer.html},
    urldate = {2024-11-24 21:37:28+01:00}
}
</pre>
</div>

          
</body>
</html>